/******************************************************************************
 **                           COPYRIGHT NOTICE
 **      (c) 2021 The Johns Hopkins University Applied Physics Laboratory
 **                         All rights reserved.
 ******************************************************************************/

/*****************************************************************************
 **
 ** File Name: sc_value.h
 **
 ** Namespace: bpsec_scv_
 **
 ** Description:
 **
 **     Security context values represent both the security parameters and
 **     security results associated with security blocks in a bundle.
 **
 **     There are four main types of values that are typically used when
 **     processing security contexts:
 **
 **     POLICY PARAMETERS:  A parameter that has been defined as part of the
 **                         policy configuration of the local node. Policy
 **                         parameters live in shared memory managed by the
 **                         ION Personal Space Manager (PSM).
 **
 **                         These parameters may be generated and used by
 **                         multiple threads within ION. For example, an admin
 **                         utility may generate policy parameters at ION
 **                         startup, a network management thread may accept
 **                         new policy parameters while the system is running,
 **                         and the main BPA thread may read these policy
 **                         parameters while generating/processing security
 **                         blocks.
 **
 **     WORKING PARAMETERS: A parameter that is created as part of security
 **                         processing solely in the context of a single
 **                         ION thread handling a security operation. These
 **                         parameters are neither stored in shared memory or
 **                         written to the SDR and are discarded as soon as
 **                         their associated processing is complete.
 **
 **                         An unwrapped session key is an example of such a
 **                         parameter. While a wrapped session key may be
 **                         present in a security block as a block parameter,
 **                         the unwrapped key is only used in the local memory
 **                         of an ION service using it to interact with a
 **                         cipher suite.
 **
 **                         Since these parameters are generated as-needed, and
 **                         in a single thread of control, they are allocated
 **                         on the heap using ION memory pools.
 **
 **
 **     BLOCK PARAMETERS:   A parameter that has been generated in the context
 **                         of processing a security block. These parameters
 **                         are either built from the encoding of parameter
 **                         values in a security block itself, or generated by
 **                         a single thread of control for the processing of a
 **                         single security block.
 **
 **                         When these parameters are associated with an
 **                         outgoing block, they are stored in the SDR with
 **                         other outgoing bundle information.
 **
 **                         When these parameters are associated with an
 **                         incoming bundle, they are stored in working
 **                         memory as part of processing security as
 **                         part of bundle acceptance. Once the incoming
 **                         bundle has been accepted, it is written to the
 **                         SDR (or delivered to the local application agent).
 **
 **     BLOCK RESULTS:      A security result associated with a security
 **                         operation within a security block.
 **
 **                         When results are associated with an outgoing
 **                         block, they are stored in the SDR with other
 **                         outgoing bundle information.
 **
 **                         When results are associated with an
 **                         incoming bundle, they are stored in working
 **                         memory as part of processing security as
 **                         part of bundle acceptance. Once the incoming
 **                         bundle has been accepted, it is written to the
 **                         SDR (or delivered to the local application agent).
 **
 ** Notes:
 **
 ** - Parameter handling for security contexts is complicated in ION because
 **   parameters can be stored in different areas of ION (such as working memory,
 **   shared memory, or the SDR). Therefore, SC values definitions contain
 **   additional annotations and functions to help with describing how these
 **   values are stored and where they are defined.
 **
 **
 ** Assumptions:
 **
 ** Modification History:
 **  MM/DD/YY  AUTHOR         DESCRIPTION
 **  --------  ------------   ---------------------------------------------
 **  02/18/22  E. Birrane     Initial implementation
 **
 *****************************************************************************/


#include "sc_value.h"
#include "sc_util.h"
#include "bpsec_util.h"


/*****************************************************************************
 *                           CONSTANTS DEFINITIONS                           *
 *****************************************************************************/


/*****************************************************************************
 *                             FUNCTION DEFINITIONS                          *
 *****************************************************************************/



/******************************************************************************
 * @brief Clear the contents of an SCI value.
 *
 * @param[in]     wm   The PsmPartition holding policy parameters
 * @param[in/out] val  The value being cleared
 *
 * This is a generic clear function which assumes an SCI value of a
 * primitive that does not need complex freeing of the internal data
 * value.
 *
 * @note
 *  1. Does not free the storage of the sc value itself, just all contents
 *
 *****************************************************************************/

void bpsec_scv_clear(PsmPartition wm, sc_value *val)
{
    CHKVOID(val);

    switch(val->scValLoc)
    {
		case SC_VAL_STORE_SM:
			psm_free(wm, val->scRawValue.asAddr);
			val->scRawValue.asAddr = 0;
			break;

		case SC_VAL_STORE_MEM:
		        MRELEASE(val->scRawValue.asPtr);
		        val->scRawValue.asPtr = NULL;
		        break;

		default:
			BPSEC_DEBUG_ERR("Cannot clear values stored in %d",
					val->scValLoc);
			return;
    }

    memset(val, 0, sizeof(sc_value));
}



 /******************************************************************************
  * @brief Allocate space for an SC value in the appropriate memory areas
  *
  * @param[in]      wm      The PsmPartition holding policy parameters
  * @param[in/out]  val     The value whose data content space is being allocated
  * @param[in]      length  Number of bytes of space to allocate
  *
  * @note
  *
  * @retval !NULL - The cursor into the SCI value data contents.
  * @retval NULL  - Error.
  *****************************************************************************/

void *bpsec_scv_rawAlloc(PsmPartition wm, sc_value *val, int length)
 {

	BPSEC_DEBUG_PROC("(wm,"ADDR_FIELDSPEC",%d", (uaddr) val, length);
     CHKNULL(val);

     val->scValLength = length;
     switch(val->scValLoc)
     {
 		case SC_VAL_STORE_SM:
 			BPSEC_DEBUG_INFO("Allocating SM value of length %d", length);
 			val->scRawValue.asAddr = psm_zalloc(wm, length);
 			return psp(wm, val->scRawValue.asAddr);
 			break;

 		case SC_VAL_STORE_MEM:
 			BPSEC_DEBUG_INFO("Allocating memory of size %d", length);
 			val->scRawValue.asPtr = MTAKE(length);
 			BPSEC_DEBUG_INFO("asPtr is "ADDR_FIELDSPEC".", (uaddr) val->scRawValue.asPtr);
 			return val->scRawValue.asPtr;
 	        break;

 		default:
 			BPSEC_DEBUG_ERR("Cannot allocate values stored in %d", val->scValLoc);
     }

     return NULL;
 }



 /******************************************************************************
  * @brief Return a local-memory pointer to a SCI value's data value.
  *
  * @param[in]  wm   The PsmPartition holding policy parameters
  * @param[in]  val  The value whose pointer is being returned
  *
  * @note
  *   - For policy parameters in shared memory, a local pointer is generated
  *     by this call.
  *   - This is a shallow copy into the value and MUST NOT be freed by the caller
  *
  * @retval !NULL - The cursor into the SCI value data contents.
  * @retval NULL  - Error.
  *****************************************************************************/

 void *bpsec_scv_rawGet(PsmPartition wm, sc_value *val)
 {
 	void *result = NULL;
     CHKNULL(val);
     switch(val->scValLoc)
     {
     	case SC_VAL_STORE_SM:
     		result = psp(wm, val->scRawValue.asAddr);
     		break;

     	case SC_VAL_STORE_MEM:
     		result = val->scRawValue.asPtr;
      	    break;

     	default:
     		BPSEC_DEBUG_ERR("Unknown location.", NULL);
     		break;
     }

     return result;
 }



 /******************************************************************************
  * @brief Releases resources associated with an SC value held in a Lyst
  *
  * @param[in]  elt The LystElt holding the sc_value.
  * @param[in]  arg The security context holding the value
  *
  * This lyst delete callback assumes that "working memory" sc_values have been
  * deep copied and that any other sc_value (such as values in shared memory
  * or on the SDR) are shallow-copied.
  *
  * Shallow-copied values are removed from the lyst, but should not be deleted
  * in this delete callback function.
  *
  * This function also assumes that any working-memory sc_values can be
  * completed destroyed by calling MRELEASE on their contents. This might not
  * be the case in circumstances where the value portion of an sc_value contains
  * a structure with its own pointers in it.
  *
  * To date, there are no instances of such an sc_value.
  *
  *****************************************************************************/

 void bpsec_scv_lystCbDel(LystElt elt, void *arg)
 {
     sc_value *val = NULL;

     if((val = lyst_data(elt)) != NULL)
     {
         if(val->scValLoc == SC_VAL_STORE_MEM)
         {
             bpsec_scv_clear(0, val);
             MRELEASE(val);
         }
     }
 }



 /******************************************************************************
  * @brief Find an sc_value with the given type and id.
  *
  * @param[in]  list - The Lyst holding sc values.
  * @param[in]  id   - The value id being searched for.
  * @param[in]  type - The type of value being searched for.
  *
  * @note
  *  1. This function assumes that all sc values in the list are defined by the
  *     same security context.
  *****************************************************************************/

 sc_value *bpsec_scv_lystFind(Lyst list, int id, int type)
 {
     sc_value *result = NULL;
     LystElt elt;

     BPSEC_DEBUG_PROC("("ADDR_FIELDSPEC",%d, %d)", (uaddr)list, id, type);

     for(elt = lyst_first(list); elt; elt = lyst_next(elt))
     {
         result = (sc_value *) lyst_data(elt);
         if((result->scValId == id) && (result->scValType == type))
         {
             BPSEC_DEBUG_INFO("Found value with id %d, type %d, length %d", result->scValId, result->scValType, result->scValLength);
             return result;
         }
     }

     return NULL;
 }



 /******************************************************************************
  * @brief Copy a SC Value that is stored in working memory.
  *
  * @param[in] oldVal  The value being copied
  *
  * This is a deep copy of the value.
  *
  * @todo
  *  1. Consider using this for all types of function (SM, SDR, and MEM).
  *
  *****************************************************************************/

sc_value* bpsec_scv_memCopy(sc_value *oldVal)
{
    sc_value	*result = NULL;
    void	*valuePtr = NULL;

    BPSEC_DEBUG_PROC("("ADDR_FIELDSPEC")", (uaddr)oldVal);

    CHKNULL(oldVal);

    if (oldVal->scValLoc == SC_VAL_STORE_MEM)
    {
	valuePtr = oldVal->scRawValue.asPtr;
    }
    else
    {
	if (oldVal->scValLoc == SC_VAL_STORE_SM)
	{
		valuePtr = psp(getIonwm(), oldVal->scRawValue.asAddr);
	}
    }

    CHKNULL(valuePtr);
    if((result = MTAKE(sizeof(sc_value))) == NULL)
    {
        BPSEC_DEBUG_ERR("Cannot allocate %d bytes.", sizeof(sc_value));
        return NULL;
    }

    result->scValId = oldVal->scValId;
    result->scValLength = oldVal->scValLength;
    result->scValLoc = SC_VAL_STORE_MEM;
    result->scValType = oldVal->scValType;
    if((result->scRawValue.asPtr = MTAKE(result->scValLength)) == NULL)
    {
        BPSEC_DEBUG_ERR("Cannot allocate raw ptr of %d bytes.",
			result->scValLength);
        MRELEASE(result);
        return NULL;
    }

    memcpy(result->scRawValue.asPtr, valuePtr, result->scValLength);

    BPSEC_DEBUG_PROC("-->"ADDR_FIELDSPEC, (uaddr)result);

    return result;
}



/******************************************************************************
 * @brief Create an SC value in working memory.
 *
 * @param[in]     type  The type of value to create.
 *
 * @note
 *   - The calling function is responsible for releasing this value when done
 *     with it.
 *
 * @retval  1 - Success
 * @retval -1 - Error.
 *****************************************************************************/

int bpsec_scv_memCreate(sc_value *val, sc_val_type type, int id, int length)
{
    CHKERR(val);
    val->scValLength = length;
    val->scValType = type;
    val->scValLoc = SC_VAL_STORE_MEM;
    val->scValId = id;
    val->scRawValue.asPtr = NULL;

    if(length > 0)
    {
		if(bpsec_scv_rawAlloc(0, val, length) == NULL)
		{
			bpsec_scv_clear(0, val);
			return -1;
		}
    }

    return 1;
}

// TODO: Comment.
sc_value bpsec_scv_memCsiConvert(csi_val_t csi_value, int type, int id)
{
    sc_value result;

    result.scValType = type;
    result.scValLoc = SC_VAL_STORE_MEM;
    result.scRawValue.asPtr = csi_value.contents;
    result.scValId = id;
    result.scValLength = csi_value.len;

    return result;
}

 /******************************************************************************
  * @brief Create an SC value by reading it from a security block.
  *
  * @param[in]     sc_id         The SC that populated the security block.
  * @param[in]     val_type      The type of value being deserialized
  * @param[in/out] cursor        Pointer into serialized data holding the value.
  * @param[in/out] unparsedBytes Bytes of unparsed serialized bytes.
  *
  * This function takes a pointer into a set of serialized data representing
  * SC values in a security block and deserializes the next value into a
  * working memory SC value structure.
  *
  * Deserialize the actual value. This is tricky for a few reasons.
  *   1. The value is CBOR encoded when "on the wire" and so it
  *   	 must be decoded to be placed in the sc_value.
  *   2. Security contexts govern how their values are CBOR encoded,
  *      so we use the security context to do this deserialization.
  *   3. Waypoint nodes might not support every security context.
  *      This *might* not be an error if we are deserializing a
  *      security block that we will later determine we don't need
  *      to operate on.
  *   4. If we are unable to find the security context, we will simply
  *      treat the CBOR-encoded value as the actual value and assume
  *      some other processing will handle the fact that the node
  *      doesn't implement the security context...
  *
  * @return !NULL - The deserialized value.
  * @return NULL  - There was a problem deserializing the value.
  *
  *****************************************************************************/

 sc_value *bpsec_scv_memDeserialize(int sc_id, int val_type, unsigned char **cursor, unsigned int *unparsedBytes)
 {
	 sc_Def  def;
	 sc_value *result = NULL;
	 uvast uvtemp = 0;
	 //uint8_t *buffer = NULL;
	 //uvast bufLen = 0;

 	/* Step 0: Sanity Checks. */
 	CHKNULL(cursor);
 	CHKNULL(*cursor);
 	CHKNULL(unparsedBytes);


 	/* Step 1: Allocate and initialize the resultant SCI value. */
 	if((result = (sc_value*) MTAKE(sizeof(sc_value))) == NULL)
 	{
 		BPSEC_DEBUG_ERR("Cannot allocate SCI value.", NULL);
 		return NULL;
 	}
 	memset(result, 0, sizeof(sc_value));
 	result->scValType = val_type;
 	result->scValLoc = SC_VAL_STORE_MEM;
 	result->scValLength = 0;


 	/*
 	 * Step 2: Make sure we are dealing with a 2-element array.
 	 *         SCI values are arrays of id/value in a security block.
 	 */
     uvtemp = 2;
     if (cbor_decode_array_open(&uvtemp, cursor, unparsedBytes) < 1)
     {
 		BPSEC_DEBUG_ERR("Cannot decode SCI parm array.", NULL);
 		MRELEASE(result);
 		return NULL;
     }

     /* Step 3: Grab the ID from the first element of the array. */
     if (cbor_decode_integer(&uvtemp, CborAny, cursor, unparsedBytes) < 1)
     {
 		BPSEC_DEBUG_ERR("Cannot decode SCI parm ID.", NULL);
 		MRELEASE(result);
 		return NULL;
     }
     result->scValId = uvtemp;

     /*
      * Step 4: Figure out the size of the encoded SC value. The CBOR interface
      *         makes this a 3 step process. First, try and decode the value
      *         with 0 allocated storage. This will return the needed length
      *         to hold the value. Then allocate the needed buffer and try the
      *         decode a second time with the correctly allocated buffer.
      *

     if(cbor_decode_byte_string(NULL, &bufLen, cursor, unparsedBytes) < 1)
     {
     	BPSEC_DEBUG_ERR("Cannot determine SCI value length.", NULL);
 		MRELEASE(result);
 		return NULL;
     }

     if((buffer = MTAKE(bufLen)) == NULL)
     {
     	BPSEC_DEBUG_ERR("Cannot allocate decode buffer length of %d", bufLen);
 		MRELEASE(result);
 		return NULL;
     }

     if(cbor_decode_byte_string((unsigned char *)buffer, &bufLen, cursor, unparsedBytes) < 1)
     {
     	BPSEC_DEBUG_ERR("Cannot extract SC val byte string.", NULL);
     	MRELEASE(buffer);
 		MRELEASE(result);
 		return NULL;
     }*/

     /*
      * Step 5: Deserialize the value using the security context, or just
      *         copy the value if no security context is found.
      */
     if(bpsec_sci_defFind(sc_id, &def))
     {
    	 sc_value_map* scvm = def.scValMapGet();
    	 int scvm_idx = bpsec_scvm_byIdIdxFind(scvm, result->scValId, result->scValType);
    	 if(scvm[scvm_idx].scValFromCBOR)
    	 {
    		// if(scvm[scvm_idx].scValFromCBOR(0, result, bufLen, buffer) < 1)
    	     int len = scvm[scvm_idx].scValFromCBOR(0, result, *unparsedBytes, *cursor);

    	     if((len < 1) || (result->scRawValue.asPtr == NULL))
    		 {
    			 BPSEC_DEBUG_ERR("Failed to extract value.", NULL);
    			 result->scValLength = 0;
    			 result->scRawValue.asPtr = NULL;
    		 }
     	     *cursor += len;
    	     *unparsedBytes -= len;
    	 }
     }
     //MRELEASE(buffer);

     /* Step 6: Sanity check results before returning. */
     if((result->scValLength == 0) || (result->scRawValue.asPtr == NULL))
     {
    	 BPSEC_DEBUG_ERR("Cannot extract SCI value.", NULL);
         MRELEASE(result);
         result = NULL;
     }

     BPSEC_DEBUG_PROC("Returning "ADDR_FIELDSPEC".", (uaddr)result);
     return result;
 }



 /******************************************************************************
  * @brief Record a list of sc values to the SDR.
  *
  * @param[in]  sdr       The SDR to hold the recorded sc values.
  * @param[in]  sdr_list  The SDR list to accept the stored values.
  * @param[in]  mem_list  The in-memory list of values being recorded.
  *
  * Record a series of in-memory sc values to the SDR. This is usually done
  * when writing a set of SC parameters or results into the SDR to be part of
  * a security extension block.
  *
  * @note
  *   - If an empty list is provided, it will be created and returned.
  *   - On error, the entire SDR list is destroyed.
  *
  * @todo
  *  1. More error checking.
  *
  * @note
  *
  * @retval >0 - The object holding the updated SDR list.
  * @retval 0 - There was an error persisting values.
  *****************************************************************************/

 Object bpsec_scv_memListRecord(Sdr sdr, Object sdr_list, Lyst values)
 {
 	sc_value *val = NULL;
 	LystElt elt = NULL;

 	BPSEC_DEBUG_PROC("(sdr,%d,"ADDR_FIELDSPEC")", sdr_list, (uaddr) values);

 	/* Step 0 - Sanity checks. */
 	if(values == NULL)
 	{
 		BPSEC_DEBUG_INFO("NO values to record.", NULL);
 	    return sdr_list;
 	}

 	/* Step 1 - If there is no list, then allocate one in the SDR. */
 	if(sdr_list == 0)
 	{
 	    if((sdr_list = sdr_list_create(sdr)) == 0)
 	    {
 	    	BPSEC_DEBUG_ERR("Unable to create sdr list.", NULL);
 	        return 0;
 	    }
 	}

 	/* Step 2 - For each in-memory value, persist it and add it to the list. */
 	for (elt = lyst_first(values); elt; elt = lyst_next(elt))
 	{
 		val = (sc_value*) lyst_data(elt);

 		if(bpsec_scv_memSdrListAppend(sdr, sdr_list, val) == -1)
 		{
 			BPSEC_DEBUG_ERR("Unable to record value.", NULL);
 			sdr_list_destroy(sdr, sdr_list, bpsec_scv_sdrListCbDel, NULL);
 			return 0;
 		}
 	}

 	return sdr_list;
 }



 /******************************************************************************
  * @brief Encode an SC value to place it in a security block.
  *
  * @param[in]  def        The SC that will perform the encoding.
  * @param[in]  val        The SC value being serialized.
  * @param[out] resultData The encoded value.
  * @param[out] resultLen  The length of the encoded value.
  *
  * This function takes the components of a SC value and generated a
  * CBOR-encoded version of the value that can be placed into a serialized
  * security block.
  *
  * The serialized form of any SC value is a 2-element CBOR array where the
  * first element is the ID of the value and the second element is the CBOR
  * encoding of the SC value's raw value.
  *
  * @return 1  - The value was serialized.
  * @return 0  - The SC def does not want this value included in the block.
  * @return -1 - System error.
  *
  *****************************************************************************/

 int bpsec_scv_memSerialize(sc_Def *def, sc_value *val, uint8_t **resultData, unsigned int *resultLen)
 {
     unsigned char tmp[64];

     uint8_t *valBuf = NULL;
     uint8_t *cursor = NULL;

     unsigned int valBufLen = 0;
     int idBufLen = 0;

     BPSEC_DEBUG_PROC("("ADDR_FIELDSPEC","ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
                      (uaddr) def, (uaddr) val, (uaddr) resultLen);

     /* Step 0: Sanity Checks. */
     CHKERR(val);
     CHKERR(resultData);
     CHKERR(resultLen);


     /* Step 1: Serialize the value to CBOR. */
     if(def)
     {
    	 sc_value_map* scvm = def->scValMapGet();
    	 int scvm_idx = bpsec_scvm_byIdIdxFind(scvm, val->scValId, val->scValType);

    	 if(scvm[scvm_idx].scValToCBOR)
    	 {
    		 if((valBuf = scvm[scvm_idx].scValToCBOR(0, val, &valBufLen)) == NULL)
    		 {
    			 BPSEC_DEBUG_ERR("Failed to encode value.", NULL);
    			 *resultLen = 0;
    		 }
    		 BPSEC_DEBUG_INFO("Adding val type %d id %d to block with len %d.", val->scValType, val->scValId, valBufLen);
//    		 char *tester = bpsec_scutl_hexStrCvt(valBuf, valBufLen);
//    	     BPSEC_DEBUG_INFO("Val serialized as %s",tester);
//    	     MRELEASE(tester);
    	 }
    	 else
    	 {
    	     BPSEC_DEBUG_INFO("Suppressing val type %d id %d from block.", val->scValType, val->scValId);
    	     return 0;
    	 }
     }

     /* Step 2: Serialize the ID. */
     unsigned char *tmpPtr = tmp;
     if((idBufLen = cbor_encode_integer(val->scValId, &tmpPtr)) <= 0)
     {
         MRELEASE(valBuf);
         return ERROR;
     }

     /*
      * Step 3: Allocate the buffer.
      *         We now know how many bytes we need to hold the serialized value:
      *         - 1 byte for the definite-length encoded array header
      *         - idLen bytes for the CBOR-encoded id
      *         - valLen bytes for the CBOR-encoded value.
      */
     *resultLen = 1 + idBufLen + valBufLen;
     if((*resultData = MTAKE(*resultLen)) == NULL)
     {
         MRELEASE(valBuf);
         return ERROR;
     }

     /* Step 4: Write the contents to the result buffer. */
     cursor = *resultData;

     oK(cbor_encode_array_open(2, &cursor));

     memcpy(cursor, tmp, idBufLen);
     cursor += idBufLen;

     memcpy(cursor, valBuf, valBufLen);
     MRELEASE(valBuf);

     return 1;
 }



 /******************************************************************************
  * @brief Copy a memory SC value to the SDR (as an SDR sc value).
  *
  * @param[in]  sdr       The SDR to hold the recorded sc value.
  * @param[in]  old_val   The memory sc value being converted
  *
  * Copy a memory sc value to the SDR by creating a new SDR sc value.
  *
  * @note
  *
  * @note
  *
  * @retval >0 - The SDR sc value Object
  * @retval  0 - Error. The  sc value was not persisted.
  *****************************************************************************/

 Object bpsec_scv_memSdrConvert(Sdr sdr, sc_value *oldVal)
 {
 	sc_value newVal;
 	Object result = 0;

 	BPSEC_DEBUG_PROC("(sdr, "ADDR_FIELDSPEC")", (uaddr)oldVal);

 	/* Step 0 - Sanity Checks. */
 	CHKZERO(sdr);
 	CHKZERO(oldVal);
 	CHKZERO(oldVal->scValLoc == SC_VAL_STORE_MEM);
 	CHKZERO(sdr_begin_xn(sdr));

 	/* Step 1 - Initialize easy SDR sc value information. */
 	newVal.scValId = oldVal->scValId;
 	newVal.scValLength = oldVal->scValLength;
 	newVal.scValType = oldVal->scValType;
 	newVal.scValLoc = SC_VAL_STORE_SDR;

 	/* Step 2 - Allocate and write sc_value raw value to the SDR. */
 	if((newVal.scRawValue.asSdr = sdr_malloc(sdr, newVal.scValLength)) == 0)
 	{
 	    BPSEC_DEBUG_ERR("Unable to allocate %d bytes in SDR.", newVal.scValLength);
 	    sdr_cancel_xn(sdr);
 		return 0;
 	}
 	sdr_write(sdr, newVal.scRawValue.asSdr, (char *) oldVal->scRawValue.asPtr, newVal.scValLength);

 	/* Step 3 - Allocate and write the sc_value itself in the SDR. */
 	if((result = sdr_malloc(sdr, sizeof(sc_value))) == 0)
 	{
        BPSEC_DEBUG_ERR("Unable to allocate %d bytes in SDR.", sizeof(sc_value));
 		sdr_free(sdr, newVal.scRawValue.asSdr);
 		sdr_cancel_xn(sdr);
 		return 0;
 	}
 	sdr_write(sdr, result, (char*) &newVal, sizeof(newVal));
 	if (sdr_end_xn(sdr) < 0)
 	{
 	    BPSEC_DEBUG_ERR("Unable to end SDR transaction.", NULL);
 	    result = 0;
 	}

 	BPSEC_DEBUG_PROC("Returning %d.", result);
 	return result;
 }



 /******************************************************************************
  * @brief Write an in-memory sc value to an SDR list.
  *
  * @param[in]  sdr   The SDR holding SC values.
  * @param[in]  list  The SDR list holding sc values.
  * @param[in]  val   The sc_value being written to the sdr list.
  *
  * @note
  *  1. The incoming sc_vlaue is duplicated into an SDR sc value
  *  2. The SDR sc_value is then written into the SDR list.
  *  3. The original in-memory sc_value is not changed. If it needs to be
  *     released, the caller must do that.
  *
  * @retval -1 - The sc_value was not added to the SDR or list.
  * @retval 0  - The sc_value is now in the SDR and SDR list.
  *****************************************************************************/
 int bpsec_scv_memSdrListAppend(Sdr sdr, Object list, sc_value *val)
 {
     Object sdr_val = 0;

     BPSEC_DEBUG_PROC("(sdr, %d,"ADDR_FIELDSPEC")", list, (uaddr)val);

     if(val->scValLoc != SC_VAL_STORE_MEM)
     {
     	BPSEC_DEBUG_ERR("Can't record values in %d.", val->scValLoc);
     	return -1;
     }

     if((sdr_val = bpsec_scv_memSdrConvert(sdr, val)) == 0)
     {
     	BPSEC_DEBUG_ERR("Cannot write sc_value to SDR.", NULL);
         return -1;
     }

     if(sdr_list_insert_last(sdr, list, sdr_val) == 0)
     {
     	BPSEC_DEBUG_ERR("Cannot write sc_value to SDR list.", NULL);

     	bpsec_scv_sdrRelease(sdr, sdr_val);
     	return -1;
     }

     return 0;
 }



 /******************************************************************************
   * @brief Copy an SDR sc value to another SDR sc value.
   *
   * @param[in]     sdr     The SDR holding the sc values.
   * @param[in]     oldObj  The value being copied.
   *
   * Copy an SDR sc value to a new SDR sc value.
   *
   * @note
   *   - This function assumes that the newVal exists on the SDR already.
   *
   * @retval >0 - The SDR sc value Object
   * @retval  0 - Error. The  sc value was not persisted.
   *****************************************************************************/

 Object bpsec_scv_sdrCopy(Sdr sdr, Object oldObj)
 {
     char *buf = NULL;
     Object newObj = 0;
     sc_value oldVal;
     sc_value newVal;

     /* Step 0: Sanity checks. */
     CHKZERO(oldObj);

     /* Step 1: Read the old sc value from the SDR. */
     sdr_read(sdr, (char *) &oldVal, oldObj, sizeof(sc_value));

     /* Step 2: Allocate an SDR object to hold the value. */
     newObj = sdr_malloc(sdr, sizeof(sc_value));
     CHKZERO(newObj);

     /*
      * Step 3: Shallow copy information over from old to new value.
      *         This will copy everything except the SDR object holding
      *         the raw value for this sc value.
      */
     memcpy(&newVal, &oldVal, sizeof(sc_value));


     /*
      * Step 2: Deep copy the actual value portion of the sc_value.
      *         This involves the following:
      *         - Allocate memory to hold the value
      *         - Read value from the old SDR location into memory
      *         - Write the value in memory to the new SDR location.
      *         - Free the memory buffer.
      */

     if((buf = MTAKE(newVal.scValLength)) == NULL)
     {
     	sdr_free(sdr, newObj);
         return -1;
     }

     if((newVal.scRawValue.asSdr = sdr_malloc(sdr, newVal.scValLength)) == 0)
     {
     	sdr_free(sdr, newObj);
         MRELEASE(buf);
         return -1;
     }

     sdr_read(sdr, buf, oldVal.scRawValue.asSdr, oldVal.scValLength);
     sdr_write(sdr, newVal.scRawValue.asSdr, buf, newVal.scValLength);
     MRELEASE(buf);


     /* Step 3: Write the new value to the SDR. */
     sdr_write(sdr, newObj, (char *)&newVal, sizeof(newVal));


     /* Step 4: We are done.*/
     return newObj;
 }


 // TODO comment..
 void  bpsec_scv_sdrListCbDel(Sdr sdr, Object eltData, void *args)
 {
     bpsec_scv_sdrRelease(sdr, sdr_list_data(sdr, eltData));
 }


 /******************************************************************************
   * @brief Copy an SDR list of values to another list.
   *
   * @param[in]  sdr      The SDR holding the sc values.
   * @param[in]  oldList  The list being copied.
   *
   * @note
   *  - This is a deep copy of SDR sc_value objects.
   *
   * @retval >0 - The SDR list of sc value objects
   * @retval  0 - Error. The  sc value was not persisted.
   *****************************************************************************/

 Object bpsec_scv_sdrListCopy(Sdr sdr, Object oldList)
 {
     Object newList = 0;
     Object elt = 0;
     Object oldObj = 0;
     Object newObj = 0;


     int success = 1;


     /* Step 0: Sanity checks. */
     CHKZERO(oldList);

     /* Step 1: Allocate the new SCI value list. */
     if((newList = sdr_list_create(sdr)) == 0)
     {
         BPSEC_DEBUG_ERR("Cannot allocate SDR list.", NULL);
         return 0;
     }

     /*
      * Step 2: For each element of the existing list of values,
      *         allocate a new value and deep copy it.
      */
     for (elt = sdr_list_first(sdr, oldList);
          elt;
          elt = sdr_list_next(sdr, elt))
        {
            /* Step 2.1: Grab the current value. */
             oldObj = sdr_list_data(sdr, elt);

             /* Step 2.3: Deep copy the old value into the new value. */
             if((newObj = bpsec_scv_sdrCopy(sdr, oldObj)) < 1)
             {
                 success = 0;
                 break;
             }

             /* Step 2.4: Add new value to the list. */
             if (sdr_list_insert_last(sdr, newList, newObj) == 0)
             {
                success = 0;
                break;
             }
        }

        if(success == 0)
        {
            sdr_list_destroy(sdr, newList, bpsec_scv_sdrListCbDel, NULL);
            newList = 0;
        }

     return newList;
 }



 /******************************************************************************
  * @brief Convert a list of SDR values to memory values.
  *
  * @param[in]  sdr       The SDR holding the list of SDR sc values.
  * @param[in]  sdr_list  The SDR list being read.
  *
  * Read a series of sc_values stored in a list on the SDR into working
  * memory.
  *
  * @note
  *   - This is a deep copy - changes to the returned memory sc values will not
  *     affect the sc_values in the SDR.
  *
  * @note
  *
  * @retval !NULL - A lyst populated with memory sc values
  * @retval NULL  - There was an error.
  *
  *****************************************************************************/
 Lyst bpsec_scv_sdrListRead(Sdr sdr, Object sdr_list)
 {
 	Object listElt;
 	Lyst result = lyst_create_using(getIonMemoryMgr());

 	BPSEC_DEBUG_PROC("(sdr, %d)", sdr_list);

 	CHKNULL(result);

 	if(sdr_list == 0)
 	{
 	    return result;
 	}

 	for(listElt = sdr_list_first(sdr, sdr_list); listElt; listElt = sdr_list_next(sdr, listElt))
 	{
 		sc_value *val = bpsec_scv_sdrMemConvert(sdr, sdr_list_data(sdr, listElt));
 		if(val == NULL)
 		{
 			BPSEC_DEBUG_ERR("Error reading sc_value from SDR.", NULL);
 		}
 		else
 		{
 			lyst_insert_last(result, val);
 		}
 	}

 	lyst_delete_set(result, bpsec_scv_lystCbDel, NULL);

 	return result;
 }



 /******************************************************************************
   * @brief Serialize a list of SDR sc values
   *
   * @param[in]  sdr      The SDR holding the sc value list.
   * @param[in]  def      The security context definition doing the serialization
   * @param[in]  sdr_list The SDR list being serialized.
   * @param[out] length   The length of the serialized value.
   *
   * @note
   *  - This will return a serialized CBOR array with each array element being
   *    a serialized sc value.
   *  - The calling function must release the returned serialized data buffer.
   *
   * @retval !NULL - The serialized data
   * @retval  NULL - Error. The list was not serialized.
   *****************************************************************************/

 uint8_t *bpsec_scv_sdrListSerialize(Sdr sdr, sc_Def *def, Object sdr_list, unsigned int *length)
 {
     uint8_t *result = NULL;
     uint8_t *cursor = NULL;
     Object elt = 0;
     int maxVals = 0;
     int curVals = 0;
     unsigned char arrayHdr[9];
     int arrayHdrLen = 0;
     BpsecSerializeData *tmpData = NULL;
     int i = 0;

     BPSEC_DEBUG_PROC("(sdr,"ADDR_FIELDSPEC",%d,"ADDR_FIELDSPEC")",
                     (uaddr)def, sdr_list, (uaddr)length);

     /* Step 0: Sanity Checks. */
     CHKNULL(sdr_list);
     CHKNULL(length);

     *length = 0;

     /*
      * Step 1: Allocate temporary storage to hold the result of individual
      *         value serialization. There are two allocations here:
      *         tmpData will hold the N serialized results for the N values.
      *         tmpLens will hold the lengths of the tmpData items.
      */
     maxVals = sdr_list_length(sdr, sdr_list);

     /*
      * If there are no independent results, then serialize this as an
      * empty byte string (h'') in CBOR.
      */
     if(maxVals == 0)
     {
         BPSEC_DEBUG_INFO("No parameters to serialize.", NULL);
         tmpData = MTAKE(1);
     }
     else
     {
         tmpData = MTAKE(maxVals * sizeof(BpsecSerializeData));
     }

     if(tmpData == NULL)
     {
         BPSEC_DEBUG_ERR("Cannot allocate %d bytes.", maxVals * sizeof(BpsecSerializeData))
         return NULL;
     }

     /* Step 2: For each value in the SDR list serialize the value. */
     for (elt = sdr_list_first(sdr, sdr_list); elt; elt = sdr_list_next(sdr, elt))
     {
         Object valObj = sdr_list_data(sdr, elt);
         int success = bpsec_scv_sdrSerialize(sdr, def, valObj, &(tmpData[i].scSerializedText), &(tmpData[i].scSerializedLength));

         if(success == -1)
         {
             BPSEC_DEBUG_ERR("Cannot serialize value.", NULL);
             MRELEASE(tmpData);
             return NULL;
         }
         else if(success == 1)
         {
             *length += tmpData[i].scSerializedLength;
             i++;
         }
     }

     /*
      * Step 3: Allocate space for the total buffer and copy the results into
      *         it.  We have the total length of the serialized data as we
      *         accumulated it in the prior loop. Now we just need to
      *         concatenate it into the final result.
      */

     /*
      * Step 3.1: Figure out how many bytes it will take to encode the CBOR
      *           array header. We do this by encoding the array header into
      *           temporary storage.
      */
     unsigned char *tmp = arrayHdr;
     curVals = i;
     arrayHdrLen = cbor_encode_array_open(curVals, &tmp);

     /*
      * Step 3.2: Size, allocate, and initialize data associated with the
      *           resulting serialized buffer.
      */
     *length += arrayHdrLen;

     if((result = MTAKE(*length)) == NULL)
     {
         BPSEC_DEBUG_ERR("Cannot allocate %d bytes", *length);
         MRELEASE(tmpData);
         return NULL;
     }
     cursor = result;

     /*
      * Step 3.3: Populate the result buffer, starting with the CBOR array header
      *           and followed by the individual value results.
      */
     memcpy(cursor, arrayHdr, arrayHdrLen);
     cursor += arrayHdrLen;

     for(i = 0; i < curVals; i++)
     {
         memcpy(cursor, tmpData[i].scSerializedText, tmpData[i].scSerializedLength);
         cursor += tmpData[i].scSerializedLength;
     }

     /* Step 4: Clean up and go home. */
     MRELEASE(tmpData);
     BPSEC_DEBUG_PROC("-->"ADDR_FIELDSPEC, (uaddr)result);
     return result;
 }



 /******************************************************************************
  * @brief Convert an SDR sc_value into a memory sc_value.
  *
  * @param[in]  sdr      The SDR holding the list of SDR sc values.
  * @param[in]  valAddr  The location of the SDR sc value.
  *
  * @note
  *   - This is a deep copy - a new, independent memory sc value is created.
  *
  * @note
  *
  * @retval !NULL - THe memory sc value.
  * @retval NULL  - There was an error.
  *
  *****************************************************************************/
 sc_value *bpsec_scv_sdrMemConvert(Sdr sdr, Object valAddr)
 {
 	sc_value sdr_val;
 	sc_value *val = NULL;

 	BPSEC_DEBUG_PROC("(sdr, %d)", valAddr);
 	CHKNULL(valAddr);

 	val = MTAKE(sizeof(sc_value));
 	CHKNULL(val);

 	sdr_read(sdr, (char *)&sdr_val, valAddr, sizeof(sc_value));
 	memcpy(val, &sdr_val, sizeof(sc_value));
 	val->scValLoc = SC_VAL_STORE_MEM;
 	if((val->scRawValue.asPtr = MTAKE(val->scValLength)) == NULL)
 	{
 		MRELEASE(val);
 		return NULL;
 	}
 	sdr_read(sdr, (char*)val->scRawValue.asPtr, sdr_val.scRawValue.asSdr, sdr_val.scValLength);
 	return val;
 }



 /******************************************************************************
   * @brief Release resources associated with a sc value in the SDR.
   *
   * @param[in]  sdr     The SDR holding the sc value
   * @param[in]  valObj  The sc value being removed.
   *
   *****************************************************************************/

 void bpsec_scv_sdrRelease(Sdr sdr, Object valObj)
 {
 	sc_value val;
 	sdr_read(sdr, (char*) &val, valObj, sizeof(val));
 	sdr_free(sdr, val.scRawValue.asSdr);
 	sdr_free(sdr, valObj);
 }


 /******************************************************************************
   * @brief Serialize an SDR sc value
   *
   * @param[in]  sdr     The SDR holding the sc value.
   * @param[in]  def     The security context definition doing the serialization
   * @param[in]  valObj  The SDR object of the value being serialized.
   * @param[out] data    The serialized value.
   * @param[out] length  The length of the serialized value.
   *
   * @note
   *  - This places the value in a form that can be included in the serialized
   *    security block.
   *  - The calling function must release the returned serialized data buffer.
   *
   * @retval 1  - The data was successfully serialized.
   * @retval 0  - The SC def does not want this value serialized.
   * @retval -1 - Error. The value was not serialized.
   *****************************************************************************/

 int bpsec_scv_sdrSerialize(Sdr sdr, sc_Def *def, Object valObj, uint8_t **data, unsigned int *length)
 {
     int success = 0;
     sc_value *tmp = NULL;

     BPSEC_DEBUG_PROC("(sdr,"ADDR_FIELDSPEC",%d,"ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
             (uaddr) def, valObj, (uaddr) data, (uaddr) length);

     /* Step 0 - Sanity Checks. */
     CHKERR(data);
     CHKERR(length);

     /* Step 1 - Read value from SDR into memory. */
     if((tmp = bpsec_scv_sdrMemConvert(sdr, valObj)) == NULL)
     {
     	return ERROR;
     }

     /* Step 2 - Serialize the in-memory value. */
     success = bpsec_scv_memSerialize(def, tmp, data, length);

     /* Step 3 - Clear the memory value. We don't need it anymore. */
     bpsec_scv_clear(0, tmp);
     MRELEASE(tmp);

     return success;
}



/******************************************************************************
 * @brief Create an SC value in ION shared memory
 *
 * @param[in] wm   - The PSP memory manager
 * @param[in] type - The type of value to create.
 *
 * @note
 *   - The calling function is responsible for releasing this value when done
 *     with it.
 *
 * @retval !0 - The allocated value
 * @retval 0  - Error.
 *****************************************************************************/

PsmAddress bpsec_scv_smCreate(PsmPartition wm, sc_val_type type)
{
    PsmAddress addr = 0;
    CHKZERO(wm);

    if((addr = psm_zalloc(wm, sizeof(sc_value))) != 0)
    {
        sc_value *val = psp(wm, addr);
        memset(val, 0, sizeof(sc_value));
        val->scValType = type;
        val->scValLoc = SC_VAL_STORE_SM;
    }
    return addr;
}



/******************************************************************************
 * @brief Releases resources associated with a policy parameter.
 *
 * @param[in]  wm   The PsmPartition holding the policy parameter
 * @param[in]  addr The shared memory address of the policy parameter
 *
 * @note
 *  1. This is an sm_list delete callback function.
 *  2. Does not currently support using the security context definition to
 *     free the SC value raw value.
 *****************************************************************************/

void  bpsec_scv_smlistCbDel(PsmPartition wm, PsmAddress addr, void *arg)
{
    sc_value *val = NULL;

    if((val = (sc_value *) psp(wm, addr)) != NULL)
    {
    	bpsec_scv_clear(wm, val);
    	psm_free(wm, addr);
    }
}



/******************************************************************************
 * @brief Generate a string representation of a series of sci values
 *
 * @param[in]  wm     The PsmPartition holding policy parameters
 * @param[in]  sc_def The security context definition interpreting the values.
 * @param[in]  vals   The Lyst of values to be printed
 *
 * @todo
 *  1. More error checking.
 *
 * @note
 *  1. The resultant string is a comma-separated list of values
 *  2. The resultant string must be released by the caller.
 *  3. Values may represent either parms or results. It is expected (but not
 *     required) that the given Lyst is all parms or all results.
 *
 * @retval !NULL - The string representation of the values.
 * @retval NULL  - Error or no values.
 *****************************************************************************/

char* bpsec_scv_smListPrint(PsmPartition wm, sc_Def *sc_def, Lyst vals)
{
    char **tmp_array;
    int num_items = 0;
    int i = 0;
    int size = 0;
    LystElt elt = NULL;
    sc_value_map *scvm = NULL;
    sc_value *cur_val = NULL;
    int cur_idx = 0;

    CHKNULL(sc_def);
    CHKNULL(vals);

    scvm = sc_def->scValMapGet();

    num_items = lyst_length(vals);

    if((tmp_array = (char **) MTAKE(num_items * sizeof(char*))) == NULL)
    {
        return NULL;
    }

    /* Step 1: Walk through the list... */
    for(elt = lyst_first(vals); elt; elt = lyst_next(elt))
    {
    	cur_val = (sc_value *)lyst_data(elt);
    	cur_idx = bpsec_scvm_byIdIdxFind(scvm, cur_val->scValId, cur_val->scValType);
    	tmp_array[i++] =scvm[cur_idx].scValToStr(wm, cur_val);
    	size += strlen(tmp_array[i++]);
    }

    return bpsec_scutl_strFromStrsCreate(tmp_array, size, num_items);
}



/******************************************************************************
 * @brief Record a list of shared memory sc values to the SDR.
 *
 * @param[in]     sdr       The SDR to hold the recorded sc values.
 * @param[in|out] sdr_list  The SDR list to accept the stored values.
 * @param[in]     wm        The shared memory parition manager.
 * @param[in]     values    The shared memory list of values being recorded.
 *
 * Record a series of shared memory sc values to the SDR. This is usually done
 * when writing a set of SC parameters or results into the SDR to be part of
 * a security extension block.
 *
 * @note
 *   - If an empty list is provided, it will be created and returned.
 *   - On error, the entire SDR list is destroyed.
 *
 * @retval >0 - The object holding the updated SDR list.
 * @retval 0 - There was an error persisting values.
 *****************************************************************************/

Object bpsec_scv_smListRecord(Sdr sdr, Object sdr_list, PsmPartition wm, PsmAddress values)
{
    Object curObj = 0;
    PsmAddress elt = 0;

	/* Step 0 - Sanity checks. */
    if(values == 0)
    {
        return sdr_list;
    }

    /* Step 1 - If there is no list, then allocate one in the SDR. */
    if(sdr_list == 0)
    {
        if((sdr_list = sdr_list_create(sdr)) == 0)
        {
            return 0;
        }
    }

    /* Step 2 - For each in-memory value, persist it and add it to the list. */
    for (elt = sm_list_first(wm, values); elt; elt = sm_list_next(wm, elt))
    {
        curObj = bpsec_scv_smSdrConvert(sdr, wm, sm_list_data(wm, elt));
        if(sdr_list_insert_last(sdr, sdr_list, curObj) == 0)
        {
        	bpsec_scv_sdrRelease(sdr, curObj);
            sdr_list_destroy(sdr, sdr_list, bpsec_scv_sdrListCbDel, NULL);
            return 0;
        }
    }

    return sdr_list;
}



/******************************************************************************
  * @brief Copy a shared memory SC value to the SDR (as an SDR sc value).
  *
  * @param[in]  sdr        The SDR to hold the recorded sc value.
  * @param[in]  wm         The shared memory parition manager.
  * @param[in]  oldValAddr The shared memory address of the sc value being converted
  *
  * Copy a memory sc value to the SDR by creating a new SDR sc value.
  *
  * @note
  *
  * @retval >0 - The SDR sc value Object
  * @retval  0 - Error. The  sc value was not persisted.
  *****************************************************************************/

Object bpsec_scv_smSdrConvert(Sdr sdr, PsmPartition wm, PsmAddress oldValAddr)
{
	sc_value *oldVal = psp(wm, oldValAddr);
    sc_value newVal;
    Object result = 0;

    /* Step 0 - Sanity Checks. */
    CHKZERO(sdr);
    CHKZERO(oldVal);
    CHKZERO(oldVal->scValLoc == SC_VAL_STORE_SM);

    /* Step 1 - Initialize easy SDR sc value information. */
    newVal.scValId = oldVal->scValId;
    newVal.scValLength = oldVal->scValLength;
    newVal.scValType = oldVal->scValType;
    newVal.scValLoc = SC_VAL_STORE_SDR;

    /* Step 2 - Allocate and write sc_value raw value to the SDR. */
    if((newVal.scRawValue.asSdr = sdr_malloc(sdr, newVal.scValLength)) == 0)
    {
        return 0;
    }
    sdr_write(sdr, newVal.scRawValue.asSdr, (char *) psp(wm, oldVal->scRawValue.asAddr), newVal.scValLength);

 	/* Step 3 - Allocate and write the sc_value itself in the SDR. */
    if((result = sdr_malloc(sdr, sizeof(sc_value))) == 0)
    {
        sdr_free(sdr, newVal.scRawValue.asSdr);
        return 0;
    }
    sdr_write(sdr, result, (char*) &newVal, sizeof(newVal));

    return result;
}


