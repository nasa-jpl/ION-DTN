{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Interplanetary Overlay Network (ION)","text":""},{"location":"#ion-description","title":"\ud83d\udef0\ufe0f ION Description","text":"<p>Interplanetary Overlay Network (ION) is an implementation of the DTN architecture, as described in Internet RFC 4838 (version 6) and RFC 9171 (version 7), that is intended to be usable in both embedded environments including spacecraft flight computers as well as ground systems. It includes modular software packages implementing Bundle Protocol version 6 (BPv6) and version 7 (BPv7), Licklider Transmission Protocol (LTP), Bundle Streaming Service (BSS), DTN-based CCSDS File Delivery Protocol (CFDP), Asynchronous Message Service (AMS), and several other DTN services and prototypes. ION is currently the baseline implementation for science instruments on the International Space Station (ISS) and the gateway node (ION Gateway) that provides relay services for command/telemetry and science data download.</p> <p>Here you will find videos of the Interplanetary Overlay Network courses and presentation materials.</p> <p>DTN Development/Deployment Kit is an ISO image of an Ubuntu virtual machine, pre-configured with ION and a GUI virtualization environment. It contains a number of pre-built scenarios (network topologies) to demonstrate various features of ION software. ( currently the DevKit is undergoing upgrade to BPv7, release date is TBD.)</p>"},{"location":"#application-domains-of-dtn-and-ion","title":"\ud83d\udce1 Application Domains of DTN and ION","text":"<ul> <li>Robotics: This technology enables us to command and control robotic explorers on distant planets and support timely decision-making despite the limitations imposed by vast distances.</li> <li>Satellite Communications: Our protocol enhances satellite constellations by providing a solution tailored to the unique challenges posed by space communications.</li> <li>Spacecraft Fleets: Our system can coordinate entire fleets of spacecraft engaged in deep space missions, ensuring synchronized actions and efficient resource use.</li> <li>Interplanetary Internet: We're laying the foundation for an internet that extends beyond Earth to span across multiple planets, paving the way for universal communication.</li> <li>Space Station Data Handling: Our technology efficiently manages data transfer between Earth and Space Station's various science payload and instruments, ensuring timely and reliable communications.</li> </ul>"},{"location":"#performance-data","title":"\ud83d\udcca Performance Data","text":"<ul> <li>BP/LTP Throughput Study: a comprehensive study of BP/LTP performance on various CPU/OS architecture will be provided in the ION Deployment Guide after ION 4.1.3 is released. (Current estimated time is Fall of 2023)</li> <li>ION TCPCL Throughput Assessment: an in-depth study conducted at Ohio University on the performance optimization of ION over the TCP convergence layer is available here and as a pdf file.</li> </ul>"},{"location":"#installation-configuration","title":"\ud83d\udee0\ufe0f Installation &amp; Configuration","text":"<ol> <li>Clone the repository:</li> </ol> <p><pre><code>git clone https://github.com/nasa-jpl/ION-DTN.git\n</code></pre> 2. Follow the steps in the Quick Start Guide to build, install, and run a simple two node example. 3. A simple tutorial of ION's configuration files can be found here. 4. A set of configuration file templates for various DTN features can be found here.</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>ION is licensed under the MIT License. Please see the LICENSE file for details.</p>"},{"location":"#important-papers-on-ion-and-dtn","title":"\ud83d\udcda Important Papers on ION and DTN","text":"<p>For a list of key DTN and ION-related publications, please refer to the List-of-Papers page.</p>"},{"location":"AMS-Programmer-Guide/","title":"AMS Programmer's Guide","text":"<p>Version 3.0</p> <p>Sky DeBaun, Jet Propulsion Laboratory, California Institute of Technology</p> <p>Document Change Log</p> Ver No. Date Affected Description Comments 2.2 Sept 2010 3.0 June 2023 All Updates and Corrections"},{"location":"AMS-Programmer-Guide/#purpose-and-scope","title":"Purpose and Scope","text":"<p>The Consultative Committee for Space Data Systems' (CCSDS)  Asynchronous Message Service (AMS) is a communication architecture for  data systems. It is designed to allow mission system modules to  operate as if they were isolated, each producing and consuming mission  information without explicit knowledge of the other active modules.  This self-configuring communication relationship minimizes complexity  in the development and operation of modular data systems.</p> <p>AMS is the foundation of a system that can be described as a  'society' of largely autonomous, interoperating modules. These  modules can adapt over time in response to changing mission  objectives, functional upgrades of modules, and recovery from  individual module failures. The primary objective of AMS is to reduce  mission cost and risk by providing a standard, reusable infrastructure  for information exchange among data system modules. This  infrastructure is designed to be user-friendly, highly automated,  flexible, robust, scalable, and efficient.</p> <p>Notably, AMS provides a publication and subscription service for both  terrestrial and extraterrestrial communications, utilizing the  Interplanetary Overlay Network (ION). This service ensures a seamless  and efficient communication system that can adapt dynamically to  various missions.</p>"},{"location":"AMS-Programmer-Guide/#definitions","title":"Definitions","text":"<p>Within the context of this document the following definitions apply:</p> <p>A continuum is a closed set of entities that utilize AMS for  purposes of communication among themselves. Each continuum is  identified by a continuum name and corresponding non-negative  continuum number. The continuum name that is the character string of  length zero indicates \"all known continua\" or \"any known continuum\",  whichever is less restrictive in the context in which this continuum  name is used; the reserved continuum number zero corresponds to this  continuum name.</p> <p>An application is a data system implementation, typically taking the  form of a set of source code text files, that relies on AMS procedures  to accomplish its purposes. Each application is identified by an  application name.</p> <p>An authority is an administrative entity or persona that may have  responsibility for the configuration and operation of an application.  Each authority is identified by an authority name.</p> <p>A venture is an instance of an application, i.e., a functioning  projection of the application -- for which some authority is  responsible -- onto a set of one or more running computers.</p> <p>A message is an octet array of known size which, when copied from  the memory of one module of a venture to that of another  (exchanged), conveys information that can further the purposes of  that venture.</p> <p>The content of a message is the array of zero or more octets  embedded in the message containing the specific information that the  message conveys.</p> <p>A role is some part of the functionality of an application. Each  role is identified by a role name and corresponding non-negative  role number. The role name that is the character string of length zero  indicates 'all roles' or 'any role', whichever is less restrictive in  the context in which the role name is used; the reserved role number  zero corresponds to this role name. The role name \"RAMS ''  identifies Remote AMS (RAMS) gateway functionality as discussed below;  the reserved role number 1 corresponds to this role name.</p> <p>A module (of some mission data system) is a communicating entity  that implements some part of the functionality of some AMS venture --  that is, performs some application role -- by, among other activities,  exchanging messages with other modules. Associated with each module is  the name of the role it performs within the application. [Note that  multiple modules may perform the same role in an application, so the  role name of a module need not uniquely identify the module within its  message space.] In order to accomplish AMS message exchange a module  generates AMS service requests and consumes AMS service indications;  the module that is the origin of a given AMS service request or the  destination of a given AMS service indication is termed the operative  module.</p> <p>A message space is the set of all of the modules of one AMS venture  that are members of a single AMS continuum; that is, a message space  is the intersection of a venture and a continuum. Each message space  is uniquely identified within that continuum by the combination of the  name of the application and the name of the authority that is  responsible for the venture, and by a corresponding venture number  greater than zero. [Note that unique naming of continua enables  multiple message spaces that are in different continua but are  identified by the same application and authority names to be  concatenated via Remote AMS (discussed below) into a single venture.]</p> <p>A unit (i.e., a unit of organization) is an identified subset of the  organizational hierarchy of the modules of one AMS venture, declared  during venture configuration as specified by the responsible authority  for that venture. Each unit is uniquely identified within the venture  by unit name and corresponding non-negative unit number. The root  unit of a venture is the unit that is coterminous with the venture  itself; its unit name is the character string that is of length zero,  and the reserved unit number zero corresponds to this unit name. A  unit whose name is identical to the first N bytes -- where N is  greater than or equal to zero -- of the name of another unit of the  same message space is said to contain that other unit. The  membership of a unit that is contained by another unit is a subset of  the membership of the containing unit.</p> <p>A cell is the set of all modules that are members of one unit of a given venture and are also members of a given continuum; that is, it is the intersection of a unit and a continuum. Since each unit is a subset of a venture, each cell is necessarily a subset of the message space for that venture in that continuum. Each cell is uniquely identified within its message space by its unit's name and number. The root cell of a message space is coterminous with the message space itself. A cell contains some other cell only if its unit contains that other cell's unit. A cell may be an empty set; that is, in a given continuum there may be no modules that are members of the cell's unit. The registered membership of a cell is the set of all modules in the cell that are not members of any other cell which does not contain that cell^1^. [Note that the root cell contains every other cell in the message space, and every module in the message space is therefore a member -- though not necessarily a registered member -- of the root cell.]</p> <p>The domain of an AMS service request is the set of modules to which  the request pertains. It comprises all of the modules that are members  of the venture in which the operative module is itself a member, with  the following exceptions:</p> <ul> <li>If the service request is one for which continuum ID is not   specified, then only modules that are members of the local continuum   are members of the service request's domain. Otherwise, if the   service request's continuum ID parameter does not indicate \"all   continua\", then only modules that are members of the continuum   identified by the service request's continuum ID parameter are   members of the service request's domain.</li> <li>Only modules that are members of the organizational unit identified   by the service request's unit ID parameter are members of the   service request's domain.</li> <li>If the service request's role ID parameter does not indicate \"all   roles\", then only modules performing the role identified by that   role ID are members of the service request's domain.</li> </ul> <p>The subject number (or subject) of a message is an integer  embedded in the message that indicates the general nature of the  information the message conveys, in the context of the AMS venture  within which the message is exchanged. A subject name is a text  string that serves as the symbolic representation of some subject  number.</p> <p>To send a message is to cause it to be copied to the memory of a  specified module. To publish a message on a specified subject is to  cause it to be sent to one or more implicitly specified modules,  namely, all those that have requested copies of all messages on the  specified subject. To announce a message is to cause it to be sent  to one or more implicitly specified modules, namely, all those modules  that are located within a specified continuum (or all continua), are  members of a specified unit (possibly the root unit) and that perform  a specified role in the application (possibly \"any role\").</p> <p>A subscription is a statement requesting that one copy of every  message published on some specified subject by any module in the  subscription's domain be sent to the subscribing module; the domain  of a subscription is the domain of the AMS service request that  established the subscription.</p> <p>^1^ For example, if cell A contains cells B and C, and cell C contains  cells D and E, any nodes in C that are not in either D or E are in the  registered membership of cell C. Those nodes are also members of cell  A, but because they are in cell C -- which does not contain cell A --  they are not in cell A's registered membership.</p> <p>An invitation is a statement of the manner in which messages on some  specified subject may be sent to the inviting module by modules in the  domain of the invitation; the invitation's domain is the domain of  the AMS service request that established the invitation.</p>"},{"location":"AMS-Programmer-Guide/#overview","title":"Overview","text":""},{"location":"AMS-Programmer-Guide/#general","title":"General","text":"<ol> <li>Architectural Character</li> </ol> <p>A data system based on AMS has the following characteristics:</p> <p>a.  Any module may be introduced into the system at any time. That is,     the order in which system modules commence operation is immaterial;     a module never needs to establish an explicit a priori     communication \"connection\" or \"channel\" to any other module in order     to pass messages to it or receive messages from it.</p> <p>b.  Any module may be removed from the system at any time without     inhibiting the ability of any other module to continue sending and     receiving messages. That is, the termination of any module, whether     planned or unplanned, only causes the termination of other modules     that have been specifically designed to terminate in this event.</p> <p>c.  When a module must be upgraded to an improved version, it may be     terminated and its replacement may be started at any time; there is     no need to interrupt operations of the system as a whole.</p> <p>d.  When the system as a whole must terminate, the order in which the     system's modules cease operation is immaterial.</p> <p>AMS-based systems are highly robust, lacking any innate single point  of failure and tolerant of unplanned module termination. At the same  time, communication within an AMS-based system can be rapid and  efficient:</p> <p>e.  Messages are exchanged directly between modules rather than through     any central message dispatching nexus.</p> <p>f.  Messages are automatically conveyed using the \"best\" (typically --     though not necessarily -- the fastest) underlying transport service     to which the sending and receiving modules both have access. For     example, messages between two ground system modules running in     different computers on a common LAN would likely be conveyed via     TCP/IP, while messages between modules running on two flight     processors connected to a common bus memory board might be conveyed     via a shared-memory message queue.</p> <p>g.  Finally, AMS is designed to be highly scalable: partitioning message     spaces into units enables a venture to comprise hundreds or     thousands of cooperating modules without significant impact on     application performance.</p> <ol> <li>Message Exchange Models</li> </ol> <p>AMS message exchange is fundamentally asynchronous, akin to a  \"postal\" system. An AMS module, after sending a message, can  continue its functions without waiting for a reply.</p> <p>While message exchange is asynchronous, AMS provides a mechanism for  linking reply messages to their original context. This is achieved by  including a context number in the original message. The reply message  automatically echoes this context number, allowing the original sender  to link the reply to the application activity that triggered the  initial message. This creates a pseudo-synchronous communication flow.  The specific mechanism for establishing this link is  implementation-dependent.</p> <p>In some cases, true message synchrony may be necessary, requiring a  module to suspend operations until a reply is received. AMS supports  this communication model when required.</p> <p>The majority of message exchange in an AMS-based system follows a  \"publish-subscribe\" model. A module announces its subscription to a  specific subject using AMS procedures. From that point, any published  message on that subject is automatically delivered to all subscribing  modules. This model simplifies application development and  integration, allowing each module to plug into a data \"grid\" and  exchange data without detailed knowledge of other modules.</p> <p>However, there may be instances where a module needs to send a message  privately to a specific module, such as in reply to a published  message. AMS also supports this communication model when necessary.</p>"},{"location":"AMS-Programmer-Guide/#architectural-elements","title":"Architectural Elements","text":"<ol> <li>General</li> </ol> <p>The architectural elements involved in the asynchronous message  service protocol are depicted as below:</p> <p></p> <p>Figure 1: Architectural Elements of AMS</p> <ol> <li>Communicating Entities</li> </ol> <p>All AMS communication is conducted among three types of communicating  entities: modules (defined earlier), registrars, and configuration  servers.</p> <p>A registrar is a communicating entity that catalogs information  regarding the registered membership of a single unit of a message  space. It responds to queries for this information, and it updates  this information as changes are announced.</p> <p>A configuration server is a communicating entity that catalogs  information regarding the message spaces established within some AMS  continuum, specifically the locations of the registrars of all units  of all message spaces. It responds to queries for this information,  and it updates this information as changes are announced.</p>"},{"location":"AMS-Programmer-Guide/#overview-of-interactions","title":"Overview of Interactions","text":"<ol> <li>Transport Services for Application Messages</li> </ol> <p>AMS, best characterized as a messaging \"middleware\" protocol,  operates between the Transport and Application layers of the OSI  protocol stack model. It relies on underlying Transport-layer  protocols for actual message copying from sender to receiver and for  transmitting meta-AMS (or MAMS) messages for dynamic  self-configuration of AMS message spaces.</p> <p>In any AMS continuum, a common transport service, termed the Primary  Transport Service (PTS), is used for MAMS traffic by all entities  involved in the operations of all message spaces. The PTS, being  universally available, can also be used for application message  exchange among all modules in a continuum. However, in some cases,  performance can be improved by using Supplementary Transport Services  (STSs), especially when modules share access to a convenient  communication medium like a shared-memory message queue.</p> <p>Supplementary Transport Services (STSs) are performance-optimizing  transport services used in the Asynchronous Message Service (AMS) for  message exchange between modules that share access to a particularly  convenient communication medium, such as a shared-memory message  queue. While the Primary Transport Service (PTS) is universally  available for message exchange, STSs can be employed to enhance  application performance in certain scenarios (see CCSDS Blue Book  Recommended Standard 735.1-B-1 \"Asynchronous Message Service\" for  additional information).</p> <p>A module's network location for receiving messages via a given  transport service is its delivery point for that service. A module may  have multiple delivery points, each characterized by the same service  mode. For a given service mode, the list of all delivery points  providing that mode to a module, ranked in descending order of  preference (typically network performance), is termed the delivery  vector for that service mode, for that module.</p> <p>See \"Primary Transport Services\" below for additional information.</p> <ol> <li>Registrar Registration</li> </ol> <p>Every message space in AMS always includes at least one unit, the root  unit, and each module is registered within a unit. In the simplest  case, all modules reside in the root unit. Each unit is served by a  single registrar, which monitors the health of all registered modules  and propagates six types of message space configuration changes.</p> <p>Registrars themselves register with the configuration server for the  continuum containing the message space. A list of all potential  network locations for the configuration server, ranked in descending  order of preference, must be well-known and included in the AMS  management information bases (MIBs) accessible to all registrars. Each  continuum must always have an operational configuration server at one  of these locations to enable registration of registrars and modules.</p> <p>All registrars and modules of the same message space must register  through the same configuration server.</p> <ol> <li>Module Registration</li> </ol> <p>Each module has a single meta-AMS delivery point (MAPD) for receiving  MAMS messages. A new module joins a message space by registering  within a unit, announcing its role name and MAPD to the unit's  registrar. However, the module cannot have hard-coded information  about the registrar's communication details, as these can change.</p> <p>Therefore, the first step in registering a new module is contacting  the configuration server at one of its known network locations. These  locations, listed in descending order of preference, are included in  the AMS Management Information Bases (MIBs) accessible to all  application modules. The configuration server then provides the new  module with the contact details for its registrar.</p> <p>The module obtains a unique module number from the registrar and  completes registration. The registrar ensures that all other modules  in the message space learn the new module's role name, module number,  and MAPD. These modules, in turn, announce their own details to the  new module.</p> <ol> <li>Monitoring Module Health</li> </ol> <p>Maintaining accurate knowledge of a message space configuration is  crucial for application purposes and resource efficiency. Each  registrar must promptly detect the termination of modules in its  unit's registered membership. While a module under application  control notifies its registrar upon termination, a module that crashes  or is powered off does not. To address this, each module sends a  \"heartbeat\" message to its registrar every few seconds (see comment  #3 at top of amscommon.h for additional details). The registrar  interprets three consecutive missing heartbeats as a module  termination.</p> <p>Upon detecting a module's termination, either overt or imputed from  heartbeat failure, the registrar informs all other modules in the  unit's registered membership and, through other registrars, all  modules in the message space.</p> <p>When termination is imputed from a heartbeat failure, the registrar  attempts to notify the presumed terminated module. If the module is  still running, it terminates immediately upon receiving this message,  minimizing system confusion due to other application behavior  triggered by the imputed termination.</p> <ol> <li>Monitoring Registrar Health</li> </ol> <p>Each registrar not only monitors the heartbeats of all modules in its  unit's registered membership but also issues its own heartbeats to  those modules. If a module detects three consecutive missing registrar  heartbeats, it assumes the registrar has crashed. The module then  re-queries the configuration server to determine the new network  location of the registrar and resumes exchanging heartbeats.</p> <p>This assumption is reasonable because the configuration server also  monitors registrar heartbeats on a slightly shorter cycle. If the  configuration server detects three consecutive missing registrar  heartbeats, it takes action to restart the registrar, possibly on a  different host. Therefore, by the time the registrar's modules detect  its crash, it should already be running again.</p> <p>Since the module heartbeat interval is two seconds (see N4 in  amscommon.h), the registrar will receive heartbeat messages from every  running module in the unit's registered membership within the first  six seconds after restart. This allows the registrar to accurately  know the unit's configuration. This accurate configuration  information must be delivered to new modules at startup, enabling them  to orient a newly-restarted registrar if it crashes. Therefore, during  the first six seconds after the registrar starts, it only accepts MAMS  messages from modules already registered in the unit. This prevents  the risk of delivering incorrect information to a new module.</p> <ol> <li>Configuration Service Fail-over</li> </ol> <p>A configuration server, like any other component, can also fail or be  rebooted. Each registrar interprets three consecutive missing  configuration server heartbeats as an indication of a crash. Upon  detecting such a crash, the registrar cycles through all the known  network locations for the continuum's configuration server, attempting  to re-establish communication after the server's restart, possibly at  an alternate network location. New modules attempting to register will  also cycle through network locations seeking a restarted configuration  server and will be unable to contact their registrars, and therefore  unable to register, until they find one. However, application message  exchange and subscription management activity among existing modules  and registrars are not affected by this infrastructure failure.</p> <p>Upon the configuration server's restart at one of its known network  locations, all registrars will eventually find it and re-announce  themselves, enabling newly registering application modules to  successfully register.</p> <p>In certain failure scenarios, multiple configuration servers may  operate concurrently for a brief period, such as when a perceived  failure is caused by a transient network connectivity issue rather  than an actual server crash. To resolve this, each running  configuration server periodically sends an \"I am running\" MAMS message  to every lower-ranking configuration server network location in the  known list of configuration server locations. If a configuration  server receives such a message, it immediately terminates. All  registrars and modules communicating with it will detect its  disappearance and search again for the highest-ranking reachable  configuration server, eventually restoring orderly operations in the  continuum.</p> <ol> <li>Configuration Resync</li> </ol> <p>Finally, every registrar can optionally be configured to re-advertise  to the entire message space the detailed configuration of its unit's  registered membership (all active modules, all subscriptions and  invitations) at some user-specified frequency, e.g., once per minute.  This capability is referred to as configuration resync.  Configuration resync of course generates additional message traffic,  and it may be unnecessary in extremely simple or extremely stable  operating environments. But it does ensure that every change in  application message space configuration will eventually be propagated  to every module in the message space, even if some MAMS messages are  lost and even if an arbitrary number of registrars had crashed at the  time the change occurred.</p> <p>Taken together, these measures make AMS applications relatively fault  tolerant:</p> <p>a.  When a module crashes, its registrar detects the loss of heartbeat     within three heartbeat intervals and notifies the rest of the     message space. Application message transmission everywhere is     unaffected.When a registrar crashes, its configuration server     detects the loss of heartbeat within three heartbeat intervals and     takes action to restart the registrar. During the time that the unit     has no registrar, transmission of application messages among modules     of the message space is unaffected, but the heartbeat failures of     crashed modules are not detected and reconfiguration messages     originating in the unit's registered membership (registrations,     terminations, subscription and invitation assertions, and     subscription and invitation cancellations) are not propagated to any     modules. However, after the registrar is restarted it will     eventually detect the losses of heartbeat from all crashed modules     and will issue obituaries to the message space, and if configuration     resync is enabled it will eventually re- propagate the lost     reconfiguration messages.</p> <p>b.  When a configuration server crashes, all new registration activity     will come to a standstill. But no application modules fail (at     least, not because of communication failure), and on restart of the     configuration server the registration of new modules eventually     resumes.</p> <ol> <li>Security</li> </ol> <p>AMS can be configured to confine service access to application modules  that can prove they are authorized to participate. For this purpose,  asymmetric MAMS encryption may be used as follows:</p> <p>a.  The AMS MIB exposed to the configuration server contains a list of     all applications for which registration service may be offered,     identified by application name. Associated with each application     name is the AMS public encryption key for that application.</p> <p>b.  The AMS MIB exposed to every registrar in each message space     contains a list of all functional role names defined for the message     space's application; this list limits the role names under which     modules may register in that message space. Associated with each     role name is the AMS public encryption key for the application     module(s) that may register in that role.</p> <p>c.  The AMS MIBs exposed to all registrars and application modules in     the message space contain the AMS public encryption key of the     configuration server.</p> <p>d.  The AMS MIBs exposed to the configuration server and to all     registrars and application modules in the message space contain the     private encryption keys that are relevant to those entities.</p> <p>As described later, this information is used to authenticate registrar  registration and exclude spurious registrars from the message space,  to authenticate module registration attempts and deny registration to  unauthorized application modules, and to assure the authenticity,  confidentiality, and integrity of MAMS traffic exchanged between  modules and their registrars.</p> <p>In addition, the confidentiality and integrity of AMS message exchange  may be protected at subject granularity. The AMS MIB exposed to each  module of a given message space may contain, for any subset of the  message subjects (identified by name and number) used in the message  space's application:</p> <p>e.  a list of the role names of all modules that are authorized senders     of messages on this subject;</p> <p>f.  a list of the role names of all modules that are authorized     receivers of messages on this subject;</p> <p>g.  encryption parameters, including a symmetric encryption key,     enabling encryption of messages on this subject.</p> <p>This information may be used to support secure transmission of  messages on selected subjects.</p> <p>Note*, though, that the JPL implementation of AMS does not  implement* any of the cryptographic algorithms that are required to  support these security features.</p> <ol> <li>Subject Catalog</li> </ol> <p>The structure of the content of messages on a given subject is  application-specific; message content structure is not defined by the  AMS protocol. However, the AMS MIB exposed to all modules of a given  message space will contain, for each message subject (identified by  name and number) used in the message space:</p> <p>a.  a description of this message subject, discussing the semantics of     this type of message;</p> <p>b.  a detailed specification of the structure of the content of messages     on this subject;</p> <p>c.  optionally, a specification of the manner in which a correctly     assembled message is marshaled for network transmission in a     platform-neutral manner and, on reception, un-marshaled into a     format that is suitable for processing by the application.</p> <p>When AMS is requested to send a message on a given subject, the  message content that is presented for transmission is always in a  format that is suitable for processing by the application. In the  event that this format is not suitable for network transmission in a  platform-neutral manner, as indicated by the presence in the MIB of a  marshaling specification for this subject, AMS will marshal the  message content as required before transmitting the message.</p> <p>When AMS receives a message on a subject for which a marshaling  specification is present in the MIB, AMS will un-marshal the message  content into a format that is suitable for processing by the  application before delivering the message.</p> <p>Message subjects, as noted earlier, are integers with  application-defined semantics. This minimizes the cost of including  subject information (in effect, message type) in every message, and it  makes processing simpler and faster: subscription and invitation  information are recorded in arrays that are indexed by subject number.</p> <p>This implementation choice, however, requires that message management  control arrays be large enough to accommodate the largest subject  numbers used in the application. The use of extremely large subject  numbers would therefore cause these arrays to consume significant  amounts of memory. In general, it is best for an AMS application to  use the smallest subject numbers possible, starting with 1.</p> <ol> <li>Remote AMS Message Exchange</li> </ol> <p>AMS' asynchronous message issuance model allows for a high degree of  concurrency in the operations of data system modules. This means that  a module can issue a message without suspending its operation until a  response is received. This feature also largely insulates applications  from variations in signal propagation time across the AMS continuum.</p> <p>However, some critical MAMS (Multicast AMS) communication is  unavoidably synchronous. For instance, a newly registering module must  wait for responses from the configuration server and the registrar  before it can proceed with application activity. Therefore, the core  AMS protocol is best suited for operational contexts with generally  uninterrupted network connectivity and relatively small and  predictable signal propagation times, such as the Internet or a  stand-alone local area network. It is typically advantageous for all  entities within a single AMS continuum to operate within such a  \"low-latency\" environment</p> <p>AMS application messages can be exchanged between modules in different  AMS continua using the Remote AMS (RAMS) procedures. These procedures  are executed by special-purpose application modules known as RAMS  gateways. Each RAMS gateway interfaces with two communication  environments: the AMS message space it serves and the RAMS network,  which is a mesh or tree of mutually aware RAMS gateways. This network  enables AMS messages produced in one message space to be forwarded to  other message spaces within the same venture.. RAMS gateways operate  as follows:</p> <p>a.  RAMS gateways operate by opening private RAMS network communication     channels to the RAMS gateways of other message spaces within the     same venture. These interconnected gateways use these communication     channels to forward message petition assertions and cancellations     among themselves.</p> <p>b.  Each RAMS gateway subscribes locally to all subjects that are of     interest in any of the linked message spaces.</p> <p>c.  When a RAMS gateway receives a message on any of these subjects, it     uses the RAMS network to forward the message to every other linked     RAMS gateway whose message space contains at least one module that     has subscribed to messages on that subject.</p> <p>d.  On receiving a message the RAMS gateway module forwards the message     to any subscribers in its own message space.</p> <p>The RAMS protocol allows for the free flow of published application  messages across deep space links while ensuring efficient utilization  of those links. Only a single copy of any message is ever transmitted  on any RAMS grid communication channel, regardless of how many  subscribers will receive copies when the message reaches its  destination.</p> <p>RAMS operations generalize the AMS architecture as shown in Figure 2  below.</p> <p>Figure 2 General AMS application structure</p> <p></p> <p>This extension of the publish/subscribe model to inter-continuum  communications is invisible to application modules. Application  functionality is unaffected by these details of network configuration,  and the only effects on behavior being those intrinsic to variability  in message propagation latency.</p> <p>It's important to note that the nature of the RAMS network  communication channels depends on the implementation of the RAMS  network. To communicate over the RAMS network for a given venture,  each RAMS gateway must know the RAMS network location, expressed as an  endpoint in the protocol used to implement the RAMS network.</p> <p>Also, only AMS application messages are propagated across continuum  boundaries by RAMS. Modules are never notified of registrations,  subscriptions, and invitations that occur in remote continua. The  purpose of RAMS is to limit traffic on the scarce link resources  supporting inter-continuum communication to the minimum necessary for  successful operation of the venture. MAMS message traffic within a  message space is required to enable the operation of the message  space, but venture-wide application message exchange can readily be  provided without propagating MAMS messages to remote continua.</p>"},{"location":"AMS-Programmer-Guide/#the-jpl-implementation","title":"The JPL Implementation","text":"<p>JPL's implementation of AMS has the following components:</p> <ul> <li>a daemon process (amsd) which can function as a configuration   server, a registrar for a single message space, or both, depending   on command-line parameters used when starting the process.</li> <li>A library (libams) that implements the AMS application   programming interface. This library is typically provided as a   \"shared object\" that is dynamically linked with application code at   run time.</li> <li>An implementation of Remote AMS (RAMS) comprising a library   (librams).</li> </ul> <p>The codebase, written in C, relies on a shared library, ICI. This  library supports other JPL implementations, like CFDP and the DTN  Bundle Protocol. ICI includes a \"platform\" portability layer, easing  code compilation and execution in environments like Linux, vxWorks,  and Interix.</p> <p>ICI also includes its own dynamic memory management system, called  \"PSM\", which provides dynamic management of a privately allocated  block of memory. This may be useful in environments such as spacecraft  flight software where the dynamic management of system memory  (malloc, free) cannot be tolerated. Use of PSM by AMS is optional.</p> <p>An AMS application program, linked with libams, uses the  ams_register function to instantiate an AMS module registered within  a specified unit of a specified message space. Once registration is  accomplished, the application may commence inviting, subscribing to,  publishing, announcing, sending, and replying to messages.</p> <p>This AMS implementation is multi-threaded. The process of registration  starts a pair of POSIX threads, or pthreads, which manage timing and  MAMS events in the background. Additionally, another pthread is  started to receive MAMS messages via the primary transport service and  add them to the MAMS event queue. This queue also includes MAMS  message transmission requests. For each transport service that the  module can receive AMS messages from, one more pthread is started.  These threads receive AMS messages and add them to the AMS event  queue, combining them with \"discovery\" events added by the MAMS  event handling thread.</p> <p>The general structure of an AMS module, then, is as shown in Figure  3 below.</p> <p>Figure 3 AMS module structure</p> <p></p> <p>The application program has the option to start another thread to  manage AMS events. This thread automatically calls event-type-specific  callback functions, leaving the main application thread free to  respond to non-AMS events, such as mouse events or keyboard input. The  application code can also add application-specific events to the AMS  event queue, potentially with higher priority than any queued AMS  messages. However, to prevent certain types of unusual application  behavior, the main application thread is not allowed to receive and  handle any AMS events while the background AMS event handling thread  is running.</p>"},{"location":"AMS-Programmer-Guide/#primary-transport-services","title":"Primary Transport Services","text":"<p>As shipped, AMS currently includes support for two underlying  transport services: TCP, and DGR (Datagram Retransmission, a UDP-based  system that includes congestion control and retransmission-based  reliability). Although TCP is faster than DGR, its connection-based  architecture makes it unsuitable as a primary transport service: all  MAMS message traffic is conveyed via connectionless DGR.</p>"},{"location":"AMS-Programmer-Guide/#installation","title":"Installation","text":"<p>AMS source is provided in the ION distribution (a gzipped tarfile containing AMS and all supporting ION packages: ici, dgr, ltp, and bp, etc.).</p> <p>The following two installation methods are provided.</p>"},{"location":"AMS-Programmer-Guide/#automake","title":"Automake","text":"<p>This method automatically compiles and links all required executables, installs them, and copies ION library headers to the relevant system path(s) on your system.Use the following command sequence in the unzipped ION source directory (Linux).</p> <pre><code>./configure\nmake\nsudo make install\nsudo ldconfig\n</code></pre> <p>Note: if support for the expat XML parsing library is required see 4.3 \"Support for the Expat XML Parsing Library\" below</p>"},{"location":"AMS-Programmer-Guide/#make","title":"Make","text":"<p>This alternate installation method installs all ION packages (if run  from ION root directory), or installs individual ION packages as  follows</p> <ol> <li>Before installation, first determine which environment (i.e.    platform) you're going to be building for: i86- redhat,    i86_64-fedora, sparc-solaris, RTEMS, etc. Note this for the    following step</li> <li>Move the ION .gz file to a directory in which you want to build the    system, gunzip the file, and then un-tar it; a number of new    directories will appear.AMS requires the following packages: ici, dgr, ltp, bp, and ams. For    each, in that specific order, do the following:cd to directory_namemodify Makefile (as needed):\"PLATFORMS = environment_name\"]modify Makefile (as needed):\"OPT = desired system path\"]makesudo make installcd ..</li> <li>For additional information see the ION Design and Operations manual    for dependency details and package build order instructions (see    ION.pdf in the ION distribution tar)</li> </ol> <p>Note that for both install methods (e.g. on Linux) the default  configuration used in the ION makefiles is as follows:</p> <ul> <li>ION package binaries are installed into /usr/local/bin/</li> <li>ION library objects are installed into /usr/local/lib/.</li> <li>ION library header files are installed into   /usr/local/include/.</li> <li>Manual pages are installed into /usr/local/man1, /usr/local/man3,   and /usr/local/man5</li> </ul> <p>If you want a different configuration, you'll need to modify the  makefiles accordingly (e.g. see the OPT variable in 2b above).</p>"},{"location":"AMS-Programmer-Guide/#support-for-the-expat-xml-parsing-library","title":"Support for the Expat XML Parsing Library","text":"<p>The expat open-source XML parsing library is required by AMS only  if MIBs use the XML format (see man amsxml and man amsrc for  additional information).</p> <p>Note that Linux environments typically have expat built in, but  for VxWorks installations it is necessary to download and install  expat prior to installing AMS.</p> <p>To build ION with support for expat use the following flag during the  .configure step of installation (see 4.1 \"Automake\" above):</p> <p><code>./configure --with-expat</code></p>"},{"location":"AMS-Programmer-Guide/#the-ams-daemon","title":"The AMS Daemon","text":"<p>The AMS daemon program amsd can function as the configuration  server for a continuum, as the registrar for one cell of a specified  message space, or both. To run it, enter a command of the following  form at a terminal window prompt:</p> <p><code>amsd mib_source_name eid_spec</code></p> <p>or</p> <p><code>amsd mib_source_name eid_spec application_name authority_name unit_name</code></p> <p>The former form of the command starts amsd as a configuration  server only.</p> <p>mib_source_name is as discussed in the documentation of ams_register  below; it enables amsd to run.</p> <p>eid_spec is a string that specifies the IP address and port that  amsd must establish in order to receive MAMS messages in its  capacity as a configuration server. See man amsd for more  information.</p> <p>When the latter form of the amsd command is used, the daemon is  configured to function as the registrar for the indicated message  space unit. If the value \".\" (period character) is supplied for  eid_spec, then the daemon will [only]  function as a  registrar. Otherwise the daemon will function as both configuration  server and registrar; this option can be useful when operating a  simple, stand-alone message space, such as a demo.</p>"},{"location":"AMS-Programmer-Guide/#c-application-programming-interface","title":"\"C\" Application Programming Interface","text":"<p>The AMS application programming interface is defined by the header  file ams.h, which must be #included at the beginning of any  AMS application program source file.</p> <p>See section 9 'Application Development Guide' for compilation and  linkage instructions.</p>"},{"location":"AMS-Programmer-Guide/#type-and-macro-definitions","title":"Type and Macro Definitions","text":"<pre><code>#define THIS_CONTINUUM  (-1)\n#define ALL_CONTINUA    (0)\n#define ANY_CONTINUUM   (0)\n#define ALL_SUBJECTS    (0)\n#define ANY_SUBJECT (0)\n#define ALL_ROLES   (0)\n#define ANY_ROLE    (0)\n\ntypedef enum\n{\nAmsArrivalOrder = 0, AmsTransmissionOrder\n} AmsSequence;\n\ntypedef enum\n{\nAmsBestEffort = 0, AmsAssured\n} AmsDiligence;\n\ntypedef enum\n{\nAmsMsgUnary = 0, AmsMsgQuery, AmsMsgReply, AmsMsgNone\n} AmsMsgType;\n\ntypedef struct amssapst *AmsModule; typedef struct amsevtst *AmsEvent;\n\n/*  AMS event types.    */\n#define AMS_MSG_EVT 1\n#define TIMEOUT_EVT 2\n#define NOTICE_EVT  3\n#define USER_DEFINED_EVT    4\n\n\ntypedef enum\n{\nAmsRegistrationState, AmsInvitationState, AmsSubscriptionState\n} AmsStateType;\n\ntypedef enum\n{\nAmsStateBegins = 1, AmsStateEnds\n} AmsChangeType;\n\ntypedef void    (*AmsMsgHandler)(AmsModule module, void *userData, AmsEvent *eventRef, int continuumNbr, int unitNbr,\nint moduleNbr, int subjectNbr,\nint contentLength, char *content,\nint context, AmsMsgType msgType, int priority);\n\ntypedef void    (*AmsRegistrationHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int unitNbr,\nint moduleNbr, int roleNbr);\n\ntypedef void    (*AmsUnregistrationHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int unitNbr,\nint moduleNbr);\n\ntypedef void    (*AmsInvitationHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int unitNbr,\nint moduleNbr,\nint domainRoleNbr,\nint domainContinuumNbr, int domainUnitNbr,\nint subjectNbr, int priority,\nunsigned char flowLabel, AmsSequence sequence, AmsDiligence diligence);\n\ntypedef void    (*AmsDisinvitationHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int unitNbr,\nint moduleNbr,\nint domainRoleNbr,\nint domainContinuumNbr, int domainUnitNbr,\nint subjectNbr);\n\ntypedef void    (*AmsSubscriptionHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int unitNbr,\nint moduleNbr,\nint domainRoleNbr,\nint domainContinuumNbr, int domainUnitNbr,\nint subjectNbr, int priority,\nunsigned char flowLabel, AmsSequence sequence, AmsDiligence diligence);\n\ntypedef void    (*AmsUnsubscriptionHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int unitNbr,\nint moduleNbr,\nint domainRoleNbr,\nint domainContinuumNbr, int domainUnitNbr,\nint subjectNbr);\n\ntypedef void    (*AmsUserEventHandler)(AmsModule  module,\nvoid *userData, AmsEvent *eventRef, int code,int dataLength, char *data);\n\ntypedef void    (*AmsMgtErrHandler)(void *userData, AmsEvent *eventRef);\ntypedef struct\n{\nAmsMsgHandler   msgHandler;\nvoid    *msgHandlerUserData;\nAmsRegistrationHandler  registrationHandler;\nvoid     *registrationHandlerUserData; AmsUnregistrationHandler unregistrationHandler;\nvoid    *unregistrationHandlerUserData;\nAmsInvitationHandler    invitationHandler;\nvoid    *invitationHandlerUserData; AmsDisinvitationHandler disinvitationHandler;\nvoid    *disinvitationHandlerUserData; AmsSubscriptionHandler   subscriptionHandler;\nvoid    *subscriptionHandlerUserData; AmsUnsubscriptionHandler  unsubscriptionHandler;\nvoid    *unsubscriptionHandlerUserData;\nAmsUserEventHandler userEventHandler;\nvoid    *userEventHandlerUserData;\nAmsMgtErrHandler    errHandler;\nvoid    *errHandlerUserData;\n} AmsEventMgt;\n\n/*  Predefined term values for ams_query and ams_get_event.  */ \n#define AMS_POLL (0)    /* Return immediately. */ \n#define AMS_BLOCKING  (-1)  /*   Wait forever.    */\n</code></pre>"},{"location":"AMS-Programmer-Guide/#module-management-functions","title":"Module Management functions","text":"<pre><code>int ams_register(char *mibSource, char *tsorder, char *applicationName, char *authorityName, char *unitName, char *roleName, AmsModule\n*module);\n</code></pre> <p>This function is used to initiate the application's participation as a  module in the message space identified by specified application and  authority names, within the local AMS continuum.</p> <p>mibSource indicates the location of the Management Information Base  (MIB) information that will enable the proposed new module to  participate in its chosen message space. Nominally it is the name of  an XML file in the current working directory; if NULL, mibSource  defaults to roleName.xml. (A future version of loadmib.c might load  MIB information from an ICI \"sdr\" database rather than from a file.)</p> <p>tsorder is the applicable overriding transport service selection  order string. This capability is not yet fully supported; for now,  tsorder should always be NULL.</p> <p>applicationName identifies the AMS application within which the  proposed new module is designed to function. The application must be  declared in the MIB.</p> <p>authorityName, together with applicationName, identifies the  message space in which the new module proposes to register. The  message space must be declared in the MIB.</p> <p>unitName identifies the cell, within the specified message space, in  which the new module proposes to register. The unit must be declared  in the MIB for ventures containing the specified message space, and a  registrar for this cell of this message space must currently be  running in order for the ams_register function to succeed.</p> <p>roleName identifies the functional role that the proposed new module  is designed to perform within the indicated application. The role must  be declared in the MIB for that application, and its name will serve  as the name of the module.</p> <p>module points to the variable in which the applicable AMS service  access point will be returned upon successful registration of the new  module.</p> <p>The function returns 0 on success, -1 on any error.</p> <p>The application thread that invoked ams_register is assumed by AMS to  be the main application thread for the module, or \"prime thread\".  Following successful completion of ams_register all threads of the  application process may commence invoking AMS services -- inviting  messages, publishing messages, etc. -- except that only the prime  thread may receive AMS events, e.g., process incoming messages.</p> <pre><code> int ams_get_module_nbr(AmsModule module);\n</code></pre> <p>The function returns the unique identifying number (within its chosen  cell) assigned to the indicated module as a result of successful  registration.</p> <pre><code> int ams_get_unit_nbr(AmsModule module);\n</code></pre> <p>The function returns the number that uniquely (within the message  space) identifies the cell in which the module registered. The  combination of unit number and module number uniquely identifies the  module within its message space.</p> <pre><code> int ams_set_event_mgr(AmsModule module, AmsEventMgt\n *rules);\n</code></pre> <p>The function starts a background \"event manager\" thread that  automatically receives and processes all AMS events (messages, notices  of message space configuration change, etc.) enqueued for the  indicated module.</p> <p>The thread processes each event according to the indicated rules  structure; any event for which a NULL callback function is provided is  simply discarded. For details of the rules structure and prototype  definitions for the callback functions that the rules point to, see  6.1 above. Some notes on this  interface:</p> <ul> <li>None of the callback functions return values, so they cannot   directly terminate the event manager. A callback function can   indirectly terminate the event manager by signaling the prime thread   to call ams_remove_event_mgr.</li> <li>The event delivered to a callback is recycled automatically when the   callback returns. If for some reason the application needs to retain   the event for a while, the callback function can prevent   therecycling of the event by simply setting *eventRef to NULL; in   this case the application assumes responsibility for recycling the   event at some future time in order to avert memory leakage.</li> </ul> <p>While the event manager thread is running, the prime thread is  prohibited from receiving any AMS events itself, i.e., ams_get_event  will always fail.</p> <p>Only the prime thread may call ams_set_event_mgr. The function returns  0 on success, -1 on any error.</p> <p><pre><code>void ams_remove_event_mgr(AmsModule module);\n</code></pre>  The function stops the background event manager thread for this  module, if any is running. Only the prime thread may call  ams_remove_event_mgr. Following completion of this function the prime  thread is once again able to receive and process AMS events.</p> <p><pre><code>int ams_unregister(AmsModule module);\n</code></pre>  The function terminates the module's registration, ending the ability  of any thread of the application process to invoke any AMS services;  it automatically stops the background event manager thread for this  module, if any is running.</p> <p>Only the prime thread may call ams_unregister. The function returns 0  on success, -1 on any error.</p>"},{"location":"AMS-Programmer-Guide/#message-subscription-and-invitation","title":"Message Subscription and Invitation","text":"<p><pre><code> int  ams_invite (AmsModule module, int roleNbr, int\n continuumNbr, int unitNbr, int subjectNbr, int priority, unsigned char\n flowLabel, AmsSequence sequence, AmsDiligence diligence);\n</code></pre>  This function establishes the module's willingness to accept messages  on a specified subject, under specified conditions, and states the  quality of service at which the module would prefer those messages to  be sent. Invitations are implicitly constrained by venture number:  only messages from modules registered in messages spaces characterized  by the same application and authority names as the message space in  which the inviting module itself is registered are included in any  invitation.</p> <p>module must be a valid AMS service access point as returned from  ams_register.</p> <p>roleNbr identifies the role that constrains the invitation: only  messages from modules registered as performing the indicated role are  included in this invitation. If zero, indicates \"all modules\".</p> <p>continuumNbr identifies the continuum that constrains the  invitation: only messages from modules operating within the indicated  continuum are included in this invitation. If -1, indicates \"the local  continuum\". If zero, indicates \"all continua\".</p> <p>unitNbr identifies the unit that constrains the invitation: only  messages from modules registered in cells identified by the indicated  number -- or in cells that are contained within such cells -- are  included in this invitation. A reminder: cell zero is the \"root cell\",  encompassing the entire message space.</p> <p>subjectNbr identifies the subject that constrains the invitation:  only messages on the indicated subject are included in this  invitation.</p> <p>priority indicates the level of priority (from 1 to 15, where 1 is  the highest priority indicating greatest urgency) at which the  inviting module prefers that messages responding to this invitation be  sent.</p> <p>flowLabel specifies the flow label (a number from 1 to 255, which  AMS may pass through to transport service adapters for  quality-of-service specification purposes) that the inviting module  asks issuing modules to cite when sending messages in response to this  invitation. Flow label 0 signifies \"no flow label.\"</p> <p>sequence indicates the minimum level of transmission order  preservation that the inviting module requires for messages responding  to this invitation.</p> <p>diligence indicates the minimum level of reliability (based on  acknowledgement and retransmission) that the inviting module requires  for messages responding to this invitation.</p> <p>The function returns 0 on success, -1 on any error. When successful,  it causes the invitation to be propagated automatically to all modules  in the inviting module's own message space.</p> <pre><code>int  ams_disinvite (AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr);\n</code></pre> <p>This function terminates the module's prior invitation for messages on  a specified subject under specified conditions. roleNbr,  continuumNbr, unitNbr, and subjectNbr must be identical to those  that characterized the invitation that is to be terminated. The  function returns 0 on success, -1 on any error. When successful, it  causes cancellation of the invitation to be propagated automatically  to all modules in the inviting module's own message space.</p> <pre><code>int  ams_subscribe (AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr, int priority, unsigned char flowLabel, AmsSequence sequence, AmsDiligence diligence);\n</code></pre> <p>This function establishes the module's request to receive a copy of  every future message published on a specified subject, under specified  conditions, and states the quality of service at which the module  would prefer those messages to be sent. Subscriptions are implicitly  constrained by venture number: only messages from modules registered  in messages spaces characterized by the same application and authority  names as the message space in which the subscribing module itself is  registered are included in any subscription.</p> <p>module must be a valid AMS service access point as returned from  ams_register.</p> <p>roleNbr identifies the role that constrains the subscription: only  messages from modules registered as performing the indicated role are  included in this subscription. If zero, indicates \"all modules\".</p> <p>continuumNbr identifies the continuum that constrains the  subscription: only messages from modules operating within the  indicated continuum are included in this subscription. If -1,  indicates \"the local continuum\". If zero, indicates \"all continua\".</p> <p>unitNbr identifies the unit that constrains the subscription: only  messages from modules registered in cells identified by the indicated  number -- or in cells that are contained within such cells -- are  included in this subscription. A reminder: cell zero is the \"root  cell\", encompassing the entire message space.</p> <p>subjectNbr identifies the subject that constrains the subscription:  only messages on the indicated subject are included in this  subscription. subjectNbr may be zero to indicate that messages  published on all subjects are requested; in this case, continuumNbr  must be -1.</p> <p>priority indicates the level of priority (from 1 to 15, where 1 is  the highest priority indicating greatest urgency) at which the  subscribing module prefers that messages responding to this  subscription be sent.</p> <p>flowLabel specifies the flow label (a number from 1 to 255, which  AMS may pass through to transport service adapters for  quality-of-service specification purposes) that the subscribing module  asks issuing modules to cite when publishing messages in response to  this subscription. Flow label 0 signifies \"no flow label.\"</p> <p>sequence indicates the minimum level of transmission order  preservation that the subscribing module requires for messages  responding to this subscription.</p> <p>diligence indicates the minimum level of reliability (based on  acknowledgement and retransmission) that the subscribing module  requires for messages responding to this subscription.</p> <p>The function returns 0 on success, -1 on any error. When successful,  it causes the subscription to be propagated automatically to all  modules in the subscribing module's own message space.</p> <pre><code>int  ams_unsubscribe (AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr);\n</code></pre> <p>This function terminates the module's prior subscription to messages  on a specified subject under specified conditions. roleNbr,  continuumNbr, unitNbr, and subjectNbr must be identical to those  that characterized the subscription that is to be terminated. The  function returns 0 on success, -1 on any error. When successful, it  causes cancellation of the subscription to be propagated automatically  to all modules in the subscribing module's own message space.</p>"},{"location":"AMS-Programmer-Guide/#configuration-lookup","title":"Configuration Lookup","text":"<p><pre><code> int  ams_lookup_unit_nbr (AmsModule module, char\n *unitName);\n</code></pre>  The function returns the unit number corresponding to the indicated  unitName, in the context of the venture encompassing the message  space in which the invoking module is registered. Returns -1 if this  unitName is undefined in this venture. <pre><code> int  ams_lookup_role_nbr (AmsModule module, char\n *roleName);\n</code></pre>  The function returns the role number corresponding to the indicated  roleName, in the context of the application characterizing the  message space in which the invoking module is registered. Returns -1  if this roleName is undefined in this application. <pre><code> int  ams_lookup_subject_nbr (AmsModule module, char\n *subjectName);\n</code></pre>  The function returns the subject number corresponding to the indicated  subjectName, in the context of the application characterizing the  message space in which the invoking module is registered. Returns -1  if this subjectName is undefined in this application. <pre><code> int  ams_lookup_continuum_nbr (AmsModule module, char\n *continuumName);\n</code></pre>  The function returns the continuum number corresponding to the  indicated continuumName, Returns -1 if the named continuum is  unknown. <pre><code> char * ams_lookup_unit_name (AmsModule module, int\n unitNbr);\n</code></pre>  The function returns the unit name corresponding to the indicated  unitNbr, in the context of the venture encompassing the message  space in which the invoking module is registered. Returns NULL if this  unitNbr is undefined in this venture. <pre><code> char * ams_lookup_role_name (AmsModule module, int\n roleNbr);\n</code></pre>  The function returns the role name corresponding to the indicated  roleNbr, in the context of the application characterizing the  message space in which the invoking module is registered. Returns NULL  if this roleNbr is undefined in this application. <pre><code> char * ams_lookup_subject_name (AmsModule module, int\n subjectNbr);\n</code></pre>  The function returns the subject name corresponding to the indicated  subjectNbr, in the context of the application characterizing the  message space in which the invoking module is registered. Returns NULL  if this subjectNbr is undefined in this application. <pre><code> char * ams_lookup_continuum_name (AmsModule module, int\n continuumNbr);\n</code></pre>  The function returns the continuum name corresponding to the indicated  continuumNbr. Returns NULL if the specified continuum is unknown. <pre><code> char * ams_get_role_name (AmsModule module, int unitNbr,\n int moduleNbr);\n</code></pre>  The function returns the name of the role under which the module  identified by unitNbr and moduleNbr is registered, within the  invoking module's own message space. Returns NULL if no module  identified by unitNbr and moduleNbr is known to be currently  registered within this message space. <pre><code> Lyst  ams_list_msgspaces (AmsModule module);\n</code></pre>  The function returns a Lyst (see the documentation for lyst) of the  numbers of all AMS continua in which there is known to be another  message space for the venture in which module is registered. Returns  NULL if there is insufficient free memory to create this list. NOTE:  be sure to use lyst_destroy to release the memory occupied by this  list when you're done with it. <pre><code> int  ams_subunit_of (AmsModule module, int argUnitNbr, int\n refUnitNbr);\n</code></pre>  The function returns 1 if the unit identified by argUnitNbr is a  subset of (or is identical to) the unit identified by refUnitNbr.  Otherwise it returns 0. <pre><code> int  ams_get_continuum_nbr ();\n</code></pre>  The function returns the local continuum number. <pre><code> int  ams_continuum_is_neighbor (int continuumNbr);\n</code></pre>  The function returns 1 if the continuum identified by continuumNbr  is a neighbor (within the RAMS network) of the local continuum.  Otherwise it returns 0. <pre><code> int  ams_rams_net_is_tree (AmsModule module);\n</code></pre>  The function returns 1 if the RAMS network is configured as a tree.  Otherwise it returns 0.</p>"},{"location":"AMS-Programmer-Guide/#message-issuance","title":"Message Issuance","text":"<p><pre><code> int  ams_publish (AmsModule module, int subjectNbr, int\n priority, unsigned char flowLabel, int contentLength, char *content,\n int context);\n</code></pre>  This function causes an AMS message to be constructed on the indicated  subject, encapsulating the indicated content and characterized by the  indicated processing context token, and causes one copy of that  message to be sent to every module in the message space that currently  asserts a subscription for messages on this subject such that the  invoking module satisfies the constraints on that subscription.</p> <p>priority may be any value from 1 to 15, overriding the priority  preference(s) asserted by the subscriber(s), or it may be zero  indicating \"use each subscriber's preferred priority.\" flowLabel may  be any value from 1 to 255, overriding the flow label preference(s)  asserted by the subscriber(s), or it may be zero indicating \"use each  subscriber's preferred flow label.\"</p> <p>The function returns 0 on success, -1 on any error. <pre><code> int  ams_send (AmsModule module, int continuumNbr, int\n unitNbr, int moduleNbr, int subjectNbr, int priority, unsigned char\n flowLabel, int contentLength, char *content, int context);\n</code></pre>  This function causes an AMS message to be constructed on the indicated  subject, encapsulating the indicated content and characterized by the  indicated processing context token, and causes that message to be sent  to the module identified by unitNbr and moduleNbr within the indicated  continuum, provided that this module currently asserts an invitation  for messages on this subject such that the invoking module satisfies  the constraints on that invitation.</p> <p>If continuumNbr is -1, the local continuum is inferred.</p> <p>priority may be any value from 1 to 15, overriding the priority  preference asserted by the destination module, or it may be zero  indicating \"use the destination module's preferred priority.\"  flowLabel may be any value from 1 to 255, overriding the flow label  preference asserted by the destination module, or it may be zero  indicating \"use the destination module's preferred flow label.\"</p> <p>The function returns 0 on success, -1 on any error. <pre><code>int  ams_query (AmsModule module, int continuumNbr, int unitNbr, int moduleNbr, int subjectNbr, int priority, unsigned char flowLabel, int contentLength, char *content, int context, int term, AmsEvent *event);\n</code></pre>  This function is identical to ams_send in usage and effect except  that, following issuance of the message, the function blocks (that is,  does not return control to the invoking function) until either (a) a  message that is a specific reply to this message is received or (b)  the time period indicated by term -- in microseconds -- elapses.  Upon return of control to the invoking function, the AMS event pointer  referenced by event points to the AMS event that caused the return  of control, either a reply message or a timeout or (possibly) a notice  of processing error. If term is 0, the function returns control to the  invoking function immediately and *event always points to a timeout  event. If term is -1, the function never returns control until a reply  message is received.</p> <p>The function returns 0 on success, -1 on any error. <pre><code> int  ams_reply (AmsModule module, AmsEvent msg, int\n subjectNbr, int priority, unsigned char flowLabel, int contentLength,\n char *content);\n</code></pre>  This function is identical to ams_send in usage and effect except that  the destination of the reply message is not stated explicitly by the  invoking function; instead, the invoking function provides a pointer  to the AMS message (an AmsEvent whose event type is AMS_MSG_EVT) whose  sender is the destination of the reply message.</p> <p>The function returns 0 on success, -1 on any error. <pre><code> int  ams_announce (AmsModule module, int roleNbr, int\n continuumNbr, int unitNbr, int subjectNbr, int priority, unsigned char\n flowLabel, int contentLength, char *content, int context);\n</code></pre>  This function causes an AMS message to be constructed on the indicated  subject, encapsulating the indicated content and characterized by the  indicated processing context token, and causes one copy of that  message to be sent to every module in the domain of the  announcement that currently asserts an invitation for messages on  this subject such that the invoking module satisfies the constraints  on that invitation. The domain of the announcement is the set of all  modules such that:</p> <ul> <li>The module is operating in the continuum identified by   continuumNbr. A value of -1 in</li> </ul> <p>continuumNbr indicates \"the local continuum\"; a value of zero  indicates \"all continua\".</p> <ul> <li>The module is registered in a message space that is characterized by   the same application name and authority name as the invoking   module's own message space.</li> <li>The module is registered, within its message space, in the unit   identified by unitNbr or in a unit that is contained within that   unit. Again, unit number zero identifies the root unit containing   all units in the message space.</li> <li>The module's role matches roleNbr. A value of zero in roleNbr   indicates \"all roles\".</li> </ul> <p>priority may be any value from 1 to 15, overriding the priority  preference(s) asserted by the destination module(s), or it may be zero  indicating \"use each destination module's preferred priority.\"  flowLabel may be any value from 1 to 255, overriding the flow label  preference(s) asserted by the destination module(s), or it may be zero  indicating \"use each destination module's preferred flow label.\"</p> <p>The function returns 0 on success, -1 on any error.</p>"},{"location":"AMS-Programmer-Guide/#event-including-message-reception","title":"Event (Including Message) Reception","text":"<p><pre><code>int  ams_get_event (AmsModule module, int term, AmsEvent\n *event);\n</code></pre>  This function acquires the next AMS event currently in the queue of  AMS events that have yet to be handled by the application. The  function blocks (that is, does not return control to the invoking  function) until either (a) an event is available to be acquired or (b)  the time period indicated by term -- in microseconds -- elapses.  Upon return of control to the invoking function, the AMS event pointer  referenced by event points to the AMS event that caused the return  of control: a message, a notice of message space configuration change,  a user-defined event, or a timeout. If term is 0, the function  returns control to the invoking function immediately. If term is -1,  the function never returns control until a non-timeout event can be  acquired.</p> <p>The function returns 0 on success, -1 on any error. Following  acquisition of an event, the application program should:</p> <ul> <li>Call ams_get_event_type to determine the type of the event.</li> <li>Call the appropriate event parsing function, based on the type of   the event, to extract the event's salient information. (Note that   timeout events contain no additional information and cannot be   further parsed.)</li> <li>Process the information conveyed by the event.</li> <li>Call ams_recycle_event to release the memory occupied by the event,   in order to prevent memory leakage.</li> </ul> <p><pre><code> int  ams_get_event_type (AmsEvent event);\n</code></pre>  This function returns the event type of the indicated event, enabling  the event to be properly parsed by the application program. The  possible event types are AMS_MSG_EVT, TIMEOUT_EVT, NOTICE_EVT, and  USER_DEFINED_EVT.</p> <p><pre><code> int  ams_parse_msg (AmsEvent event, int *continuumNbr,\n int *unitNbr, int *moduleNbr, int *subjectNbr, int *contentLength, char **content,\n int *context, AmsMsgType *msgType, int *priority, unsigned char *flowLabel);\n</code></pre>  This function extracts the content of an AMS event that is a received  message, inserting values into the variables that the function's  arguments point to. continuumNbr, unitNbr, and moduleNbr  identify the module that sent the message. Returns 0 unless one or  more of the arguments provided to the function are NULL, in which case  the function returns -1. <pre><code>int  ams_parse_notice (AmsEvent event, AmsStateType\n *state, AmsChangeType *change, int *unitNbr, int *moduleNbr, int *roleNbr, int *domainContinuumNbr, int *domainUnitNbr, int *subjectNbr, int *priority, unsigned char *flowLabel, AmsSequence *sequence, AmsDiligence *diligence);\n</code></pre>  This function extracts the content of an AMS event that is a notice of  change in message space configuration, inserting values into the  variables that the function's arguments point to.</p> <p>state and change indicate the nature of the change.</p> <p>unitNbr and moduleNbr identify the module to which the change  pertains.</p> <p>roleNbr is provided in the event that the change is the registration  of a new module (in which case it indicates the functional nature of  the new module) or is a subscription, unsubscription, invitation, or  disinvitation (in which case it indicates the role constraining the  subscription or invitation).</p> <p>For a notice of subscription, unsubscription, invitation, or  disinvitation:</p> <ul> <li>domainContinuumNbr indicates the continuum constraining the   subscription or invitation.</li> <li>domainUnitNbr indicates the unit constraining the subscription or   invitation.</li> <li>subjectNbr indicates the subject to which the subscription or   invitation pertains.</li> </ul> <p>For a notice of subscription or invitation, priority, flowLabel,  sequence, and diligence indicate the quality of service requested  by the module for this subscription or invitation.</p> <p>Returns 0 unless one or more of the arguments provided to the function  are NULL, in which case the function returns -1. <pre><code> int  ams_parse_user_event (AmsEvent event, int *code, int *dataLength, char **data);\n</code></pre>  This function extracts the content of a user-defined AMS event,  inserting values into the variables that the function's arguments  point to. Returns 0 unless one or more of the arguments provided to  the function are NULL, in which case the function returns -1. <pre><code> int  ams_recycle_event (AmsEvent event);\n</code></pre>  This function simply releases all memory occupied by the indicated  event. Returns 0 unless event is NULL, in which case the function  returns -1.</p>"},{"location":"AMS-Programmer-Guide/#user-event-posting","title":"User Event Posting","text":"<p><pre><code> int  ams_post_user_event (AmsModule module, int\n userEventCode, int userEventDataLength, char *userEventData, int\n priority);\n</code></pre>  This function posts a user-defined event into the queue of AMS events  that have yet to be handled by the application. userEventCode is an  arbitrary, user-defined numeric value; userEventData, if not NULL,  is assumed to be an arbitrary, user-defined character string of length  userEventDataLength.</p> <p>priority may be any value from 0 to 16. Note that this enables the  application to post an event to itself that is guaranteed to be of  higher priority than any message -- assuring that it will be processed  before any message that is currently enqueued or that arrives in the  future -- or, alternatively, to post an event that is guaranteed to be  of lower priority than any message and will therefore only be  processed during a lull in message reception.</p> <p>Returns 0 on success, -1 on any error.</p>"},{"location":"AMS-Programmer-Guide/#remote-ams","title":"Remote AMS","text":"<p>The JPL implementation of Remote AMS comprises a library  (librams.c) and a sample RAMS gateway program (ramsTest.c)  that uses that library.</p>"},{"location":"AMS-Programmer-Guide/#library","title":"Library","text":"<p>The RAMS library implements a very simple API, which is defined by the  header file</p> <p>rams.h and comprises just a single function: <pre><code> int  rams_run (char *mibSource, char *tsorder, char\n *applicationName, char *authorityName, char *unitName, char\n *roleName, int lifetime);\n</code></pre>  This function initiates a RAMS gateway operations loop. mibSource,  tsorder, mName, memory, mSize, applicationName,  authorityName, unitName, and roleName are as discussed in the  documentation of  ams_register  above; they are used to  register the RAMS gateway process as an AMS module. lifetime is the  user-specified maximum time to live for all DTN bundles issued by the  RAMS gateway in the course of its communications over the RAMS  network.</p> <p>Note that the priority assigned to any DTN bundle that conveys a  published or privately sent AMS message over the RAMS network will be  computed as a function of the flow label specified at the time the  message was originally published or sent. If no overriding flow label  was specified, then the bundle priority will be 1 (standard).  Otherwise, the number represented by the two low-order bits of the  flow label will be used as the bundle priority and two \"extended class  of service\" parameters will be derived from the next two higher-order  bits of the flow label: bit 5 (the 3^rd^-lowest-order bit) will be  used as the value of the \"minimum latency\" flag, with a value of 1  indicating that the bundle is critical, and bit 4 (the  4^th^-lowest-order bit) will be used as the value of the \"best-effort\"  flag, with a value of 1 indicating that the bundle should be sent over  an unacknowledged convergence-layer protocol. All bundles issued by  the RAMS gateway that don't carry AMS messages will be assigned bundle  priority 1.</p> <p>This function runs indefinitely until it fails or is interrupted by a  SIGINT signal. Returns -1 on any failure, 0 on normal termination.</p>"},{"location":"AMS-Programmer-Guide/#ramsgate","title":"ramsgate","text":"<p>The sample RAMS gateway program ramsgate provides basic RAMS  gateway functionality. To run it, enter a command of the following  form at a terminal window prompt: <pre><code> ramsgate *application_name authority_name_name lifetime*\n [*memory_size* [*memory_manager_name*]]\n</code></pre> application_name, authority_name, lifetime,  memory_manager_name, and memory_size are as discussed in the  documentation of ams_register. If not specified, memory size defaults  to 200000. The gateway process always registers in the role named  \"RAMS\".</p> <p>Note that ramsgate relies on the ION implementation of DTN; be  sure an ION node is operating on the local computer before starting  ramsgate. (See the ION Design and Operations Guide for details.)</p> <p>To terminate operation of the gateway process, just use CTRL-C to  interrupt the program.</p>"},{"location":"AMS-Programmer-Guide/#management-information-base","title":"Management Information Base","text":"<p>In order to operate correctly, every AMS application process -- and  amsd as well -- must initially load Management Information Base  (MIB) values that are universally consistent.</p> <p>Currently this is accomplished automatically during registration: MIB  value declaration commands in XML format are read from a file, parsed,  and processed automatically.</p>"},{"location":"AMS-Programmer-Guide/#mib-file-syntax","title":"MIB file syntax","text":"<p>The elements of the XML files used to load AMS MIBs are as follows:  [ams_mib_load] : contains a series of MIB load commands.</p> <p>Attributes: none</p> <p>[ams_mib_init] : command that initializes the MIB.  Attributes:</p> <p>continuum_nbr: the number identifying the local continuum ptsname: the  name of the primary transport service</p> <p>[ams_mib_add] : contains a series of elements that add  items to the MIB.</p> <p>Attributes: none</p> <p>[continuum] :</p> <p>Attributes:</p> <p>nbr: the number that identifies this continuum name: the name that  identifies this continuum</p> <p>neighbor: a Boolean indication (\"1\" or \"0\") of whether or not this is  a neighboring continuum [If omitted, the continuum is by default  assumed to be a neighbor -- that is, an implicit neighbor=\"1\"  attribute is the default.]</p> <p>desc: a brief textual description of this continuum</p> <p>[csendpoint] : configuration server endpoint specification  (i.e., network location of configuration server)</p> <p>Attributes:</p> <p>epspec: PTS-specific endpoint specification string (to be more fully  documented in a later edition of this [Programmer's  Guide] )</p> <p>[application] : defines an application Attributes:</p> <p>name: name of application</p> <p>[venture] : defines a venture (an instance of an  application) Attributes:</p> <p>[nbr]: the number that identifies this venture</p> <p>[appname]: the name of the application served by this venture</p> <p>[authname]: the name of the authority responsible for this instance of  this application</p> <p>[net_config]: the configuration (\"mesh\" or \"tree\") of the RAMS network  comprising all AMS continua that participate in this venture. If  omitted, the RAMS network configuration is by default assumed to be a  mesh.</p> <p>[gweid]: a string identifying the endpoint for the local continuum's  RAMS gateway within the RAMS network for this venture; default is  \"bp@ipn:local_continuum_nbr.venture_nbr\"</p> <p>root_cell_resync_period: the period (expressed as a count of registrar  heartbeats) on which the configuration of the root unit of this  venture will automatically be resynchronized. If omitted or set to  zero, automatic resync is disabled within the root unit.</p> <p>[role] : defines a role within a venture Attributes:</p> <p>[nbr]: the number that identifies this role </p> <p>[name]: the name that  identifies this role</p> <p>[subject] : defines a message subject within a venture  Attributes:</p> <p>[nbr]: the number that identifies this subject </p> <p>[name]: the name that  identifies this subject</p> <p>[desc]: a brief textual description of this message subject</p> <p>[element] : defines one of the elements (fields) of a  message on a given subject (note that elements must be defined in the  order in which they appear in the message, without omission)</p> <p>Attributes:</p> <p>[type]: a number that specifies the data type of this element (1 = long,  2 = int, 3 = short, 4 = char, 5 = string)</p> <p>[name]: the name that identifies this element</p> <p>[desc]: a brief textual description of this message field.  [unit] : defines a unit of a venture</p> <p>Attributes:</p> <p>[nbr]: the number that identifies this unit name: the name that  identifies this unit</p> <p>[resync_period]: the period (expressed as a count of registrar  heartbeats) on which the configuration of this unit will automatically  be resynchronized. If omitted or set to zero, automatic resync is  disabled within this unit.</p> <p>[msgspace] : identifies a remote continuum that contains a  message space that is part of this venture</p> <p>[Attributes]:</p> <p>[nbr]: the number that identifies the continuum containing this message  space</p> <p>[gweid]: a string identifying the endpoint for the indicated continuum's  RAMS gateway, within the RAMS network for this venture; default is  \"bp@ipn:continuum_nbr.venture_nbr\"</p> <p>neighbor: Signifies adjacency of the message space with the parent  continuum using a Boolean value (i.e. 1 is adjacent, 0 is  non-adjacent). Note that in this context message space is analogous to  continuum. If the neighbor attribute is omitted the default value is  1.</p>"},{"location":"AMS-Programmer-Guide/#a-sample-mib","title":"A Sample MIB","text":"<pre><code>&lt;?xml version=\"1.0\" standalone=\"yes\"?&gt;\n&lt;ams_mib_load&gt;\n&lt;ams_mib_init continuum_nbr=\"1\" ptsname=\"dgr\"/&gt;\n&lt;ams_mib_add&gt;\n&lt;continuum nbr=\"2\" name=\"gsfc\"\" desc=\"Goddard Space Flight Center\"/&gt;\n&lt;csendpoint epspec=\"amroc.net:2502\"/&gt;\n&lt;application name=\"demo\"/&gt;\n&lt;venture nbr=\"9\" appname=\"demo\" authname=\"test\" &gt;\n&lt;role nbr=\"2\" name=\"shell\"/&gt;\n&lt;role nbr=\"3\" name=\"log\"/&gt;\n&lt;role nbr=\"4\" name=\"pitch\"/&gt;\n&lt;role nbr=\"5\" name=\"catch\"/&gt;\n&lt;role nbr=\"6\" name=\"benchs\"/&gt;\n&lt;role nbr=\"7\" name=\"benchr\"/&gt;\n&lt;subject nbr=\"1\" name=\"text\" desc=\"ASCII text\"/&gt;\n&lt;subject nbr=\"2\" name=\"noise\" desc=\"more ASCII text\"/&gt;\n&lt;subject nbr=\"3\" name=\"bench\" desc=\"numbered messages\"/&gt;\n&lt;unit nbr=\"1\" name=\"orbiters\"/&gt;\n&lt;unit nbr=\"2\" name=\"orbiters.near\"/&gt;\n&lt;unit nbr=\"3\" name=\"orbiters.far\"/&gt;\n&lt;msgspace nbr=\"2\" neighbor=1/&gt;\n&lt;/venture&gt;\n&lt;/ams_mib_add&gt;\n&lt;/ams_mib_load&gt;\n</code></pre>"},{"location":"AMS-Programmer-Guide/#application-development","title":"Application Development","text":"<p>AMS applications (i.e. \"modules\") are custom software built using AMS'  application programming interface (API). These AMS modules serve as  the interfaces between AMS and mission-specific processes or  applications.</p>"},{"location":"AMS-Programmer-Guide/#overview_1","title":"Overview","text":"<p>A general overview of the required steps follows this sequence:</p> <ol> <li>Include the AMS library header file (ams.h) in your application's    source code</li> <li>Use the provided AMS library functions to implement the interface    (to include functionality such as publication and subscription)</li> <li>Compile your application and link the compiled binary to the    required library objects (i.e. ici, dgr, ltp, bp)</li> </ol>"},{"location":"AMS-Programmer-Guide/#compiling-custom-ams-applications","title":"Compiling Custom AMS Applications","text":"<p>Applications created with the API must be compiled with links to ION's  dynamic libraries.</p> <p>The following two-step build procedure provides an example of how this works (note that the default path for installed ION library files (Linux) is used: /usr/local/lib/):</p> <pre><code>gcc -g -Wall -Werror -Dlinux -DUDPTS -DTCPTS -DDGRTS -DNOEXPAT -fPIC -DSPACE_ORDER=3 -I../library -I../include -I../rams -I/usr/local/include -c your_module_name.c\n\ngcc -g -Wall -Werror -Dlinux -DUDPTS -DTCPTS -DDGRTS -DNOEXPAT -fPIC -DSPACE_ORDER=3 -I../library -I../include -I../rams -I/usr/local/include -o your_module_name your_module_name.o -L./lib -L/usr/local/lib -lams -ldgr -lici -lpthread -lm*\n</code></pre>"},{"location":"AMS-Programmer-Guide/#running-the-application","title":"Running the Application","text":"<p>Applications must self-register with an AMS registrar. To facilitate this the following information is required by the application (i.e. using the ams_register() function):</p> <ol> <li>unit name</li> <li>role name</li> <li>application name</li> <li>authority name</li> </ol> <p>Given this requirement, it may be useful (but not necessary) for the  application to accept command line arguments.</p> <p>An example command to start a custom AMS module might look like the  following: <pre><code>./your_module_name ' ' your_module_mib_role_name amsdemo test\n</code></pre>  Note: the empty quotes (' ') above are used to specify registration  with the root unit registrar.</p>"},{"location":"AMS-Programmer-Guide/#a-sample-application","title":"A Sample Application","text":"<p>Follows is the complete source code for 'amshello', a simple  Unix-based AMS application installed alongside AMS. It is a complete  distributed system comprising two AMS application modules that  functions as follows.</p> <p>When the amshello program starts it fork()s into two processes, a  \"pitcher\" and a \"catcher\". Both processes then register as modules in  the root cell of an \"amsdemo/test\" message space. The catcher invites  messages on subject \"text\" and waits for the first such message to  arrive. The pitcher waits for an invitation to send messages of  subject \"text\" and, when it arrives, sends one such message and  terminates. When the catcher receives the message it prints the text  of the message and then terminates.</p> <p>To run the 'amshello' demonstration application the following 2 steps  are required.</p> <ol> <li>An AMS configuration server and registrar must be started (do this    after all other ION processes have started) using the following    command:amsd @ @ amsdemo test \"\" &amp;</li> <li>Then run the amshello application using the following command:    amshello</li> </ol> <p>Important points regarding the above amsd command (see man amsd  for additional details):</p> <ul> <li>The first '@' character specifies the use of AMS' in-memory MIB   (used for demonstration purposes only)</li> <li>The second '@' character specifies that the daemon will serve as   both a registrar and configuration server (running at   127.0.0.1:2357)</li> <li>The \"\" parameter specifies that the registrar function as the \"root   unit\" registrar</li> </ul> <pre><code>/*\namshello.c\n\"Hello world\" demonstration using AMS - Unix platform (only)\n\nCopyright (c) 2023, California Institute of Technology. \nSky DeBaun, Jet Propulsion Laboratory.\n\n\nThis program assumes the following conditions---------------\n1.) ION is running\n2.) An AMS Registrar is running     \n3.) An AMS Configuration Server is running \n4.) An MIB configuration file has been created and is specified for use (see note below)\n\n*NOTE: the following command completes steps 2, 3, and 4 above (run this command after other ION processes start, then run the \u2018amshello\u2019 command from terminal to run the program):\n\namsd @ @ amsdemo test \"\" &amp;\n\n\n*/\n\n#include \"ams.h\"\n\nstatic int  runPitcher()\n{\n    AmsModule           me;\n    AmsEvent            evt;\n    AmsStateType        state;\n    AmsChangeType       change;\n    int             zn, nn, rn, dcn, dzn, sn, pr, textlen;\n    unsigned char       fl;\n    AmsSequence         sequence;\n    AmsDiligence        diligence;\n    char                buffer[80];\n\n    isprintf(buffer, sizeof buffer, \"Hello from process %d\", (int)     getpid());\n    textlen = strlen(buffer) + 1;\n\n    //register pitch module using default in-memory MIB (i.e. using the @)\n    oK(ams_register(\"@\", NULL, \"amsdemo\", \"test\", \"\", \"pitch\", &amp;me));\n\n    while (1)\n    {\n        if (ams_get_event(me, AMS_BLOCKING, &amp;evt) &lt; 0) \n{\nreturn 0;\n}\nelse\n{\n            ams_parse_notice(evt, &amp;state, &amp;change, &amp;zn, &amp;nn, &amp;rn, &amp;dcn,\n                    &amp;dzn, &amp;sn, &amp;pr, &amp;fl, &amp;sequence, &amp;diligence);\n            ams_recycle_event(evt);\n}\n\n        if (state == AmsInvitationState &amp;&amp; sn == 1)\n        {\n            printf(\"Process %d sending:  '%s'\\n\", (int) getpid(), buffer);\n            fflush(stdout);\n            ams_send(me, -1, zn, nn, 1, 0, 0, textlen, buffer, 0);\n            ams_unregister(me); \nreturn 0;\n        }\n    }\n}\n\nstatic int  runCatcher()\n{\n    AmsModule           me;\n    AmsEvent            evt;\n    int             cn, zn, nn, sn, len, ct, pr;\n    unsigned char       fl;\n    AmsMsgType          mt;\n    char                *txt;\n\n    //register catch module using default in-memory MIB (i.e. @)\n    oK(ams_register(\"@\", NULL, \"amsdemo\", \"test\", \"\", \"catch\", &amp;me));\n    ams_invite(me, 0, 0, 0, 1, 8, 0, AmsArrivalOrder, AmsAssured);\n\n    while (1)\n    {\n        if (ams_get_event(me, AMS_BLOCKING, &amp;evt) &lt; 0) return 0;\n        if (ams_get_event_type(evt) == AMS_MSG_EVT) break;\n        else ams_recycle_event(evt);\n    }\n\n    ams_parse_msg(evt, &amp;cn, &amp;zn, &amp;nn, &amp;sn, &amp;len, &amp;txt, &amp;ct, &amp;mt, &amp;pr, &amp;fl);\n    printf(\"Process %d received: '%s'\\n\", (int) getpid(), txt); fflush(stdout);\n    ams_recycle_event(evt); ams_unregister(me); return 0;\n}\n\n\nint main(void) \n{\n    pid_t pid = fork();\n\n    if (pid == -1) {\n        fprintf(stderr, \"Failed to create child process.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (pid == 0)\n        //child process runs transmitter----------------------\n        runPitcher();\n    else \n    {\n        //parent process runs receiver------------------------\n        runCatcher();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"AMS-Programmer-Guide/#acknowledgment","title":"Acknowledgment","text":"<p>The research described in this publication was carried out at the Jet  Propulsion Laboratory, California Institute of Technology, under a  contract with the National Aeronautics and Space Administration.</p>"},{"location":"BP-Service-API/","title":"BP Service API","text":"<p>This tutorial goes over the basic user APIs for developing application software to take advantage of the Bundle Protocol (BP) services provided by ION.</p>"},{"location":"BP-Service-API/#pre-requisite","title":"Pre-requisite","text":"<p>For a user-developed software to utilize BP services provided by ION, there are two pre-requisite conditions: (1) ION services must be properly configured and already running in a state ready to provide BP services, and (2) BP libraries and header files must be installed and linked to the user application.</p>"},{"location":"BP-Service-API/#check-ion-installation-bp-version","title":"Check ION Installation &amp; BP Version","text":"<p>A simple way to check if ION is installed in the host is to determine the installation location of ION, one can execute <code>which ionadmin</code> and it will show the directory where ionadmin is currently located:</p> <pre><code>$ which ionadmin\n/usr/local/bin/ionadmin\n</code></pre> <p>If ionadmin is not found, it means either ION was not built or not properly installed in the execution path. If ionadmin is found, run it and provide the command <code>v</code> at the <code>:</code> prompt to determine the installed ION software version. For example:</p> <pre><code>$ ionadmin\n: v\nION-OPEN-SOURCE-4.1.2\n</code></pre> <p>Quit ionadmin by command <code>q</code>. Quitting <code>ionadmin</code> will not terminate any ION and BP services, it simply ends ION's user interface for configuration query and management. If you see warning messages such as those shown below when quitting <code>ionadmin</code>, then it confirms that ION is actually not running at the moment. There are no software error:</p> <pre><code>: q\nat line 427 of ici/library/platform_sm.c, Can't get shared memory segment: Invalid argument (0)\nat line 312 of ici/library/memmgr.c, Can't open memory region.\nat line 367 of ici/sdr/sdrxn.c, Can't open SDR working memory.\nat line 513 of ici/sdr/sdrxn.c, Can't open SDR working memory.\nat line 963 of ici/library/ion.c, Can't initialize the SDR system.\nStopping ionadmin.\n</code></pre> <p>You can also run <code>bpversion</code> to determine the version of Bundle Protocol built in the host:</p> <pre><code>$ bpversion\nbpv7\n</code></pre>"},{"location":"BP-Service-API/#determine-bp-service-state","title":"Determine BP Service State","text":"<p>Once it is determined that ION has been installed, a user may want to determine whether BP service is running by checking for the presence of various BP daemons and shared memory/semaphores, which are created by ION for interprocess communications among the various the BP service daemons.</p> <p>To check if BP service is running, you can list current running processes using <code>ps -aux</code> command and inspect if you see the following BP service daemons:</p> <ul> <li><code>rfxclock</code> - background daemon that schedules ION network configuration events</li> <li><code>bpclm</code> - background daemon that selects and meters data transmission to outbound convergence layers</li> <li><code>bpclock</code> - background daemon that schedule BP level events</li> <li><code>bptransit</code> - daemon to move inbound traffic to outbound queue for forwarding</li> <li><code>ipnfw</code> - BP IPN scheme-specific bundle routing daemon</li> <li><code>ipnadminep</code> - IPN scheme-specific administrative end-point daemon</li> </ul> <p>You can find more details about these daemons in the manual pages. You may also see  daemons related to other activate modules. For example, if the LTP engine is active in the system, you will see the following daemons:</p> <ul> <li><code>ltpclock</code></li> <li><code>ltpdeliv</code></li> <li><code>ltpmeter</code></li> <li><code>udplso</code></li> <li><code>udplsi</code></li> <li><code>ltpcli</code></li> <li><code>ltpclo</code></li> </ul> <p>To further vary that BP service is running, you can check for presence of ION shared memory and semaphores:</p> <pre><code>------ Shared Memory Segments --------\nkey        shmid      owner         perms      bytes      nattch     status   \n0x0000ee02 47         userIon       666        641024     13                  \n0x0000ff00 48         userIon       666        50000000   13                  \n0x93de0005 49         userIon       666        1200002544 13                  \n0x0000ff01 50         userIon       666        500000000  13                  \n\n------ Semaphore Arrays --------\nkey        semid      owner         perms      nsems   \n0x0000ee01 23         userIon       666        1     \n0x18020001 24         userIon       666        250   \n</code></pre> <p>In this example, the shared memory and semaphore keys for the SDR heap space (shmid 49) and the semaphorebase (semid 24) are created using a random key generated from the process ID of <code>ionadmin</code> and they will vary each time ION is instantiated. This is specific to SVR4 semaphore, which is the default for ION 4.1.2. However, starting with ION 4.1.3, the default semaphore will switch to POSIX semaphore and the output will be different. The other memory and semaphore keys listed in this example are typical default values, but they too, can be changed through ionconfig files.</p>"},{"location":"BP-Service-API/#if-ion-is-installed-but-not-running","title":"If ION is installed but not running","text":"<p>If ION is installed but not running (either you see no shared memory or don't see the BP service daemons) you can restart ION. Before restarting ION, run <code>ionstop</code> to clear all remaining orphaned processes/shared memory allocations in case the previous instance of BP service was not properly shutdown or has suffered a crash. Here is an example of the output you may see:</p> <pre><code>$ ionstop\nIONSTOP will now stop ion and clean up the node for you...\ncfdpadmin .\nStopping cfdpadmin.\nbpv7\nbpadmin .\nStopping bpadmin.\nltpadmin .\nStopping ltpadmin.\nionadmin .\nStopping ionadmin.\nbsspadmin .\nBSSP not initialized yet.\nStopping bsspadmin.\nThis is a single-ION instance configuration. Run killm.\nkillm\nSending TERM to acsadmin lt-acsadmin    acslist lt-acslist      aoslsi lt-aoslsi        aoslso lt-aoslso        bibeadmin lt-bibeadmin  bibeclo lt-bibeclo     bpadmin lt-bpadmin      bpcancel lt-bpcancel    bpchat lt-bpchat        bpclm lt-bpclm  bpclock lt-bpclock      bpcounter lt-bpcounter         bpdriver lt-bpdriver    bpecho lt-bpecho        bping lt-bping  bplist lt-bplist        bpnmtest lt-bpnmtest    bprecvfile lt-bprecvfile       bpsecadmin lt-bpsecadmin        bpsendfile lt-bpsendfile        bpsink lt-bpsink        bpsource lt-bpsource    bpstats lt-bpstats     bpstats2 lt-bpstats2    bptrace lt-bptrace      bptransit lt-bptransit  brsccla lt-brsccla      brsscla lt-brsscla      bsscounter lt-bsscounter       bssdriver lt-bssdriver  bsspadmin lt-bsspadmin  bsspcli lt-bsspcli      bsspclo lt-bsspclo      bsspclock lt-bsspclock  bssrecv lt-bssrecv     bssStreamingApp lt-bssStreamingApp      cgrfetch lt-cgrfetch    cpsd lt-cpsd    dccpcli lt-dccpcli      dccpclo lt-dccpclo    dccplsi lt-dccplsi       dccplso lt-dccplso      dgr2file lt-dgr2file    dgrcli lt-dgrcli        dgrclo lt-dgrclo        dtka lt-dtka    dtkaadmin lt-dtkaadmin         dtn2admin lt-dtn2admin  dtn2adminep lt-dtn2adminep      dtn2fw lt-dtn2fw        dtpcadmin lt-dtpcadmin  dtpcclock lt-dtpcclock         dtpcd lt-dtpcd  dtpcreceive lt-dtpcreceive      dtpcsend lt-dtpcsend    file2dgr lt-file2dgr    file2sdr lt-file2sdr    file2sm lt-file2sm     file2tcp lt-file2tcp    file2udp lt-file2udp    hmackeys lt-hmackeys    imcadmin lt-imcadmin    imcadminep lt-imcadminep      imcfw lt-imcfw   ionadmin lt-ionadmin    ionexit lt-ionexit      ionrestart lt-ionrestart        ionsecadmin lt-ionsecadmin      ionunlock lt-ionunlock         ionwarn lt-ionwarn      ipnadmin lt-ipnadmin    ipnadminep lt-ipnadminep        ipnd lt-ipnd    ipnfw lt-ipnfw  lgagent lt-lgagent     lgsend lt-lgsend        ltpadmin lt-ltpadmin    ltpcli lt-ltpcli        ltpclo lt-ltpclo        ltpclock lt-ltpclock    ltpcounter lt-ltpcounter       ltpdeliv lt-ltpdeliv    ltpdriver lt-ltpdriver  ltpmeter lt-ltpmeter    ltpsecadmin lt-ltpsecadmin      nm_agent lt-nm_agent  nm_mgr lt-nm_mgr         owltsim lt-owltsim      owlttb lt-owlttb        psmshell lt-psmshell    psmwatch lt-psmwatch    ramsgate lt-ramsgate  rfxclock lt-rfxclock     sdatest lt-sdatest      sdr2file lt-sdr2file    sdrmend lt-sdrmend      sdrwatch lt-sdrwatch    sm2file lt-sm2file    smlistsh lt-smlistsh     smrbtsh lt-smrbtsh      stcpcli lt-stcpcli      stcpclo lt-stcpclo      tcaadmin lt-tcaadmin    tcaboot lt-tcaboot    tcacompile lt-tcacompile tcapublish lt-tcapublish        tcarecv lt-tcarecv      tcc lt-tcc      tccadmin lt-tccadmin    tcp2file lt-tcp2file  tcpbsi lt-tcpbsi         tcpbso lt-tcpbso        tcpcli lt-tcpcli        tcpclo lt-tcpclo        udp2file lt-udp2file    udpbsi lt-udpbsi      udpbso lt-udpbso         udpcli lt-udpcli        udpclo lt-udpclo        udplsi lt-udplsi        udplso lt-udplso                amsbenchr lt-amsbenchr         amsbenchs lt-amsbenchs  amsd lt-amsd    amshello lt-amshello    amslog lt-amslog        amslogprt lt-amslogprt  amsshell lt-amsshell   amsstop lt-amsstop      bputa lt-bputa  cfdpadmin lt-cfdpadmin  cfdpclock lt-cfdpclock  cfdptest lt-cfdptest    bpcp lt-bpcp    bpcpd lt-bpcpd ...\nSending KILL to the processes...\nChecking if all processes ended...\nDeleting shared memory to remove SDR...\nKillm completed.\nION node ended. Log file: ion.log\n</code></pre> <p>At this point run <code>ps -aux</code> or <code>ipcs</code> to verify that ION has terminated completely.</p>"},{"location":"BP-Service-API/#simple-ion-installation-test","title":"Simple ION Installation Test","text":"<p>When ION is not running, you can performance a simple unit test to verify ION is build properly.</p> <p>Navigate to the root directory of the ION source code, <code>cd</code> into the <code>tests</code> folder and then execute a <code>bping</code> test using the command:</p> <pre><code>./runtest bping\n</code></pre> <p>You can watch the terminal output ION restarting itself and executing a loopback ping. When successful it will indicate at the end of the test:</p> <pre><code>TEST PASSED!\n\npassed: 1\n    bping\n\nfailed: 0\n\nskipped: 0\n\nexcluded by OS type: 0\n\nexcluded by BP version: 0\n\nobsolete tests: 0\n</code></pre>"},{"location":"BP-Service-API/#locate-ion-libraries-and-header-files","title":"Locate ION Libraries and Header Files","text":"<p>The standard <code>./configure; make; sudo make install; sudo ldconfig</code> process should automatically install the BP libraries under <code>/usr/local/lib</code> and the relevant header files under <code>/usr/local/include</code> unless ION is specifically configured to a different customized install location through the <code>./configure</code> script during the compilation process. Here is a list of libraries and header files you should find there:</p> <pre><code>$ cd /usr/local/lib\n$ ls\nlibamp.a                 libbp.so.0.0.0    libcgr.a          libdtpc.la        libmbedcrypto.so.7   libtc.so.0.0.0      libudpcla.a\nlibamp.la                libbss.a          libcgr.la         libdtpc.so        libmbedtls.a         libtcaP.a           libudpcla.la\nlibamp.so                libbss.la         libcgr.so         libdtpc.so.0      libmbedtls.so        libtcaP.la          libudpcla.so\nlibamp.so.0              libbss.so         libcgr.so.0       libdtpc.so.0.0.0  libmbedtls.so.14     libtcaP.so          libudpcla.so.0\nlibamp.so.0.0.0          libbss.so.0       libcgr.so.0.0.0   libici.a          libmbedx509.a        libtcaP.so.0        libudpcla.so.0.0.0\nlibampAgentADM.a         libbss.so.0.0.0   libdgr.a          libici.la         libmbedx509.so       libtcaP.so.0.0.0    libudplsa.a\nlibampAgentADM.la        libbssp.a         libdgr.la         libici.so         libmbedx509.so.1     libtcc.a            libudplsa.la\nlibampAgentADM.so        libbssp.la        libdgr.so         libici.so.0       libstcpcla.a         libtcc.la           libudplsa.so\nlibampAgentADM.so.0      libbssp.so        libdgr.so.0       libici.so.0.0.0   libstcpcla.la        libtcc.so           libudplsa.so.0\nlibampAgentADM.so.0.0.0  libbssp.so.0      libdgr.so.0.0.0   libltp.a          libstcpcla.so        libtcc.so.0         libudplsa.so.0.0.0\nlibams.a                 libbssp.so.0.0.0  libdtka.a         libltp.la         libstcpcla.so.0      libtcc.so.0.0.0     libzfec.a\nlibams.la                libcfdp.a         libdtka.la        libltp.so         libstcpcla.so.0.0.0  libtcpbsa.a         libzfec.la\nlibbp.a                  libcfdp.la        libdtka.so        libltp.so.0       libtc.a              libtcpbsa.la        libzfec.so\nlibbp.la                 libcfdp.so        libdtka.so.0      libltp.so.0.0.0   libtc.la             libtcpbsa.so        libzfec.so.0\nlibbp.so                 libcfdp.so.0      libdtka.so.0.0.0  libmbedcrypto.a   libtc.so             libtcpbsa.so.0      libzfec.so.0.0.0\nlibbp.so.0               libcfdp.so.0.0.0  libdtpc.a         libmbedcrypto.so  libtc.so.0           libtcpbsa.so.0.0.0\n\n\n$ cd /usr/local/include\n$ ls\nams.h               bpsec_instr.h  cfdpops.h  eureka.h       llcv.h    platform.h     rfc9173_utils.h  sdrhash.h    sdrxn.h    tcaP.h\nbcb_aes_gcm_sc.h    bpsec_util.h   crypto.h   icinm.h        ltp.h     platform_sm.h  rfx.h            sdrlist.h    smlist.h   tcc.h\nbib_hmac_sha2_sc.h  bss.h          dgr.h      ion.h          lyst.h    psa            sci.h            sdrmgt.h     smrbt.h    tccP.h\nbp.h                bssp.h         dtka.h     ion_test_sc.h  mbedtls   psm.h          sda.h            sdrstring.h  sptrace.h  zco.h\nbpsec_asb.h         cfdp.h         dtpc.h     ionsec.h       memmgr.h  radix.h        sdr.h            sdrtable.h   tc.h\n</code></pre> <p>In this document, we assume that ION was build and installed via the <code>./configure</code> installation process using the full open-source codebase and with the standard set of options.</p> <p>The location and content of the library and header directories shown above included non-BP modules and may not match exactly with what you have especially if you have built ION with features options enabled via <code>./configure</code> or used a manual/custom Makefile, or built ION from the <code>ion-core</code> package instead.</p>"},{"location":"BP-Service-API/#launch-ion-bp-services","title":"Launch ION &amp; BP Services","text":"<p>Once you are confidant that ION has been properly built and installed in the system, you can start BP service by launching ION. To do this, please consult the various tutorials under Configuration.</p> <p>After launching ION, you can verify BP service status in the same manner as described in previous section.</p>"},{"location":"BP-Service-API/#bp-service-api-reference","title":"BP Service API Reference","text":""},{"location":"BP-Service-API/#header","title":"Header","text":"<pre><code>#include \"bp.h\"\n</code></pre>"},{"location":"BP-Service-API/#bp_attach","title":"bp_attach","text":"<p>Function Prototype</p> <pre><code>int bp_attach( )\n</code></pre> <p>Parameters</p> <ul> <li>None.</li> </ul> <p>Return Value</p> <ul> <li>On success: 0</li> <li>Any error: -1</li> </ul> <p>Example Call</p> <pre><code>if (bp_attach() &lt; 0)\n{\n        printf(\"Can't attach to BP.\\n\");\n        /* user inser error handling code */\n}\n</code></pre> <p>Description</p> <p>Typically the <code>bp_attach()</code> call is made at the beginning of a user's application to attach to BP Service provided by ION in the host machine. This code checks for a negative return value.</p> <p><code>bp_attach()</code> automatically calls the ICI API <code>ion_attach()</code> when necessary, so there is no need to call them separately. In addition to gaining access to ION's SDR, which is what <code>ion_attach()</code> provides, <code>bp_attach()</code> also gains access to the Bundle Protocol's state information and database. For user application that interacts with the Bundle Protocol, <code>bp_attach()</code> is the entry point to ION.</p>"},{"location":"BP-Service-API/#sdr-bp_get_sdr","title":"Sdr bp_get_sdr( )","text":"<p>Function Prototype</p> <pre><code>Sdr bp_get_sdr()\n</code></pre> <p>Parameters</p> <ul> <li>None.</li> </ul> <p>Return Value</p> <ul> <li>Handle for the SDR data store: success</li> <li><code>NULL</code>: any error</li> </ul> <p>Example Call</p> <pre><code>/* declare SDR handle */\nSdr sdr;\n\n/* get SDR handle */\nsdr = bp_get_sdr();\n\n/* user check sdr for NULL \n * and handle error */\n</code></pre> <p>Description</p> <p>Returns handle for the SDR data store used for BP, to enable creation and interrogation of bundle payloads (application data units). Since the SDR handle is needed by many APIs, this function is typically executed early in the user's application in order to access other BP services.</p>"},{"location":"BP-Service-API/#bp_detach","title":"bp_detach","text":"<p>Function Prototype</p> <pre><code>void bp_detach( )\n</code></pre> <p>Parameters</p> <ul> <li>None.</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Terminates all access to BP functionality for the invoking process.</p>"},{"location":"BP-Service-API/#bp_open","title":"bp_open","text":"<p>Function Prototype</p> <pre><code>int bp_open(char *eid, BpSAP *ionsapPtr)\n</code></pre> <p>Parameters</p> <ul> <li><code>*eid</code>: name of the endpoint</li> <li><code>*ionsapPtr</code>: pointer to variable in which address of BP service access point will be returned</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: any error</li> </ul> <p>Example Call</p> <pre><code>if (bp_open(ownEid, &amp;sap) &lt; 0)\n{\n        putErrmsg(\"bptrace can't open own endpoint.\", ownEid);\n\n        /* user's error handling function here */\n}\n</code></pre> <p>Description</p> <p>Opens the application's access to the BP endpoint identified by the string at <code>eid</code>, so that the application can take delivery of bundles destined for the indicated endpoint. This SAP can also be used for sending bundles whose source is the indicated endpoint.</p> <p>Please note that all bundles sent via this SAP will be subject to immediate destruction upon transmission, i.e., no bundle addresses will be returned by <code>bp_send</code> for use in tracking, suspending/resuming, or cancelling transmission of these bundles.</p> <p>On success, places a value in *ionsapPtr that can be supplied to future bp function invocations.</p> <p>NOTE: To allow for bp_send to return a bundle address for tracking purpose, please use <code>bp_open_source</code> instead.</p>"},{"location":"BP-Service-API/#bp_open_source","title":"bp_open_source","text":"<p>Function Prototype</p> <pre><code>int bp_open_source(char *eid, BpSAP *ionsapPtr, int detain)\n</code></pre> <p>Parameters</p> <ul> <li><code>*eid</code>: name of the endpoint</li> <li><code>*ionsapPtr</code>: pointer to variable in which address of BP service access point will be returned</li> <li><code>detain</code>: indicator as to whether or not bundles sourced using this BpSAP should be detained in storage until explicitly released</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Example Call</p> <pre><code>if (bp_open_source(ownEid, &amp;txSap, 1) &lt; 0)\n{\n        putErrmsg(\"can't open own 'send' endpoint.\", ownEid);\n\n        /* user error handling routine here */\n}\n</code></pre> <p>Description</p> <p>Opens the application's access to the BP endpoint identified by eid, so that the application can send bundles whose source is the indicated endpoint. If and only if the value of detain is non-zero, citing this SAP in an invocation of bp_send() will cause the address of the newly issued bundle to be returned for use in tracking, suspending/resuming, or cancelling transmission of this bundle.</p> <p>USE THIS FEATURE WITH GREAT CARE: such a bundle will continue to occupy storage resources until it is explicitly released by an invocation of bp_release() or until its time to live expires, so bundle detention increases the risk of resource exhaustion. (If the value of detain is zero, all bundles sent via this SAP will be subject to immediate destruction upon transmission.)</p> <p>On success, places a value in *ionsapPtr that can be supplied to future bp function invocations and returns 0. Returns -1 on any error.</p>"},{"location":"BP-Service-API/#bp_send","title":"bp_send","text":"<p>Function Prototype</p> <pre><code>int bp_send(BpSAP sap, char *destEid, char *reportToEid, \n             int lifespan, int classOfService, BpCustodySwitch custodySwitch, \n             unsigned char srrFlags, int ackRequested, \n             BpAncillaryData *ancillaryData, Object adu, Object *newBundle)\n</code></pre> <p>Parameters</p> <ul> <li><code>sap</code>: the source endpoint for the bundle, provided by the <code>bp_open</code> call.</li> <li><code>*destEid</code>: identifies the destination endpoint for the bundle.</li> <li><code>reportToEid</code>: identifies the endpoint to which any status reports pertaining to this bundle will be sent; if NULL, defaults to the source endpoint.</li> <li><code>lifespan</code>: is the maximum number of seconds that the bundle can remain in-transit (undelivered) in the network prior to automatic deletion.</li> <li><code>classOfService</code>: is simply priority for now: BP_BULK_PRIORITY, BP_STD_PRIORITY, or BP_EXPEDITED_PRIORITY. If class-of-service flags are defined in a future version of Bundle Protocol, those flags would be OR'd with priority.</li> <li><code>custodySwitch</code>: indicates whether or not custody transfer is requested for this bundle and, if so, whether or not the source node itself is required to be the initial custodian. The valid values are SourceCustodyRequired, SourceCustodyOptional, NoCustodyRequired. Note that custody transfer is possible only for bundles that are uniquely identified, so it cannot be requested for bundles for which BP_MINIMUM_LATENCY is requested, since BP_MINIMUM_LATENCY may result in the production of multiple identical copies of the same bundle. Similarly, custody transfer should never be requested for a \"loopback\" bundle, i.e., one whose destination node is the same as the source node: the received bundle will be identical to the source bundle, both residing in the same node, so no custody acceptance signal can be applied to the source bundle and the source bundle will remain in storage until its TTL expires.</li> <li><code>srrFlags</code>: if non-zero, is the logical OR of the status reporting behaviors requested for this bundle: BP_RECEIVED_RPT, BP_CUSTODY_RPT, BP_FORWARDED_RPT, BP_DELIVERED_RPT, BP_DELETED_RPT.</li> <li><code>ackRequested</code>: is a Boolean parameter indicating whether or not the recipient application should be notified that the source application requests some sort of application-specific end-to-end acknowledgment upon receipt of the bundle.</li> <li><code>ancillaryData</code>: if not NULL, is used to populate the Extended Class Of Service block for this bundle. The block's ordinal value is used to provide fine-grained ordering within \"expedited\" traffic: ordinal values from 0 (the default) to 254 (used to designate the most urgent traffic) are valid, with 255 reserved for custody signals. The value of the block's flags is the logical OR of the applicable extended class-of-service flags:</li> </ul> <pre><code>BP_MINIMUM_LATENCY designates the bundle as \"critical\" for the\npurposes of Contact Graph Routing.\n\nBP_BEST_EFFORT signifies that non-reliable convergence-layer protocols, as\navailable, may be used to transmit the bundle.  Notably, the bundle may be\nsent as \"green\" data rather than \"red\" data when issued via LTP.\n\nBP_DATA_LABEL_PRESENT signifies whether or not the value of _dataLabel_\nin _ancillaryData_ must be encoded into the ECOS block when the bundle is\ntransmitted.\n</code></pre> <p>NOTE: For Bundle Protocol v7, no Extended Class of Service, or equivalent, has been standardized yet. This capability, however, has been retained from BPv6 and is available to BPv7 implementation in ION.</p> <ul> <li><code>adu</code>: is the \"application data unit\" that will be conveyed as the payload of the new bundle. adu must be a \"zero-copy object\" (ZCO). To ensure orderly access to transmission buffer space for all applications, adu must be created by invoking ionCreateZco(), which may be configured either to block so long as insufficient ZCO storage space is available for creation of the requested ZCO or to fail immediately if insufficient ZCO storage space is available.</li> </ul> <p>Return Value</p> <ul> <li>1: success</li> <li>0: user error</li> <li>-1: any system error</li> </ul> <p>Example Call</p> <pre><code>if (bp_send(sap, destEid, reportToEid, ttl, priority,\n    custodySwitch, srrFlags, 0, &amp;ancillaryData,\n    traceZco, &amp;newBundle) &lt;= 0)\n{\n        putErrmsg(\"bptrace can't send file in bundle.\",\n                        fileName);\n\n        /* user error handling code goes here */\n}\n</code></pre> <p>Description</p> <p>Sends a bundle to the endpoint identified by destEid, from the source endpoint as provided to the bp_open() call that returned sap.</p> <p>When sap is NULL, the transmitted bundle is anonymous, i.e., the source of the bundle is not identified. This is legal, but anonymous bundles cannot be uniquely identified; custody transfer and status reporting therefore cannot be requested for an anonymous bundle.</p> <p>The function returns 1 on success, 0 on user error, -1 on any system error.</p> <p>If 0 is returned, then an invalid argument value was passed to bp_send(); a message to this effect will have been written to the log file.</p> <p>If 1 is returned, then either the destination of the bundle was \"dtn:none\" (the bit bucket) or the ADU has been accepted and queued for transmission in a bundle. In the latter case, if and only if sap was a reference to a BpSAP returned by an invocation of bp_open_source() that had a non-zero value in the detain parameter, then newBundle must be non-NULL and the address of the newly created bundle within the ION database is placed in newBundle. This address can be used to track, suspend/resume, or cancel transmission of the bundle.</p>"},{"location":"BP-Service-API/#bp_track","title":"bp_track","text":"<p>Function Prototype</p> <pre><code>int bp_track(Object bundle, Object trackingElt)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: the bundle object data structure</li> <li><code>trackingElt</code>: an sdrlist element managed by the user's application</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: any error</li> </ul> <p>Example Call</p> <pre><code>/* a lyst of bundles in SDR */\nObject bundleList;\n\n/* a bundle object in SDR */\nObject bundleObject;\n\nbundleElt = sdr_list_insert_last(sdr, bundleList,\n                bundleObject);\nif (bp_track(outAdu.bundleObj, bundleElt) &lt; 0)\n{\n        sdr_cancel_xn(sdr);\n        putErrmsg(\"Can't track bundle.\", NULL);\n\n        /* user error handling code goes here */\n}\n</code></pre> <p>The bundleList is managed via the sdr_list library of APIs.</p> <p>Description</p> <p>Adds <code>trackingElt</code> to the list of \"tracking\" references in bundle. <code>trackingElt</code> must be the address of an SDR list element -- whose data is the address of this same bundle -- within some list of bundles that is privately managed by the application. Upon destruction of the bundle this list element will automatically be deleted, thus removing the bundle from the application's privately managed list of bundles. This enables the application to keep track of bundles that it is operating on without risk of inadvertently de-referencing the address of a nonexistent bundle.</p>"},{"location":"BP-Service-API/#bp_untrack","title":"bp_untrack","text":"<p>Function Prototype</p> <pre><code>void bp_untrack(Object bundle, Object trackingElt)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: the bundle object data structure</li> <li><code>trackingElt</code>: an sdrlist element managed by the user's application</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Removes <code>trackingElt</code> from the list of \"tracking\" references in bundle, if it is in that list. Does not delete <code>trackingElt</code> itself.</p>"},{"location":"BP-Service-API/#bp_suspend","title":"bp_suspend","text":"<p>Function Prototype</p> <pre><code>int bp_suspend(Object bundle)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: a bundle object in the SDR</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Suspends transmission of bundle. Has no effect if bundle is \"critical\" (i.e., has got extended class of service BP_MINIMUM_LATENCY flag set) or if the bundle is already suspended. Otherwise, reverses the enqueuing of the bundle to its selected transmission outduct and places it in the \"limbo\" queue until the suspension is lifted by calling bp_resume. Returns 0 on success, -1 on any error.</p>"},{"location":"BP-Service-API/#bp_resume","title":"bp_resume","text":"<p>Function Prototype</p> <pre><code>int bp_resume(Object bundle)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: a bundle object in the SDR</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Terminates suspension of transmission of bundle. Has no effect if bundle is \"critical\" (i.e., has got extended class of service BP_MINIMUM_LATENCY flag set) or is not suspended. Otherwise, removes the bundle from the \"limbo\" queue and queues it for route re-computation and re-queuing. Returns 0 on success, -1 on any error.</p>"},{"location":"BP-Service-API/#bp_cancel","title":"bp_cancel","text":"<p>Function Prototype</p> <pre><code>int bp_cancel(Object bundle)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: a bundle object in the SDR</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Cancels transmission of bundle. If the indicated bundle is currently queued for forwarding, transmission, or retransmission, it is removed from the relevant queue and destroyed exactly as if its Time To Live had expired. Returns 0 on success, -1 on any error.</p>"},{"location":"BP-Service-API/#bp_release","title":"bp_release","text":"<p>Function Prototype</p> <pre><code>int bp_release(Object bundle)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: a bundle object in the SDR</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Releases a detained bundle for destruction when all retention constraints have been removed. After a detained bundle has been released, the application can no longer track, suspend/resume, or cancel its transmission. Returns 0 on success, -1 on any error.</p> <p>NOTE: for bundles sent through an bundle protocol end-point which is opened via <code>bp_open_source</code> with <code>detain</code> set to non-zero value, they will not be destroyed, even after successful transmissions, until time-to-live has expired or explicitly released via <code>bp_release</code>.</p>"},{"location":"BP-Service-API/#bp_receive","title":"bp_receive","text":"<p>Function Prototype</p> <pre><code>int bp_receive(BpSAP sap, BpDelivery *dlvBuffer, int timeoutSeconds)\n</code></pre> <p>Parameters</p> <ul> <li><code>sap</code>: the source endpoint for the bundle, provided by the <code>bp_open</code> call</li> <li><code>*dlvBuffer</code>: a pointer to a <code>BpDelivery</code> structure used to return the received bundle and/or outcome of reception</li> <li><code>timoutSeconds</code>: a reception timer in seconds</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: any error</li> </ul> <p>Example Call</p> <pre><code>if (bp_receive(state.sap, &amp;dlv, BP_BLOCKING) &lt; 0)\n{\n        putErrmsg(\"bpsink bundle reception failed.\", NULL);\n\n        /* user code to handle error or timeout*/\n}\n</code></pre> <p>In this example, BP_BLOCKING is set to -1, that means that the call will block forever until a bundle is received, unless interrupted <code>bp_interrupt</code>.</p> <p>Description</p> <p>Receives a bundle, or reports on some failure of bundle reception activity.</p> <p>The \"result\" field of the dlvBuffer structure will be used to indicate the outcome of the data reception activity.</p> <p>If at least one bundle destined for the endpoint for which this SAP is opened has not yet been delivered to the SAP, then the payload of the oldest such bundle will be returned in <code>dlvBuffer-&gt;adu</code> and <code>dlvBuffer-&gt;result</code> will be set to BpPayloadPresent. If there is no such bundle, bp_receive() blocks for up to timeoutSeconds while waiting for one to arrive.</p> <p>If timeoutSeconds is BP_POLL (i.e., zero) and no bundle is awaiting delivery, or if timeoutSeconds is greater than zero but no bundle arrives before timeoutSeconds have elapsed, then <code>dlvBuffer-&gt;result</code> will be set to BpReceptionTimedOut. If timeoutSeconds is BP_BLOCKING (i.e., -1) then bp_receive() blocks until either a bundle arrives or the function is interrupted by an invocation of <code>bp_interrupt</code>().</p> <p><code>dlvBuffer-&gt;result</code> will be set to BpReceptionInterrupted in the event that the calling process received and handled some signal other than SIGALRM while waiting for a bundle.</p> <p><code>dlvBuffer-&gt;result</code> will be set to BpEndpointStopped in the event that the operation of the indicated endpoint has been terminated.</p> <p>The application data unit delivered in the data delivery structure, if any, will be a \"zero-copy object\" reference. Use zco reception functions (see zco(3)) to read the content of the application data unit.</p> <p>Be sure to call <code>bp_release_delivery</code>() after every successful invocation of <code>bp_receive</code>().</p> <p>The function returns 0 on success, -1 on any error.</p>"},{"location":"BP-Service-API/#bp_interrupt","title":"bp_interrupt","text":"<p>Function Prototype</p> <pre><code>void bp_interrupt(BpSAP sap)\n</code></pre> <p>Parameters</p> <ul> <li><code>bundle</code>: a bundle object in the SDR</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: Any error</li> </ul> <p>Description</p> <p>Interrupts a <code>bp_receive</code>() invocation that is currently blocked. This function is designed to be called from a signal handler; for this purpose, sap may need to be obtained from a static variable.</p>"},{"location":"BP-Service-API/#bp_release_delivery","title":"bp_release_delivery","text":"<p>Function Prototype</p> <pre><code>void bp_release_delivery(BpDelivery *dlvBuffer, int releaseAdu)\n</code></pre> <p>Parameters</p> <ul> <li><code>*dlvBuffer</code>: a pointer to a <code>BpDelivery</code> structure used to return the received bundle and/or outcome of reception</li> <li><code>releaseAdu</code>: a Boolean parameter: if non-zero, the ADU ZCO reference in dlvBuffer (if any) is destroyed.</li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Releases resources allocated to the indicated delivery by <code>dlvBuffer</code>, which is returned by bp_receive. <code>releaseAdu</code> is a Boolean parameter: if non-zero, the ADU ZCO reference in <code>dlvBuffer</code> (if any) is destroyed, causing the ZCO itself to be destroyed if no other references to it remain.</p>"},{"location":"BP-Service-API/#bp_close","title":"bp_close","text":"<p>Function Prototype</p> <pre><code>void bp_close(BpSAP sap)\n</code></pre> <p>Parameters</p> <ul> <li><code>sap</code>: the source endpoint for the bundle, provided by the <code>bp_open</code> or <code>bp_open_source</code> call</li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Terminates the application's access to the BP endpoint identified by the eid cited by the indicated service access point. The application relinquishes its ability to take delivery of bundles destined for the indicated endpoint and to send bundles whose source is the indicated endpoint.</p>"},{"location":"BP-Service-API/#walk-through-of-bpsourcec","title":"Walk Through of <code>bpsource.c</code>","text":"<ul> <li>For this example, it is assumed that the user is already familiar with the ICI APIs.</li> </ul> <p>TO BE UPDATED.</p>"},{"location":"BP-Service-API/#compiling-and-linking","title":"Compiling and Linking","text":""},{"location":"BP-Service-API/#zero-copy-object-zco-types","title":"Zero-copy Object (ZCO) Types","text":"<p>We have shown that the way to hand user data from an application to BP is via a zero-copy object (ZCO).</p> <p>In general there are two types of ZCO that is relevant to a user.</p> <ul> <li>Note A third type of ZCO is called a ZCO ZCO - one consists of multiple other ZCOs. This is used internally by ION to handle concatenation of data but it is not relevant in the context of this topic.</li> </ul>"},{"location":"BP-Service-API/#sdr-zco","title":"SDR ZCO","text":"<ul> <li>Used in our example</li> <li>Example in <code>bpsource.c</code></li> </ul>"},{"location":"BP-Service-API/#file-zco","title":"File ZCO","text":"<ul> <li>Can be used if you wish not to make a copy of the data in the ION SDR (possibly to save SDR space)</li> <li>You allow ION to access the original data (file) in the host computer's file system. Need to check if this restriction applies.</li> <li>See example in <code>bpdriver.c</code></li> </ul>"},{"location":"Basic-Configuration-File-Tutorial/","title":"Basic Configuration File Tutorial","text":""},{"location":"Basic-Configuration-File-Tutorial/#programs-in-ion","title":"Programs in ION","text":"<p>The following tools are available to you after ION is built:</p> <p>Daemon and Configuration</p> <ul> <li>ionadmin\u00a0is the administration and configuration interface for the local ION node contacts and manages shared memory resources used by ION.</li> <li>ltpadmin\u00a0is the administration and configuration interface for LTP operations on the local ION node.</li> <li>bsspadmin\u00a0is the administrative interface for operations of the Bundle Streaming Service Protocol on the local ion node.</li> <li>bpadmin\u00a0is the administrative interface for bundle protocol operations on the local ion node.</li> <li>ipnadmin\u00a0is the administration and configuration interface for the IPN addressing system and routing on the ION node. (ipn:)</li> <li>dtn2admin\u00a0is the administration and configuration interface for the DTN addressing system and routing on the ION node. (dtn://)</li> <li>killm\u00a0is a script which tears down the daemon and any running ducts on a single machine (use\u00a0ionstop\u00a0instead).</li> <li>ionstart\u00a0is a script which completely configures an ION node with the proper configuration file(s).</li> <li>ionstop\u00a0is a script which completely tears down the ION node.</li> <li>ionscript\u00a0is a script which aides in the creation and management of configuration files to be used with\u00a0ionstart.</li> </ul> <p>Simple Sending and Receiving</p> <ul> <li>bpsource\u00a0and\u00a0bpsink\u00a0are for testing basic connectivity between endpoints.\u00a0bpsink\u00a0listens for and then displays messages sent by\u00a0bpsource.</li> <li>bpsendfile\u00a0and\u00a0bprecvfile\u00a0are used to send files between ION nodes.</li> </ul> <p>Testing and Benchmarking</p> <ul> <li>bpdriver\u00a0benchmarks a connection by sending bundles in two modes: request-response and streaming.</li> <li>bpecho\u00a0issues responses to\u00a0bpdriver\u00a0in request-response mode.</li> <li>bpcounter\u00a0acts as receiver for streaming mode, outputting markers on receipt of data from\u00a0bpdriver\u00a0and computing throughput metrics.</li> </ul>"},{"location":"Basic-Configuration-File-Tutorial/#ion-logging","title":"ION Logging","text":"<p>It is important to note that, by default, the administrative programs will all trigger the creation of a log file called\u00a0ion.log\u00a0in the directory where the program is called. This means that write-access in your current working directory is required. The log file itself will contain the expected log information from administrative daemons, but it will also contain error reports from simple applications such as\u00a0bpsink. This is important to note since the BP applications may not be reporting all error information to stdout or stderr.</p>"},{"location":"Basic-Configuration-File-Tutorial/#starting-the-ion-daemon","title":"Starting the ION Daemon","text":"<p>A script has been created which allows a more streamlined configuration and startup of an ION node. This script is called\u00a0ionstart, and it has the following syntax. Don't run it yet; we still have to configure it!</p> <p><code>ionstart -I &lt;filename&gt;</code></p> <p>filename: This is the name for configuration file which the script will attempt to use for the various configuration commands. The script will perform a sanity check on the file, splitting it into command sections appropriate for each of the administration programs.</p> <p>Configuration information (such as routes, connections, etc) can be specified one of two ways for any of the individual administration programs:</p> <p>(Recommended) Creating a configuration file and passing it to\u00a0ionadmin,\u00a0bpadmin,\u00a0ipnadmin...\u00a0either directly or via the\u00a0ionstart\u00a0helper script. Manually typing configuration commands into the terminal for each administration program.</p> <p>You can find appropriate commands in the following sections.</p>"},{"location":"Basic-Configuration-File-Tutorial/#configuration-files-overview","title":"Configuration Files Overview","text":"<p>There are five configuration files about which you should be aware.</p> <p>The first,\u00a0ionadmin's configuration file, assigns an identity (node number) to the node, optionally configures the resources that will be made available to the node, and specifies contact bandwidths and one-way transmission times. Specifying the \"contact plan\" is important in deep-space scenarios where the bandwidth must be managed and where acknowledgments must be timed according to propagation delays. It is also vital to the function of contact-graph routing.</p> <p>The second,\u00a0ltpadmin's configuration file, specifies spans, transmission speeds, and resources for the Licklider Transfer Protocol convergence layer.</p> <p>The third,\u00a0ipnadmin's configuration file, maps endpoints at \"neighboring\" (topologically adjacent, directly reachable) nodes to convergence-layer addresses. Our examples use TCP/IP and LTP (over IP/UDP), so it maps endpoint IDs to IP addresses. This file populates the ION analogue to an ARP cache for the \"ipn\" naming scheme.</p> <p>The fourth,\u00a0bpadmin's configuration file, specifies all of the open endpoints for delivery on your local end and specifies which convergence layer protocol(s) you intend to use. With the exception of LTP, most convergence layer adapters are fully configured in this file.</p> <p>The fifth,\u00a0dtn2admin's configuration file, populates the ION analogue to an ARP cache for the \"dtn\" naming scheme.</p>"},{"location":"Basic-Configuration-File-Tutorial/#the-ion-configuration-file","title":"The ION Configuration File","text":"<p>Given to\u00a0ionadmin\u00a0either as a file or from the daemon command line, this file configures contacts for the ION node. We will assume that the local node's identification number is 1.</p> <p>This file specifies contact times and one-way light times between nodes. This is useful in deep-space scenarios: for instance, Mars may be 20 light-minutes away, or 8. Though only some transport protocols make use of this time (currently, only LTP), it must be specified for all links nonetheless. Times may be relative (prefixed with a + from current time) or absolute. Absolute times, are in the format\u00a0<code>yyyy/mm/dd-hh:mm:ss</code>. By default, the contact-graph routing engine will make bundle routing decisions based on the contact information provided.</p> <p>The configuration file lines are as follows:</p> <p><code>1 1 ''</code></p> <p>This command will initialize the ion node to be node number 1.</p> <p>1\u00a0refers to this being the initialization or ''first'' command. 1\u00a0specifies the node number of this ion node. (IPN node 1). ''\u00a0specifies the name of a file of configuration commands for the node's use of shared memory and other resources (suitable defaults are applied if you leave this argument as an empty string).</p> <p><code>s</code></p> <p>This will start the ION node. It mostly functions to officially \"start\" the node in a specific instant; it causes all of ION's protocol-independent background daemons to start running.</p> <p><code>a contact +1 +3600 1 1 100000</code></p> <p>specifies a transmission opportunity for a given time duration between two connected nodes (or, in this case, a loopback transmission opportunity).</p> <p>a\u00a0adds this entry in the configuration table. contact\u00a0specifies that this entry defines a transmission opportunity. +1\u00a0is the start time for the contact (relative to when the\u00a0s\u00a0command is issued). +3600\u00a0is the end time for the contact (relative to when the\u00a0s\u00a0command is issued). 1\u00a0is the source node number. 1\u00a0is the destination node number. 100000\u00a0is the maximum rate at which data is expected to be transmitted from the source node to the destination node during this time period (here, it is 100000 bytes / second).</p> <p><code>a range +1 +3600 1 1 1</code></p> <p>specifies a distance between nodes, expressed as a number of light seconds, where each element has the following meaning:</p> <p>a\u00a0adds this entry in the configuration table. range\u00a0declares that what follows is a distance between two nodes. +1\u00a0is the earliest time at which this is expected to be the distance between these two nodes (relative to the time\u00a0s\u00a0was issued). +3600\u00a0is the latest time at which this is still expected to be the distance between these two nodes (relative to the time\u00a0s\u00a0was issued). 1\u00a0is one of the two nodes in question. 1\u00a0is the other node. 1\u00a0is the distance between the nodes, measured in light seconds, also sometimes called the \"one-way light time\" (here, one light second is the expected distance).</p> <p><code>m production 1000000</code></p> <p>specifies the maximum rate at which data will be produced by the node.</p> <p>m\u00a0specifies that this is a management command. production\u00a0declares that this command declares the maximum rate of data production at this ION node. 1000000\u00a0specifies that at most 1000000 bytes/second will be produced by this node.</p> <p><code>m consumption 1000000</code></p> <p>specifies the maximum rate at which data can be consumed by the node.</p> <p>m\u00a0specifies that this is a management command. consumption\u00a0declares that this command declares the maximum rate of data consumption at this ION node. 1000000\u00a0specifies that at most 1000000 bytes/second will be consumed by this node.</p> <p>This will make a final configuration file\u00a0host1.ionrc\u00a0which looks like this:</p> <pre><code>1 1 ''\ns\na contact +1 +3600 1 1 100000\na range +1 +3600 1 1 1\nm production 1000000\nm consumption 1000000\n</code></pre>"},{"location":"Basic-Configuration-File-Tutorial/#the-licklider-transfer-protocol-configuration-file","title":"The Licklider Transfer Protocol Configuration File","text":"<p>Given to\u00a0ltpadmin\u00a0as a file or from the command line, this file configures the LTP engine itself. We will assume the local IPN node number is 1; in ION, node numbers are used as the LTP engine numbers.</p> <p><code>1 32</code></p> <p>This command will initialize the LTP engine:</p> <p>1\u00a0refers to this being the initialization or ''first'' command. 32\u00a0is an estimate of the maximum total number of LTP ''block'' transmission sessions - for all spans - that will be concurrently active in this LTP engine. It is used to size a hash table for session lookups.</p> <p><code>a span 1 32 32 1400 10000 1 'udplso localhost:1113'</code></p> <p>This command defines an LTP engine 'span':</p> <p>a\u00a0indicates that this will add something to the engine.</p> <p>span\u00a0indicates that an LTP span will be added.</p> <p>1\u00a0is the engine number for the span, the number of the remote engine to which LTP segments will be transmitted via this span. In this case, because the span is being configured for loopback, it is the number of the local engine, i.e., the local node number. This will have to match an outduct in Section\u00a02.6.</p> <p>32\u00a0specifies the maximum number of LTP ''block'' transmission sessions that may be active on this span. The product of the mean block size and the maximum number of transmission sessions is effectively the LTP flow control ''window'' for this span: if it's less than the bandwidth delay product for traffic between the local LTP engine and this spa's remote LTP engine then you'll be under-utilizing that link. We often try to size each block to be about one second's worth of transmission, so to select a good value for this parameter you can simply divide the span's bandwidth delay product (data rate times distance in light seconds) by your best guess at the mean block size.</p> <p>The second\u00a032specifies the maximum number of LTP ''block'' reception sessions that may be active on this span. When data rates in both directions are the same, this is usually the same value as the maximum number of transmission sessions.</p> <p>1400\u00a0is the number of bytes in a single segment. In this case, LTP runs atop UDP/IP on ethernet, so we account for some packet overhead and use 1400.</p> <p>1000\u00a0is the LTP aggregation size limit, in bytes. LTP will aggregate multiple bundles into blocks for transmission. This value indicates that the block currently being aggregated will be transmitted as soon as its aggregate size exceeds 10000 bytes.</p> <p>1\u00a0is the LTP aggregation time limit, in seconds. This value indicates that the block currently being aggregated will be transmitted 1 second after aggregation began, even if its aggregate size is still less than the aggregation size limit.</p> <p>'udplso localhost:1113'\u00a0is the command used to implement the link itself. The link is implemented via UDP, sending segments to the localhost Internet interface on port 1113 (the IANA default port for LTP over UDP).</p> <p><code>s 'udplsi localhost:1113'</code></p> <p>Starts the ltp engine itself:</p> <p>s\u00a0starts the ltp engine.</p> <p>'udplsi localhost:1113'\u00a0is the link service input task. In this case, the input ''duct' is a UDP listener on the local host using port 1113.</p> <p>This means that the entire configuration file\u00a0host1.ltprc\u00a0looks like this:</p> <pre><code>1 32\na span 1 32 32 1400 10000 1 'udplso localhost:1113'\ns 'udplsi localhost:1113'\n</code></pre>"},{"location":"Basic-Configuration-File-Tutorial/#the-bundle-protocol-configuration-file","title":"The Bundle Protocol Configuration File","text":"<p>Given to\u00a0bpadmin\u00a0either as a file or from the daemon command line, this file configures the endpoints through which this node's Bundle Protocol Agent (BPA) will communicate. We will assume the local BPA's node number is 1; as for LTP, in ION node numbers are used to identify bundle protocol agents.</p> <p><code>1</code> </p> <p>This initializes the bundle protocol:</p> <p>1\u00a0refers to this being the initialization or ''first'' command.</p> <p><code>a scheme ipn 'ipnfw' 'ipnadminep'</code></p> <p>This adds support for a new Endpoint Identifier (EID) scheme:</p> <p>a\u00a0means that this command will add something.</p> <p>scheme\u00a0means that this command will add a scheme.</p> <p>ipn\u00a0is the name of the scheme to be added.</p> <p>'ipnfw'\u00a0is the name of the IPN scheme's forwarding engine daemon.</p> <p>'ipnadminep'\u00a0is the name of the IPN scheme's custody transfer management daemon.</p> <p><code>a endpoint ipn:1.0 q</code></p> <p>This command establishes this BP node's membership in a BP endpoint:</p> <p>a\u00a0means that this command will add something.</p> <p>endpoint\u00a0means that this command adds an endpoint.</p> <p>ipn\u00a0is the scheme name of the endpoint.</p> <p>1.0\u00a0is the scheme-specific part of the endpoint. For the IPN scheme the scheme-specific part always has the form\u00a0nodenumber:servicenumber. Each node must be a member of the endpoint whose node number is the node's own node number and whose service number is 0, indicating administrative traffic.</p> <p>q\u00a0means that the behavior of the engine, upon receipt of a new bundle for this endpoint, is to queue it until an application accepts the bundle. The alternative is to silently discard the bundle if no application is actively listening; this is specified by replacing\u00a0q\u00a0with\u00a0x.</p> <p><code>a endpoint ipn:1.1 q</code></p> <p><code>a endpoint ipn:1.2 q</code></p> <p>These specify two more endpoints that will be used for test traffic.</p> <p><code>a protocol ltp 1400 100</code></p> <p>This command adds support for a convergence-layer protocol:</p> <p>a\u00a0means that this command will add something.</p> <p>protocol\u00a0means that this command will add a convergence-layer protocol.</p> <p>ltp\u00a0is the name of the convergence-layer protocol.</p> <p>1400\u00a0is the estimated size of each convergence-layer protocol data unit (in bytes); in this case, the value is based on the size of a UDP/IP packet on Ethernet.</p> <p>100\u00a0is the estimated size of the protocol transmission overhead (in bytes) per convergence-layer procotol data unit sent.</p> <p><code>a induct ltp 1 ltpcli</code></p> <p>This command adds an induct, through which incoming bundles can be received from other nodes:</p> <p>a\u00a0means that this command will add something.</p> <p>induct\u00a0means that this command will add an induct.</p> <p>ltp\u00a0is the convergence layer protocol of the induct.</p> <p>1\u00a0is the identifier of the induct, in this case the ID of the local LTP engine.</p> <p>ltpcli\u00a0is the name of the daemon used to implement the induct.</p> <p><code>a outduct ltp 1 ltpclo</code></p> <p>This command adds an outduct, through which outgoing bundles can be sent to other nodes:</p> <p>a\u00a0means that this command will add something.</p> <p>outduct\u00a0means that this command will add an outduct.</p> <p>ltp\u00a0is the convergence layer protocol of the outduct.</p> <p>1\u00a0is the identifier of the outduct, the ID of the convergence-layer protocol induct of some remote node. See Section\u00a02.5\u00a0for remote LTP engine IDs.</p> <p>ltpclo\u00a0is the name of the daemon used to implement the outduct.</p> <p><code>s</code></p> <p>This command starts the bundle engine including all daemons for the inducts and outducts.</p> <p>That means that the entire configuration file\u00a0host1.bprc\u00a0looks like this:</p> <pre><code>1\na scheme ipn 'ipnfw' 'ipnadminep'\na endpoint ipn:1.0 q\na endpoint ipn:1.1 q\na endpoint ipn:1.2 q\na protocol ltp 1400 100\na induct ltp 1 ltpcli\na outduct ltp 1 ltpclo\ns\n</code></pre>"},{"location":"Basic-Configuration-File-Tutorial/#ipn-routing-configuration","title":"IPN Routing Configuration","text":"<p>As noted earlier, this file is used to build ION's analogue to an ARP cache, a table of ''egress plans.'' It specifies which outducts to use in order to forward bundles to the local node's neighbors in the network. Since we only have one outduct, for forwarding bundles to one place (the local node), we only have one egress plan.</p> <p><code>a plan 1 ltp/1</code></p> <p>This command defines an egress plan for bundles to be transmitted to the local node:</p> <p>a\u00a0means this command adds something.</p> <p>plan\u00a0means this command adds an egress plan.</p> <p>1\u00a0is the node number of the remote node. In this case, that is the local node's own node number; we're configuring for loopback.</p> <p>ltp/1\u00a0is the identifier of the outduct through which to transmit bundles in order to convey them to this ''remote'' node.</p> <p>This means that the entire configuration file\u00a0host1.ipnrc\u00a0looks like this:</p> <p><code>a plan 1 ltp/1</code></p>"},{"location":"Basic-Configuration-File-Tutorial/#testing-your-connection","title":"Testing Your Connection","text":"<p>Assuming no errors occur with the configuration above, we are now ready to test loopback communications. In one terminal, we have to run the start script (the one we said that you would have to have earlier). It's right here, in case you forgot to write it down:</p> <p><code>ionstart -i host1.ionrc -l host1.ltprc -b host1.bprc -p host1.ipnrc</code></p> <p>This command will run the appropriate administration programs, in order, with the appropriate configuration files. Don't worry that the command is lengthy and unwieldly; we will show you how to make a more clean single configuration file later.</p> <p>Once the daemon is started, run:</p> <p><code>bpsink ipn:1.1</code></p> <p>This will begin listening on the Endpoint ID with the\u00a0endpoint_number\u00a01 on\u00a0service_number\u00a01, which is used for testing.</p> <p>Now open another terminal and run the command:</p> <p><code>bpsource ipn:1.1</code></p> <p>This will begin sending messages you type to the Endpoint ID\u00a0ipn:1.1, which is currently being listened to by\u00a0bpsink. Type messages into\u00a0bpsource, press enter, and see if they are reported by\u00a0bpsink.</p> <p>If so, you're ready for bigger and better things. If not, check the following:</p> <p>Do you have write permissions for your current directory? If not, you will not be able to start the daemon as it has to write out to the ion.log file. Are your config files exactly as specified, except for IP address changes? Are you running it on one of our supported platforms? Currently, those are the only supported distributions.</p> <p>If you are still having problems, you can ask for help on the ION users' list or file an ION bug report.</p>"},{"location":"Basic-Configuration-File-Tutorial/#stopping-the-daemon","title":"Stopping the Daemon","text":"<p>As the daemon launches many ducts and helper applications, it can be complicated to turn it all off. To help this, we provided a script. The script similar to\u00a0ionstart\u00a0exists called\u00a0ionstop, which tears down the ion node in one step. You can call it like so:</p> <p><code>ionstop</code></p> <p>After stopping the daemon, it can be restarted using the same procedures as outlined above. Do remember that the ion.log file is still present, and will just keep growing as you experiment with ION.</p> <p>IMPORTANT:\u00a0The user account that runs ionstart\u00a0must also run ionstop. If that account does not, no other accounts can successfully start the daemon, as the shared memory vital to ION's functionality will already be occupied.</p>"},{"location":"Basic-Configuration-File-Tutorial/#more-advanced-usage","title":"More Advanced Usage","text":"<p>Detailed documentation of ION and its applications are available via the man pages. It is suggested that you start with\u00a0man ion\u00a0, as this is an overview man page listing all available ION packages.</p>"},{"location":"Basic-Configuration-File-Tutorial/#ionscript-for-simplified-configuration-files","title":"Ionscript for Simplified Configuration Files","text":"<p>The most difficult and cumbersome method of starting an ION node is to manually run the various administration programs in order, manually typing configuration commands all the way. It is much more efficient and less error-prone to place the configuration commands into a configuration file and using that as input to the administration program, but this is still cumbersome as you must type in each administration program in order. The\u00a0ionstart\u00a0program will automatically execute the appropriate administration programs with their respective configuration files in order. Unfortunately, as seen in the previous sections,\u00a0the command is lengthy. This is why the\u00a0ionscript\u00a0script was added to make things even easier.</p> <p>The ionscript\u00a0will basically concatenate the configuration files into one large file. The format of this large configuration file is simply to bookend configuration sections with the lines:\u00a0## begin PROGRAM\u00a0and\u00a0## end PROGRAM, where\u00a0PROGRAM\u00a0is the name of the administration program for which the configuration commands should be sent (such as\u00a0ionadmin, bpadmin, ipnadmin).</p> <p>To create a single file\u00a0host1.rc\u00a0out of the various configuration files defined in the previous section, run this command:</p> <p><code>ionscript -i host1.ionrc -p host1.ipnrc -l host1.ltprc -b host1.bprc -O host1.rc</code></p> <p>The command can also be used to split the large\u00a0host1.rc\u00a0into the individual configuration files (so long as the large file is formatted correctly). Just run this command to revert the process:</p> <p><code>ionscript -i host1.ionrc -p host1.ipnrc -l host1.ltprc -b host1.bprc -I host1.rc</code></p> <p>This isn't very practical in this specific case (as you already have the individual files) but if you start with a single configuration file, this can be helpful.</p> <p>Once you have a single configuration file, starting the ION node is a single command:</p> <p><code>ionstart -I host1.rc</code></p> <p>Note that\u00a0ionstart\u00a0and\u00a0ionscript\u00a0require\u00a0sed\u00a0and\u00a0awk, but those are almost universally available on Unix-based systems. The two scripts will always sanity-check the large configuration file to ensure that it interprets the bookend lines correctly- and it will warn you of any errors you have made in the file. Consult the USAGE for each script for further help, by attempting to run the script with no arguments or the\u00a0-h\u00a0argument.</p>"},{"location":"Basic-Configuration-File-Tutorial/#examples-of-network-configurations","title":"Examples of Network Configurations","text":"<p>For a simple single-node ION configuration - running multiple instances of ION in the same host, see the tutorial here.</p> <p>For a two-node configuration, see the tutorial here.</p> <p>For a multi-hop and also multi-network configuration, see this page.</p>"},{"location":"CLA-API/","title":"Convergence Layer Adaptor - APIs","text":"<p>ION currently provides several CLAs, include LTP, TCP, UDP, STCP. However, it is possible to develop a customized CLA using ION's API. This document will describe the basic set of API used to develop a customized CLA.</p>"},{"location":"CLA-API/#cla-apis","title":"CLA APIs","text":""},{"location":"CLA-API/#header","title":"Header","text":"<pre><code>#include \"bpP.h\"\n</code></pre>"},{"location":"CLA-API/#bpdequeue","title":"bpDequeue","text":"<p>Function Prototype</p> <pre><code>extern int bpDequeue(VOutduct *vduct,\n                    Object *outboundZco,\n                    BpAncillaryData *ancillaryData,\n                    int stewardship);\n</code></pre> <p>This function is invoked by a convergence-layer output adapter (outduct) daemon to get a bundle that it is to transmit to some remote convergence-layer input adapter (induct) daemon.</p> <p>The function first pops the next (only) outbound bundle from the queue of outbound bundles for the indicated duct. If no such bundle is currently waiting for transmission, it blocks until one is [or until the duct is closed, at which time the function returns zero without providing the address of an outbound bundle ZCO].</p> <p>On obtaining a bundle, bpDequeue does DEQUEUE processing on the bundle's extension blocks; if this processing determines that the bundle is corrupt, the function returns zero while providing 1 (a nonsense address) in *bundleZco as the address of the outbound bundle ZCO.  The CLO should handle this result by simply calling bpDequeue again.</p> <p>bpDequeue then catenates (serializes) the BP header information (primary block and all extension blocks) in the bundle and prepends that serialized header to the source data of the bundle's payload ZCO.  Then it returns the address of that ZCO in *bundleZco for transmission at the convergence layer (possibly entailing segmentation that would be invisible to BP).</p> <p>Requested quality of service for the bundle is provided in *ancillaryData so that the requested QOS can be mapped to the QOS features of the convergence-layer protocol.  For example, this is where a request for custody transfer is communicated to BIBE when the outduct daemon is one that does BIBE transmission. The stewardship argument controls the disposition of the bundle following transmission.  Any value other than zero indicates that the outduct daemon is one that performs \"stewardship\" procedures.  An outduct daemon that performs stewardship procedures will disposition the bundle as soon as the results of transmission at the convergence layer are known, by calling one of two functions: either bpHandleXmitSuccess or else bpHandleXmitFailure.  A value of zero indicates that the outduct daemon does not perform stewardship procedures and will not disposition the bundle following transmission; instead, the bpDequeue function itself will assume that transmission at the convergence layer will be successful and will disposition the bundle on that basis.</p> <p>Return Values</p> <ul> <li>0: on success</li> <li>-1: on failure</li> </ul>"},{"location":"CLA-API/#bphandlexmitsuccess","title":"bpHandleXmitSuccess","text":"<p>Function Prototype</p> <pre><code>extern int      bpHandleXmitSuccess(Object zco);\n</code></pre> <p>This function is invoked by a convergence-layer output adapter (an outduct) on detection of convergence- layer protocol transmission success. It causes the serialized (catenated) outbound bundle in zco to be destroyed, unless some constraint (such as local delivery of a copy of the bundle) requires that bundle destruction be deferred.</p> <p>Return Values</p> <ul> <li>1: if bundle success was handled</li> <li>0: if bundle had already been destroyed</li> <li>-1: on system failure.</li> </ul>"},{"location":"CLA-API/#bphandlexmitfailure","title":"bpHandleXmitFailure","text":"<p>Function Prototype</p> <pre><code>extern int bpHandleXmitFailure(Object zco);\n</code></pre> <p>This function is invoked by a convergence-layer output adapter (an outduct) on detection of a convergence- layer protocol transmission error. It causes the serialized (catenated) outbound bundle in zco to be queued up for re-forwarding.</p> <p>Return Values</p> <ul> <li>1: if bundle failure was handled</li> <li>0: if bundle had already been destroyed</li> <li>-1: on system failure.</li> </ul>"},{"location":"CLA-API/#bpgetacqarea","title":"bpGetAcqArea","text":"<pre><code>extern AcqWorkArea  *bpGetAcqArea(VInduct *vduct);\n</code></pre> <p>Allocates a bundle acquisition work area for use in acquiring inbound bundles via the indicated duct. This is typically invoked just once at the beginning of a CLA process initialization</p> <p>Return Value</p> <ul> <li><code>NULL</code>: on any failure</li> </ul>"},{"location":"CLA-API/#bpreleaseacqarea","title":"bpReleaseAcqArea","text":"<pre><code>extern void     bpReleaseAcqArea(AcqWorkArea *workArea);\n</code></pre> <p>Releases dynamically allocated bundle acquisition work area. This should be called before shutting down a CLA process.</p> <p>Return Value</p> <ul> <li><code>NULL</code>: on any failure</li> </ul>"},{"location":"CLA-API/#bpbeginacquisition","title":"bpBeginAcquisition","text":"<pre><code>extern int  bpBeginAcq( AcqWorkArea *workArea,\n                int authentic,\n                char *senderEid);\n</code></pre> <p>This function is invoked by a convergence-layer input adapter to initiate acquisition of a new bundle via the indicated workArea. It initializes deserialization of an array of bytes constituting a single transmitted bundle. The \"authentic\" Boolean and \"senderEid\" string are knowledge asserted by the convergence-layer input adapter invoking this function: an assertion of authenticity of the data being acquired (e.g., per knowledge that the data were received via a physically secure medium) and, if non-NULL, an EID characterizing the node that send this inbound bundle.</p> <p>Return Values</p> <ul> <li>0: on success</li> <li>-1: on any failure                </li> </ul>"},{"location":"CLA-API/#bpcontinueacq","title":"bpContinueAcq","text":"<pre><code>extern int  bpContinueAcq(  AcqWorkArea *workArea,\n                char *bytes,\n                int length,\n                ReqAttendant *attendant,\n                unsigned char priority);\n</code></pre> <p>This function continues acquisition of a bundle as initiated by an invocation of bpBeginAcq().  To do so, it appends the indicated array of bytes, of the indicated length, to the byte array that is encapsulated in workArea.</p> <p>bpContinueAcq is an alternative to bpLoadAcq, intended for use by convergence-layer adapters that incrementally acquire portions of concatenated bundles into byte-array buffers.  The function transparently creates a zero-copy object for acquisition of the bundle, if one does not already exist, and appends \"bytes\" to the source data of that ZCO.</p> <p>The behavior of bpContinueAcq when currently available space for zero- copy objects is insufficient to contain this increment of bundle source data depends on the value of \"attendant\".  If \"attendant\" is NULL, then bpContinueAcq will return 0 but will flag the acquisition work area for refusal of the bundle due to resource exhaustion (congestion). Otherwise, (i.e., \"attendant\" points to a ReqAttendant structure, which  MUST have already been initialized by ionStartAttendant()), bpContinueAcq will block until sufficient space is available or the attendant is paused or the function fails, whichever occurs first.</p> <p>\"priority\" is normally zero, but for the TCPCL convergence-layer receiver threads it is very high (255) because any delay in allocating space to an extent of TCPCL data delays the processing of TCPCL control messages, potentially killing TCPCL performance.</p> <p>Return Values</p> <ul> <li>0: on success (even if \"attendant\" was paused or the acquisition work area is flagged for refusal due to congestion)</li> <li>-1: on any failure.</li> </ul>"},{"location":"CLA-API/#bpcancelacq","title":"bpCancelAcq","text":"<pre><code>extern void     bpCancelAcq(    AcqWorkArea *workArea);\n</code></pre> <p>Cancels acquisition of a new bundle via the indicated workArea, destroying the bundle acquisition ZCO of workArea.</p>"},{"location":"CLA-API/#bpendacq","title":"bpEndAcq","text":"<p><pre><code>extern int      bpEndAcq(   AcqWorkArea *workArea);\n</code></pre> Concludes acquisition of a new bundle via the indicated workArea. This function is invoked after the convergence-layer input adapter has invoked either bpLoadAcq() or bpContinueAcq() [perhaps invoking the latter multiple times] such that all bytes of the transmitted bundle are now included in the bundle acquisition ZCO of workArea.</p> <p>Return Value</p> <ul> <li> <p>1: on success, the bundle has been  fully acquired and dispatched (that is, queued for delivery and/or forwarding). In this case, the invoking convergence- layer input adapter should simply continue with the next cycle of bundle acquisition, i.e., it should call bpBeginAcq().</p> </li> <li> <p>0: on any failure pertaining only to this bundle.  The failure is transient, applying only to the bundle that is currently being acquired.  In this case, the current bundle acquisition has failed but BP itself can continue; the invoking convergence-layer input adapter should simply continue with the next cycle of bundle acquisition just as if the return code had been 1.</p> </li> <li> <p>-1: on any other (i.e., system) failure.  </p> </li> </ul>"},{"location":"CLA-API/#bploadacq-suitable-for-certain-cla-types","title":"bpLoadAcq (suitable for certain CLA types)","text":"<p><pre><code>extern int      bpLoadAcq(  AcqWorkArea *workArea,\n                    Object zco);\n</code></pre> This function continues the acquisition of a bundle as initiated by an invocation of bpBeginAcq().  To do so, it inserts the indicated zero-copy object - containing possibly multiple whole bundles in concatenated form - into workArea.</p> <p>bpLoadAcq is an alternative to bpContinueAcq, intended for use by convergence-layer adapters that natively acquire concatenated bundles into zero-copy objects such as LTP.</p> <p>Return Value</p> <ul> <li>0: on success</li> <li>-1: on any failure    </li> </ul>"},{"location":"CLA-API/#setting-up-a-custom-cla-in-ion","title":"Setting up a custom CLA in ION","text":"<p>This section is under construction</p>"},{"location":"Configure-Multiple-Network-Interfaces/","title":"Configure ION for Multiple Network Interfaces","text":"<p>Lab testing of ION-based DTN network often uses only a single network. However, during deployment or operational testing, ION network must operate over multiple networks. To clarify how to configure ION, we consider the following hypothetical network configuration.</p> <p>The basic topology is illustrated here:</p> <pre><code>    +-------+  protocol a     protocol b  +-------+\n    |       |                             |       |\n    |  SC1  +-----+                  +---&gt;+  MOC1 |\n    |  21   |     |                  |    |  24   |\n    +-------+     |     +-------+    |    +-------+\n                  +----&gt;+       +----+\n          rfnet         |  GS   |          gsnet\n                  +----&gt;+  23   +----+\n    +-------+     |     +-------+    |    +-------+\n    |       |     |                  |    |       |\n    |  SC2  +-----+                  +---&gt;+  MOC2 |\n    |  22   |                             |  25   |\n    +-------+                             +-------+\n\nsubnet: 192.168.100.0/24      subnet:192.168.200.0/24\n</code></pre> <ul> <li>There are five ION nodes deployed across two networks, <code>rfnet</code> (192.168.100.0/24) and <code>gsnet</code> (192.168.200.0/24).</li> <li>The GS node is connected to both networks and acts as a DTN router between ION nodes on rfnet and gsnet.</li> <li>We assume the link convergence layer in <code>rfnet</code> is protocol A and in <code>gsnet</code>, protocol B.</li> <li>We present a series of ION configurations with the following protocol (A,B) combinations:</li> <li>(LTP, TCP)</li> <li>(LTP, STCP)</li> <li>(TCP, TCP)</li> <li>(STCP, STCP)</li> <li>(UDP, UDP)</li> <li>(LTP, LTP)</li> </ul>"},{"location":"Configure-Multiple-Network-Interfaces/#induct-and-outduct-relationship","title":"Induct and Outduct Relationship","text":"<p>ION associates each neighbor with an convergence layer protocol and an outduct. With the exception of UDP convergence layer, each outduct is associated with an induct as well.</p> <p>When there are multiple neighbors using the same convergence layer protocol, only one induct is used to 'pair' with multiple outducts of the same protocol.</p> <p>If neighbors using the same protocol are all within the same network, then the induct is associated with the IP address of the ION node on that particular network.</p> <p>If the neighbors using the same protocol are from multiple networks, then the induct will need to be associated with INADDR_ANY, 0.0.0.0:port defined for protocols such as TCP, UDP, and STCP.</p> <p>For LTP, however, multiple inducts can be defined for each network using the IP address of each network separately, and the induct for a network is called <code>seat</code> (see manual page for ltprc).</p>"},{"location":"Configure-Multiple-Network-Interfaces/#ion-configurations","title":"ION Configurations","text":""},{"location":"Configure-Multiple-Network-Interfaces/#ltptcp-example","title":"LTP/TCP Example","text":"<p>In this case, SC1 and SC2 communicates with GS using LTP, while MOC1 and MOC2 communicate with GS using TCP. The port we used is 4556.</p> <p>For GS, it defines TCP in this manner in the <code>.bprc</code> file:</p> <pre><code>a protocol tcp\n\na induct tcp 192.168.200.23:4556 tcpcli\n\na outduct tcp 192.168.200.24:4556 tcpclo\na outduct tcp 192.168.200.25:4556 tcpclo\n\na plan ipn:24.0\na planduct ipn:24.0 tcp 192.168.200.24:4556\na planduct ipn:25.0 tcp 192.168.200.25:4556\n</code></pre> <p>There is only induct for the two outducts. Since node 23, 24, and 25 are in the 192.168.200.0/24 subnet, the induct for 23 can simply use its statically assigned IP address of 192.168.200.23:4556.</p> <p>For MOC1, TCP is specified in this manner in the <code>.bprc</code> file:</p> <pre><code>a protocol tcp\n\na induct tcp 192.168.200.24:4556 tcpcli\n\na outduct tcp 192.168.200.23:4556 tcpclo\n\na plan ipn:23.0\n\na planduct ipn:23.0 tcp 192.168.200.23:4556\n</code></pre> <p>Since MOC1 has only 1 neighbor and uses TCP, the induct/outduct and egress plans are very much the standard configuration we see typically in a single network configuration.</p> <p>Similar configuration can be written for MOC2.</p> <p>For LTP, the configuration for GS is:</p> <pre><code># in bprc file\na protocol ltp\n\na induct ltp 23 ltpcli\n\na outduct ltp 21 ltpclo\na outduct ltp 22 ltpclo\n\na plan ipn:21.0 \na plan ipn:22.0\n\na planduct ipn:21.0 ltp 21\na planduct ipn:22.0 ltp 22\n\n# in .ltprc file\na span 21 100 100 1482 100000 1 'udplso 192.168.100.21:1113'\na span 22 100 100 1482 100000 1 'udplso 192.168.100.22:1113'\na seat 'udplsi 192.168.100.23:1113'\n\ns\n</code></pre> <p>For ltp, a single induct is specified for the 192.168.100.0/24 subnet using the <code>a seat</code> (add seat) command. The older syntax is <code>s 'udplsi 192.168.100.23:1113'</code>, which works only for the case of a single network and port combination. However, when extending LTP to multiple seats (inducts) when there are multiple networks or when there are multiple ports, the <code>seat</code> command offers the flexibility to support more complex configurations.</p>"},{"location":"Configure-Multiple-Network-Interfaces/#ltpstcp","title":"LTP/STCP","text":"<p>The syntax for LTP/STCP is identical, except replacing <code>tcp</code> with <code>stcp</code>, <code>tcpcli</code> and <code>tcpclo</code> with <code>stcpcli</code> and <code>stcpclo</code> in the configuration files.</p>"},{"location":"Configure-Multiple-Network-Interfaces/#tcp-and-stcp-across-multiple-networks","title":"TCP and STCP across multiple networks","text":"<p>When runing TCP or STCP over both networks, the only change is that for the GS node, the induct definitions in .bprc are replaced by:</p> <p><code>a induct tcp 0.0.0.0:4556 tcpcli</code> and <code>a induct stcp 0.0.0.0:4556 tcpcli</code></p>"},{"location":"Configure-Multiple-Network-Interfaces/#ltp-over-multiple-networks","title":"LTP over multiple networks","text":"<p>When running LTP over both networks, the only key difference is that in the <code>.ltprc</code> file for the GS node, two seats are defined:</p> <pre><code>a span 21 100 100 1482 100000 1 'udplso 192.168.100.21:1113'\na span 22 100 100 1482 100000 1 'udplso 192.168.100.22:1113'\na span 24 100 100 1482 100000 1 'udplso 192.168.200.24:1113'\na span 25 100 100 1482 100000 1 'udplso 192.168.200.25:1113'\na seat 'udplsi 192.168.100.23:1113'\na seat 'udplsi 192.168.200.23:1113'\n\ns\n</code></pre> <p>Of course the bprc file must also be updated to add reflect the additional LTP neighbors, but that extension is straightforward so we will not be listing them here.</p>"},{"location":"Configure-Multiple-Network-Interfaces/#use-of-contact-graph","title":"Use of Contact Graph","text":"<p>For ION, the use contact graph is optional when there is one hop. In that case, the data rate, normally defined in the contact graph, is provided through commands <code>plan</code> command in <code>.bprc</code> file.</p> <p>When contact graph is present, the information in the contact graph supersedes the data rate specified in the <code>plan</code> command.</p> <p>If there are no contact graph and the data rate is either 0 or omitted in the <code>plan</code> command, then there is no bundle level throttling of data.</p>"},{"location":"Configure-Multiple-Network-Interfaces/#use-of-exit-command","title":"Use of <code>exit</code> command","text":"<p>When no contact graph is provided, only immediate neighbor can exchange data. If relay operation is stil desired, an <code>exit</code> command can be used. In the case of the topology presented earlier, the node GS can be a gateway between the rfnet and gsnet. So GS can be added as an <code>exit</code> node for identified pair of source-destination.</p>"},{"location":"Extension-Block-Interface/","title":"BP Extension Interface","text":"<p>ION offers software developer a set of standard interface for adding extensions to Bundle Protocol without modifying the core BP source code. This capability can be used to implement both standardized bundle extension blocks or user-specific extension blocks.</p> <p>ION's interface for extending the Bundle Protocol enables the definition of external functions that insert extension blocks into outbound bundles (either before or after the payload block), parse and record extension blocks in inbound bundles, and modify extension blocks at key points in bundle processing. All extension-block handling is statically linked into ION at build time, but the addition of an extension never requires that any standard ION source code be modified.</p> <p>Standard structures for recording extension blocks -- both in transient storage memory during bundle acquisition (AcqExtBlock) and in persistent storage [the ION database] during subsequent bundle processing (ExtensionBlock) -- are defined in the bei.h header file. In each case, the extension block structure comprises a block type code, block processing flags, possibly a list of EID references, an array of bytes (the serialized form of the block, for transmission), the length of that array, optionally an extension-specific opaque object whose structure is designed to characterize the block in a manner that's convenient for the extension processing functions, and the size of that object.</p>"},{"location":"Extension-Block-Interface/#extension-definition-extesniondef-extensiondefs","title":"Extension Definition: <code>ExtesnionDef</code> &amp; <code>extensionDefs</code>","text":"<p>The definition of each extension is asserted in an ExtensionDef structure, also as defined in the <code>bei.h</code> header file. </p> <pre><code>/**\n *  \\struct ExtensionDef\n *  \\brief Defines the callbacks used to process extension blocks.\n *\n * ExtensionDef defines the callbacks for production and acquisition\n * of a single type of extension block, identified by block type name\n * and number.\n */\ntypedef struct\n{\n    char            name[32];   /** Name of extension   */\n    BpBlockType     type;       /** Block type      */\n\n    /*  Production callbacks.                   */\n\n    BpExtBlkOfferFn     offer;      /** Offer       */\n    BpExtBlkSerializeFn serialize;  /** Serialize       */\n    BpExtBlkProcessFn   process[5]; /** Process     */\n    BpExtBlkReleaseFn   release;    /** Release         */\n    BpExtBlkCopyFn      copy;       /** Copy        */\n\n    /*  Acquisition callbacks.                  */\n\n    BpAcqExtBlkAcquireFn    acquire;    /** Acquire         */\n    BpAcqExtReviewFn    review;     /** Review      */\n    BpAcqExtBlkDecryptFn    decrypt;    /** Decrypt         */\n    BpAcqExtBlkParseFn  parse;      /** Parse       */\n    BpAcqExtBlkCheckFn  check;      /** Check       */\n    BpExtBlkRecordFn    record;     /** Record      */\n    BpAcqExtBlkClearFn  clear;      /** Clear       */\n} ExtensionDef;\n</code></pre> <p>Each ExtensionDef must supply:</p> <ul> <li> <p>The name of the extension. (Used in some diagnostic messages.)</p> </li> <li> <p>The extension's block type code.</p> </li> <li> <p>A pointer to an offer function.</p> </li> <li> <p>A pointer to a function to be called when forwarding a bundle containing this sort of block.</p> </li> <li> <p>A pointer to a function to be called when taking custody of a bundle containing this sort of block.</p> </li> <li> <p>A pointer to a function to be called when enqueuing for transmission a bundle containing this sort of block.</p> </li> <li> <p>A pointer to a function to be called when a convergence-layer adapter dequeues a bundle containing this sort of block, before serializing it.</p> </li> <li> <p>A pointer to a function to be called immediately before a convergence-layer adapter transmits a bundle containing this sort of block, after the bundle has been serialized.</p> </li> <li> <p>A pointer to a release function.</p> </li> <li> <p>A pointer to a copy function.</p> </li> <li> <p>A pointer to an acquire function.</p> </li> <li> <p>A pointer to a review function.</p> </li> <li> <p>A pointer to a decrypt function.</p> </li> <li> <p>A pointer to a parse function.</p> </li> <li> <p>A pointer to a check function.</p> </li> <li> <p>A pointer to a record function.</p> </li> <li> <p>A pointer to a clear function.</p> </li> </ul> <p>All extension definitions must be coded into an array of ExtensionDef structures named extensionDefs.</p>"},{"location":"Extension-Block-Interface/#extensionspec-specification-for-producing-an-extension-block","title":"ExtensionSpec - specification for producing an extension block","text":"<pre><code>/*  ExtensionSpec provides the specification for producing an\n *  outbound extension block: block definition (identified by\n *  block type number), a formulation tag whose semantics are\n *  block-type-specific, and applicable CRC type.           */\n\ntypedef struct\n{\n    BpBlockType type;       /*  Block type      */\n    unsigned char   tag;        /*  Extension-specific  */\n    BpCrcType   crcType;    /*  Type of CRC on block    */\n} ExtensionSpec;\n</code></pre> <p>An array of ExtensionSpec structures named extensionSpecs is also required. Each ExtensionSpec provides the specification for producing an outbound extension block: </p> <ol> <li>block definition (identified by block type number), </li> <li>three discriminator tags whose semantics are block-type-specific, and </li> <li>CRC type indicating what type of CRC must be used to protect this extension block. </li> </ol> <p>The order of appearance of extension specifications in the extensionSpecs array determines the order in which extension blocks will be inserted into locally sourced bundles.</p>"},{"location":"Extension-Block-Interface/#procedure-to-extend-the-bundle-protocol","title":"Procedure to Extend the Bundle Protocol","text":"<p>The standard extensionDefs array -- which is empty -- is in the <code>noextensions.c</code> prototype source file. The procedure for extending the Bundle Protocol in ION is as follows:</p> <ol> <li> <p>Specify -DBP_EXTENDED in the Makefile's compiler command line when building the libbpP.c library module.</p> </li> <li> <p>Create a copy of the prototype extensions file, named \"bpextensions.c\", in a directory that is made visible to the Makefile's libbpP.c compilation command line (by a -I parameter).</p> </li> <li> <p>In the \"external function declarations\" area of \"bpextensions.c\", add \"extern\" function declarations identifying the functions that will implement your extension (or extensions).</p> </li> <li> <p>Add one or more ExtensionDef structure initialization lines to the extensionDefs array, referencing those declared functions.</p> </li> <li> <p>Add one or more ExtensionSpec structure initialization lines to the extensionSpecs array, referencing those extension definitions.</p> </li> <li> <p>Develop the implementations of the extension implementation functions in one or more new source code files.</p> </li> <li> <p>Add the object file or files for the new extension implementation source file (or files) to the Makefile's command line for linking libbpP.so.</p> </li> </ol>"},{"location":"Extension-Block-Interface/#extension-implementation-functions","title":"Extension Implementation Functions","text":"<p>The function pointers supplied in each ExtensionDef must conform to the following specifications. </p> <p>NOTE that any function that modifies the bytes member of an ExtensionBlock or AckExtBlock must set the corresponding length to the new length of the bytes array, if changed.</p> <pre><code>int (*BpExtBlkOfferFn)(ExtensionBlock *blk, Bundle *bundle)\n</code></pre> <p>Populates all fields of the indicated ExtensionBlock structure for inclusion in the indicated outbound bundle. This function is automatically called when a new bundle is locally sourced or upon acquisition of a remotely sourced bundle that does not contain an extension block of this type. The values of the extension block are typically expected to be a function of the state of the bundle, but this is extension-specific. If it is not appropriate to offer an extension block of this type as part of this bundle, then the size, length, object, and bytes members of blk must all be set to zero. If it is appropriate to offer such a block but no internal object representing the state of the block is needed, the object and size members of blk must be set to zero. The type, blkProcFlags, and dataLength members of blk must be populated by the implementation of the \"offer\" function, but the length and bytes members are typically populated by calling the BP library function serializeExtBlk(), which must be passed the block to be serialized (with type, blkProcFlags and dataLength already set), a Lyst of EID references (two list elements -- offsets -- per EID reference, if applicable; otherwise NULL), and a pointer to the extension-specific block data. The block's bytes array and object (if present) must occupy space allocated from the ION database heap. Return zero on success, -1 on any system failure.</p> <pre><code>int (*BpExtBlkProcessFn)(ExtensionBlock *blk, Bundle *bundle, void *context)\n</code></pre> <p>Performs some extension-specific transformation of the data encapsulated in blk based on the state of bundle. The transformation to be performed will typically vary depending on whether the identified function is the one that is automatically invoked upon forwarding the bundle, upon taking custody of the bundle, upon enqueuing the bundle for transmission, upon removing the bundle from the transmission queue, or upon transmitting the serialized bundle. The context argument may supply useful supplemental information; in particular, the context provided to the ON_DEQUEUE function will comprise the name of the protocol for the duct from which the bundle has been dequeued, together with the EID of the neighboring node endpoint to which the bundle will be directly transmitted when serialized. The block-specific data in blk is located within bytes immediately after the header of the extension block; the length of the block's header is the difference between length and dataLength. Whenever the block's blkProcFlags, EID extensions, and/or block-specific data are altered, the serializeExtBlk() function should be called again to recalculate the size of the extension block and rebuild the bytes array. Return zero on success, -1 on any system failure.</p> <pre><code>void (*BpExtBlkReleaseFn)(ExtensionBlock *blk)\n</code></pre> <p>Releases all ION database space occupied by the object member of blk. This function is automatically called when a bundle is destroyed. Note that incorrect implementation of this function may result in a database space leak.</p> <pre><code>int (*BpExtBlkCopyFn)(ExtensionBlock *newblk, ExtensionBlock *oldblk)\n</code></pre> <p>Copies the object member of oldblk to ION database heap space and places the address of that new non-volatile object in the object member of newblk, also sets size in newblk. This function is automatically called when two copies of a bundle are needed, e.g., in the event that it must both be delivered to a local client and also fowarded to another node. Return zero on success, -1 on any system failure.</p> <pre><code>int (*BpAcqExtBlkAcquireFn)(AcqExtBlock *acqblk, AcqWorkArea *work)\n</code></pre> <p>Populates the indicated AcqExtBlock structure with size and object for retention as part of the indicated inbound bundle. (The type, blkProcFlags, EID references (if any), dataLength, length, and bytes values of the structure are pre-populated with data as extracted from the serialized bundle.) This function is only to be provided for extension blocks that are never encrypted; a extension block that may be encrypted should have a BpAcqExtBlkParseFn callback instead. The function is automatically called when an extension block of this type is encountered in the course of parsing and acquiring a bundle for local delivery and/or forwarding. If no internal object representing the state of the block is needed, the object member of acqblk must be set to NULL and the size member must be set to zero. If an object is needed for this block, it must occupy space that is allocated from ION working memory using MTAKE and its size must be indicated in blk. Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if the block is successfully parsed, -1 on any system failure.</p> <pre><code>int (*BpAcqExtBlkReviewFn)(AcqWorkArea *work)\n</code></pre> <p>Reviews the extension blocks that have been acquired for this bundle, checking to make sure that all blocks of this type that are required by policy are present. Returns 0 if any blocks are missing, 1 if all required blocks are present, -1 on any system failure.</p> <pre><code>int (*BpAcqExtBlkDecryptFn)(AcqExtBlock *acqblk, AcqWorkArea *work)\n</code></pre> <p>Decrypts some other extension block that has been acquired but not yet parsed, nominally using encapsulated ciphersuite information. Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if no error in decryption was encountered, -1 on any system failure.</p> <pre><code>int (*BpAcqExtBlkParseFn)(AcqExtBlock *acqblk, AcqWorkArea *work)\n</code></pre> <p>Populates the indicated AcqExtBlock structure with size and object for retention as part of the indicated inbound bundle. (The type, blkProcFlags, EID references (if any), dataLength, length, and bytes values of the structure are pre-populated with data as extracted from the serialized bundle.) This function is provided for extension blocks that may be encrypted; a extension block that can never be encrypted should have a BpAcqExtBlkAcquireFn callback instead. The function is automatically called when an extension block of this type is encountered in the course of parsing and acquiring a bundle for local delivery and/or forwarding. If no internal object representing the state of the block is needed, the object member of acqblk must be set to NULL and the size member must be set to zero. If an object is needed for this block, it must occupy space that is allocated from ION working memory using MTAKE and its size must be indicated in blk. Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if the block is successfully parsed, -1 on any system failure.</p> <pre><code>int (*BpAcqExtBlkCheckFn)(AcqExtBlock *acqblk, AcqWorkArea *work)\n</code></pre> <p>Examines the bundle in work to determine whether or not it is authentic, in the context of the indicated extension block. Return 1 if the block is determined to be inauthentic (this will cause the bundle to be discarded), zero if no inauthenticity is detected, -1 on any system failure.</p> <pre><code>int (*BpExtBlkRecordFn)(ExtensionBlock *blk, AcqExtBlock *acqblk)\n</code></pre> <p>Copies the object member of acqblk to ION database heap space and places the address of that non-volatile object in the object member of blk; also sets size in blk. This function is automatically called when an acquired bundle is accepted for forwarding and/or delivery. Return zero on success, -1 on any system failure.</p> <pre><code>void (*BpAcqExtBlkClearFn)(AcqExtBlock *acqblk)\n</code></pre> <p>Uses MRELEASE to release all ION working memory occupied by the object member of acqblk. This function is automatically called when acquisition of a bundle is completed, whether or not the bundle is accepted. Note that incorrect implementation of this function may result in a working memory leak.</p>"},{"location":"Extension-Block-Interface/#utility-functions-for-extension-processing","title":"Utility Functions for Extension Processing","text":"<pre><code>void discardExtensionBlock(AcqExtBlock *blk)\n</code></pre> <p>Deletes this block from the bundle acquisition work area prior to the recording of the bundle in the ION database.</p> <pre><code>void scratchExtensionBlock(ExtensionBlock *blk)\n</code></pre> <p>Deletes this block from the bundle after the bundle has been recorded in the ION database.</p> <pre><code>Object findExtensionBlock(Bundle *bundle, unsigned int type, unsigned char tag1, unsigned char tag2, unsigned char tag3)\n</code></pre> <p>On success, returns the address of the ExtensionBlock in bundle for the indicated type and tag values. If no such extension block exists, returns zero.</p> <pre><code>int serializeExtBlk(ExtensionBlock *blk, char *blockData)\n</code></pre> <p>Constructs a BPv7-conformant serialized representation of this extension block in blk-&gt;bytes. Returns 0 on success, -1 on an unrecoverable system error.</p> <pre><code>void suppressExtensionBlock(ExtensionBlock *blk)\n</code></pre> <p>Causes blk to be omitted when the bundle to which it is attached is serialized for transmission. This suppression remains in effect until it is reversed by restoreExtensionBlock();</p> <pre><code>void restoreExtensionBlock(ExtensionBlock *blk)\n</code></pre> <p>Reverses the effect of suppressExtensionBlock(), enabling the block to be included when the bundle to which it is attached is serialized.</p>"},{"location":"ICI-API/","title":"Interplanetary Communications Infrastructure (ICI) APIs","text":"<p>This section will focus on a subset of ICI APIs that enables an external application to create, manipulate, and access data objects inside ION's SDR.</p>"},{"location":"ICI-API/#ici-apis","title":"ICI APIs","text":""},{"location":"ICI-API/#header","title":"Header","text":"<pre><code>#include \"ion.h\"\n</code></pre>"},{"location":"ICI-API/#mtake-mrelease","title":"MTAKE &amp; MRELEASE","text":"<pre><code>#define MTAKE(size) allocFromIonMemory(__FILE__, __LINE__, size)\n#define MRELEASE(addr)  releaseToIonMemory(__FILE__, __LINE__, addr)\n</code></pre> <ul> <li>MTAKE and MRELEASE provide syntactically terse ways of calling <code>allocFromIonMemory</code> and <code>releaseToIonMemory</code>, the functional equivalent of <code>malloc</code> and <code>free</code> for ION. The allocated memory space comes from the ION working memory, which has been pre-allocated during the ION configuration.</li> <li>FILE and LINE provide the source file name and line number of the calling function and can assist in debugging and tracking down memory leaks.</li> </ul>"},{"location":"ICI-API/#ionattach","title":"ionAttach","text":"<p>Function Prototype</p> <pre><code>extern int  ionAttach();\n</code></pre> <p>Parameters</p> <ul> <li>None.</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: any error</li> </ul> <p>Example Call</p> <pre><code>if (ionAttach() &lt; 0)\n{\n    putErrmsg(\"bpadmin can't attach to ION.\", NULL);\n\n    /* User calls error handling routine. */\n}\n</code></pre> <p>Description</p> <p>Attached is the invoking task to ION infrastructure as previously established by running the ionadmin utility program. After successful execution, the handle to the ION SDR can be obtained by a separate API call. <code>putErrmsg</code> is an ION logging API, which will be described later in this document.</p>"},{"location":"ICI-API/#iondetach","title":"ionDetach","text":"<p>Function Prototype</p> <pre><code>extern void ionDetach();\n</code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Return Value</p> <ul> <li>None</li> </ul> <p>Example Call</p> <pre><code>ionDetach();\n</code></pre> <p>Description</p> <p>Detaches the invoking task from ION infrastructure. In particular, releases handle allocated for access to ION's non-volatile database.</p>"},{"location":"ICI-API/#ionterminate","title":"ionTerminate","text":"<p>Function Prototype</p> <pre><code>extern void ionTerminate();\n</code></pre> <p>Parameters</p> <ul> <li>None</li> </ul> <p>Return Value</p> <ul> <li>None</li> </ul> <p>Example Call</p> <pre><code>ionTerminate();\n</code></pre> <p>Description</p> <p>Shuts down the entire ION node, terminating all daemons. The state of the SDR will be destroyed during the termination process, even if the SDR heap is implemented in a non-volatile storage, such as a file.</p>"},{"location":"ICI-API/#ionstartattendant","title":"ionStartAttendant","text":"<p>Function Prototype</p> <pre><code>extern int  ionStartAttendant(ReqAttendant *attendant);\n</code></pre> <p>Parameters</p> <ul> <li><code>*attendant</code>: pointer to a <code>ReqAttendant</code> structure that will be initialized by this function.</li> </ul> <pre><code>typedef struct\n{\n    sm_SemId    semaphore;\n} ReqAttendant;\n</code></pre> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: any error</li> </ul> <p>Example Call</p> <pre><code>if (ionStartAttendant(&amp;attendant))\n{\n    putErrmsg(\"Can't initialize blocking transmission.\", NULL);\n\n    /* user implemented error handling routine */\n}\n</code></pre> <p>Description</p> <p>Initializes the semaphore in <code>attendant</code> to block a pending ZCO space request. This is necessary to ensure that the invoking task cannot inject data into the Bundle Protocol Agent until SDR space has been allocated.</p>"},{"location":"ICI-API/#ionstopattendant","title":"ionStopAttendant","text":"<p>Function Prototype</p> <pre><code>extern void ionStopAttendant(ReqAttendant *attendant);\n</code></pre> <p>Parameters</p> <ul> <li><code>*attendant</code>: pointer to a <code>ReqAttendant</code> structure that will be destroyed by this function.</li> </ul> <p>Return Value</p> <ul> <li>0: Success</li> <li>-1: Any error</li> </ul> <p>Example Call</p> <pre><code>ionStopAttendant(&amp;attendant);\n</code></pre> <p>Description</p> <p>Destroys the semaphore in <code>attendant</code>, preventing a potential resource leak. This is typically called at the end of a BP application after all user data have been injected into the SDR.</p>"},{"location":"ICI-API/#ionpauseattendent","title":"ionPauseAttendent","text":"<p>Function Prototype</p> <pre><code>void ionPauseAttendant(ReqAttendant *attendant)\n</code></pre> <p>Parameters</p> <ul> <li><code>*attendant</code>: pointer to a <code>ReqAttendant</code> structure.</li> </ul> <p>Return Value</p> <ul> <li>None</li> </ul> <p>Example Call</p> <pre><code>ionStopAttendant(&amp;attendant);\n</code></pre> <p>Description</p> <p>\"Ends\" the semaphore in attendant so that the task blocked on taking it is interrupted and may respond to an error or shutdown condition. This may be required when trying to quit a blocked user application while acquiring ZCO space.</p>"},{"location":"ICI-API/#ioncreatezco","title":"ionCreateZco","text":"<p>Function Prototype</p> <pre><code>extern Object ionCreateZco( ZcoMedium source,\n            Object location,\n            vast offset,\n            vast length,\n            unsigned char coarsePriority,\n            unsigned char finePriority,\n            ZcoAcct acct,\n            ReqAttendant *attendant);\n</code></pre> <p>Parameters</p> <p>Source: the type of ZCO to be created. Each source data object may be either a file, a \"bulk\" item in mass storage, an object in SDR heap space (identified by heap address stored in an \"object reference\" object in SDR heap), an array of bytes in SDR heap space (identified by heap address), or another ZCO.</p> <pre><code>typedef enum\n{\n    ZcoFileSource = 1,\n    ZcoBulkSource = 2,\n    ZcoObjSource = 3,\n    ZcoSdrSource = 4,\n    ZcoZcoSource = 5\n} ZcoMedium;\n</code></pre> <ul> <li><code>location</code>: the location in the heap where a single extent of source data resides. The user application usually places this data via <code>sdr_malloc()</code>, which will be discussed later.</li> <li><code>offset</code>: the offset within the source data object where the first byte of the ZCO should be placed.</li> <li><code>length</code>: the length of the ZCO to be created.</li> <li><code>coarsePriority</code>: this sets the bundle's Class of Service (COS) as an inherited feature from BPv6. Although COS is not specified in BPv7, ION API supports this feature when creating ZCOs. From the lowest to the highest priorities, it can be set to the following values:<ul> <li><code>BP_BULK_PRIORITY</code> (value =0)</li> <li><code>BP_STD_PRIORITY</code> (value = 1), or </li> <li><code>BP_EXPEDITED_PRIORITY</code> (value = 2)</li> </ul> </li> <li><code>finePriority</code>: this is inherited from BPv6 COS and is the finer grain priority level (level 0 to 254) within the <code>BP_STD_PRIORITY</code> class. The default value is 0.</li> <li><code>acct</code>: The accounting category for the ZCO, which is either <code>ZcoInbound</code> (0), <code>ZcoOutbound</code> (1), or <code>ZcoUnknown</code> (2). If a ZCO is created for transmission to another node, this parameter is typically set to <code>ZcoOutbound</code>.</li> <li><code>*attendant</code>: the semaphore that blocks the return of the function until the necessary resources have been allocated in the SDR for the ZCO</li> </ul> <p>Return Value</p> <ul> <li>Location of the ZCO: on success, the requested space has become available, and the ZCO has been created to hold the user data</li> <li><code>((Object) -1)</code>: the function has failed</li> <li><code>0</code>: either the attendant was <code>NULL</code> and sufficient space for the first extent of the ZCO was not immediately available, or the function was interrupted by <code>ionPauseAttendant</code> before space for the ZCO became available.</li> </ul> <p>Example Call</p> <pre><code>SdrObject bundleZco;\n\nbundleZco = ionCreateZco(ZcoSdrSource, extent, 0, lineLength,\n        BP_STD_PRIORITY, 0, ZcoOutbound, &amp;attendant);\nif (bundleZco == 0 || bundleZco == (Object) ERROR)\n{\n    putErrmsg(\"Can't create ZCO extent.\", NULL);\n    /* user implemented error handling routine goes here */\n}\n</code></pre> <p>Description</p> <p>This function provides a \"blocking\" implementation of admission control in ION. Like zco_create(), it constructs a zero-copy object (see zco(3)) that contains a single extent of source data residing at a location in the source, of which the initial offset number of bytes are omitted and the subsequent <code>length</code> bytes are included. By providing an attendant semaphore, initialized by <code>ionStartAttendant</code>, <code>ionCreateZco()</code> can be executed as a blocking call so long as the total amount of space in the <code>source</code> available for new ZCO formation is less than the length. <code>ionCreateZco()</code> operates by calling <code>ionRequestZcoSpace</code>, then pending on the semaphore in attendant as necessary before creating the ZCO and then populating it with the user's data.</p>"},{"location":"ICI-API/#sdr-database-heap-apis","title":"SDR Database &amp; Heap APIs","text":"<p>SDR persistent data are referenced by object and address values in the application code, simply displacements (offsets) within the SDR address space. The difference between the two is that an <code>Object</code> is always the address of a block of heap space returned by some call to <code>sdr_malloc</code>, while an <code>Address</code> can refer to any byte in the SDR address space. An <code>Address</code> is the SDR functional equivalent of a C pointer; some Addresses point to actual Objects.</p> <p>The number of SDR-related APIs is significant, and most are used by ION internally. Fortunately, there are only a few APIs that an external application will likely need to use. The following list of the most commonly used APIs is drawn from the Database I/O and the Heap Space Management API categories.</p>"},{"location":"ICI-API/#header_1","title":"Header","text":"<pre><code>#include \"sdr.h\"\n</code></pre>"},{"location":"ICI-API/#sdr_malloc","title":"sdr_malloc","text":"<p>Function Prototype</p> <pre><code>Object sdr_malloc(Sdr sdr, unsigned long size)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>size</code>: size of the block to allocate</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: Success. The requested space has been allocated</li> <li>0: Failure</li> </ul> <p>Example Call</p> <pre><code>CHKZERO(sdr_begin_xn(sdr));\nextent = sdr_malloc(sdr, lineLength);\nif (extent)\n{\n    sdr_write(sdr, extent, text, lineLength);\n}\n\nif (sdr_end_xn(sdr) &lt; 0)\n{\n    putErrmsg(\"No space for ZCO extent.\", NULL);\n    bp_detach();\n    return 0;\n}\n</code></pre> <p>In this example, a 'critical section' has been implemented by API calls: <code>sdr_begin_xn</code> and <code>sdr_end_xn</code>. The critical section ensures that the SDR is not altered while the space allocation is in progress. These APIs will be explained later in this document. The <code>sdr_write</code> API is used to write data into the space acquired by <code>sdr_malloc</code>.</p> <p>It may seem strange that failing to allocate space or write the data into the allocated space relies on checking the return value of <code>sdr_end_xn</code> instead of sdr_malloc and sdr_write functions. This is because when <code>sdr_end_xn</code> returns a negative value, it indicates that an SDR transaction was already terminated, which occurs when <code>sdr_malloc</code> or <code>sdr_write</code> fails. So, this is a convenient way to detect the failure of two calls simultaneously by checking the <code>sdr_end_xn</code> call return value.</p> <p>Description</p> <p>Allocates a block of space from the indicated SDR's heap. The maximum size is 1/2 of the maximum address space size (i.e., 2G for a 32-bit machine). Returns block address if successful, zero if block could not be allocated.</p>"},{"location":"ICI-API/#sdr_insert","title":"sdr_insert","text":"<p>Function Prototype</p> <pre><code>Object sdr_insert(Sdr sdr, char *from, unsigned long size)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>*from</code>: pointer to the location where several bytes (specified by <code>size</code>) of data are to be copied into the allocated space in the SDR</li> <li><code>size</code>: size of the block to allocate</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: Failure</li> </ul> <p>Example Call</p> <pre><code>CHKZERO(sdr_begin_xn(sdr));\nextent = sdr_insert(sdr, text, lineLength);\nif (sdr_end_xn(sdr) &lt; 0)\n{\n    putErrmsg(\"No space for ZCO extent.\", NULL);\n    bp_detach();\n    return 0;\n}\n</code></pre> <p>Description</p> <p>This function combines the action of <code>sdr_malloc</code> and <code>sdr_write</code>. It first uses <code>sdr_malloc</code> to obtain a block of space, and if this allocation is successful, it uses <code>sdr_write</code> to copy size bytes of data from memory into the newly allocated block.</p>"},{"location":"ICI-API/#sdr_stow","title":"sdr_stow","text":"<p>Function Prototype</p> <pre><code>Object sdr_stow(sdr, variable)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>variable</code>: the variable whose value is to be inserted into an SDR space</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: Failure</li> </ul> <p>Description</p> <p><code>sdr_stow</code> is a macro that uses <code>sdr_insert</code> to insert a copy of a variable into the dataspace. The size of the variable is used as the number of bytes to copy.</p>"},{"location":"ICI-API/#sdr_object_length","title":"sdr_object_length","text":"<p>Function Prototype</p> <pre><code>int sdr_object_length(Sdr sdr, Object object)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>object</code>: the location of an application data object</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: Failure</li> </ul> <p>Description</p> <p>Returns the number of bytes of heap space allocated to the application data at object.</p>"},{"location":"ICI-API/#sdr_free","title":"sdr_free","text":"<p>Function Prototype</p> <pre><code>void sdr_free(Sdr sdr, Object object)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>object</code>: the location of an application data Object</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: failure</li> </ul> <p>Description</p> <p>Frees the heap space occupied by an object at object. The space freed are put back into the SDR memory pool and will become available for subsequent re-allocation.</p>"},{"location":"ICI-API/#sdr_read","title":"sdr_read","text":"<p>Function Prototype</p> <pre><code>void sdr_read(Sdr sdr, char *into, Address from, int length)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>*into</code>: the location in memory data should be read into</li> <li><code>from</code>: this is a location in the SDR heap</li> <li><code>length</code>: this is the size to be read</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: Failure</li> </ul> <p>Description</p> <p>Copies length characters from (a location in the indicated SDR) to the memory location given by into. The data are copied from the shared memory region in which the SDR resides, if any; otherwise, they are read from the file in which the SDR resides.</p>"},{"location":"ICI-API/#sdr_stage","title":"sdr_stage","text":"<p>Function Prototype</p> <pre><code>void sdr_stage(Sdr sdr, char *into, Object from, int length)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>*into</code>: the location in memory data should be read into</li> <li><code>from</code>: this is a location in the SDR heap which is occupied by an allocated object</li> <li><code>length</code>: this is the size to be read</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: Failure</li> </ul> <p>Description</p> <p>Like <code>sdr_read</code>, this function will copy length characters from (a location in the heap of the indicated SDR) to the memory location given by into. Unlike <code>sdr_get</code>, <code>sdr_stage</code> requires that from be the address of some allocated object, not just any location within the heap. <code>sdr_stage</code>, when called from within a transaction, notifies the SDR library that the indicated object may be updated later in the transaction; this enables the library to retrieve the object's size for later reference in validating attempts to write into some location within the object. If the length is zero, the object's size is privately retrieved by SDR, but none of the object's content is copied into memory.</p> <p><code>sdr_get</code> is a macro that uses <code>sdr_read</code> to load variables from the SDR address given by heap_pointer; heap_pointer must be (or be derived from) a heap pointer as returned by <code>sdr_pointer</code>. The size of the variable is used as the number of bytes to copy.</p>"},{"location":"ICI-API/#sdr_write","title":"sdr_write","text":"<p>Function Prototype</p> <pre><code>void sdr_write(Sdr sdr, Address into, char *from, int length)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>*into</code>: the location in the SDR heap where data should be written into</li> <li><code>from</code>: this is a location in memory where data should copied from</li> <li><code>length</code>: this is the size to be written</li> </ul> <p>Return Value</p> <ul> <li>address of the allocated space: success</li> <li>0: Failure</li> </ul> <p>Description</p> <p>Like <code>sdr_read</code>, this function will copy length characters from (a location in the heap of the indicated SDR) to the memory location given by into. Unlike <code>sdr_get</code>, <code>sdr_stage</code> requires that from be the address of some allocated object, not just any location within the heap. <code>sdr_stage</code>, when called from within a transaction, notifies the SDR library that the indicated object may be updated later in the transaction; this enables the library to retrieve the object's size for later reference in validating attempts to write into some location within the object. If length is zero, the object's size is privately retrieved by SDR but none of the object's content is copied into memory.</p> <p><code>sdr_get</code> is a macro that uses <code>sdr_read</code> to load variables from the SDR address given by heap_pointer; heap_pointer must be (or be derived from) a heap pointer as returned by <code>sdr_pointer</code>. The size of the variable is used as the number of bytes to copy.</p>"},{"location":"ICI-API/#sdr-transaction-apis","title":"SDR Transaction APIs","text":"<p>The following APIs manage transactions by implementing a critical section in which SDR content cannot be modified.</p>"},{"location":"ICI-API/#header_2","title":"Header","text":"<pre><code>#include \"sdrxn.h\"\n</code></pre>"},{"location":"ICI-API/#sdr_begin_xn","title":"sdr_begin_xn","text":"<p>Function Prototype</p> <pre><code>int sdr_begin_xn(Sdr sdr)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> </ul> <p>Return Value</p> <ul> <li>1: Success</li> <li>0: Failure</li> </ul> <p>Description</p> <p>Initiates a transaction. Returns 1 on success, 0 on any failure. Note that transactions are single-threaded; any task that calls <code>sdr_begin_xn</code> is suspended until all previously requested transactions have been ended or canceled.</p>"},{"location":"ICI-API/#sdr_in_xn","title":"sdr_in_xn","text":"<p>Function Prototype</p> <pre><code>int sdr_in_xn(Sdr sdr)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> </ul> <p>Return Value</p> <ul> <li>1: transaction in progress</li> <li>0: no transaction in progress</li> </ul> <p>Description</p> <p>Returns 1 if called in the course of a transaction, 0 otherwise.</p>"},{"location":"ICI-API/#sdr_exit_xn","title":"sdr_exit_xn","text":"<p>Function Prototype</p> <pre><code>void sdr_exit_xn(Sdr sdr)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Simply abandons the current transaction, ceasing the calling task's lock on ION. MUST NOT be used if any dataspace modifications were performed during the transaction; <code>sdr_end_xn</code> must be called instead to commit those modifications.</p>"},{"location":"ICI-API/#sdr_cancel_xn","title":"sdr_cancel_xn","text":"<p>Function Prototype</p> <pre><code>void sdr_cancel_xn(Sdr sdr)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Cancels the current transaction. If reversibility is enabled for the SDR, canceling a transaction reverses all heap modifications performed during that transaction.</p>"},{"location":"ICI-API/#sdr_end_xn","title":"sdr_end_xn","text":"<p>Function Prototype</p> <pre><code>int sdr_end_xn(Sdr sdr)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> </ul> <p>Return Value</p> <ul> <li>0: transaction completed successfully</li> <li>-1: transaction unable to complete due to failed operations; transaction canceled</li> </ul> <p>Description</p> <p>Ends the current transaction. Returns 0 if the transaction was completed without any error; returns -1 if any operation performed in the course of the transaction failed, in which case the transaction was automatically canceled.</p>"},{"location":"ICI-API/#sdr-list-management-apis","title":"SDR List management APIs","text":"<p>The SDR list management functions manage doubly-linked lists in managed SDR heap space. The functions manage two kinds of objects: lists and list elements. A list knows how many elements it contains and what its start and end elements are. An element knows what list it belongs to and the elements before and after it in the list. An element also knows its content, which is normally the SDR Address of some object in the SDR heap. A list may be sorted, which speeds the process of searching for a particular element.</p>"},{"location":"ICI-API/#header_3","title":"Header","text":"<pre><code>#include \"sdr.h\"\n\ntypedef int (*SdrListCompareFn)(Sdr sdr, Address eltData, void *argData);\ntypedef void (*SdrListDeleteFn)(Sdr sdr, Object elt, void *argument);\n</code></pre>"},{"location":"ICI-API/#callback-sdrlistcomparefn","title":"Callback: SdrListCompareFn","text":""},{"location":"ICI-API/#callback-sdrlistdeletefn","title":"Callback: SDRListDEleteFn","text":"<p>USAGE</p> <p>When inserting elements or searching a list, the user may optionally provide a compare function of the form:</p> <pre><code>int user_comp_name(Sdr sdr, Address eltData, void *dataBuffer);\n</code></pre> <p>When provided, this function is automatically called by the sdrlist function being invoked; when the function is called, it is passed the content of a list element (eltData, nominally the Address of an item in the SDR's heap space) and an argument, dataBuffer, which is nominally the address in the local memory of some other item in the same format. The user-supplied function normally compares some key values of the two data items. It returns 0 if they are equal, an integer less than 0 if eltData's key value is less than that of dataBuffer, and an integer greater than 0 if eltData's key value is greater than that of dataBuffer. These return values will produce a list in ascending order. If the user desires the list to be in descending order, the function must reverse the signs of these return values.</p> <p>When deleting an element or destroying a list, the user may optionally provide a delete function of the form:</p> <pre><code>void user_delete_name(Sdr sdr, Address eltData, void *argData)\n</code></pre> <p>When provided, this function is automatically called by the sdrlist function being invoked; when the function is called, it is passed the content of a list element (eltData, nominally the Address of an item in the SDR's heap space) and an argument, argData, which if non-NULL is normally the address in the local memory of a data item providing context for the list element deletion. The user-supplied function performs any application-specific cleanup associated with deleting the element, such as freeing the element's content data item and/or other SDR heap space associated with the element.</p>"},{"location":"ICI-API/#sdr_list_insert_first","title":"sdr_list_insert_first","text":""},{"location":"ICI-API/#sdr_list_insert_last","title":"sdr_list_insert_last","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_insert_first(Sdr sdr, Object list, Address data)\nObject sdr_list_insert_last(Sdr sdr, Object list, Address data)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: a list</li> <li><code>data</code>: an address in SDR</li> </ul> <p>Return Value</p> <ul> <li><code>address of newly created element</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Creates a new element and inserts it at the front/end of the list. This function should not be used to insert a new element into any ordered list; use <code>sdr_list_insert</code>() instead.</p>"},{"location":"ICI-API/#sdr_list_create","title":"sdr_list_create","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_create(Sdr sdr)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> </ul> <p>Return Value</p> <ul> <li><code>address of newly created list</code>: Success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Creates a new list object in the SDR; the new list object initially contains no list elements. Returns the address of the new list or zero on any error.</p>"},{"location":"ICI-API/#sdr_list_length","title":"sdr_list_length","text":"<p>Function Prototype</p> <pre><code>int sdr_list_length(Sdr sdr, Object list)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: a list in SDR</li> </ul> <p>Return Value <code>number of elements in the</code> list<code>: Success *</code>-1`: any error</p> <p>Description</p> <p>Returns the number of elements in the list, or -1 on any error.</p>"},{"location":"ICI-API/#sdr_list_destroy","title":"sdr_list_destroy","text":"<p>Function Prototype</p> <pre><code>void sdr_list_destroy(Sdr sdr, Object list, SdrListDeleteFn fn, void *arg)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: a list in SDR to be destroyed</li> <li><code>fn</code>: a sdrlist delete function</li> <li><code>arg</code>: arguments passed to the delete function</li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Destroys a list, freeing all elements of the list. If fn is non-NULL, that function is called once for each freed element; when called, fn is passed the Address that is the element's data, and the argument pointer is passed to <code>sdr_list_destroy</code>. See the manual page for <code>sdrlist</code> for details on the form of the delete function sdrlist.</p> <p>Do not use sdr_free to destroy an SDR list, as this would leave the elements of the list allocated yet unreferenced.</p>"},{"location":"ICI-API/#sdr_list_user_data_set","title":"sdr_list_user_data_set","text":"<p>Function Prototype</p> <pre><code>void sdr_list_user_data_set(Sdr sdr, Object list, Address userData)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: a list in SDR to be destroyed</li> <li><code>userData</code>: a single word which is a SDR address</li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Sets the \"user data\" word of list to userData. Note that userData is nominally an Address but can be any value that occupies a single word. It is typically used to point to an SDR object that somehow characterizes the list as a whole, such as a name.</p>"},{"location":"ICI-API/#sdr_list_user_data","title":"sdr_list_user_data","text":"<p>Function Prototype</p> <pre><code>Address sdr_list_user_data(Sdr sdr, Object list)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: a list in SDR to be destroyed</li> </ul> <p>Return Value</p> <ul> <li><code>value of the \"user data\" word of list</code>: Success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Returns the value of the \"user data\" word of list, or zero on any error.</p>"},{"location":"ICI-API/#sdr_list_insert","title":"sdr_list_insert","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_insert(Sdr sdr, Object list, Address data, SdrListCompareFn fn, void *dataBuffer)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: a list in SDR to be destroyed</li> <li><code>data</code>: address in SDR</li> <li><code>fn</code>: a sdrlist compare function</li> <li><code>dataBuffer</code>: data pass to the compare function</li> </ul> <p>Return Value</p> <ul> <li><code>value of the \"user data\" word of list</code>: Success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Creates a new list element whose data value is data and inserts that element into the list. If fn is NULL, the new list element is simply appended to the list; otherwise, the new list element is inserted after the last element in the list whose data value is \"less than or equal to\" the data value of the new element (in dataBuffer) according to the collating sequence established by fn. Returns the address of the newly created element or zero on any error.</p>"},{"location":"ICI-API/#sdr_list_insert_before","title":"sdr_list_insert_before","text":""},{"location":"ICI-API/#sdr_list_insert_after","title":"sdr_list_insert_after","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_insert_before(Sdr sdr, Object elt, Address data)\nObject sdr_list_insert_after(Sdr sdr, Object elt, Address data)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: an element of a list in the SDR</li> <li><code>data</code>: an address in SDR</li> </ul> <p>Return Value</p> <ul> <li><code>address of the newly created list element</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Creates a new element and inserts it before/after the specified list element. This function should not be used to insert a new element into an ordered list; use <code>sdr_list_insert</code> instead. Returns the address of the newly created list element or zero on any error.</p>"},{"location":"ICI-API/#sdr_list_delete","title":"sdr_list_delete","text":"<p>Function Prototype</p> <pre><code>void sdr_list_delete(Sdr sdr, Object elt, SdrListDeleteFn fn, void *arg)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: an element of a list in the SDR</li> <li><code>fn</code>: a sdr list delete function</li> <li><code>*arg</code>: argument passed to the delete function</li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Description</p> <p>Delete elt from the list it is in. If fn is non-NULL, that function will be called upon deletion of elt; when called, that function is passed the Address that is the list element's data value and the arg pointer passed to <code>sdr_list_delete</code>.</p>"},{"location":"ICI-API/#sdr_list_first","title":"sdr_list_first","text":""},{"location":"ICI-API/#sdr_list_last","title":"sdr_list_last","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_first(Sdr sdr, Object list)\nObject sdr_list_last(Sdr sdr, Object list)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>list</code>: address of a list in the SDR</li> </ul> <p>Return Value</p> <ul> <li><code>address to the first/last element</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Returns the address of the first/last element of the list, or zero on any error.</p>"},{"location":"ICI-API/#sdr_list_next","title":"sdr_list_next","text":""},{"location":"ICI-API/#sdr_list_prev","title":"sdr_list_prev","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_next(Sdr sdr, Object elt)\nObject sdr_list_prev(Sdr sdr, Object elt)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: address of an element in a sdrlist</li> </ul> <p>Return Value</p> <ul> <li><code>address to the element following/preceding the element provided</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Returns the address of the element following/preceding elt in that element's list or zero on any error.</p>"},{"location":"ICI-API/#sdr_list_search","title":"sdr_list_search","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_search(Sdr sdr, Object elt, int reverse, SdrListCompareFn fn, void *dataBuffer);\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: address of an element in a sdrlist</li> <li><code>reverse</code>: order of search</li> <li><code>fn</code>: a sdrlist compare function</li> <li><code>*dataBuffer</code>: address of data to be used for search</li> </ul> <p>Return Value</p> <ul> <li><code>address to the matching element</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Search a list for an element whose data matches the data in dataBuffer, starting at the indicated initial list element.</p> <p>If the compare function is non-NULL, the list is assumed to be sorted in the order implied by that function, and the function is automatically called once for each element of the list until it returns a value that is greater than or equal to zero (where zero indicates an exact match and a value greater than zero indicates that the list contains no matching element); each time compare is called it is passed the Address that is the element's data value and the dataBuffer value passed to sm_list_search(). If the reverse is non-zero, then the list is searched in reverse order (starting at the indicated initial list element), and the search ends when the compare function returns a value that is less than or equal to zero. If the compare function is NULL, then the entire list is searched (in either forward or reverse order, as directed) until an element is located whose data value is equal to ((Address) dataBuffer). Returns the address of the matching element if one is found, 0 otherwise.</p>"},{"location":"ICI-API/#sdr_list_list","title":"sdr_list_list","text":"<p>Function Prototype</p> <pre><code>Object sdr_list_list(Sdr sdr, Object elt)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: address of an element in a sdrlist</li> </ul> <p>Return Value</p> <ul> <li><code>address to the list to which elt belongs</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Returns the address of the list to which elt belongs, or 0 on any error.</p>"},{"location":"ICI-API/#sdr_list_data","title":"sdr_list_data","text":"<p>Function Prototype</p> <pre><code>Address sdr_list_data(Sdr sdr, Object elt)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: address of an element in a sdrlist</li> </ul> <p>Return Value</p> <ul> <li><code>address that is the data value of elt</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Returns the Address that is the data value of elt, or 0 on any error.</p>"},{"location":"ICI-API/#sdr_list_data_set","title":"sdr_list_data_set","text":"<p>Function Prototype</p> <pre><code>Address sdr_list_data_set(Sdr sdr, Object elt, Address data)\n</code></pre> <p>Parameters</p> <ul> <li><code>sdr</code>: handle to the ION SDR obtained through <code>ionAttach</code> or <code>bp_attach</code></li> <li><code>elt</code>: address of an element in a sdrlist</li> <li><code>data</code>: address of data in SDR</li> </ul> <p>Return Value</p> <ul> <li><code>original data value of elt</code>: success</li> <li><code>0</code>: any error</li> </ul> <p>Description</p> <p>Sets the data value for elt to data, replacing the original value. Returns the original data value for elt, or 0 on any error. The original data value for elt may or may not have been the address of an object in heap data space; even if it was, that object was NOT deleted.</p> <p>Warning: changing the data value of an element of an ordered list may ruin the ordering of the list.</p>"},{"location":"ICI-API/#other-less-used-ici-apis","title":"Other less used ICI APIs","text":"<p>There are many other less frequently used APIs. Please see the manual pages for the following:</p> <p><code>ion</code>, <code>sdr</code>, <code>sdrlist</code>, <code>platform</code>, <code>lyst</code>, <code>psm</code>, <code>memmgr</code>, <code>sdrstring</code>, <code>sdrtable</code>, and <code>smlist</code>.</p>"},{"location":"ION-Application-Service-Interface/","title":"ION Application Services","text":"<p>This section covers interfaces for users to access the following four DTN application-level services provided by ION:</p> <ul> <li>CFDP (CCSDS File Delivery Protocol) - CCSDS Bluebook CCSDS 727.0-B-4</li> <li>BSS (Bundle Streaming Service)</li> <li>AMS (Asynchronous Message Service) - CCSDS Bluebook CCSDS 735.1-B-1, Greenbook CCSDS 735.0-G-1</li> <li>DTPC (Delay-Tolerant Payload Conditioning)</li> </ul>"},{"location":"ION-Application-Service-Interface/#ccsds-file-delivery-protocol-cfdp-apis","title":"CCSDS File Delivery Protocol (CFDP) APIs","text":"<p>The CFDP library provides functions enabling application software to use CFDP to send and receive files. It conforms to the Class 1 (Unacknowledged) service class defined in the CFDP Blue Book and includes several standard CFDP user operations implementations.</p> <p>In the ION implementation of CFDP, the CFDP notion of entity ID is identical to the BP (CBHE) notion of DTN node number used in ION.</p> <p>CFDP entity and transaction numbers may be up to 64 bits in length. For portability to 32-bit machines, these numbers are stored in the CFDP state machine as structures of type <code>CfdpNumber</code>.</p> <p>To simplify the interface between CFDP and the user application without risking storage leaks, the CFDP-ION API uses <code>MetadataList</code> objects. A MetadataList is a specially formatted SDR list of user messages, filestore requests, or filestore responses. During the time that a MetadataList is pending processing via the CFDP APIs, but is not yet (or is no longer) reachable from any FDU object, a pointer to the list is appended to one of the lists of MetadataList objects in the CFDP non-volatile database. This assures that any unplanned termination of the CFDP daemons won't leave any SDR lists unreachable - and therefore un-recyclable - due to the absence of references to those lists. Restarting CFDP will automatically purge any unused MetadataLists from the CFDP database. The \"user data\" variable of the MetadataList itself is used to implement this feature: while the list is reachable only from the database root, its user data variable points to the database root list from which it is referenced. In contrast, the list is attached to a File Delivery Unit; its user data is NULL.</p> <p>CFDP transmits the data in a source file in fixed-sized segments by default. The user application can override this behavior at the time transmission of a file is requested by supplying a file reader callback function that reads the file - one byte at a time - until it detects the end of a \"record\" that has application significance. Each time CFDP calls the reader function, the function must return the length of one such record (not greater than 65535).</p> <p>When CFDP is used to transmit a file, a 32-bit checksum must be provided in the \"EOF\" PDU to enable the receiver of the file to ensure that it was not corrupted in transit. When supplied with an application-specific file reader function, it updates the computed checksum as it reads each file byte; a CFDP library function is provided. Two types of file checksums are supported: a simple modular checksum or a 32-bit CRC. The checksum type must be passed through to the CFDP checksum computation function, so it must be provided by (and thus to) the file reader function.</p> <p>The user application may provide per-segment metadata. To enable this, upon formation of each file data segment, CFDP will invoke the user-provided per-segment metadata composition callback function (if any), a function conforming to the CfdpMetadataFn type definition. The callback will be passed the offset of the segment within the file, the segment's offset within the current record (as applicable), the length of the segment, an open file descriptor for the source file (in case the data must be read to construct the metadata), and a 63-byte buffer in which to place the new metadata. The callback function must return the metadata length to attach to the file data segment PDU (may be zero) or -1 in case of a general system failure.</p> <p>The return value for each CFDP \"request\" function (put, cancel, suspend, resume, report) is a reference number that enables \"events\" obtained by calling cfdp_get_event() to be matched to the requests that caused them. Events with a reference number set to zero were caused by autonomous CFDP activity, e.g., the reception of a file data segment.</p> <pre><code>#include \"cfdp.h\"\n\ntypedef enum\n{\n    CksumTypeUnknown = -1,\n    ModularChecksum = 0,\n    CRC32CChecksum = 2,\n    NullChecksum = 15\n} CfdpCksumType;\n\ntypedef int (*CfdpReaderFn)(int fd, unsigned int *checksum, CfdpCksumType ckType);\n\ntypedef int (*CfdpMetadataFn)(uvast fileOffset, unsigned int recordOffset, unsigned int length, int sourceFileFD, char *buffer);\n\ntypedef enum\n{\n    CfdpCreateFile = 0,\n    CfdpDeleteFile,\n    CfdpRenameFile,\n    CfdpAppendFile,\n    CfdpReplaceFile,\n    CfdpCreateDirectory,\n    CfdpRemoveDirectory,\n    CfdpDenyFile,\n    CfdpDenyDirectory\n} CfdpAction;\n\ntypedef enum\n{\n    CfdpNoEvent = 0,\n    CfdpTransactionInd,\n    CfdpEofSentInd,\n    CfdpTransactionFinishedInd,\n    CfdpMetadataRecvInd,\n    CfdpFileSegmentRecvInd,\n    CfdpEofRecvInd,\n    CfdpSuspendedInd,\n    CfdpResumedInd,\n    CfdpReportInd,\n    CfdpFaultInd,\n    CfdpAbandonedInd\n} CfdpEventType;\n\ntypedef struct\n{\n    char            *sourceFileName;\n    char            *destFileName;\n    MetadataList    messagesToUser;\n    MetadataList    filestoreRequests;\n    CfdpHandler     *faultHandlers;\n    int             unacknowledged;\n    unsigned int    flowLabelLength;\n    unsigned char   *flowLabel;\n    int             recordBoundsRespected;\n    int             closureRequested;\n} CfdpProxyTask;\n\ntypedef struct\n{\n    char            *directoryName;\n    char            *destFileName;\n} CfdpDirListTask;\n</code></pre>"},{"location":"ION-Application-Service-Interface/#cfdp_attach","title":"cfdp_attach","text":"<pre><code>int cfdp_attach()\n</code></pre> <p>Attaches the application to CFDP functionality on the local computer. </p> <p>Return Value</p> <ul> <li>0: on success</li> <li>-1: on any error</li> </ul>"},{"location":"ION-Application-Service-Interface/#cfdp_entity_is_started","title":"cfdp_entity_is_started","text":"<pre><code>int cfdp_entity_is_started()\n</code></pre> <p>Return Value * 1: if the local CFDP entity has been started and not yet stopped * 0: otherwise</p>"},{"location":"ION-Application-Service-Interface/#cfdp_detach","title":"cfdp_detach","text":"<pre><code>void cfdp_detach()\n</code></pre> <p>Terminates all access to CFDP functionality on the local computer.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_compress_number","title":"cfdp_compress_number","text":"<pre><code>void cfdp_compress_number(CfdpNumber *toNbr, uvast from)\n</code></pre> <p>Converts an unsigned vast number into a CfdpNumber structure, e.g., for use when invoking the cfdp_put() function.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_decompress_number","title":"cfdp_decompress_number","text":"<pre><code>void cfdp_decompress_number(uvast toNbr, CfdpNumber *from)\n</code></pre> <p>Converts a numeric value in a CfdpNumber structure to an unsigned vast integer.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_update_checksum","title":"cfdp_update_checksum","text":"<pre><code>void cfdp_update_checksum(unsigned char octet, uvast *offset, unsigned int *checksum, CfdpCksumType ckType)\n</code></pre> <p>For use by an application-specific file reader callback function, which must pass to cfdp_update_checksum() the value of each byte (octet) it reads. offset must be octet's displacement in bytes from the start of the file. The checksum pointer is provided to the reader function by CFDP.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_create_usrmsg_list","title":"cfdp_create_usrmsg_list","text":"<pre><code>MetadataList cfdp_create_usrmsg_list()\n</code></pre> <p>Creates a non-volatile linked list, suitable for containing messages-to-user that are to be presented to cfdp_put().</p>"},{"location":"ION-Application-Service-Interface/#cfdp_add_usrmsg","title":"cfdp_add_usrmsg","text":"<pre><code>int cfdp_add_usrmsg(MetadataList list, unsigned char *text, int length)\n</code></pre> <p>Appends the indicated message-to-user to list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_get_usrmsg","title":"cfdp_get_usrmsg","text":"<pre><code>int cfdp_get_usrmsg(MetadataList list, unsigned char *textBuf, int *length)\n</code></pre> <p>Removes from list the first of the remaining messages-to-user contained in the list and delivers its text and length. When the last message in the list is delivered, destroys the list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_destroy_usrmsg_list","title":"cfdp_destroy_usrmsg_list","text":"<pre><code>void cfdp_destroy_usrmsg_list(MetadataList *list)\n</code></pre> <p>Removes and destroys all messages-to-user in list and destroys the list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_create_fsreq_list","title":"cfdp_create_fsreq_list","text":"<pre><code>MetadataList cfdp_create_fsreq_list()\n</code></pre> <p>Creates a non-volatile linked list, suitable for containing filestore requests that are to be presented to cfdp_put().</p>"},{"location":"ION-Application-Service-Interface/#cfdp_add_fsreq","title":"cfdp_add_fsreq","text":"<pre><code>int cfdp_add_fsreq(MetadataList list, CfdpAction action, char *firstFileName, char *seconfdFIleName)\n</code></pre> <p>Appends the indicated filestore request to list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_get_fsreq","title":"cfdp_get_fsreq","text":"<pre><code>int cfdp_get_fsreq(MetadataList list, CfdpAction *action, char *firstFileNameBuf, char *secondFileNameBuf)\n</code></pre> <p>Removes from list the first of the remaining filestore requests contained in the list and delivers its action code and file names. When the last request in the list is delivered, destroys the list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_destroy_fsreq_list","title":"cfdp_destroy_fsreq_list","text":"<pre><code>void cfdp_destroy_fsreq_list(MetadataList *list)\n</code></pre> <p>Removes and destroys all filestore requests in list and destroys the list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_get_fsresp","title":"cfdp_get_fsresp","text":"<pre><code>int cfdp_get_fsresp(MetadataList list, CfdpAction *action, int *status, char *firstFileNameBuf, char *secondFileNameBuf, char *messageBuf)\n</code></pre> <p>Removes from list the first of the remaining filestore responses contained in the list and delivers its action code, status, file names, and message. When the last response in the list is delivered, it destroys the list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_destroy_fsresp_list","title":"cfdp_destroy_fsresp_list","text":"<pre><code>void cfdp_destroy_fsresp_list(MetadataList *list)\n</code></pre> <p>Removes and destroys all filestore responses in list and destroys the list.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_read_space_packets","title":"cfdp_read_space_packets","text":"<pre><code>int cfdp_read_space_packets(int fd, unsigned int *checksum)\n</code></pre> <p>This is a standard \"reader\" function that segments the source file on CCSDS space packet boundaries. Multiple small packets may be aggregated into a single file data segment.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_read_text_lines","title":"cfdp_read_text_lines","text":"<pre><code>int cfdp_read_text_lines(int fd, unsigned int *checksum)\n</code></pre> <p>This is a standard \"reader\" function that segments a source file of text lines on line boundaries.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_put","title":"cfdp_put","text":"<pre><code>int cfdp_put(CfdpNumber *destinationEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpMetadataFn metadataFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpTransactionId *transactionId)\n</code></pre> <p>Sends the file identified by <code>sourceFileName</code> to the CFDP entity identified by <code>destinationEntityNbr</code>. destinationFileName is used to indicate the name by which the file will be catalogued upon arrival at its final destination; if NULL, the destination file name defaults to sourceFileName. If sourceFileName is NULL, it is assumed that the application is requesting transmission of metadata only (as discussed below) and destinationFileName is ignored. Note that both sourceFileName and destinationFileName are interpreted as path names, i.e., directory paths may be indicated in either or both. The syntax of path names is opaque to CFDP; the syntax of sourceFileName must conform to the path naming syntax of the source entity's file system and the syntax of destinationFileName must conform to the path naming syntax of the destination entity's file system.</p> <p>The byte array identified by <code>utParms</code>, if non-NULL, is interpreted as transmission control information that is to be passed on to the UT layer. The nominal UT layer for ION's CFDP being Bundle Protocol, the utParms array is normally a pointer to a structure of type BpUtParms; see the bp man page for a discussion of the parameters in that structure.</p> <p><code>closureLatency</code> is the length of time following transmission of the EOF PDU within which a responding Transaction Finish PDU is expected. If no Finish PDU is requested, this parameter value should be zero.</p> <p><code>messagesToUser</code> and <code>filestoreRequests</code>, where non-zero, must be the addresses of non-volatile linked lists (that is, linked lists in ION's SDR database) of <code>CfdpMsgToUser</code> and <code>CfdpFilestoreRequest</code> objects identifying metadata that are intended to accompany the transmitted file. Note that this metadata may accompany a file of zero length (as when sourceFileName is NULL as noted above) -- a transmission of metadata only.</p> <p>Return Value</p> <ul> <li>request number of this \"put\" request: On success, the function populates <code>*transactionID</code> with the source entity ID and the transaction number assigned to this transmission and returns the request number identifying this \"put\" request. The transaction ID may be used to suspend, resume, cancel, or request a report on the progress of this transmission. </li> <li>-1: on any error</li> </ul>"},{"location":"ION-Application-Service-Interface/#cfdp_cancel","title":"cfdp_cancel","text":"<pre><code>int cfdp_cancel(CfdpTransactionId *transactionId)\n</code></pre> <p>Cancels transmission or reception of the indicated transaction. Note that, since the ION implementation of CFDP is Unacknowledged, cancellation of a file transmission may have little effect. </p> <p>Return Value * request number: on success * -1: on any error</p>"},{"location":"ION-Application-Service-Interface/#cfdp_suspend","title":"cfdp_suspend","text":"<pre><code>int cfdp_suspend(CfdpTransactionId *transactionId)\n</code></pre> <p>Suspends transmission of the indicated transaction. Note that, since the ION implementation of CFDP is Unacknowledged, suspension of a file transmission may have little effect. </p> <p>Return Value * request number: on success * -1: on any error</p>"},{"location":"ION-Application-Service-Interface/#cfdp_resume","title":"cfdp_resume","text":"<pre><code>int cfdp_resume(CfdpTransactionId *transactionId)\n</code></pre> <p>Resumes transmission of the indicated transaction. Note that, since the ION implementation of CFDP is Unacknowledged, resumption of a file transmission may have little effect. </p> <p>Return Value * request number: on success * -1: on any error</p>"},{"location":"ION-Application-Service-Interface/#cfdp_report","title":"cfdp_report","text":"<pre><code>int cfdp_report(CfdpTransactionId *transactionId)\n</code></pre> <p>Requests issuance of a report on the transmission or reception progress of the indicated transaction. The report takes the form of a character string that is returned in a CfdpEvent structure; use cfdp_get_event() to receive the event (which may be matched to the request by request number). </p> <p>Return Value * request number: on success * 0: if the transaction ID is unknown * -1: on any error</p>"},{"location":"ION-Application-Service-Interface/#cfdp_get_event","title":"cfdp_get_event","text":"<pre><code>int cfdp_get_event(CfdpEventType *type, time_t *time, int *reqNbr, CfdpTransactionId *transactionId, char *sourceFileNameBuf, char *destFileNameBuf, uvast *fileSize, MetadataList *messagesToUser, uvast *offset, unsigned int *length, CfdpCondition *condition, uvast *progress, CfdpFileStatus *fileStatus, CfdpDeliveryCode *deliveryCode, CfdpTransactionId *originatingTransactionId, char *statusReportBuf, MetadataList *filestoreResponses);\n</code></pre> <p>Populates return value fields with data from the oldest CFDP event not yet delivered to the application. cfdp_get_event() blocks indefinitely until a CFDP processing event is delivered or the function is interrupted by an invocation of cfdp_interrupt().</p> <p>Return Value * 0: on success -OR- on application error, returns zero but sets errno to EINVAL.  * -1: on system failure</p>"},{"location":"ION-Application-Service-Interface/#cfdp_interrupt","title":"cfdp_interrupt","text":"<pre><code>void cfdp_interrupt()\n</code></pre> <p>Interrupts an cfdp_get_event() invocation. This function is designed to be called from a signal handler.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_rput","title":"cfdp_rput","text":"<pre><code>int cfdp_rput(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpNumber *beneficiaryEntityNbr, CfdpProxyTask *proxyTask, CfdpTransactionId *transactionId)\n</code></pre> <p>Sends to the indicated respondent entity a \"proxy\" request to perform a file transmission. The transmission is to be subject to the configuration values in proxyTask and the destination of the file is to be the entity identified by <code>beneficiaryEntityNbr</code>.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_rput_cancel","title":"cfdp_rput_cancel","text":"<pre><code>int cfdp_rput_cancel(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpTransactionId *rputTransactionId, CfdpTransactionId *transactionId)\n</code></pre> <p>Sends to the indicated respondent entity a request to cancel a prior \"proxy\" file transmission request as identified by rputTransactionId, which is the value of transactionId that was returned by that earlier proxy transmission request.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_get","title":"cfdp_get","text":"<pre><code>int cfdp_get(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpProxyTask *proxyTask, CfdpTransactionId *transactionId)\n</code></pre> <p>Same as cfdp_rput except that beneficiaryEntityNbr is omitted; the local entity is the implicit beneficiary of the request.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_rls","title":"cfdp_rls","text":"<pre><code>int cfdp_rls(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpDirListTask *dirListTask, CfdpTransactionId *transactionId)\n</code></pre> <p>Sends to the indicated respondent entity a request to prepare a directory listing, save that listing in a file, and send it to the local entity. The request is subject to the configuration values in <code>dirListTask</code>.</p>"},{"location":"ION-Application-Service-Interface/#cfdp_preview","title":"cfdp_preview","text":"<pre><code>int cfdp_preview(CfdpTransactionId *transactionId, uvast offset, unsigned int length, char *buffer);\n</code></pre> <p>This function enables the application to get an advanced look at the content of a file that CFDP has not yet fully received. Reads length bytes starting at offset bytes from the start of the file that is the destination file of the transaction identified by <code>transactionID</code>, into <code>buffer</code>. </p> <p>Return Value * number of bytes read: on success * 0: on user error (transaction is nonexistent or is outbound, or offset is beyond the end of file)  * -1: on system failure </p>"},{"location":"ION-Application-Service-Interface/#cfdp_map","title":"cfdp_map","text":"<pre><code>int cfdp_map(CfdpTransactionId *transactionId, unsigned int *extentCount, CfdpExtent *extentsArray);\n</code></pre> <p>This function enables the application to report on the portions of a partially-received file that have been received and written. Lists the received continuous data extents in the destination file of the transaction identified by <code>transactionID</code>. The extents (offset and length) are returned in the elements of <code>extentsArray</code>; the number of extents returned in the array is the total number of continuous extents received so far, or <code>extentCount</code>, whichever is less. </p> <p>Return Value * 0: on success, the total number of extents received so far is reported through <code>extentCount</code> * -1: on system failure, returns -1</p>"},{"location":"ION-Application-Service-Interface/#cfdp-shell-test-program-cfdptest","title":"CFDP Shell Test Program: <code>cfdptest</code>","text":"<p>ION provides application CFDP test program called <code>cfdptest</code>, which installed as part of regular ION build/install process and can be invoked from terminal this way:</p> <pre><code>cfdptest\n</code></pre> <p>The shell program present a ':' prompt for interactive mode commanding. You can type 'h' to see a list of available commands.</p> <p>One can also feed a sequence of commands to <code>cfdptest</code> non-interactively such that you will not see the stdout of the program. This is useful for running automated tests.</p> <pre><code>cfdptest [file_containing_cfdptest_commands]\n</code></pre> <p>A third way to use cfdptest is to feed command scripts but allows the interactive responses to be displayed in stdout:</p> <pre><code>cfdptest &lt; [file_containing_cfdptest_commands]\n</code></pre> <p>The <code>cfdptest.c</code> source code is also provided as a code examples on how write applications using the CFDP APIs. The cfdptest command set can be found in the manual pages here.</p>"},{"location":"ION-Application-Service-Interface/#cfdp-application-code-example","title":"CFDP Application Code Example","text":"<p>this section is work-in-progress</p>"},{"location":"ION-Application-Service-Interface/#bundle-streaming-service-bss","title":"Bundle Streaming Service (BSS)","text":"<p>The BSS library supports the streaming of data over delay-tolerant networking (DTN) bundles. The intent of the library is to enable applications that pass streaming data received in transmission time order (i.e., without time regressions) to an application-specific \"display\" function -- notionally for immediate real-time display -- but to store all received data (including out-of-order data) in a private database for playback under user control. The reception and real-time display of in-order data is performed by a background thread, leaving the application's main (foreground) thread free to respond to user commands controlling playback or other application-specific functions.</p> <p>The application-specific \"display\" function invoked by the background thread must conform to the RTBHandler type definition. It must return 0 on success, -1 on any error that should terminate the background thread. Only on return from this function will the background thread proceed to acquire the next BSS payload.</p> <p>All data acquired by the BSS background thread is written to a BSS database comprising three files: table, list, and data. The name of the database is the root name that is common to the three files, e.g., db3.tbl, db3.lst, db3.dat would be the three files making up the db3 BSS database. All three files of the selected BSS database must reside in the same directory of the file system.</p> <p>Several replay navigation functions in the BSS library require that the application provide a navigation state structure of type bssNav as defined in the bss.h header file. The application is not reponsible for populating this structure; it's strictly for the private use of the BSS library.</p>"},{"location":"ION-Application-Service-Interface/#bundle-streaming-service-bss-bundle-streaming-service-protocol-bssp-cla","title":"Bundle Streaming Service (BSS) &amp; Bundle Streaming Service Protocol (BSSP CLA)","text":"<p>The Bundle Streaming Service (BSS) and the Bundle Streaming Service Protocol (BSSP) CLA are independent modules.</p> <p>The BSSP CLA is designed to emulate a connection between two DTN neighboring nodes characterized by two delivery mechanisms: (a) a minimal delay, unreliable channel (physical or logical), and (b) a potentially delayed, but reliable channel. The minimal delay channel is emulated by transpot UDP (with a timer mechanism added) and the reliable channel is emulated via TCP transport. </p> <p>A DTN user mission may decide to use a single CCSDS AOS or TM downlink with LTP CLA running on top as its reliability mechanism. In that case, it can directly use the LTP CLA in ION and interface it with the CCSDS framing protocol which could be implemented by the mission's avionic system or the radio. </p> <p>However, it is also possible that a mission may utilize different types of transports, for example, using multiple downlinks via  S, X, Ka-band or optical, each with different reliability mechanism (or not). Alternatively, a flight system may also use commercial communications services with differentiated delays and levels of reliability. In such case, BSSP can be used to approximate such configuration in a lab environment for prototyping and testing the impact on streaming data delivery, until the actual CLAs are implemented and tested.</p> <p>The Bundle Streaming Service, on the other hand, is an application-level service that can be used with any underlying CLAs to handle both realtime and delayed, in-order playback of streaming data including video, audio, and telemetry. When the user scenario is appropriate, BSS can certainly be used over BSSP CLA, but that is not a requirement. </p>"},{"location":"ION-Application-Service-Interface/#bss-apis","title":"BSS APIs","text":"<p>The following section describes the BSS library APIs.</p>"},{"location":"ION-Application-Service-Interface/#bssopen","title":"bssOpen","text":"<p><pre><code>int bssOpen(char *bssName, char *path, char *eid)\n</code></pre> Opens access to a BSS database, to enable data playback. bssName identifies the specific BSS database that is to be opened. path identifies the directory in which the database resides. eid is ignored. On any failure, returns -1. On success, returns zero.</p>"},{"location":"ION-Application-Service-Interface/#bssstart","title":"bssStart","text":"<pre><code>int bssStart(char *bssName, char *path, char *eid, char *buffer, int bufLen, RTBHandler handler)\n</code></pre> <p>Starts a BSS data acquisition background thread. bssName identifies the BSS database into which data will be acquired. path identifies the directory in which that database resides. eid is used to open the BP endpoint at which the delivered BSS bundle payload contents will be acquired. buffer identifies a data acquisition buffer, which must be provided by the application, and bufLen indicates the length of that buffer; received bundle payloads in excess of this length will be discarded.</p> <p>handler identifies the display function to which each in-order bundle payload will be passed. The time and count parameters passed to this function identify the received bundle, indicating the bundle's creation timestamp time (in seconds) and counter value. The buffer and bufLength parameters indicate the location into which the bundle's payload was acquired and the length of the acquired payload. handler must return -1 on any unrecoverable system error, 0 otherwise. A return value of -1 from handler will terminate the BSS data acquisition background thread.</p> <p>On any failure, returns -1. On success, returns zero.</p>"},{"location":"ION-Application-Service-Interface/#bssrun","title":"bssRun","text":"<pre><code>int bssRun(char *bssName, char *path, char *eid, char *buffer, int bufLen, RTBHandler handler)\n</code></pre> <p>A convenience function that performs both bssOpen() and bssStart(). On any failure, returns -1. On success, returns zero.</p>"},{"location":"ION-Application-Service-Interface/#bssclose","title":"bssClose","text":"<p><pre><code>void bssClose()\n</code></pre> Terminates data playback access to the most recently opened BSS database.</p>"},{"location":"ION-Application-Service-Interface/#bssstop","title":"bssStop","text":"<pre><code>void bssStop()\n</code></pre> <p>Terminates the most recently initiated BSS data acquisition background thread.</p>"},{"location":"ION-Application-Service-Interface/#bssexit","title":"bssExit","text":"<pre><code>void bssExit()\n</code></pre> <p>A convenience function that performs both bssClose() and bssStop().</p>"},{"location":"ION-Application-Service-Interface/#bssread","title":"bssRead","text":"<pre><code>long bssRead(bssNav nav, char *data, int dataLen)\n</code></pre> <p>Copies the data at the current playback position in the database, as indicated by nav, into data; if the length of the data is in excess of dataLen then an error condition is asserted (i.e., -1 is returned). Note that bssRead() cannot be successfully called until nav has been populated, nominally by a preceding call to bssSeek(), bssNext(), or bssPrev(). Returns the length of data read, or -1 on any error.</p>"},{"location":"ION-Application-Service-Interface/#bssseek","title":"bssSeek","text":"<pre><code>long bssSeek(bssNav *nav, time_t time, time_t *curTime, unsigned long *count)\n</code></pre> <p>Sets the current playback position in the database, in nav, to the data received in the bundle with the earliest creation time that was greater than or equal to time. Populates nav and also returns the creation time and bundle ID count of that bundle in curTime and count. Returns the length of data at this location, or -1 on any error.</p>"},{"location":"ION-Application-Service-Interface/#bssseek_read","title":"bssSeek_read","text":"<pre><code>long bssSeek_read(bssNav *nav, time_t time, time_t *curTime, unsigned long *count, char *data, int dataLen)\n</code></pre> <p>A convenience function that performs bssSeek() followed by an immediate bssRead() to return the data at the new playback position. Returns the length of data read, or -1 on any error.</p>"},{"location":"ION-Application-Service-Interface/#bssnext","title":"bssNext","text":"<pre><code>long bssNext(bssNav *nav, time_t *curTime, unsigned long *count)\n</code></pre> <p>Sets the playback position in the database, in nav, to the data received in the bundle with the earliest creation time and ID count greater than that of the bundle at the current playback position. Populates nav and also returns the creation time and bundle ID count of that bundle in curTime and count. Returns the length of data at this location (if any), -2 on reaching end of list, or -1 on any error.</p>"},{"location":"ION-Application-Service-Interface/#bssnext_read","title":"bssNext_read","text":"<pre><code>long bssNext_read(bssNav *nav, time_t *curTime, unsigned long *count, char *data, int dataLen)\n</code></pre> <p>A convenience function that performs bssNext() followed by an immediate bssRead() to return the data at the new playback position. Returns the length of data read, -2 on reaching end of list, or -1 on any error.</p>"},{"location":"ION-Application-Service-Interface/#bssprev","title":"bssPrev","text":"<pre><code>long bssPrev(bssNav *nav, time_t *curTime, unsigned long *count)\n</code></pre> <p>Sets the playback position in the database, in nav, to the data received in the bundle with the latest creation time and ID count earlier than that of the bundle at the current playback position. Populates nav and also returns the creation time and bundle ID count of that bundle in curTime and count. Returns the length of data at this location (if any), -2 on reaching end of list, or -1 on any error.</p>"},{"location":"ION-Application-Service-Interface/#bssprev_read","title":"bssPrev_read","text":"<pre><code>long bssPrev_read(bssNav *nav, time_t *curTime, unsigned long *count, char *data, int dataLen)\n</code></pre> <p>A convenience function that performs bssPrev() followed by an immediate bssRead() to return the data at the new playback position. Returns the length of data read, -2 on reaching end of list, or -1 on any error</p>"},{"location":"ION-Application-Service-Interface/#asynchronous-messaging-service-ams-apis","title":"Asynchronous Messaging Service (AMS) APIs","text":"<p>This section is under construction.</p>"},{"location":"ION-Application-Service-Interface/#delay-tolerant-payload-conditioning-dtpc-communications-library","title":"Delay-Tolerant Payload Conditioning (DTPC) communications library","text":""},{"location":"ION-Application-Service-Interface/#description","title":"Description","text":"<p>The dtpc library provides functions enabling application software to use Delay-Tolerant Payload Conditioning (DTPC) when exchanging information over a delay-tolerant network.  DTPC is an application service protocol, running in a layer immediately above Bundle Protocol, that offers delay-tolerant support for several end-to-end services to applications that may require them.  These services include delivery of application data items in transmission (rather than reception) order; detection of reception gaps in the sequence of transmitted application data items, with end-to-end negative acknowledgment of the missing data; end-to-end positive acknowledgment of successfully received data; end-to-end retransmission of missing data, driven either by negative acknowledgment or timer expiration; suppression of duplicate application data items; aggregation of small application data items into large bundle payloads, to reduce bundle protocol overhead; and application-controlled elision of redundant data items in aggregated payloads, to improve link utiliization.</p>"},{"location":"ION-Application-Service-Interface/#dtpc-apis","title":"DTPC APIs","text":"<p><pre><code>int dptc_attach( )\n</code></pre> Attaches the application to DTPC functionality on the local computer.  Returns 0 on success, -1 on any error.</p> <pre><code>void dptc_detach( )\n</code></pre> <p>Terminates all access to DTPC functionality on the local computer.</p> <p><pre><code>int dtpc_entity_is_started( )\n</code></pre> Returns 1 if the local DTPC entity has been started and not yet stopped, 0 otherwise.</p> <pre><code>int dtpc_open(unsigned int topicID, DtpcElisionFn elisionFn, DtpcSAP *dtpcsapPtr)\n</code></pre> <p>Establishes the application as the sole authorized client for posting and receiving application data items on topic topicID within the local BP node.  On success, the service access point for posting and receiving such data items is placed in *dtpcsapPtr, the elision callback function elisionFn (if not NULL) is associated with this topic, and 0 is returned. Returns -1 on any error.</p> <p><pre><code>int dtpc_send(unsigned int profileID, DtpcSAP sap, char *destEid, unsigned int maxRtx, unsigned int aggrSizeLimit, unsigned int aggrTimeLimit, int lifespan, BpAncillaryData *ancillaryData, unsigned char srrFlags, BpCustodySwitch custodySwitch, char *reportToEid, int classOfService, Object item, unsigned int length)\n</code></pre> Inserts an application data item into an outbound DTPC application data unit destined for destEid.</p> <p>Transmission of that outbound ADU will be subject to the profile identified by profileID, as asserted by dtpcadmin(1), if profileID is non-zero.  In that case, maxRtx, aggrSizeLimit, aggrTimeLimit, lifespan, ancillaryData, srrFlags, custodySwitch, reportToEid, and classOfService are ignored.</p> <p>If profileID is zero then the profile asserted by dtpcadmin(1) that matches maxRtx, aggrSizeLimit, aggrTimeLimit, lifespan, ancillaryData, srrFlags, custodySwitch, reportToEid, and classOfService will govern transmission of the ADU, unless no such profile has been asserted, in which case dtpc_send() returns 0 indicating user error.</p> <p>maxRtx is the maximum number of times any single DTPC ADU transmitted subject to the indicated profile may be retransmitted by the DTPC entity.  If maxRtx is zero, then the DTPC transport service features (in-order delivery, end-to-end acknowledgment, etc.) are disabled for this profile.</p> <p>aggrSizeLimit is the size threshold for concluding aggregation of an outbound ADU and requesting transmission of that ADU.  If aggrSizeLimit is zero, then the DTPC transmission optimization features (aggregation and elision) are disabled for this profile.</p> <p>aggrTimeLimit is the time threshold for concluding aggregation of an outbound ADU and requesting transmission of that ADU.  If aggrTimeLimit is zero, then the DTPC transmission optimization features (aggregation and elision) are disabled for this profile.</p> <p>lifespan, ancillaryData, srrFlags, custodySwitch, reportToEid, and classOfService are as defined for bp_send (see bp(3)).</p> <p>item must be an object allocated within ION's SDR \"heap\", and length must be the length of that object.  The item will be inserted into the outbound ADU's list of data items posted for the topic associated with sap, and the elision callback function declared for sap (if any, and if the applicable profile does not disable transmission optimization features) will be invoked immediately after insertion of the application data item but before DTPC makes any decision on whether or not to initiate transmission of the outbound ADU.</p> <p>The function returns 1 on success, 0 on any user application error, -1 on any system error.</p> <p><pre><code>int dtpc_receive(DtpcSAP sap, DtpcDelivery *dlvBuffer, int timeoutSeconds)\n</code></pre> Receives a single DTPC application data item, or reports on some failure of DTPC reception activity.</p> <p>The \"result\" field of the dlvBuffer structure will be used to indicate the outcome of the data reception activity.</p> <p>If at least one application data item on the topic associated with sap has not yet been delivered to the SAP, then the payload of the oldest such item will be returned in dlvBuffer-__item_ and dlvBuffer-__result_ will be set to PayloadPresent.  If there is no such item, dtpc_receive() blocks for up to timeoutSeconds while waiting for one to arrive.</p> <p>If timeoutSeconds is DTPC_POLL (i.e., zero) and no application data item is awaiting delivery, or if timeoutSeconds is greater than zero but no item arrives before timeoutSeconds have elapsed, then dlvBuffer-__result_ will be set to ReceptionTimedOut.  If timeoutSeconds is DTPC_BLOCKING (i.e., -1) then bp_receive() blocks until either an item arrives or the function is interrupted by an invocation of dtpc_interrupt().</p> <p>dlvBuffer-__result_ will be set to ReceptionInterrupted in the event that the calling process received and handled some signal other than SIGALRM while waiting for a bundle.</p> <p>dlvBuffer-__result_ will be set to DtpcServiceStopped in the event that DTPC service has been terminated on the local node.</p> <p>The application data item delivered in the DTPC delivery structure, if any, will be an object allocated within ION's SDR \"heap\"; the length of that object will likewise be provided in the DtpcDelivery structure.</p> <p>Be sure to call dtpc_release_delivery() after every successful invocation of dtpc_receive().</p> <p>The function returns 0 on success, -1 on any error.</p> <p><pre><code>void dtpc_interrupt(DtpcSAP sap)\n</code></pre> Interrupts a dtpc_receive() invocation that is currently blocked.  This function is designed to be called from a signal handler; for this purpose, sap may need to be obtained from a static variable.</p> <p><pre><code>void dtpc_release_delivery(DtpcDelivery *dlvBuffer)\n</code></pre> Releases resources allocated to the indicated DTPC delivery.</p> <p><pre><code>void dtpc_close(DtpcSAP sap)\n</code></pre> Removes the application as the sole authorized client for posting and receiving application data items on the topic indicated in sap within the local BP node.  The application relinquishes its ability to send and receive application data items on the indicated topic.</p>"},{"location":"ION-Coding-Guide/","title":"ION Coding Guide","text":"<ul> <li>ION Coding Guide</li> <li>Preface</li> <li>Application Behavior</li> <li>Function Design Guidelines</li> <li>Error Checking</li> <li>Error and Status Reporting</li> <li>\u2018C\u2019 Coding Style<ul> <li>Naming Conventions</li> <li>Indentation, Bracketing, Whitespace</li> <li>Comment Formatting</li> <li>Miscellaneous Rules</li> </ul> </li> </ul>"},{"location":"ION-Coding-Guide/#preface","title":"Preface","text":"<p>The following coding guidelines apply to all software delivered as part of the Interplanetary Overlay Network (ION) distribution, except:</p> <ul> <li>Where the delivered software is legacy code rather than code developed specifically for ION.</li> <li>Where conformance to some other standard is clearly appropriate. For example, when using a framework library like Motif it may be appropriate to modify these guidelines so as to be consistent with the practices of the framework. </li> <li>Where, in the judgment of the programmer, deviating from the guidelines in a particular case results in manifestly clearer code. This is not a license to ignore the guidelines; it is intended to cover special circumstances.  Adherence to these guidelines is the responsibility of the individual programmer but will be considered during peer reviews of new ION code.</li> </ul>"},{"location":"ION-Coding-Guide/#application-behavior","title":"Application Behavior","text":"<p>Every process should return an exit code on termination.  * On normal termination, the exit code should be 0.  * On abnormal or error termination, the exit code should be a non-zero number in the range 1-255.      * In this case the code should be 1 unless specific codes are used to distinguish between different kinds of errors.</p>"},{"location":"ION-Coding-Guide/#function-design-guidelines","title":"Function Design Guidelines","text":"<p>All file I/O should be performed using POSIX functions rather than the buffered I/O functions <code>fopen</code>, <code>fread</code>, <code>fseek</code>, etc.  This is because buffered I/O entails the dynamic allocation of system memory, which some missions may prohibit in flight software.  </p> <p>The iputs function provided in <code>platform.c</code> should be used in place of <code>fputs</code>, and the <code>igets</code> function should be used in place of <code>fgets</code>.  Rather than <code>fscanf</code>, use <code>igets</code> and <code>sscanf</code>; rather than <code>fprintf</code>, use <code>isprintf</code> and <code>iputs</code>.</p> <p>All varargs-based string composition should be performed using <code>isprintf</code> rather than <code>sprintf</code>, to minimize the chance of overrunning string composition buffers.  (<code>isprintf</code> is similar to <code>snprintf</code>.  Since VxWorks 5.4 does not support <code>snprintf</code>, <code>isnprintf</code> is included in <code>platform.c</code>.)  </p> <p>Similarly, all string copying should be performed using <code>istrcpy</code> rather than <code>strcpy</code>, <code>strncpy</code>, and <code>strcat</code>.</p> <p>The <code>isignal</code> function should be used instead of <code>signal</code>; it ensures that reception of a signal will always interrupt system calls in SVR4 fashion even when running on a FreeBSD platform. </p> <p>The <code>iblock</code> function provides a simple, portable means of preventing reception of the indicated signal by the calling thread.</p> <p>Data objects larger than 1024 bytes should not be declared in stack space.  This is to    * Minimize complaints by Coverity, and    * Minimize the chance of overrunning allocated stack space when running on a VxWorks platform.</p> <p>Static variables that must be made globally accessible should be declared within external functions, rather than declared as external variables.  This is per the JPL C Coding Standard, but it also has the useful property of providing an easy way to track all access to a global static variable in <code>gdb</code>: you just set a breakpoint at the start of the function in which the variable is declared.</p>"},{"location":"ION-Coding-Guide/#error-checking","title":"Error Checking","text":"<p>In the implementation of any ION library function or any ION task\u2019s top-level driver function, any condition that prevents the function from continuing execution toward producing the effect it is designed to produce is considered an \u201cerror\u201d.</p> <p>Detection of an error should result in the printing of an error message and, normally, the immediate return of whatever return value is used to indicate the failure of the function in which the error was detected. </p> <p>By convention this value is usually -1, but both zero and NULL are appropriate failure indications under some circumstances such as object  creation.</p> <p>The <code>CHKERR</code>, <code>CHKZERO</code>, <code>CHKNULL</code>, and <code>CHKVOID</code> macros are used to implement this behavior in a standard and lexically terse manner. Use of these macros offers an additional feature: for debugging purposes, they can easily be configured to call <code>sm_Abort()</code> to terminate immediately with a core dump instead of returning a error indication.  This option is enabled by setting the compiler parameter <code>CORE_FILE_NEEDED</code> to 1 at compilation time.</p> <p>In the absence of any error, the function returns a value that indicates nominal completion. By convention this value is usually zero, but under some circumstances other values (such as pointers or addresses) are appropriate indications of nominal completion. Any additional information produced by the function, such as an indication of \u201csuccess\u201d, is usually returned as the value of a reference argument.  </p> <p>However, database management functions and the SDR hash table management functions deviate from this rule: most return 0 to indicate nominal completion but functional failure (e.g., duplicate key or object not found) and return 1 to indicate functional success.</p> <p>Whenever returning a value that indicates an error: * If the failure is due to the failure of a system call or some other non-ION function, assu=me that errno has already been set by the function at the lowest layer of the call stack; use <code>putSysErrmsg</code> (or <code>postSysErrmsg</code> if in a hurry) as described below. * Otherwise \u2013 i.e., the failure is due to a condition that was detected within ION \u2013use <code>putErrmsg</code> (or <code>postErrmg</code> if pressed for time) as described below; this will aid in tracing the failure through the function stack in which the failure was detected.</p> <p>When a failure in a called function is reported to \u201cdriver\u201d code in an application program, before continuing or exiting use <code>writeErrmsgMemos()</code> to empty the message pool and print a simple stack trace identifying the failure.</p> <p>Calling code may choose to ignore the error indication returned by a function (e.g., when an error returned by an sdr function is subsumed by a future check of the error code returned by <code>sdr_end_xn</code>).  To do so without incurring the wrath of a static analysis tool, pass the entire function call as the sole argument to the <code>oK</code> macro; the macro operates on the return code, casting it to <code>(void)</code> and thus placating static analysis.</p>"},{"location":"ION-Coding-Guide/#error-and-status-reporting","title":"Error and Status Reporting","text":"<p>To write a simple status message, use <code>writeMemo</code>.  To write a status message and annotate that message with some other context-dependent string, use <code>writeMemoNote</code>.  (The <code>itoa</code> and <code>utoa</code> functions may be used to express signed and unsigned integer values, respectively, as strings for this purpose.)  Note that adhering to ION\u2019s conventions for tagging status messages will simplify any automated status message processing that the messages might be delivered to, i.e., the first four characters of the status message should be as follows:</p> <ul> <li>[i] \u2013 informational</li> <li>[?] \u2013 warning</li> <li>[s] \u2013 reserved for bundle status reports</li> <li>[x] \u2013 reserved for communication statistics</li> </ul> <p>To write a simple diagnostic message, use <code>putErrmsg</code>; the source file name and line number will automatically be inserted into the message text, and a context-dependent string may be provided.  (Again the <code>itoa</code> and <code>utoa</code> functions may be helpful here.)  The diagnostic message should normally begin with a capital letter and end with a period.</p> <p>To write a diagnostic message in response to the failure of a system call or some other non-ION function that sets errno, use <code>putSysErrmsg</code> instead.  In this case, the diagnostic message should normally begin with a capital letter and not end with a period.</p>"},{"location":"ION-Coding-Guide/#c-coding-style","title":"\u2018C\u2019 Coding Style","text":"<p>This page contains guidelines for programming in the C language.</p>"},{"location":"ION-Coding-Guide/#naming-conventions","title":"Naming Conventions","text":"<p>Names of global variables, local variables, structure fields, and function arguments are in mixed upper and lower case, without embedded underscores, and beginning with a lowercase letter.  <pre><code>int numItems;\n</code></pre> Private function names are in mixed upper and lower case, without embedded underscores, and beginning with a lowercase letter. </p> <p><pre><code>void    computeSomething(int firstArg, int secondArg);\n</code></pre> Public function names are in lower case with tokens separated by underscores.  The first token of each public function name is the name of the package whose \u201cinclude\u201d directory contains the .h file in which the function prototype is defined. <pre><code>    extern int  ltp_open(unsigned long clientId);\n</code></pre> Macro names are written in upper case with tokens separated by underscores.  <pre><code>#define SYMBOLIC_CONSTANT 5\n</code></pre></p> <p>Unions are not used.</p> <p>Typedef names are in mixed upper and lower case, with the first token capitalized.  Type names are never the same as the structure or enum tags for the structures and enums that they name.  <pre><code>typedef struct gloplist_str\n{\nint thing1;\nint thing2;\n} GlopList;\n</code></pre></p>"},{"location":"ION-Coding-Guide/#indentation-bracketing-whitespace","title":"Indentation, Bracketing, Whitespace","text":"<p>No line of source text is ever more than 80 characters long.  When the length of a line of code exceeds 80 characters, the line of code is wrapped across two or more lines of text.  Whenever the point at which the text must be wrapped is within a literal, a newline character () is inserted at the wrap point and the continuation of the literal begins in the first column of the next text line.  Otherwise, each continuation line is normally indented two tab stops from the first text line of the long line of code; when indenting just one tab stop (rather than two) seems to make the code more readable, indenting one tab stop is okay.  When a single meaningful clause of a source code line must be wrapped across multiple lines of text, each text line after the first line in that clause is normally indented one additional tab stop.</p> <p>In the declaration of a function or variable, the type name and function/variable name are normally separated by a single tab.  They may be separated by multiple tabs when this is necessary in order to have the variable names in multiple consecutive variable declarations line up, which is always preferred.</p> <p>Functions are written with the return type, function name, and arguments as a single line of code, subject to the code line wrapping guidelines given above.  The opening brace of the function definition appears in the first column of the next line.</p> <p>The opening brace of a structure definition likewise appears in the first column of the next line after the structure name.</p> <p>A control statement (starting with <code>if</code>, <code>else</code>, <code>while</code>, or <code>switch</code>) begins a new line of code.  The opening brace for the control statement always appears on the next line, at the same indentation as the control statement keyword.</p> <p>The first line of code appearing after an opening brace (whether for a structure definition, for a function definition, or in the scope of a control statement) always appears on the next line, indented one tab stop.  From that point on, every subsequent line of code is indented the same number of tabs as the preceding line of code, subject to the code line wrapping guidelines given above.</p> <p>Every closing brace always appears in the same column as the corresponding opening brace.</p> <p>Every closing brace is always followed by a single blank line, except when it is immediately followed either by another closing brace (which will be indented one less tab stop) or by an else (which will be indented by the same number of tab stops as the closing brace and, therefore, the corresponding if).</p> <pre><code>static void     computeSomething(int numItems, Item *items)\n{\n    unsigned int    x;\n    int     i;\n\n    while (x &gt; 0)\n    {\n        x--;\n    }\n\n    for (i = 0; i &lt; numItems; i++)\n    {\n        x += items[i].field1;\n    }\n\n    if (numItems == 0)\n    {\n        doThis();\n    }\n    else\n    {\n        doThat();\n    }\n}\n</code></pre> <p>The case labels in switch statements line up with the braces.  Every case (or default) label in the switch, after the first case, is preceded by a blank line.  Cases which do not include a break or return statement either contain no code at all  or else end with a comment along the lines of:</p> <pre><code>/* Intentional fall-through to next case. */\nFor example:\nswitch (ch)\n{\ncase 'A':\n.\n.\n.\nbreak;\n\ncase 'B':\ncase 'C':\n.\n.\n.\nbreak;\n\ncase 'D':\n.\n.\n.\n/* Intentionally falls through. */\n\ncase 'E':\n.\n.\n.\nbreak;\n\ndefault:\n.\n.\n.\nbreak;\n}\n</code></pre>"},{"location":"ION-Coding-Guide/#comment-formatting","title":"Comment Formatting","text":"<p>Comments are so rare and valuable that we hesitate to risk discouraging them by overly constraining their format.  In general, comments should be inserted in such a way as to be as easy as possible to read in relevant context.  The multi-line comment formatting performed automatically by vim is particularly acceptable.</p> <pre><code>/*  Here is the beginning of an extremely long comment, so long\n *  that it has to wrap over two lines of source code text. */\n</code></pre>"},{"location":"ION-Coding-Guide/#miscellaneous-rules","title":"Miscellaneous Rules","text":"<p>Use \u2013 and write \u2013 thread-safe library functions where possible.  E.g., normally prefer <code>strtok_r()</code> to <code>strtok()</code>. </p> <p>Avoid writing non-portable code, e.g., prefer POSIX library calls to OS-specific library calls. </p> <p>Template for \".c\" files <pre><code> 1 2 3 4 5 6 7  \n123456789012345678901234567890123456789012345678901234567890123456789012\n/*\n    platform_sm.c:  platform-dependent implementation of common\n            functions, to simplify porting.\n\n    Author:  Alan Schlutsmeyer, JPL\n\n    Copyright 1997, California Institute of Technology.\n    ALL RIGHTS RESERVED.  U.S. Government sponsorship\n    acknowledged.\n                                                                    */\n</code></pre></p> <p>Each file should have a header comment like the one shown above. </p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;locallib.h&gt;\n#include \"appheader.h\"\n  .\n  .\n  .\n</code></pre> <p>.h files are included just after the header.  System-provided headers should be specified with angle brackets; ION-provided headers should be specified with double-quotes. <pre><code>#define SYMBOLIC_CONSTANT 5\n</code></pre></p> <p>Next, symbolic constants and macros (if any) are defined. They normally go first, because they might be used in the definitions of data types and static variables.  However, symbolic constants and macros may be inserted later in the source text if that will improve the readability of the file. </p> <pre><code>typedef struct fb_str\n{\n    int field1;\n    in  field2;\n} Foobar;\n</code></pre> <p>Data types are defined next because they might be used by static variables.  <pre><code>static int numFoobars = 0;  /* Number of foobars in the program. */\n  .\n  .\n  .\n</code></pre></p> <p>Global functions used only within the program should be declared static.  Public function prototypes should be in a header file; the definitions of those functions, with their headers, are included in the corresponding .c file.  Low-level functions, such as commonly-used utility functions, appear first in the .c file.  They are followed by the functions that call those functions directly, followed by higher-level-functions that call those functions, and so on.</p> <p>Template for \".h\" Files <pre><code> 1 2 3 4 5 6 7  \n123456789012345678901234567890123456789012345678901234567890123456789012\n/*\n    platform_sm.h:  portable definitions of types and functions.\n\n    Author:  Alan Schlutsmeyer, JPL\n\n    Copyright 1997, California Institute of Technology.\n    ALL RIGHTS RESERVED.  U.S. Government sponsorship\n    acknowledged.\n                                                                    */\n</code></pre></p> <p>Each header file begins with a standard header comment like the one shown above. <pre><code>#ifndef _PLATFORM_SM_H_\n#define _PLATFORM_SM_H_\n</code></pre></p> <p>Each header file must have an \"include\" guard.  <pre><code>#include \"platform.h\"\n  .\n  .\n  .\n</code></pre> Next come any includes required by the declarations in the header.  <pre><code>#ifdef __cplusplus\nextern \"C\" {\n#endif\n</code></pre> Next comes the beginning of the C++ guard. This allows the header to be included in a C++ program without error. </p> <p>Next come declarations of various sorts, followed by the ends of the C++ and \u201cinclude\u201d guards.  <pre><code>#ifdef __cplusplus\n}\n#endif\n\n#endif\n</code></pre></p> <p>Nothing should go after the \"#endif\" of the include guard. </p>"},{"location":"ION-Coding-Guide/#sdr-transaction","title":"SDR Transaction","text":"<p>All writing to an SDR heap must occur during a transaction that was initiated by the task issuing the write.  Transactions are single-threaded; if task B wants to start a transaction while a transaction begun by task A is still in progress, it must wait until A's transaction is either ended or cancelled.  </p> <p>A transaction is begun by calling <code>sdr_begin_xn()</code>, and the current transaction is normally ended by calling the <code>sdr_end_xn()</code> function, which returns an error code in the event that any serious SDR-related processing error was encountered in the course of the transaction Transactions may safely be nested, provided that every level of transaction activity that is begun is properly ended.</p> <p>Another way to terminate a transaction is using the <code>sdr_exit_xn()</code> call, as a way to implement a critical section within which SDR data is read while no data modifications occurred. Using the <code>sdr_exit_xn()</code> to end a transaction indicates that no SDR modification should have occurred during the critical section. Therefore the <code>sdr_exit_xn</code> function will check whether any SDR modifications were made during the transaction and if the current transaction is the outer most layer (depth = 1) then it will result in a unrecoverable SDR error.</p> <p>Given that <code>sdr_end_xn()</code> is designed to handle transaction with SDR modification while <code>sdr_exit_xn()</code> does not, why would one want to use <code>sdr_exit_xn()</code> to end a transaction? This is useful as a way to detect SDR changes that is not supposed to occur but does occur - it catches both logical error and implementation error in the code. It is a useful \"check\" whether the SDR behavior is as expected. In case  <code>sdr_exit_xn()</code> detected a SDR modification as the outer most layer of transaction, an error message will be loggedin ion.log file to document a potential issue with the implementation logic. This is usedul for debugging and improving the overall SDR transaction management software.</p> <p>The choice between <code>sdr_end_xn()</code> and <code>sdr_exit_xn()</code> depends on the intent of the transaction and the outcome of a transaction:</p> <ul> <li> <p>Situation A: If a fault occurred that requires reverting SDR modifications (including those made by all nested layers) leading up to the fault event, then one should call sdr_cancel_xn to trigger SDR reversibility, if configured, and allow ion to reload the volatile protocol state to restore the SDR heap and working memory state.</p> </li> <li> <p>Situation B: If a fault occurred but the implementation has the proper procedure and logic to handle handling it such as:</p> </li> <li> <p>The fault did not result in any SDR heap changes, or</p> </li> <li>The modifications that occurred before the fault and as part of fault handling afterward do not require reversal. For example, if the SDR modifications made before the fault may still be valid despite the occurrence of the fault, and the SDR modifications made after the fault, intentionally as part of fault handling procedure such as updating bundle error counters are successful, AND</li> <li> <p>In either case, the integrity of the protocol state is not affected or can be resotred. For example, an invalid bundle was detected and can be safety removed from ION by making appropriate updates to the heap and the working memory. Then one can still call <code>sdr_end_xn</code> since the failure was handled nominally.</p> </li> <li> <p>Situation C: All transactions and modifications are nominal. In this case, call <code>sdr_end_xn.</code></p> </li> </ul> <p>The implementation must be able to discern between situations A and B. When one cannot make certain that the SDR will be in operation state due to a complex transaction failure case, or due to system errors, one one should default to A and issue transaction cancellation and rely on reversibility in order to avoid leaving the SDR in an inconsistent state.</p>"},{"location":"ION-Config-File-Templates/","title":"Available Configuration File Templates","text":""},{"location":"ION-Config-File-Templates/#two-node-ion-configurations","title":"Two-node ION configurations:","text":"<ul> <li>Two-Node BP over UDP Configuration download</li> <li>Two-Node BP over TCP Configuration download</li> <li>Two-Node BP over LTP Configuration download</li> <li>Two-Node BP over BSSP Configuration download</li> <li>Two-Node BP over STCP Configuration download</li> <li>Two-Node CFDP over BP over LTP Configuration download - in this CFDP configuration file, we also included a CFDP command file that can be used with  cfdptest  program to send and receive data. Please use <code>man cfdptest</code> to get information on command syntax and functions.</li> <li>Two-Node Datagram Retransmission (DGR) download</li> <li>Two-Node Bundle-In-Bundle Encapsulation with Custody Transfer (BIBE-CT) download</li> </ul>"},{"location":"ION-Config-File-Templates/#three-node-ion-configuration","title":"Three-node ION Configuration","text":"<ul> <li>Three-Node 'spacecraft-relay-ground' scenario with BPv7 and LTP download</li> </ul>"},{"location":"ION-Config-File-Templates/#notes","title":"Notes","text":"<p>The choice of IP addresses, port IDs, contact delay ('range') and data rate, and memory/storage for 'heap', 'SDR working memory', 'ION working memory', etc, do not indicate a recommended setting. The approproiate setting for ION must be tailored to your specific use case.</p> <p>To understand the full range of configuration parameters, please consult the appropriate man pages for more details: for memory configuration, see <code>man ionconfig</code>, for ION and contact graph configurations, see <code>man ionrc</code>, For bundle protocol and LTP protocol configurations options, see <code>man bprc</code>, <code>man ltprc</code>, etc.</p> <p>To launch each ION node, cd into the configuration folder and execute the appropriate shell script that will launch ION by running a series of administration programs. This script is   called <code>./ionstart</code> or <code>./start_&lt;name name&gt;</code> in these examples but they can be called anything.</p> <p>To terminate each ION node, please utilize a globall installed <code>killm</code> or <code>ionstop</code> script.</p> <p>You can write and use your own script to shutdown ION from the local directory. The advantage of using your own script is that you can also clean up, and post-process data generated during the ION execution such as removing unwanted files and storing/copying the <code>ion.log</code> to a different location.</p> <p>These configuration files are provided to give you a basic functional setup; they may not be sufficient to support all features and achieve the throughput performance needed by your applications. Please use them as a template and modify/optimize as necessary.</p>"},{"location":"ION-Deployment-Guide/","title":"ION Deployment Guide","text":"<p>Version 4.1.3</p> <p>Jay Gao, Jet Propulsion Laboratory, California Institute of Technology</p> <p>Sky DeBaun, Jet Propulsion Laboratory, California Institute of Technology</p> <p>Document Change Log</p> Ver No. Date Description Note V4.1.3 11/6/2023 Add LTP Performance Test Converted to markd down V4.1.2 1/5/2023 Added notes on SDR file and CGRM"},{"location":"ION-Deployment-Guide/#overview","title":"Overview","text":"<p>The effort required to deploy the Interplanetary Overlay Network (ION) software in an operational setting may vary widely depending on the scope of the deployment and the degree to which the required ION functionality coincides with the capability provided by default in the software as distributed. This effort will be expended in two general phases: initial infusion and ongoing operation.</p>"},{"location":"ION-Deployment-Guide/#infusion","title":"Infusion","text":"<p>Even in the best case, some minimal degree of configuration will be required. Many elements of ION behavior are managed at run time by decisions recorded in ION's protocol state databases, as populated by a variety of administration utility programs. Others are managed at compile time by means of compiler command-line switches selected when the software is built. These compile-time configuration options are described in the Configuration section below.</p> <p>In some cases, mission-specific behavior that goes beyond the options built into ION must be enabled during ION deployment. The intent of the ION design is to minimize -- to eliminate, if possible -- any need to modify ION source code in order to enable mission-specific behavior. Two general strategies are adopted for this purpose.</p> <p>First, ION includes a number of conditionally defined functions that can be cleanly replaced with mission-specific alternative source code by setting a compiler command-line switch at build time. Setting such a switch causes the mission-specific source code, written in C, to be simply included within the standard ION source code at the time of compilation.</p> <p>Second, more generally it is always possible to add new application executables, new startup/shutdown/monitor/control utilities or scripts, and even entirely new route computation systems, BP convergence-layer adapters, and/or LTP link service adapters without ever altering the distributed ION source code. A few rough guidelines for making these kinds of modifications are described in the Adaptation section below.</p> <p>Finally, in rare cases it may be necessary to execute ION in an operating-system environment to which it has not yet been ported. Guidance for porting ION to new platforms will be provided in a future edition of this Deployment Guide.</p>"},{"location":"ION-Deployment-Guide/#operation","title":"Operation","text":"<p>On an ongoing basis, an ION deployment may require reconfiguration from time to time and/or may require troubleshooting to resolve performance or stability problems. Some suggestions for reconfiguration and troubleshooting procedures are offered in the Operation section below.</p>"},{"location":"ION-Deployment-Guide/#configuration","title":"Configuration","text":""},{"location":"ION-Deployment-Guide/#configuring-the-ici-module","title":"Configuring the \"ici\" module","text":"<p>Declaring values for the following variables, by setting parameters that are provided to the C compiler (for example, --DFSWSOURCE or --DSM_SEMBASEKEY=0xff13), will alter the functionality of ION as noted below.</p> <p><code>PRIVATE_SYMTAB</code></p> <p>This option causes ION to be built for VxWorks 5.4 or RTEMS with reliance on a small private local symbol table that is accessed by means of a function named sm_FindFunction. Both the table and the function definition are, by default, provided by the symtab.c source file, which is automatically included within the platform_sm.c source when this option is set. The table provides the address of the top-level function to be executed when a task for the indicated symbol (name) is to be spawned, together with the priority at which that task is to execute and the amount of stack space to be allocated to that task.</p> <p>PRIVATE_SYMTAB is defined by default for RTEMS but not for VxWorks 5.4.</p> <p>Absent this option, ION on VxWorks 5.4 must successfully execute the VxWorks symFindByName function in order to spawn a new task. For this purpose the entire VxWorks symbol table for the compiled image must be included in the image, and task priority and stack space allocation must be explicitly specified when tasks are spawned.</p> <p><code>FSWLOGGER</code></p> <p>This option causes the standard ION logging function, which simply writes all ION status messages to a file named ion.log in the current working directory, to be replaced (by #include) with code in the source file fswlogger.c. A file of this name must be in the inclusion path for the compiler, as defined by --Ixxxx compiler option parameters.</p> <p><code>FSWCLOCK</code></p> <p>This option causes the invocation of the standard time function within getUTCTime (in ion.c) to be replaced (by #include) with code in the source file fswutc.c, which might for example invoke a mission-specific function to read a value from the spacecraft clock. A file of this name must be in the inclusion path for the compiler.</p> <p><code>FSWWDNAME</code></p> <p>This option causes the invocation of the standard getcwd function within cfdpInit (in libcfdpP.c) to be replaced (by #include) with code in the source file wdname.c, which must in some way cause the mission-specific value of current working directory name to be copied into cfdpdbBuf.workingDirectoryName. A file of this name must be in the inclusion path for the compiler.</p> <p><code>FSWSYMTAB</code></p> <p>If the PRIVATE_SYMTAB option is also set, then the FSWSYMTAB option causes the code in source file mysymtab.c to be included in platform_sm.c in place of the default symbol table access implementation in symtab.c. A file named mysymtab.c must be in the inclusion path for the compiler.</p> <p><code>FSWSOURCE</code></p> <p>This option simply causes FSWLOGGER, FSWCLOCK, FSWWDNAME, and FSWSYMTAB all to be set.</p> <p><code>GDSLOGGER</code></p> <p>This option causes the standard ION logging function, which simply writes all ION status messages to a file named ion.log in the current working directory, to be replaced (by #include) with code in the source file gdslogger.c. A file of this name must be in the inclusion path for the compiler, as defined by --Ixxxx compiler option parameters.</p> <p><code>GDSSOURCE</code></p> <p>This option simply causes GDSLOGGER to be set.</p> <p><code>TRACKRFXEVENTS</code></p> <p>This option causes user-written code, in a file named rfxtracker.c, to be executed every time the rfxclock daemon dispatches a schedule RFX event such as the start or end of a transmission contact. A file of this name must be in the inclusion path for the compiler, as defined by --Ixxxx compiler option parameters.</p> <p><code>ION_OPS_ALLOC=*xx*</code></p> <p>This option specifies the percentage of the total non-volatile storage space allocated to ION that is reserved for protocol operational state information, i.e., is not available for the storage of bundles or LTP segments. The default value is 40.</p> <p><code>ION_SDR_MARGIN=*xx*</code></p> <p>This option specifies the percentage of the total non-volatile storage space allocated to ION that is reserved simply as margin, for contingency use. The default value is 20.</p> <p>The sum of ION_OPS_ALLOC and ION_SDR_MARGIN defines the amount of non-volatile storage space that is sequestered at the time ION operations are initiated: for purposes of congestion forecasting and prevention of resource oversubscription, this sum is subtracted from the total size of the SDR \"heap\" to determine the maximum volume of space available for bundles and LTP segments. Data reception and origination activities fail whenever they would cause the total amount of data store space occupied by bundles and segments to exceed this limit.</p> <p><code>HEAP_PTRS</code></p> <p>This is an optimization option for the SDR non-volatile data management system: when set, it enables the value of any variable in the SDR heap to be accessed directly by means of a pointer into the dynamic memory that is used as the data store storage medium, rather than by reading the variable into a location in local stack memory. Note that this option must not be enabled if the data store is configured for file storage only, i.e., if the SDR_IN_DRAM flag was set to zero at the time the data store was created by calling sdr_load_profile. See the ionconfig(5) man page in Appendix A for more information.</p> <p><code>NO_SDR_TRACE</code></p> <p>This option causes non-volatile storage utilization tracing functions to be omitted from ION when the SDR system is built. It disables a useful debugging option but reduces the size of the executable software.</p> <p><code>NO_PSM_TRACE</code></p> <p>This option causes memory utilization tracing functions to be omitted from ION when the PSM system is built. It disables a useful debugging option but reduces the size of the executable software.</p> <p><code>IN_FLIGHT</code></p> <p>This option controls the behavior of ION when an unrecoverable error is encountered.</p> <p>If it is set, then when an unrecoverable error is encountered the status message \"Unrecoverable SDR error\" is logged and the SDR non-volatile storage management system is globally disabled: the current data store access transaction is ended and (provided transaction reversibility is enabled) rolled back, and all ION tasks terminate.</p> <p>Otherwise, the ION task that encountered the error is simply aborted, causing a core dump to be produced to support debugging.</p> <p><code>SM_SEMKEY=0x*XXXX*</code></p> <p>This option overrides the default value (0xee01) of the identifying \"key\" used in creating and locating the global ION shared-memory system mutex.</p> <p><code>SVR4_SHM</code></p> <p>This option causes ION to be built using svr4 shared memory as the pervasive shared-memory management mechanism. svr4 shared memory is selected by default when ION is built for any platform other than MinGW (for which File Mapping objects are used), VxWorks 5.4, or RTEMS. (For the latter two operating systems all memory is shared anyway, due to the absence of a protected-memory mode.)</p> <p><code>POSIX1B_SEMAPHORES</code></p> <p>This option causes ION to be built using POSIX semaphores as the pervasive semaphore mechanism. POSIX semaphores are selected by default when ION is built for RTEMS but are otherwise not used or supported; this option enables the default to be overridden.</p> <p><code>SVR4_SEMAPHORES</code></p> <p>This option causes ION to be built using svr4 semaphores as the pervasive semaphore mechanism. svr4 semaphores are selected by default when ION is built for any platform other than MinGW (for which Windows event objects are used), VxWorks 5.4 (for which VxWorks native semaphores are the default choice), or RTEMS (for which POSIX semaphores are the default choice).</p> <p><code>SM_SEMBASEKEY=0x*XXXX*</code></p> <p>This option overrides the default value (0xee02) of the identifying \"key\" used in creating and locating the global ION shared-memory semaphore database, in the event that svr4 semaphores are used.</p> <p><code>SEMMNI=*xxx*</code></p> <p>This option declares to ION the total number of svr4 semaphore sets provided by the operating system, in the event that svr4 semaphores are used. It overrides the default value, which is 128. (Changing this value typically entails rebuilding the O/S kernel.)</p> <p><code>SEMMSL=*xxx*</code></p> <p>This option declares to ION the maximum number of semaphores in each svr4 semaphore set, in the event that svr4 semaphores are used. It overrides the default value, which is 250. (Changing this value typically entails rebuilding the O/S kernel.)</p> <p><code>SEMMNS=*xxx*</code></p> <p>This option declares to ION the total number of svr4 semaphores that the operating system can support; the maximum possible value is SEMMNI x SEMMSL. It overrides the default value, which is 32000. (Changing this value typically entails rebuilding the O/S kernel.)</p> <p>Note that this option is also supported in the MinGW (Windows) port of ION, with the same default value; changing this value does not involve an operating system modification.</p> <p><code>ION_NO_DNS</code></p> <p>This option causes the implementation of a number of Internet socket I/O operations to be omitted for ION. This prevents ION software from being able to operate over Internet connections, but it prevents link errors when ION is loaded on a spacecraft where the operating system does not include support for these functions.</p> <p><code>ERRMSGS_BUFSIZE=*xxxx*</code></p> <p>This option set the size of the buffer in which ION status messages are constructed prior to logging. The default value is 4 KB.</p> <p><code>SPACE_ORDER=*x*</code></p> <p>This option declares the word size of the computer on which the compiled ION software will be running: it is the base-2 log of the number of bytes in an address. The default value is 2, i.e., the size of an address is 2^2^ = 4 bytes. For a 64-bit machine, SPACE_ORDER must be declared to be 3, i.e., the size of an address is 2^3^ = 8 bytes.</p> <p><code>NO_SDRMGT</code></p> <p>This option enables the SDR system to be used as a data access transaction system only, without doing any dynamic management of non-volatile data. With the NO_SDRMGT option set, the SDR system library can (and in fact must) be built from the sdrxn.c source file alone.</p> <p><code>DOS_PATH_DELIMITER</code></p> <p>This option causes ION_PATH_DELIMITER to be set to '\\' (backslash), for use in the construction of path names. The default value of ION_PATH_DELIMITER is '/' (forward slash, as is used in Unix-like operating systems).</p>"},{"location":"ION-Deployment-Guide/#configuring-the-ltp-module","title":"Configuring the \"ltp\" module","text":"<p>Declaring values for the following variables, by setting parameters that are provided to the C compiler (for example, --DUDP_MULTISEND, will alter the functionality of LTP as noted below.</p> <p><code>UDP_MULTISEND</code></p> <p>The UDP_MULTISEND option can improve LTP performance by sharply reducing system call overhead: multiple LTP segments encapsulated in UDP datagrams may be transmitted with a single sendmmsg() call rather than multiple sendmsg() calls. This reduces the cost of sending LTP blocks in small segments, which in turn can limit IP fragmentation for LTP traffic.</p> <p>Note that sendmmsg() has no built-in rate control and offers no opportunity to exercise the rate control algorithm that minimizes UDP congestion loss in non-MULTISEND LTP. In order to achieve similar reduction in UDP congestion loss, a node that receives data sent by sendmmsg() may need to be configured for larger socket buffers. The sysctl operating system utility may be used for this purpose, setting new values for net.core.rmem_max and _default and net.core.wmem_max and _default.</p> <p>Note also that not all operating systems support the sendmmsg() system call. ION currently enables UDP_MULTISEND only for flavors of Linux other than bionic.</p> <p><code>MULTISEND_SEGMENT_SIZE</code></p> <p>By default, ION LTP in UDP_MULTISEND mode will always limit LTP segment size to 1450 so that every segment may be encapsulated in an IP packet whose size does not exceed the standard Ethernet frame size. For networks in which the MTU is known to be larger, this parameter may be overridden at compile time.</p> <p><code>MULTISEND_BATCH_LIMIT</code></p> <p>By default, the maximum number of UDP datagrams that ION LTP in UDP_MULTISEND mode will send in a single sendmmsg() call is automatically computed as the block aggregation size threshold divided by the maximum segment size; that is, normally the amount of data sent per sendmmsg() call is about one LTP block. This parameter may be overridden at compile time.</p> <p><code>MULTIRECV_BUFFER_COUNT</code></p> <p>In UDP_MULTISEND mode, ION LTP will also use recvmmsg() to receive multiple LTP segments (encapsulated in UDP datagrams) in a single system call. By default, 127 segment reception buffers (each one large enough to receive a single LTP segment of maximum size) are reserved for this purpose. This parameter may be overridden at compile time.</p>"},{"location":"ION-Deployment-Guide/#configuring-the-bp-module","title":"Configuring the \"bp\" module","text":"<p>Declaring values for the following variables, by setting parameters that are provided to the C compiler (for example, --DION_NOSTATS or --DBRSTERM=60), will alter the functionality of BP as noted below.</p> <p><code>TargetFFS</code></p> <p>Setting this option adapts BP for use with the TargetFFS flash file system on the VxWorks operating system. TargetFFS apparently locks one or more system semaphores so long as a file is kept open. When a BP task keeps a file open for a sustained interval, subsequent file system access may cause a high-priority non-BP task to attempt to lock the affected semaphore and therefore block; in this event, the priority of the BP task may automatically be elevated by the inversion safety mechanisms of VxWorks. This \"priority inheritance\" can result in preferential scheduling for the BP task -- which does not need it -- at the expense of normally higher-priority tasks, and can thereby introduce runtime anomalies. BP tasks should therefore close files immediately after each access when running on a VxWorks platform that uses the TargetFFS flash file system. The TargetFFS compile-time option ensures that they do so.</p> <p><code>MULTIDUCTS</code></p> <p>It is possible for multiple outducts to be attached to a single egress plan, enabling some bundles to be forwarded to a neighboring node using one outduct while others are forwarded using another. Selection of the outduct to use for the forwarding of a given bundle is a function of the bpclm \"convergence-layer manager\" daemon; each of a given node's egress plans is managed by a single bpclm task. The default outduct selection algorithm exercised by bpclm can be overridden by means of the MULTIDUCTS compile-time configuration option. Setting the -DMULTIDUCTS switch causes the standard outduct configuration logic in the outductSelected() function of bpclm.c to be replaced (by #include) with code in the source file named <code>selectcla.c</code>. A file of this name must be in the inclusion path for the compiler, as defined by --Ixxxx compiler option parameters.</p> <p>The implementation of outductSelected() in ION bpv7 implementation differs somewhat from that in the bpv6 implementation. The content of a very simple <code>selectcla.c</code> file for a node deploying bpv7 might look like this:</p> <pre><code>if (bundle-\\&gt;destination.ssp.ipn.serviceNbr == 99)\n{\n    if (strcmp(protocol-\\&gt;name, \"bssp\") == 0)\n    {\n        return 1; /\\* Use a BSSP outduct for this bundle. \\*/\n    }\n}\n</code></pre> <p>Note that any element of the state of the bundle may be used to select an outduct based on any element of the state of the outduct. The intent is for ION to be able to accommodate virtually any mission-defined algorithm for selecting among communication channels between topologically adjacent BP nodes.</p> <p><code>BRSTERM=*xx*</code></p> <p>This option sets the maximum number of seconds by which the current time at the BRS server may exceed the time tag in a BRS authentication message from a client; if this interval is exceeded, the authentication message is presumed to be a replay attack and is rejected. Small values of BRSTERM are safer than large ones, but they require that clocks be more closely synchronized. The default value is 5.</p> <p><code>ION_NOSTATS</code></p> <p>Setting this option prevents the logging of bundle processing statistics in status messages.</p> <p><code>KEEPALIVE_PERIOD=*xx*</code></p> <p>This option sets the number of seconds between transmission of keep-alive messages over any TCP or BRS convergence-layer protocol connection. The default value is 15.</p> <p><code>ION_BANDWIDTH_RESERVED</code></p> <p>Setting this option overrides strict priority order in bundle transmission, which is the default. Instead, bandwidth is shared between the priority-1 and priority-0 queues on a 2:1 ratio whenever there is no priority-2 traffic.</p>"},{"location":"ION-Deployment-Guide/#configuring-the-ams-module","title":"Configuring the \"ams\" module","text":"<p>Defining the following macros, by setting parameters that are provided to the C compiler (for example, -DNOEXPAT or --DAMS_INDUSTRIAL), will alter the functionality of AMS as noted below.</p> <p><code>NOEXPAT</code></p> <p>Setting this option adapts AMS to expect MIB information to be presented to it in \"amsrc\" syntax (see the amsrc(5) man page) rather than in XML syntax (as described in the amsxml(5) man page), normally because the expat XML interpretation system is not installed. Note that the default syntax for AMS MIB information is now amsrc syntax so the -DNOEXPAT switch is rarely needed.</p> <p><code>AMS_INDUSTRIAL</code></p> <p>Setting this option adapts AMS to an \"industrial\" rather than safety-critical model for memory management. By default, the memory acquired for message transmission and reception buffers in AMS is allocated from limited ION working memory, which is fixed at ION start-up time; this limits the rate at which AMS messages may be originated and acquired. When --DAMS_INDUSTRIAL is set at compile time, the memory acquired for message transmission and reception buffers in AMS is allocated from system memory, using the familiar malloc() and free() functions; this enables much higher message traffic rates on machines with abundant system memory where flight software constraints on dynamic system memory allocation are not applicable.</p>"},{"location":"ION-Deployment-Guide/#configuring-the-cfdp-module","title":"Configuring the \"cfdp\" module","text":"<p>Defining the following macro, by setting a parameter that is provided to the C compiler (i.e., --DTargetFFS), will alter the functionality of CFDP as noted below.</p> <p><code>TargetFFS</code></p> <p>Setting this option adapts CFDP for use with the TargetFFS flash file system on the VxWorks operating system. TargetFFS apparently locks one or more system semaphores so long as a file is kept open. When a CFDP task keeps a file open for a sustained interval, subsequent file system access may cause a high-priority non-CFDP task to attempt to lock the affected semaphore and therefore block; in this event, the priority of the CFDP task may automatically be elevated by the inversion safety mechanisms of VxWorks. This \"priority inheritance\" can result in preferential scheduling for the CFDP task -- which does not need it -- at the expense of normally higher-priority tasks, and can thereby introduce runtime anomalies. CFDP tasks should therefore close files immediately after each access when running on a VxWorks platform that uses the TargetFFS flash file system. The TargetFFS compile-time option assures that they do so.</p>"},{"location":"ION-Deployment-Guide/#initialization","title":"Initialization","text":"<p>ION requires several runtime configuration settings to be defined at the time a node is initialized. Most notable are the settings for the Admin functions of ION. ION provides a variety of administration utilities including ionadmin, ionsecadmin, ltpadmin, bsspadmin, bpadmin, ipnadmin, and cfdpadmin. Each of the corresponding modules that is to be used at runtime will need to be configured. The commands that perform these configuration tasks are normally presented to the admin utility in an admin configuration file.</p> <p>In the Linux environment, two different styles of configuration files are possible. Both styles are accepted by the \"ionstart\" program that installs as part of the official release, an AWK program. The first style requires that all configuration commands for all in-use admins will be stored in one file. This single file is sectioned off internally to separate the commands of each admin. The ionstart program accepts this single configuration file's name as a parameter, parses this file looking for sectioned-off areas for each possible admin function, and then uses the commands within these sections to configure the corresponding modules.</p> <p>The other style requires that each admin will have its own distinct configuration file. The ionstart program consumes these files as guided by command line switches and parameters identifying each configuration file.</p>"},{"location":"ION-Deployment-Guide/#runtime-parameters","title":"Runtime Parameters","text":"<p>Some ION configuration parameters are declared only at node initialization time; they cannot later be revised. In particular, the ionadmin \"1\" (the numeral one) initialization command must be executed just once, before any other configuration command is processed. The first parameter to this command is required and is a numeric value that indicates the node number of the DTN node being configured. The second parameter to this command is optional; if present, it must provide the full pathname of a local file of immutable configuration parameter values:</p> <pre><code>wmKey (integer)\nwmSize (integer)\nwmAddress (integer)\nsdrName (string)\n\nsdrWmSize (integer)\n# bit pattern in integer form, e.g., 3 for 00000011\nconfigFlags 3\nheapWords (integer)\nheapKey (integer)\npathName (string)\n</code></pre> <p>This path name should NOT be enclosed in any type of quotation marks. The file is a text file with 2 fields per line; lines are processed in sequence. The first field on each line holds one of the parameter identifier text strings as shown above. The second field holds the value that will be placed into the identified parameter. Make sure that the data type specified in the second field matches the type expected.</p> <p>For documentation on these parameters, see the ionconfig(5) man page.</p>"},{"location":"ION-Deployment-Guide/#configflags","title":"configFlags","text":"<p>The <code>configFlags</code> entry controls several features of the <code>Simple Data Recorder (SDR)</code>.\u00a0 There are several flags of interest:</p> <pre><code>#define SDR_IN_DRAM\u00a0\u00a0\u00a0\u00a0 1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /*\u00a0\u00a0Write to &amp; read from memory.\u00a0 */\n#define SDR_IN_FILE\u00a0\u00a0\u00a0\u00a0 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /*\u00a0\u00a0Write file; read file if nec. */\n#define SDR_REVERSIBLE\u00a0 4\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /*\u00a0\u00a0Transactions may be reversed.\u00a0*/\n</code></pre> <p>SDR_IN_DRAM is required for normal ION operation and should virtually always be specified.</p> <p>When SDR_REVERSIBLE is specified, SDR transactions that fail (e.g., due to memory allocation failure) are rolled back, allowing transactions to fail gracefully without corrupting the ION databases.\u00a0 If the flag is not supplied, failed transactions will cause an immediate task failure and, where supported, a core dump.\u00a0 This feature is intended only as an aid to debugging; in operations ION should normally be configured with reversible transactions.\u00a0 When transaction reversibility is enabled, ION creates &amp; manages a log file in the directory named by \"pathName\" which must be writable by ION and which tracks the SDR changes and supports rollback to the last consistent state.\u00a0 The filesystem for this directory should be high-performance; a ramdisk is usually ideal.\u00a0 The maximum size of the logfile is dependent upon the largest transaction in the SDR, and is therefore of a size on the same order of magnitude as the largest bundle. NOTE that if the directory named by \"pathname\" does not exist then transaction reversibility will be disabled automatically; a message to this effect will be written to the ION log file.</p> <p>When <code>SDR_IN_FILE</code> is specified, ION creates a file in the \"pathName\" directory, which is maintained as a copy of the SDR heap in DRAM; whenever the SDR heap in memory is modified, the changes are also written to the sdr heap file.\u00a0 Thus the heap file is always the same size as the in-memory heap. Again, if the directory named by \"pathname\" does not exist then retention of the ION SDR heap in a file will be disabled automatically; a message to this effect will be written to the ION log file. NOTE that</p> <ol> <li>The use of <code>SDR_IN_FILE</code> may have the adverse effect of slowing down    all SDR transactions, which can significantly impact transmission,    relay, and reception speed of ION. Users should conduct performance    testing to ensure that keeping SDR in file can still achieve the    operational performance expected.</li> <li>The advantage of a <code>SDR_IN_FILE</code> option is that in the case of ION    shutdown due to power reset where the state of SDR is not    corrupted, it is possible to start ION with the SDR file and    resume data transfer operations such as LTP transaction. However, if    ION shuts down due to an internal error, then it is not recommended    to keep the SDR file when restarting ION, as the SDR state is not    certain to be without corruption.</li> <li>As a general rule, please always remove or move the SDR file away    from the specified path between operations. It should only be left    in place, if users are intentionally attempting to resume    interrupted operations just prior to ION shutdown.</li> </ol>"},{"location":"ION-Deployment-Guide/#allocating-working-memory","title":"Allocating Working Memory","text":"<p>When ION stores a bundle, it typically holds part of the bundle part in memory (heap) as determined by the maxheap parameter in bprc. The default value is about 650 bytes. The rest of the payload is placed into file reference. Also a bundle, before transmission, kept its header and extensions inside a data structure for quick look up and manipulations; the bundle is serialized into a chunk of octet according to the standard just prior to transmission. Therefore, when a bundle is stored in an ION node, part of its footprint is in the 'heap' and part of it is in the 'working memory.'</p> <p>Test shows that leaving the maxHeap parameter to its default value, a bundle uses about 1.5KB of space in heap and about 100-150 Byte in working memory. Adding a 200% margin, we recommend that following relationship between <code>heapWords</code> and <code>wmSize</code>:</p> <pre><code>wmSize = 3 x heapWords x 8 x 0.4 / 10\n</code></pre> <p>where 3 is the margin, 8 is the number of octets per word, 0.4 accounts for the fact that inbound and outbound heap space is only 40% of the heap, and 10 accounts for the empirically estimated 10:1 ratio between heap and working memory footprints per bundle.</p> <p>Many ION runtime configuration parameters can be declared at node initialization and later revised dynamically, either by passing supplementary configuration files to the admin utilities or by exercising the admin utilities in interactive mode.</p> <p>For documentation on the admin commands, see the man pages. The man page names are in the form of <code>&lt;xxx&gt;rc</code>, where <code>&lt;xxx&gt;</code> gets replaced by the specific module name (bp, dtn2, ion, ionsec, ipn, ltp, bssp, cfdp). The directories in which to find these files are: ./ici/doc/pod5, ./ltp/doc/pod5, ./bssp/doc/pod5, ./bp/doc/pod5, and ./cfdp/doc/pod5.</p>"},{"location":"ION-Deployment-Guide/#multi-node-operation","title":"Multi-node Operation","text":"<p>Normally the instantiation of ION on a given computer establishes a single ION node on that computer, for which hard-coded values of wmKey and sdrName (see ionconfig(5)) are used in common by all executables to assure that all elements of the system operate within the same state space. For some purposes, however, it may be desirable to establish multiple ION nodes on a single workstation. (For example, constructing an entire self-contained DTN network on a single machine may simplify some kinds of regression testing.) ION supports this configuration option as follows:</p> <ul> <li>Multi-node operation on a given computer is enabled if and only if   the environment variable <code>ION_NODE_LIST_DIR</code> is defined in the   environment of every participating ION process. Moreover, the value   assigned to this variable must be the same text string in the   environments of all participating ION processes. That value must be   the name (preferably, fully qualified) of the directory in which the   ION multi-node database file \"ion_nodes\" will reside.</li> <li>The definition of <code>ION_NODE_LIST_DIR</code> makes it possible to establish   up to one ION node per directory rather than just one ION node on   the computer. When ionadmin is used to establish a node, the   ionInitialize() function will get that node's wmKey and sdrName from   the .ionconfig file, use them to allocate working memory and create   the SDR data store, and then write a line to the ion_nodes file   noting the nodeNbr, wmKey, sdrName, and wdName for the node it just   initialized. wdName is the current working directory in which   ionadmin was running at the time it called ionInitialize(); it   is the directory within which the node resides.</li> <li>This makes it easy to connect all the node\\'s daemon processes --   running within the same current working directory -- to the correct   working memory partition and SDR data store: the ionAttach()   function simply searches the ion_nodes file for a line whose wdName   matches the current working directory of the process that is trying   to attach, then uses that line\\'s wmKey and sdrName to link up.</li> <li>It is also possible to initiate a process from within a directory   other than the one in which the node resides. To do so, define the   additional environment variable ION_NODE_WDNAME in the shell from   which the new process is to be initiated. When ionAttach() is called   it will first try to get \"current working directory\" (for ION   attachment purposes only) from that environment variable; only   if ION_NODE_WDNAME is undefined will it use the actual cwd that it   gets from calling igetcwd().</li> <li>When running multiple ION instances, the first ION instance must have the largest sdr working memory specified by <code>sdrWmSize</code> or default. If any later ION instance launched with <code>sdrWmSize</code> exceeding the first ION instance, it will result in crash upon launch. It is further recommended that all ION instances running simultaneously on a single host should set their <code>sdrWmSize</code> the same.</li> </ul>"},{"location":"ION-Deployment-Guide/#shutdown","title":"Shutdown","text":"<p>Included in the root directory of the ION distribution is a bash script named ionstop. This script executes each of the \"admin\" utilities and instructs each subsystem to exit, by supplying the dummy command file name \".\". Once all of the utilities have exited, the script calls another script named killm (likewise located in the root directory of ion-open-source). The killm script first tries to kill all ION processes by name, then tries to destroy all of the shared-memory resources allocated to ION at the time the node was created.</p> <p>There are also many \"local\" versions of ionstop script, stored in test subdirectories out of which one or multiple ION instances were launched on the same host. These local versions of ionstop script differ from the ionstop script in the root directory in that it usually contains (a) additional, customized scripts to clean up test artifacts such as ion.log, sdr file, received test files, and temporarily acquisition files for LTP and BP that remained after a test is completed and (b) it generally does not execute kilim, which will kill all ION processes, not just the ones related to the ION instance being terminated.</p> <p>If you invoke the ionstop script that is part of the ION root directory, it does not clean up test artifacts or other products created during operation and if it detects that there are multiple ION instances running in the same host, it will NOT execute killm. In that case, the user is advised to always check that all processes are terminated properly and that the shared memory is cleared appropriately.</p> <p>When running ionstop, various administrative programs will process a dummy command file \".\" that signals shutdown. It will first check the value of the environment variable <code>ION_NODE_WDNAME</code>, defined in the current shell, to determine which instance of ION must be taken down. The ION instance that was shutdown does not depend on the current directory the shell is in. Therefore it is possible to use either the ionstop script provided in ION's root directory or a local, customized version to shutdown an individual ION instance.</p> <p>If you are having trouble shutting an ION node down, see the notes on \"Destroying a Node\" later in this Guide.</p> <p>It has been pointed out that if you are running ION in a Docker container inside a Kubernetes pod, the system is likely to assign process ID 1 to one of the ION processes at startup; since process 1 cannot be killed, the ionstop script can't complete and your node will not be cleanly destroyed. One solution seems to be to usedumb-init for the docker container.</p> <p>To make this work, you may have to override your entry point in the manifest file used by the Kubectl \"apply\" command.</p>"},{"location":"ION-Deployment-Guide/#example-configuration-files","title":"Example Configuration Files","text":""},{"location":"ION-Deployment-Guide/#ion-node-number-cross-reference","title":"ION Node Number Cross-reference","text":"<p>When you define a DTN node, you do so using ionadmin and its Initialize command (using the token '1'). This node is then referenced by its node number throughout the rest of the configuration file.</p> <pre><code>## begin ionadmin  \n1   1  /home/spwdev/cstl/ion-configs/23/badajoz/3node-udp-ltp/badajoz.ionconfig\ns\n\na  contact  +1  +86400    25    25  50000000\na  contact  +1  +84600    25   101  50000000\na  contact  +1  +84600    25     1  50000000\n\na  contact  +1  +86400   101    25  50000000\na  contact  +1  +86400   101   101  50000000\na  contact  +1  +86400   101     1  50000000\n\na  contact  +1  +86400     1    25  50000000\na  contact  +1  +86400     1   101  50000000\na  contact  +1  +86400     1     1  50000000\n\n\na  range  +1  +86400    25    25  1\na  range  +1  +86400    25   101  10\na  range  +1  +86400    25     1  10\n\na  range  +1  +86400   101    25  10\na  range  +1  +86400   101   101  1\na  range  +1  +86400   101     1  10\n\na  range  +1  +86400     1    25  10\na  range  +1  +86400     1   101  10\na  range  +1  +86400     1     1  1\n\nm  production   50000000\nm  consumption  50000000\n\n## end ionadmin\n##########################################################################\n## begin ltpadmin  \n1  32\n\na  span   25  1  1  1400  1400  1  'udplso 192.168.1.25:1113 1000000000'\na  span  101  1  1  1400  1400  1  'udplso 192.168.1.101:1113 1000000000'\na  span    1  1  1  1400  1400  1  'udplso 192.168.1.1:1113 1000000000'\n\ns  'udplsi 192.168.1.1:1113'\n\n## end ltpadmin  \n##########################################################################\n## begin bpadmin  \n1\n\na  scheme  ipn  'ipnfw'    'ipnadminep'\n\na  endpoint  ipn:1.0  q\na  endpoint  ipn:1.1  q\na  endpoint  ipn:1.2  q\n\na  protocol  ltp  1400  100\na  protocol  tcp  1400  100\n\na  outduct  ltp   25              ltpclo\na  outduct  ltp  101              ltpclo\na  outduct  ltp    1              ltpclo\n\na  induct   ltp   1              ltpcli\n\ns\n## end bpadmin\n##########################################################################\n##  begin  ipnadmin\n\na  plan   25  ltp/25\na  plan  101  ltp/101\na  plan    1  ltp/1\n\n## end  ipnadmin  \n</code></pre>"},{"location":"ION-Deployment-Guide/#ipn-parameters-cross-reference","title":"IPN Parameters Cross-reference","text":"<p>The \"ipn\" scheme for URI formation is generally used to form the endpoint IDs of endpoints in an ION deployment. Any transmission using endpoints formed in the \"ipn\" scheme will have endpoints IDs of this form:</p> <p><code>ipn:nodenumber.servicenumber</code></p> <p>The Add Scheme command on line 51 below specifies that the \"ipn\" endpoint naming scheme is supported; the names of three endpoints formed in this scheme are shown in lines 53 thru 55.</p> <p>The two remaining parameters on this command are used to define the software functions that will act as data forwarder and administrative data receiver.</p>"},{"location":"ION-Deployment-Guide/#the-bpadmin-add-scheme-command","title":"The bpadmin Add Scheme command","text":"<p><code>a scheme scheme_name forwarder_command admin_app_command</code></p> <p>The add scheme command. This command declares an endpoint naming scheme for use in endpoint IDs, which are structured as URIs: scheme_name:scheme-specific_part. forwarder_command will be executed when the scheme is started on this node, to initiate operation of a forwarding daemon for this scheme. admin_app_command will also be executed when the scheme is started on this node, to initiate operation of a daemon that opens an administrative endpoint identified within this scheme so that it can receive and process custody signals and bundle status reports.</p> <p>Starting at line 71, the egress plans are defined. These determine the outducts by which data are sent to nodes that are topologically adjacent to the current node in the DTN-based network.</p>"},{"location":"ION-Deployment-Guide/#the-ipnadmin-add-plan-command","title":"The ipnadmin Add Plan command","text":"<p><code>a plan node_nbr default_duct_expression</code></p> <p>The add plan command. This command establishes an egress plan for the bundles that must be transmitted to the neighboring node identified by node_nbr. Each duct expression is a string of the form</p> <p><code>protocol_name outduct_name</code></p> <p>signifying that the bundle is to be queued for transmission via the indicated convergence layer protocol outduct.</p>"},{"location":"ION-Deployment-Guide/#ltp-parameters-cross-reference","title":"LTP Parameters Cross-reference","text":"<p>The ltpadmin utility allows the features of the LTP protocol to become available. For details of the LTP protocol, see RFC 5325.</p> <p>The first command that must be issued to ltpadmin is the Initialize command (see line number 38 below, the command token is the '1' (one)). The sole parameter passed to this command is est_max_export_sessions.</p>"},{"location":"ION-Deployment-Guide/#the-ltpadmin-initialize-command","title":"The ltpadmin Initialize command","text":"<p>This command uses est_max_export_sessions to configure the hash table it will use to manage access to export transmission sessions that are currently in progress. (For optimum performance, est_max_export_sessions should normally equal or exceed the summation of max_export_sessions over all spans as discussed below.)</p> <p>Appropriate values for this parameter and for the parameters configuring each span of potential LTP data exchange between the local LTP and neighboring engines are non-trivial to determine. See the ION LTP configuration spreadsheet and accompanying documentation for details.</p> <p>- Essentially, the \"max export sessions\" must be &gt;= the total number of export sessions on all the spans. If it is expected that new spans will be added during an ION session, then max export sessions figure should be large enough to cover the maximum # of sessions possible.</p> <p>- Next to be defined are the Spans. They define the interconnection between two LTP engines. There are many parameters associated with the Spans.</p>"},{"location":"ION-Deployment-Guide/#the-ltpadmin-add-span-command","title":"The ltpadmin Add Span command","text":"<p><code>a span peer_engine_nbr max_export_sessions max_import_sessions max_segment_size aggregation_size_threshold aggregation_time_limit 'LSO_command' [queuing_latency]</code></p> <p>The \"add span\" command. This command declares that a span of potential LTP data interchange exists between the local LTP engine and the indicated (neighboring) LTP engine.</p> <p>The max_segment_size and the aggregation_size_threshold are expressed as numbers of bytes of data. max_segment_size limits the size of each of the segments into which each outbound data block will be divided; typically this limit will be the maximum number of bytes that can be encapsulated within a single transmission frame of the underlying link service. max_segment_size specifies the largest LTP segment that this span will produce.</p> <p>aggregation_size_threshold limits the number of LTP service data units (e.g., bundles) that can be aggregated into a single block: when the sum of the sizes of all service data units aggregated into a block exceeds this limit, aggregation into this block must cease and the block must be segmented and transmitted. When numerous small bundles are outbound, they are aggregated into a block of at least this size instead of being sent individually.</p> <p>aggregation_time_limit alternatively limits the number of seconds that any single export session block for this span will await aggregation before it is segmented and transmitted, regardless of size. The aggregation time limit prevents undue delay before the transmission of data during periods of low activity. When a small number of small bundles are outbound, they are collected until this time limit is met, whereupon the aggregated quantity is sent as a single, larger block.</p> <p>max_export_sessions constitutes the size of the local LTP engine's retransmission window for this span. The retransmission windows of the spans impose flow control on LTP transmission, preventing the allocation of all available space in the ION node's data store to LTP transmission sessions.</p> <p>The max_import_sessions parameter is simply the neighboring engine's own value for the corresponding export session parameter.</p> <p>LSO_command is script text that will be executed when LTP is started on this node, to initiate operation of a link service output task for this span. Note that peer_engine_nbr will automatically be appended to LSO_command by ltpadmin before the command is executed, so only the link-service-specific portion of the command should be provided in the LSO_command string itself.</p> <p>queuing_latency is the estimated number of seconds that we expect to lapse between reception of a segment at this node and transmission of an acknowledging segment, due to processing delay in the node. (See the 'm ownqtime' command below.) The default value is 1.</p> <p>If queuing_latency is a negative number, the absolute value of this number is used as the actual queuing latency and session purging is enabled; otherwise session purging is disabled. If session purging is enabled for a span then at the end of any period of transmission over this span all of the span's export sessions that are currently in progress are automatically canceled. Notionally this forces re-forwarding of the DTN bundles in each session's block, to avoid having to wait for the restart of transmission on this span before those bundles can be successfully transmitted.</p> <p>Additional notes:</p> <p>- A \"session block\" is filled by outbound bundles until its aggregation size threshold is reached, or its aggregation time limit is reached, whereupon it is output as a series of segments (of size bounded by max_segment_size). This series of segments is reliably transferred via a LTP protocol session with the remote node, one session per block. By adjusting the size of the session block, the rate of arrival of response segments from the remote node can be controlled. Assuming a bundle rate sufficient to fill the session block, a large session block size means a lot of LTP segments per session (good for a high-rate return, low-rate forward link situation). A small session block size means the number of segments per session is smaller and the LTP protocol will complete the block transfer more quickly because the number of segment retries is generally smaller.</p> <p>- A good starting point for a configuration is to set the aggregation size threshold to the number of bytes that will typically be transmitted in one second, so that blocks are typically clocked out about once per second. The maximum number of export sessions then should be at least the total number of seconds in the round-trip time for traffic on this LTP span, to prevent transmission from being blocked due to inability to start another session while waiting for the LTP acknowledgment that can end one of the current sessions.</p> <p>- The multiplicity of session blocks permits bundles to stream; while one session block is being transmitted, a second can be filled (and itself transmitted) before the first is completed. By increasing the number of blocks, high latency links can be filled to capacity (provided there is adequate bandwidth available in the return direction for the LTP acknowledgments). But it is desirable to reduce the max_export_sessions to a value where \"most\" of the sessions are employed because each session allocates an increment of buffer memory from the SDR whether it is used or not.</p> <p>- When a session block is transmitted, it is emitted as a series of back-to-back LTP segments that are simply queued for transmission; LTP does not meter segment issuance in any way. The underlying link layer is expected to pop segments from the queue and transmit them at the current rate as indicated in the contact plan. The udplso task does limit the task's rate of segment transmission over UDP/IP to the transmission rate declared in the contact plan, reducing the incidence of UDP congestion loss.</p> <p>- Note that an LTP session can only be concluded (enabling space occupied by the block to be recycled) when all segments have been successfully received -- or retransmission limits have been reached and the session is canceled. High bit error rates on the link correlate to high rates of data loss when segments are large and/or blocks comprise large numbers of segments; this typically results in larger numbers of NACK/retransmit cycles, retarding session completion. When bit error rates are high, LTP performance can be improved by reducing segment size and/or aggregation size threshold.</p>"},{"location":"ION-Deployment-Guide/#the-ltpadmin-start-command","title":"The ltpadmin Start command","text":"<p><code>s 'LSI command'</code></p> <p>This command starts link service output tasks for all LTP spans (to remote engines) from the local LTP engine, and it starts the link service input task for the local engine.</p> <p>The sole command on line number 44 below starts two main operations within LTP. The first of these operations starts all of the link service output tasks, the ones defined for each LTP span (see the LSO_command parameter of the Add Span command). In this example, each task instantiates the same function (named 'udplso'). Each 'udplso' needs a destination for its transmissions and these are defined as hostname or IP Address (192.168.1.1) and port number (nominally 1113, the pre-defined default port number for all LTP traffic).</p> <p>The second operation started by this command is to instantiate the link service input task. In this instance, the task is named \"udplsi\". It is through this task that all LTP input traffic will be received. Similar to the output tasks, the input task also needs definition of the interface on which LTP traffic will arrive, namely hostname or IP address (192.168.1.1) and port number (1113). If it is necessary for udplsi to listen on multiple network interfaces simultaneously, \\'udplsi 0.0.0.0[:port]\\' can be invoked. This instructs udplsi to listen to the UDP broadcast address, which aggregates traffic from all available network interfaces, including localhost.</p> <p>Once the LTP engine has been defined, initialized and started, we need a definition as to how data gets routed to the Convergence Layer Adaptors. Defining a protocol via bpadmin is the first step in that process.</p>"},{"location":"ION-Deployment-Guide/#the-bpadmin-add-protocol-command","title":"The bpadmin Add Protocol command","text":"<p><code>a protocol protocol_name payload_bytes_per_frame overhead_bytes_per_frame</code></p> <p>The \"add protocol\" command. This command establishes access to the named convergence layer protocol at the local node. As noted earlier, the payload_bytes_per_frame and overhead_bytes_per_frame arguments were previously used in calculating the estimated transmission capacity consumption of each bundle, to aid in route computation and congestion forecasting; in later versions of ION they are not needed and may be omitted.</p> <p>Once the protocol has been defined, it can be used to define ducts, both inducts and outducts, as seen in lines 76 thru 80 below. The Add \"duct\" commands associate a protocol (in this case, LTP) with individual node numbers (in this case, 25, 101 and 1) and a task designed to handle the appropriate Convergence Layer output operations. A similar scenario applies for the induct where the LTP protocol and node number 13 get connected with \"ltpcli\" as the input Convergence Layer function.</p>"},{"location":"ION-Deployment-Guide/#the-bpadmin-add-outduct-and-add-induct-commands","title":"The bpadmin Add Outduct and Add Induct commands","text":"<p><code>a outduct protocol_name duct_name 'CLO_command' [max_payload_length]</code></p> <p>The \"add outduct\" command. This command establishes a duct for transmission of bundles via the indicated CL protocol. The duct's data transmission structure is serviced by the outduct task whose operation is initiated by CLO_command at the time the duct is started. max_payload_length, if specified, causes ION to fragment bundles issued via this outduct (as necessary) to ensure that all such bundles have payloads that are no larger than max_payload_length.</p> <p><code>a induct protocol_name duct_name 'CLI_command'</code></p> <p>The \"add induct\" command. This command establishes a duct for reception of bundles via the indicated CL protocol. The duct's data acquisition structure is used and populated by the induct task whose operation is initiated by CLI_command at the time the duct is started.</p> <p>Note that only a single induct is needed for all bundle reception via any single protocol at any single node, and in fact ION may operate poorly if multiple inducts are established for any single protocol. For any induct whose duct name includes an IP address, use IP address 0.0.0.0 (INADDR_ANY) if the machine on which the node resides is multihomed and you want the node to be reachable via all of the machine's network interfaces.</p> <p>Once all of this has been defined, the last piece needed is the egress plan -- namely how do packets get transmitted to DTN nodes that are the local node's \"neighbors\" in the topology of the network.</p> <p>As you can see from line numbers 6 thru 29, the only network neighbor to node 1 is node 101. Node 25 has not been defined (because the commands in lines 8, 14, 21 and 27 have been commented). In line numbers 15 and 16, we see that the only destinations for data beginning at node 1 are nodes 101 and 1 (a loopback as such). Therefore, in order to get data from node 1 to node 25, our only choice is to send data to node 101. Out best hope of reaching node 25 is that the configurations for node 101 define a connection to node 25 (either a one-hop direct connection, or more multi-hop assumptions). This is where egress plans come into play.</p> <p>On line numbers 87 thru 89, this configuration defines the only choices that can be made regarding destinations. For a destination of node 25, which is not a neighbor, all node 1 can do is pass the data to its only neighbor, namely node 101; the \"exit\" command enables this operation. For destinations of nodes 101 and 1, the scenario is pretty simple.</p>"},{"location":"ION-Deployment-Guide/#the-ipnadmin-add-exit-command","title":"The ipnadmin Add Exit command","text":"<p><code>a exit first_node_nbr last_node_nbr gateway_endpoint_ID</code></p> <p>The \"add exit\" command. This command establishes an \"exit\" for static routing. An exit is an association of some defined routing behavior with some range of node numbers identifying a set of nodes. Whenever a bundle is to be forwarded to a node whose number is in the exit's node number range and it has not been possible to compute a dynamic route to that node from the contact schedules that have been provided to the local node and that node is not a neighbor to which the bundle can be directly transmitted, BP will forward the bundle to the gateway node associated with this exit.</p>"},{"location":"ION-Deployment-Guide/#the-ipnadmin-add-plan-command_1","title":"The ipnadmin Add Plan command","text":"<p><code>a plan node_nbr duct_expression [nominal_data_rate]</code></p> <p>The \"add plan\" command. This command establishes an egress plan for the bundles that must be transmitted to the neighboring node identified by node_nbr.</p> <p>Each duct expression is a string of the form</p> <p><code>protocol_name outduct_name</code></p> <p>signifying that the bundle is to be queued for transmission via the indicated convergence layer protocol outduct.</p> <p>The duct expression used in these examples has \"ltp\" being the protocol name and 101 and 1 being the outduct names.</p>"},{"location":"ION-Deployment-Guide/#ipnadmins-plan-commands-have-been-superseded-by-bpadmin","title":"ipnadmin's \"plan\" commands have been superseded by bpadmin","text":"<p>As of ION 4.1.0, bprc's \"plan\" and \"planduct\" commands supersede and generalize the egress plan commands documented in the ipnrc(5) and dtn2rc(5) man pages, which are [retained for backward compatibility]. The syntax of the egress plan commands consumed by bpadmin is DIFFERENT from that of the commands consumed by ipnadmin and dtn2admin. Please see the man page for bprc (5) for details.</p>"},{"location":"ION-Deployment-Guide/#bundle-in-bundle-encapsulation","title":"Bundle-in-Bundle Encapsulation","text":"<p>For some purposes it may be helpful to encapsulate a bundle inside another bundle -- that is, to let the serialized representation of a bundle be part of the payload of another bundle. This mechanism is called \"Bundle-in-Bundle Encapsulation\" (BIBE) and is defined in Internet Draft draft-burleigh-dtn-bibect-00.txt (which will likely be renamed at some point and ideally will become an IETF standards-track Request For Comments in due course).</p>"},{"location":"ION-Deployment-Guide/#introduction-to-bibe","title":"Introduction to BIBE","text":"<p>By way of overview, here is an excerpt from that document:</p> <p>Each BP node that conforms to the BIBE specification provides a BIBE convergence-layer adapter (CLA) that is implemented within the administrative element of the BP node's application agent. Like any convergence-layer adapter, the BIBE CLA provides:</p> <ul> <li>A transmission service that sends an outbound bundle (from the   bundle protocol agent) to a peer CLA. In the case of BIBE, the   sending CLA and receiving peer CLA are both BP nodes.</li> <li>A reception service that delivers to the bundle protocol agent an   inbound bundle that was sent by a peer CLA (itself a BP node) via   the BIBE convergence layer protocol.</li> </ul> <p>The BIBE CLA performs these services by:</p> <ul> <li>Encapsulating outbound bundles in BIBE protocol data units, which   take the form of Bundle Protocol administrative records as described   later.</li> <li>Requesting that the bundle protocol agent transmit bundles whose   payloads are BIBE protocol data units.</li> <li>Taking delivery of BIBE protocol data units that are the payloads of   bundles received by the bundle protocol agent.</li> <li>Delivering to the bundle protocol agent the bundles that are   encapsulated in delivered BIBE protocol data units.</li> </ul> <p>Bundle-in-bundle encapsulation may have broad utility, but the principal motivating use case is the deployment of \"cross domain solutions\" in secure communications. Under some circumstances a bundle may arrive at a node that is on the frontier of a region of network topology in which augmented security is required, from which the bundle must egress at some other designated node. In that case, the bundle may be encapsulated within a bundle to which the requisite additional BP Security (BPSEC) extension block(s) can be attached, whose source is the point of entry into the insecure region (the \"security source\") and whose destination is the point of egress from the insecure region (the \"security destination\").</p> <p>Note that:</p> <ul> <li>If the payload of the encapsulating bundle is protected by a Bundle   Confidentiality Block (BCB), then the source and destination of the   encapsulated bundle are encrypted, providing defense against traffic   analysis that BPSEC alone cannot offer.</li> <li>Bundles whose payloads are BIBE protocol data units may themselves   be forwarded via a BIBE convergence-layer adapter, enabling nested   bundle encapsulation to arbitrary depth as required by security   policy.</li> <li>Moreover, in the event that no single point of egress from an   insecure region of network topology can be determined at the moment   a bundle is to be encapsulated, multiple copies of the bundle may be   encapsulated individually and forwarded to all candidate points of   egress.</li> </ul> <p>The protocol includes a mechanism for recovery from loss of an encapsulating bundle, called \"custody transfer\". This mechanism is adapted from the custody transfer procedures described in the experimental Bundle Protocol specification developed by the Delay-Tolerant Networking Research group of the Internet Research Task Force and documented in RFC 5050. Custody transfer is a convention by which the loss or corruption of BIBE encapsulating bundles can be mitigated by the exchange of other bundles, which are termed \"custody signals\".</p> <p>BIBE is implemented in ION, but configuring ION nodes to employ BIBE is not as simple as one might think. That is because BIBE functions as both a BP application and a convergence-layer adapter; coercing the Bundle Protocol to function in both capacities, offering services to itself at two different layers of the protocol stack, requires careful configuration.</p>"},{"location":"ION-Deployment-Guide/#configuring-bibe-in-ion","title":"Configuring BIBE in ION","text":"<p>Like any convergence-layer protocol, BIBE is used to copy a bundle from one BP node (the sending node) to another node (the receiving node), over one segment of the end-to-end path from the bundle's source node to its destination node. Somewhat confusingly, in BIBE the copying of the bundle is accomplished by issuing a second encapsulating bundle, which has its own source node and destination node:</p> <ul> <li>The source node of the encapsulating bundle accepts a bundle from   the sending node (which, in ION, is always the same node),   encapsulates that original bundle in the encapsulating bundle, and   forwards the encapsulating bundle.</li> <li>The destination endpoint of the encapsulating bundle receives the   encapsulating bundle, extracts the original bundle from the   encapsulating bundle, and conveys the original bundle to the   receiving node (which may be the same node or some other node).</li> </ul> <p>Each pair of sending and receiving nodes can be thought of as a \"tunnel\" which requires specific configuration. These tunnels constitute the communication relationships that must be implemented as \"outducts\" in ION.</p>"},{"location":"ION-Deployment-Guide/#bclas","title":"BCLAs","text":"<p>While the node IDs of the source and destination nodes of encapsulating bundles are necessary parameters for BIBE transmission, they are not sufficient: encapsulating bundles are characterized by quality of service, lifetime, etc., just like other bundles. For this purpose we use an additional BIBE administration utility program -- bibeadmin -- that consumes a file of .bprc commands; these commands add, revise, and delete BIBE convergence layer adapter objects (bclas) that are managed in a BIBE database. For example:</p> <p><code>a bcla ipn:3.0 20 20 300 2 128</code></p> <p>This command adds a bcla identified by \"ipn:3.0\" -- the ID of the destination node of all encapsulating bundles formed according to this bcla -- which asserts that the expected latency for each encapsulating bundle to reach this destination node is 20 seconds, the expected latency for a responding custody signal bundle is likewise 20 seconds, the encapsulating bundle's time-to-live is 300 seconds, its class of service is 2 (expedited), and its ordinal sub-priority is 128.</p> <p>Note that other configuration elements may also be implicitly associated with this bcla. For example, BPSEC security rules may map this BIBE source/destination node pair to security block configurations that will pertain to all encapsulating bundles formed according to this bcla.</p>"},{"location":"ION-Deployment-Guide/#ducts","title":"Ducts","text":"<p>Since BIBE is a convergence-layer protocol, each BIBE tunnel must be configured by means of BP administration (bpadmin) using .bprc commands; BIBE must be added as a protocol, the local node must be added as the BIBE induct, and each supported BIBE tunnel must be added as a BIBE outduct. For example:</p> <pre><code>a protocol bibe\na induct bibe \\* ''\na outduct bibe ipn:4.0 'bibeclo ipn:3.0'\n</code></pre> <p>The \"a outduct\" command states that the BIBE outduct (tunnel) identified by node ID \"ipn:4.0\" (the receiving node) is serviced by a BIBE convergence-layer output daemon operating according to the bcla identified by \"ipn:3.0\" as described above. The destination node ipn:3.0 is responsible for forwarding each extracted (encapsulated) bundle to the receiving node ipn:4.0. The sending node and the source node of the encapsulating bundles are both, implicitly, the local node.</p> <p>Note that for most convergence-layer adapters the node ID of the receiving node for a given outduct is implicit; for example, an stcp outduct explicitly identifies only the socket address of the receiving node's socket -- that is, the convergence-layer protocol endpoint ID -- not the node ID of the receiving node. BIBE differs only in that the convergence-layer protocol endpoint ID is, explicitly, the node ID of the receiving node, simply because BP is being used as the convergence-layer protocol.</p>"},{"location":"ION-Deployment-Guide/#plans","title":"Plans","text":"<p>In order to cause bundles to be conveyed to a specified receiving node via a BIBE outduct, that outduct must be associated with that node in an egress plan. For example, in the .ipnrc file:</p> <pre><code>a plan ipn:4.0 bibe/ipn:4.0\na plan ipn:3.0 stcp/91.7.31.134:4546\n</code></pre> <p>The first command asserts that all bundles destined for node \"ipn:4.0\" are to be forwarded using BIBE outduct \"ipn:4.0\". The second asserts that all bundles destined for node \"ipn:3.0\" (here, all BIBE encapsulating bundles formed according to the bcla identified by \"ipn:3.0\") are to be forwarded using the stcp outduct connected to TCP socket \"91.7.31.134:4546\".</p>"},{"location":"ION-Deployment-Guide/#contacts","title":"Contacts","text":"<p>Finally, in order for data to flow to receiving node ipn:4.0 via the bibe/ipn:4.0 outduct, a contact object must be added to the contact plan enabling the transmissions:</p> <p><code>a contact +0 +1000000000 2 4 100000</code></p> <p>This command states that data flow from node 2 (here, the local node) to node 4 (the receiving node) is continuously enabled, but the rate of transmission is limited to 100,000 bytes per second.</p>"},{"location":"ION-Deployment-Guide/#overrides","title":"Overrides","text":"<p>Under some circumstances, successful forwarding of BIBE bundles requires that outduct overrides be applied. See the biberc(5) man page for details.</p>"},{"location":"ION-Deployment-Guide/#adaptations","title":"Adaptations","text":""},{"location":"ION-Deployment-Guide/#error-logging","title":"Error Logging","text":"<p>ION contains a flexible system that allows its code to display errors in several different ways. At the core of this system is a typedef that defines a data type named \"Logger\" (with upper case \"L\") that is a function variable that accepts a character pointer (string) parameter and returns a value of type void.</p> <p>typedef void (* Logger)(char *);</p> <p>In ION, there is one variable defined to be of this type. Its identifier is \"logger\" (with lower case \"L\") and it is initialized to a value of \"logToStdout\". The function \"logToStdout\" is defined and its contents cause the string parameter to be printed to the stdout device. Therefore, any call to the function variable \"logger\" will have same effects as a call to the function \"logToStdout\".</p> <p>However, remember that \"logger\" is a variable and is allowed to change its value to that of other functions that accept string parameters and return void. This is how ION allows for flexibility in logging errors.</p> <p>At startup, ION makes a call to \"ionRedirectMemos\". This function makes a call to \"setLogger\" which eventually changes the value of the \"logger\" variable. The new value of the variable named \"logger\" is \"writeMemoToIonLog\". This function writes strings to a file named \"ion.log\".</p> <p>It is through this mechanism that any calls to the functions \"writeMemo\", \"writeMemoNote\" or \"writeErrMemo\" eventually pass their parameters to the function \"writeMemoToIonLog\". This is how the Linux-based ION's operate.</p> <p>Check out the FSWLOGGER macro option as documented in section 2.1.1 of the Design Guide.</p>"},{"location":"ION-Deployment-Guide/#memory-allocation","title":"Memory Allocation","text":"<p>What types of memory does ION use and how is memory allocated/controlled?</p> <p>For an introductory description of the memory resources used by ION, see Section 1.5 of the ION Design and Operation guide entitled \"Resource Management in ION\".</p> <p>Section 1.5 of the Design and Operation guide makes reference to parameters called \"wmSize\" and \"heapWords\". Discussion on these and all of the parameters can be found in this document under the section entitled \"Runtime Parameters\".</p> <p>ION allocates its large blocks of memory via calls to malloc. Should the need ever arise to place these large blocks of memory at known, fixed addresses, it would be possible to modify the function memalign, in the file platform.c. A better approach would be to create a shared-memory segment for each pre-allocated memory block (possibly using ION's sm_ShmAttach() function to do this) and pass the applicable shared-memory key values to ION at startup, in the \"heapKey\" and/or \"wmKey\" runtime parameters.</p> <p>Any code that references the function \"sm_ShmAttach\" will be looking to acquire some block of memory. These would include the Space Management Trace features and standalone programs such as \"file2sm\", \"sm2file\" and \"smlistsh\".</p>"},{"location":"ION-Deployment-Guide/#testing-known-issues","title":"Testing &amp; Known Issues","text":""},{"location":"ION-Deployment-Guide/#factors-affecting-ltp-testing-over-udp","title":"Factors Affecting LTP Testing Over UDP","text":"<p>Terrestrial testing of LTP during the prototype and initial system integration phases often relies on using the UDP protocol because it is readily available on most terrestrial computing systems. ION's udplso and udplsi programs provide the basic capability to flow LTP traffic between two hosts on the internet. To increase the fidelity of LTP testing, short of directly utilizing actual radio systems, customized software or hardware can be added to the data path. This addition aims to introduce longer delays and data corruption/loss in a controlled manner.</p> <p>However, testing LTP over UDP can yield unpredictable results due to several factors. Understanding these factors is essential for accurate analysis and troubleshooting:</p>"},{"location":"ION-Deployment-Guide/#udps-inherent-unreliability","title":"UDP's Inherent Unreliability","text":"<p>UDP lacks a built-in mechanism for retransmitting lost packets. Consequently, the rate at which packets are lost can fluctuate significantly. This inherent unreliability of UDP may affect the performance and reliability tests of LTP, as LTP relies on UDP for transport.</p>"},{"location":"ION-Deployment-Guide/#kernel-buffering-and-ip-fragment-reassembly","title":"Kernel Buffering and IP Fragment Reassembly","text":"<p>The ability of the operating system kernel to buffer and reassemble IP fragments plays a critical role, especially if an LTP segment exceeds the Maximum Transmission Unit (MTU) size. The efficiency of this process can vary based on:</p> <ul> <li>The default configuration of the kernel's IP protocol stack.</li> <li>The rate at which UDP traffic is injected by the user.</li> <li>Differences in these aspects can introduce variability in test outcomes, as they affect how well the underlying system can handle large LTP segments transmitted over UDP.</li> </ul>"},{"location":"ION-Deployment-Guide/#external-factors-link-simulator","title":"External Factors: Link Simulator","text":"<p>External testing tools, either customized software or WAN emulators, are often used to simulate network conditions or impairments but may also impact the fidelity of testing by exaggerating the delay differences between different traffic streams, including UDP fragments, when improperly configured, and further complicate the interpretation of LTP performance results over UDP.</p>"},{"location":"ION-Deployment-Guide/#operation_1","title":"Operation","text":"<p>ION is generally optimized for continuous operational use rather than research. In practice, this means that a lot more attention, both in the code and in the documentation, has been paid to the care and feeding of an existing ION-based network than to the problem of setting up a new network in the first place. (The unspoken expectation is that you're only going to do it once anyway.)</p> <p>Unfortunately this can make ION somewhat painful for new users to work with. The notes in this section are aimed at reducing this pain, at least a little.</p>"},{"location":"ION-Deployment-Guide/#wrong-profile-for-this-sdr","title":"\"Wrong profile for this SDR\"","text":"<p>ION is based on shared access to a common data store in memory (and/or in a file), and the objects in that data store are intended to persist across multiple restarts of network activity in a continuously operational network. That's okay for Space Station operations, but it's not helpful while you're still struggling to get the network running in the first place. For this purpose you are probably creating and destroying one or more nodes repetitively.</p> <p>A key concept:</p> <p>Each time you run the standard ionstart script provided with ION, you are creating a new network from scratch. To minimize confusion, be sure to clear out the old data store first.</p> <p>If you don't wipe out the old system before trying to start the new one, then either you will pick up where you left off in testing the old system (and any endpoints, ducts, etc. you try to add will be rejected as duplicates) or -- in the event that you have changed something fundamental in the configuration, or are using an entirely different configuration file -- you'll see the \"Wrong profile for this SDR\" message and won't be able to continue at all.</p>"},{"location":"ION-Deployment-Guide/#destroying-a-node","title":"Destroying a node","text":"<p>In most cases the ionstop script should terminate the node for you. Invoke it once for every node of your network. To verify that you're starting from a clean slate, run the ipcs command after ionstop: the list of Semaphore Arrays should be empty. If it's not, you've got one or more leftover processes from the previous network still running; use ps ax to find them and kill -9 to get rid of them. The process names to look for are:</p> <ul> <li>Most names that start with \"ion\", \"bp\", \"brs\", \"stcp\", \"dgr\", \"ltp\",   \"cfdp\", or \"ams\".</li> <li>udplsi, udpcli, tcpcli, rfxclock.</li> </ul> <p>Then run the killm script again to make sure the node's shared-memory resources have been released; run ipcs again to verify, and review your leftover processes again if those resources still haven't been released.</p> <p>An additional wrinkle: if you configure ION to manage your ION data store in a file as well as (or instead of) managing it in shared memory, then in addition to calling killm to destroy the semaphores and the copy of the data store that resides in shared memory, you also need to delete the data store file; this destroys the copy of the data store that resides in the file system. If the data store isn't deleted, then when you restart ION using your standard configuration file the file-system copy of the data store will automatically be reloaded into shared memory and all the config file commands that create new schemes, endpoints, etc. will fail, because they're still in the data store that you were using before.</p> <p>Another habit that can be helpful: whenever you restart ION from scratch, delete all the ion.log files in all of the directories in which you're configuring your ION nodes. This isn't mandatory -- ION will happily append new log messages to existing log files, and the messages are time-tagged anyway, so it's always possible to work out what happened when. But starting fresh with new log files removes a lot of clutter so that it's easy to see exactly what's happening in this particular iteration of your network research. ION will create new log files automatically if they don't exist; if there's something particularly interesting in the log from a prior system, copy that log file with a different name so you can come back to it if you need to.</p>"},{"location":"ION-Deployment-Guide/#no-such-directory-disabling-heap-residence-in-file","title":"\"No such directory; disabling heap residence in file...\"","text":"<p>This message just means that the directory whose name you've provided as the value of pathName in the ION configuration file does not exist, and therefore the ION operations that rely on being able to write files in that directory are disabled. It's strictly informative; nearly everything in ION will work just fine even if this message is printed every time you run.</p> <p>But if you do care about transaction reversibility, for example, or if you just want to get rid of the annoying message, simply create the directory that is named in pathName (it can be any path name you like) and make sure it's world-writable. The ionconfig(5) man page discusses this parameter and others that affect the fundamental character of the system you're configuring.</p>"},{"location":"ION-Deployment-Guide/#cant-find-ion-security-database","title":"\"Can't find ION security database\"","text":"<p>These messages are just warnings, but they are annoying. We're still struggling to work out a way to support bundle security protocol as fully and readily as possible but still let people run ION without it, if they want, without too much hassle.</p> <p>For now, the best answer might be to insert the following lines into each host.rc file immediately after the \"##end ionadmin\" line. They should create an empty ION security database on each host, which should shut down all those warnings:</p> <pre><code>## begin ionsecadmin\n1\n## end ionsecadmin\n</code></pre>"},{"location":"ION-Deployment-Guide/#clock-sync","title":"Clock sync","text":"<p>Several key elements of ION (notably LTP transmission and bundle expiration) rely on the clocks of all nodes in the network being synchronized to within a few seconds. NTP is a good way to accomplish this, if you've got access to an NTP server. If you can't get your clocks synchronized, stick to the TCP or UDP convergence-layer adapters, don't count on using contact graph routing, and use long lifetimes on all bundles to prevent premature bundle expiration.</p>"},{"location":"ION-Deployment-Guide/#node-numbers","title":"Node numbers","text":"<p>In ION we always use the same numeric value for LTP (and BSSP) engine number and BP node number -- and for CFDP entity number and AMS continuum number as well. The idea is that a given ION node has a single identifying number, which by convention we use wherever a protocol endpoint identifier is needed for any local protocol agent. This is not a DTN or CCSDS requirement, but it doesn't violate any of the protocol specifications and it does marginally simplify both implementation and configuration.</p>"},{"location":"ION-Deployment-Guide/#duct-names","title":"Duct names","text":"<p>The bprc(5) man page explains the general format of the commands for adding convergence-layer inducts and outducts, but it doesn't provide the syntax for duct names, since duct name syntax is different for different CL protocols. Here's a summary of duct name syntax for the CL protocols supported as of ION 3.6.1:</p> <ul> <li>LTP and BSSP: the duct name is simply the engine number, which in   ION is always the same as the BP node number. E.g., \"9\". The induct   name is the number of the local node. One outduct is needed for each   node to which bundles will be sent by the indicated protocol   (including the local node, if you want to do BP loopback   transmission), naming the corresponding induct of the receiving   node.</li> <li>BRSS (bundle relay service -- server): the induct name format is   hostname[:portnbr], where portnbr defaults to 80 if omitted.   Whenever possible, it's best to use the host's IP address in   dotted-string form (\"109.32.19.6\") as its \"hostname\". (Where host   names are resolved by reference to /etc/hosts rather than DNS, the   name of a given host may be known by a variety of different names on   different peer hosts. This can introduce baffling connectivity   problems.) The induct name identifies the local node's machine. All   BRSS outducts are created automatically upon acceptance of   connections from clients, never added by bpadmin.</li> <li>BRSC (bundle relay service -- client): the induct and sole outduct   have the same name, of the form hostname[:portnbr]_nodenbr,   where hostname[:portnbr] is the BRS server's induct name and   nodenbr is the local node's BP node number. Port number defaults   to 80 if omitted.</li> <li>All other Internet-based CL protocols (udp, tcp, stcp): induct and   outduct names are of the form hostname[:portnbr]. Port number   defaults to 4556 if omitted. One outduct is needed for each node to   which bundles will be sent, naming the induct of the receiving node.</li> </ul>"},{"location":"ION-Deployment-Guide/#config-file-pitfalls-to-watch-for","title":"Config file pitfalls to watch for","text":"<p>Here are some other points to bear in mind as you debug your ION node configuration:</p> <ul> <li>The ranges between all pairs of neighboring nodes are required for   the correct operation of contact graph routing. The canonical form   of a range expression is \"from\" the smaller node number \"to\" the   larger node number, and this form implies that the range in the   opposite direction is the same (as one would normally expect). A   range expression with those values reversed is interpreted as an   overriding range, indicating that the distance between the two nodes   is not symmetrical -- weird, but for some environments we have to be   able to say this because the forward and reverse data paths are very   different (e.g., configured to go through different antenna   complexes).</li> <li>Be very careful when you code Internet-style (TCP, UDP, etc.) duct   names. These names have to be correct and consistent, or else you   will see no flow of data. Don't ever use \"127.0.0.1\" as a hostname   unless you are certain you will never want to communicate with nodes   on any other machines. If your hostname is mapped to an IP address   in /etc/hosts rather than by DNS, make sure that the address that   the hostname maps to is not 127.0.0.1, for the same reason.</li> </ul>"},{"location":"ION-Deployment-Guide/#ion-hard-reset","title":"ION hard reset","text":"<ul> <li>If SDR is implemented in File (non-volatile) storage, then it is   possible that after a power reset of ION while in nominal   operational state, the BP and LTP protocol states can recover when   ION is started again while leaving the SDR file in place. When ION   is launched (not by ionrestart command), it will check for an   existing SDR. If a SDR file is detected in the directory pointed to   by 'pathName' in ionconfig, it will try to resume operation from   that SDR file.</li> <li>Because ION checks for the presence of an existing SDR when it   starts, if one desires to start ION from a fresh (blank) state, one   should remember to remove old SDR files from previous sessions.</li> <li>It should also be noted that operation ION with SDR implemented in   file will slow down system performance. Testing indicated that   whether ION crashes (due to transaction error or other system   errors) or shutdowns nominally by invoking various ION   administration program with the single argument \".\" The SDR state in   the SDR file is not guaranteed to be in a consistent state. In other   words, under both the above circumstances, the SDR file should be   removed or deleted prior to relaunching ION.</li> <li>Through testing, it has been shown that only when the SDR file left   behind due to power reset while ION is operating nominally can be   used to resume SDR operation. However, this mode of recovery has yet   to receive thorough testing and analysis.</li> </ul>"},{"location":"ION-Deployment-Guide/#ion-and-ltp-state-recovery","title":"ION and LTP State Recovery","text":"<ul> <li>If there is a need to repair ION/LTP protocol state, one may try   issue ionrestart command to re-build the volatile database and   clean up failed/stuck transactions instead of shutting down and   restarting ION again.</li> <li>When restarting the sender side of LTP, the session numbers will   recycle back to 0, unless the SDR is implemented in file. The   receiving side LTP engine, however, will retain the memory of   previously closed session numbers and reject new export sessions   using recycled session numbers. Typically, this memory period of   previously closed import session numbers is appropriately short --   just long enough to ensure that redundant handshake messages, if   any, that arrive late will not trigger the start of a false import   session. This memory period is derived from the maxBer parameter,   which controls how aggressively a sender LTP engine will attempt to   close a failed handshake procedure. Therefore, overly pessimistic   maxBer value will cause LTP to set a much longer closed import   session memory period than necessary and prevent LTP from   efficiently reusing session numbers after a reset.</li> </ul>"},{"location":"ION-Deployment-Guide/#configuring-loopback-contact","title":"Configuring \"Loopback\" Contact","text":"<ul> <li>In the contact graph, one may set range and contact for a node with   itself. Be careful of the value assigned to these \"loopback\" links.   In general, they should have shorter delay and higher bandwidth than   actual communication links with neighboring nodes.</li> <li>If the loopback delay, data rate, and on-off periods are not set   appropriately, a bundle sent from a node to another endpoint on the   local node will be transmitted to other nodes and relayed back to   itself, which is a counter-intuitive behavior and introduces   unnecessary traffic. CGR does not treat loopback contacts with   special preferences -- as we typically expect. Instead, CGR looks at   all contacts as equally valid and will compute a lowest latency   routing decision based on the actual delay, data rate, and on-off   windows assigned to them.</li> <li>When a node joins a multicast group, a registration contact (a   contact with zero data rate and a contact time in 2038) is created   automatically and is visible when listing contact through ionadmin.   This is an expected behavior.</li> </ul>"},{"location":"ION-Deployment-Guide/#ltp-performance-assessment-ion-412","title":"LTP Performance Assessment (ION 4.1.2)","text":"<p>In this section, we present LTP throughput measurements collected on different computing platforms. The goal of these tests is to provide a set of data points that give ION users a sense of the achievable LTP throughput for a given level of computing resources, ranging from single-board computers (SBC) to medium-level or high-end servers connected via 10Gbps Ethernet. We made no attempt to match any particular user's computing environment in this test. Users must exercise their own good engineering sense when generalizing and applying these data points to make predictions regarding the performance of their own systems. The users are encouraged to install ION on the target platform and configure ION - using some of the configuration recommendations in this report - when conducting their own tests.</p> <p>Since our focus is to explore the speed limitation caused by software processing within ION, we try to eliminate external factors that can slow down throughput, such as a poor network connection or other processing-intensive software running concurrently on the host machine that compete for CPU cycles, etc. We also eliminated the impact of round-trip delay and packet error by testing LTP over a high-speed, low-error, direct Ethernet connection between two LTP peers.</p>"},{"location":"ION-Deployment-Guide/#considerations-for-configuration","title":"Considerations for Configuration","text":"<p>Given that LTP is designed for space links, not terrestrial links, LTP segment sizes much larger than typical terrestrial network MTUs (nominally 1,500 to 9,000 bytes) are considered in our testing. For LTP configuration in space, the CCSDS Packet Encapsulation service enables LTP segments of variable sizes to be transmitted over different CCSDS space link protocols.</p> <p>Most of our testing was conducted with the SDR in DRAM (configuration 1) to achieve higher data processing speed. However, we did collect data on several cases where reversibility and SDR object boundness checks were turned on.</p> <p>In the interest of efficiency, we also favor selecting larger bundles, potentially much larger than the LTP aggregation block size. In previous TCPCL testing, it was observed that a larger bundle size improves throughput since more data can be transferred per logical operation. For the same reason, we believe that a larger bundle size will improve LTP performance.</p> <p>ION performs bundle-level metering to throttle the speed with which data is presented to LTP engines for transmission. The throttle rate is set by the contact plan and should not exceed the line rate of the physical Ethernet connection. In many cases, we configure ION with a contact plan rate that is lower than the Ethernet line rate to allow BP/LTP to operate as fast as possible without creating a destructive level of congestion. To facilitate better testing, we also use the bpdriver utility program with the \\'i\\' option to control the source data injection rate. For some tests, we find data metering unnecessary, and ION can buffer and handle local congestion and deliver the maximum possible throughput.</p> <p>NOTE: The results presented here are based on System V semaphore. Recent upgrade and testing of a POSIX semaphore approach indicated a substantial performance increase to ION, and that result will be published in the next release of this document.</p> <p>As stated earlier, our goal is to test the ION processing rate limitation, not the host system\\'s memory availability. Therefore, we configure ION SDR with a generous amount of heap and working memory to ensure that data storage is not a limiting factor.</p> <p>Now, we present our test cases.</p>"},{"location":"ION-Deployment-Guide/#test-case-1-mid-grade-linux-server-with-direct-ethernet-connection","title":"Test Case 1: Mid-grade Linux Server with Direct Ethernet Connection","text":"<p>B = byte</p> <p>b = bit</p> <p>M = mega</p> <p>K = kilo</p> <p>G = giga</p> <p>ION Configuration:</p> <ul> <li>SDR in DRAM only (config flag 1)</li> <li>Contact Plan Rate Limit: 100Mbps</li> <li>Aggregation Block: 64,000 B</li> <li>Segment Size: 1,500 B</li> <li>Bundle size 64,000 B</li> </ul> <p>Hardware Specification and Operating System:</p> <ul> <li>Intel Xeon X3210 CPU @ 2.13GHz (2007 era processor)</li> <li>3.5GB RAM</li> <li>4 cores/4 threads.</li> <li>1 Gbps physical Ethernet connection</li> <li>Oracle Linux 8</li> </ul> <p>Throughput Measured:</p> <ul> <li>90 Mbps (one-way)</li> <li>70 Mbps/ 20 Mbps (two-way)</li> </ul>"},{"location":"ION-Deployment-Guide/#test-case-2-arm64-raspberry-pi-4b","title":"Test Case 2: ARM64 Raspberry Pi 4B","text":"<p>ION Configuration:</p> <ul> <li>SDR in DRAM only</li> <li>Contact Plan Rate Limit: 100Mbps</li> <li>Aggregation Block: 64,000 B</li> <li>Segment Size: 1,500 B</li> <li>Bundle size 64,000 B</li> </ul> <p>Hardware Specification and Operating System:</p> <ul> <li>BROADCOM BCM2711 QUAD-CORE CORTEX-A72 (ARM V8) 64-BIT SOC @ 1.5GHZ</li> <li>8G RAM</li> <li>1 Gbps physical Ethernet connection</li> <li>Ubuntu 20.04 for ARM64</li> </ul> <p>Throughput Measured:</p> <ul> <li>60 Mbps (one-way)</li> </ul>"},{"location":"ION-Deployment-Guide/#test-case-3-sdr-configuration-study-2015-xeon-skylake","title":"Test Case 3: SDR configuration Study (2015 Xeon Skylake)","text":"<p>In this test case, we considered several SDR configuration combinations and assessed their impact.</p> <ul> <li>1: DRAM only</li> <li>9: DRAM + bounded</li> <li>13: DRAM + bounded + reversibility</li> </ul> <p>We do not include the \"SDR in file\" or any combination with that since file operation will slow down performance significantly.</p> <p>Base ION Memory Configuration</p> <ul> <li>configFlags 1</li> <li>sdrWmSize 50000000</li> <li>wmSize 120000000</li> <li>heapWords 500000000</li> </ul> <p>BP/LTP Configuration</p> <ul> <li> <p>The following is representational of .ltprc file on both nodes</p> </li> <li> <p>1 50</p> </li> <li>a span \\&lt;node #&gt; 50 50 64000 128000 1 \\'udplso     192.168.XXX.XX:XXXX\\'</li> <li>m maxber .000000001</li> <li>Bundle Size = 1MB</li> </ul> <p>Contact Plan Data Rate (1 Gb/sec)</p> <ul> <li>a contact +0 2024/01/01-00:00:00 \\&lt;node #&gt; \\&lt;node #&gt; 134217728</li> </ul> <p>Hardware Specification and Operating System:</p> <ul> <li>CPU: 2 core 2.10GHz vCPU based on Intel Xeon Skylake</li> <li>Memory: 4GB</li> <li>OS: Oracle Linux 8.6</li> <li> <p>Network link reported by iperf as follows (PTL Orange Testbed)</p> </li> <li> <p>UDP: 1.35 GB/sec</p> </li> <li>TCP: 16.5 GB/sec</li> </ul> <p>Throughput Measured</p> <ul> <li>SDR config 1 -&gt; SDR config 1: 900 Mbps</li> <li>SDR config 13 -&gt; SDR config 1: 130 Mbps</li> <li>SDR config 1 \\&lt;-&gt; SDR config 1: 600 Mbps, 400 Mbps (simultaneously   two-way)</li> <li>SDR config 9 -&gt; SDR config 9: 800 Mbps</li> <li>SDR config 9 \\&lt;-&gt; SDR config 9: 500 Mbps, 300 Mbps (simultaneously   two-way)</li> </ul> <p>General observation is that SDR boundedness checks (each write operation must ensure that the location where data is written is occupied by an object of the same size of the write operation) introduce about 11% of throughput degradation. Adding reversibility will substantially slow down the system since the reversibility, by default, saves transaction operations record in a file until the transaction is complete or until when the transaction is canceled and must be reversed. Although it is possible to store transaction record in ION's working memory, we didn't consider this case in our testing due to time constraint.</p>"},{"location":"ION-Deployment-Guide/#test-case-4-10gbps-physical-ethernet-study-with-2012-xeon-sandy-bridge","title":"Test Case 4: 10Gbps Physical Ethernet Study (with 2012 Xeon Sandy Bridge)","text":"<p>In this 10Gbps case study, we measured LTP performance between two machines physically connected by a 10Gbps Ethernet switch. Initial testing with iperf showed that although the physical connection was 10Gbps, the actual throughput maxed out at 2.5Gbps. Improved throughput was attained by increasing the kernel buffer sizes to 8MB. Additionally, increasing the MTU (Maximum Transmission Unit) size from 1500 to 9600 resolved some caching issues seen at the receiving node.</p> <p>UDP Configuration Details</p> <p>The following kernel buffer size settings were used to enable full utilization of the 10Gbps Ethernet on the host machine. These are provided for your reference. Depending on your host system's configuration, you may not need to adjust any parameters to make sure the full capacity of the Ethernet connection is achievable. Even in cases where you do find it necessary to make such adjustments, the actual parameters values may not be the same.</p> <ul> <li>net.core.rmem_max=16777216</li> <li>net.core.wmem_max=16777216</li> <li>net.core.rmem_default=8388608</li> <li>net.core.wmem_default=8388608</li> </ul> <p>To resolve the caching issue, which allows the LTP engine to clean up after the test quickly, we set the MTU to 9600. This is not strictly required but we find it helpful when the MTU is set to 9600 Bytes instead of the typical value of 1500 Bytes (we observed improved LTP session cleanup times with the higher MTU). After applying these updates, iperf testing showed 9.9Gbps throughput on the Ethernet connection between the two hosts.</p> <p>Test Network Details</p> <p>The test network consists of 2 host machines physically connected via 10 Gb Network Interface Card</p> <ul> <li>ION-IOS 4.1.2</li> <li>Ubuntu 22.04 LTS</li> </ul> <p>Hardware</p> <ul> <li>CPU: 16 Core 2.10 Ghz Xeon Sandy Bridge</li> <li>Memory: 128 GB</li> <li>NIC: 10 Gb/se[c]{.mark}</li> </ul> <p>ION Memory Configuration Details</p> <ul> <li>configFlags 1</li> <li>sdrWmSize 50000000</li> <li>wmSize 120000000</li> <li>heapWords 500000000</li> </ul> <p>LTP Configuration Details</p> <ul> <li>Initialization command: 1 50 (Note: 5 is more performant - see test   results for comparison)</li> <li>Max export sessions: 50 (Note: 5 is more performant - see test   results for comparison)</li> <li>Max import sessions: 50 (Note: 5 is more performant - see test   results for comparison)</li> <li>Max segment size: 64000</li> <li>Aggregation size limit: 128000</li> <li>maxber 0.000000001</li> <li>Contact plan transmission rate: 1342177280 (10 Gb)</li> </ul> <p>Throughput Measurement</p> <p>The first series of tests provided some insights into the impact of bundle size on throughput. In general, using a larger bundle size allows ION to transfer more data per logical operation since the overhead of a bundle is relatively fixed regardless of the size of the payload. In our tests, we controlled the size of all bundles injected into ION for LTP transfer. In real operations, bundle size will vary, but for bulk data transfer, the user is generally able to dictate the size of the bundle it sends. To avoid processing smaller bundles individually (which occurs in real operations), we turned on LTP block aggregation and set the size to 64KB.</p> <p>Figure 1: LTP Throughput as a Function of Bundle Size</p> <p></p> <p>In Figure 1, we can immediately observe that bundle size has a significant impact on LTP throughput. This is because the bundle is the basic unit of an LTP block. When LTP block aggregation is turned on, a block may consist of one or multiple bundles. When LTP block aggregation is not applied, each block is one bundle. When the bundle size is less than the aggregation size, LTP will accumulate several bundles before creating a block. While this will limit LTP overhead, the use of small bundles still has an impact on the bundle protocol level processing, both before LTP transmission and during post-LTP-reception reconstruction. Therefore, as we can see, when the bundle size is dropped below the LTP aggregation threshold, the throughput is still impacted by bundle size.</p> <p>While it may seem that the aggregation size limit does not have a strong impact on throughput, it does for long delay-bandwidth space links, where it dictates the maximum number of import/export sessions that ION must support simultaneously. That will be another investigation for a future study. For now, we focus solely on testing the limit of ION\\'s data processing speed in a low latency lab environment.</p> <p>We also conducted a second series of tests to look at the impact of LTP segment sizes on throughput. The results are in Figure 2 below.</p> <p>Figure 2: Impact of LTP Segment Size on Throughput</p> <p></p> <p>In this test, we looked at bundle sizes that are 1MB or lower, with segment sizes ranging from 64KB to 1,500 bytes. Again, we observed that segment size has a stronger impact on throughput when it is less than 10% of the bundle size; once it goes above 10%, the impact is noticeably diminished. This has to do with the fact that each segment levies a minimal amount of logical operation. Using a large segment size can help reduce LTP processing overhead. However, since the segment is LTP\\'s standard protocol data unit and it determines the vulnerability/likelihood of data loss (large segments expose more data to loss due to corruption), it is not advised to arbitrarily increase the segment size in a real flight environment with a substantial data loss probability. The key point here is to illustrate that the choice of segment size can impact the processing overhead and speed of LTP.</p>"},{"location":"ION-Deployment-Guide/#impact-of-variable-bundles-size","title":"Impact of variable bundles size","text":"<p>In real life operation, we expect the users to generate a wide mixture of large and small bundles. Although we don't have a commonly agreed on \"profile\" of how a typical DTN user will generate bundles, it is nonetheless valuable for us to get a sense of how BP/LTP in ION would perform when handling bundles of random sizes.</p> <p>For a quick study, we leveraged the same 2.1GHz Xeon Sandy Bridge processor configuration with 1MB LTP aggregation limit and injected bundles whose payload size is a uniformly distributed random value between 1024 bytes and 62464 bytes. We found that the throughput is approximately 260Mbps for segment size of 9600 B, and 300Mbps when segment size is increased to 64,000B. For the second test, we increased the bundle size ranges to be between 1KB and 1MB, the measured throughput is 2.08Gbps.</p> <p>This performance is higher than we expected. For the same amount of data delivery, using 1MB bundle vs an average of 31KB per bundle (uniform between 1K and 62K) would increase bundle process overhead by a factor of 32. Holding all other parameters constant, the 300Mbps throughput is only a factor of 9.6 lower compared to the 1MB bundle case with throughput of 2.9Gbps. The 32-fold increase of bundle overhead didn't result in a 32-fold reduction of speed. The reason for this better-than-expected result is, we believe, due to the use of LTP block aggregation. Similarly, for the second test, we increased the average bundle overhead by a factor 2, but the data rate reduction is only about 29 percent. By keeping the block aggregation to 1MB, we keep the number of LTP sessions and handshaking overhead low, which mitigated some of the impact of the presence of smaller bundles.</p> <p>Our initial assessment is that the mixed use of larger and smaller bundles will reduce throughput but not as substantially as one would expect based on a linear interpolation of the bundle processing overhead. The use of LTP block aggregation can maintain a higher efficiency under such circumstances. Additional investigation in this area will be conducted and reported in the near future.</p>"},{"location":"ION-Deployment-Guide/#summary-of-ltp-throughput-test-results","title":"Summary of LTP Throughput Test Results","text":"<p>We conducted a series of tests, documenting the performance of BP/LTP for a range of hardware and ION configuration options. At the lower end, we tested two stock Raspberry Pi 4B single-board computers running ION 4.1.2 and achieved 60 Mbps one-way data transfer without any hardware or OS optimization. At the higher end of our tests, we measured ION performance between two Linux servers (see spec in Test Case 4; 2012 era Xeon Sandy Bridge Processors) and showed that ION's BP/LTP implementation can support up to 3.7Gbps throughput over a 10Gbps Ethernet physical connection. We also presented a discussion on the performance trades regarding various LTP configuration parameters.</p> <p>We hope that these data points will provide users with a sense of how to configure ION, BP, and LTP to achieve the highest possible throughput on their own systems. We acknowledge that these tests focus on exploring the performance envelope of ION\\'s data processing speed and do not emulate specific flight configurations, nor do they cover long round-trip delay and high error rate space links. For specific link conditions and computing the recommended LTP settings, please consult the LTP Configuration Tool spreadsheet provided with each ION open-source package.</p>"},{"location":"ION-Deployment-Guide/#acknowledgment","title":"Acknowledgment","text":"<p>Some of the technology described in this Deployment Guide was developed at the Jet Propulsion Laboratory, California Institute of Technology, under a contract with the National Aeronautics and Space Administration.</p> <p>Copyright \u00a9 2021 California Institute of Technology</p> <p>The ION team would like to acknowledge the following individuals for contributed to the earlier versions of this Guide: Jane Marquart, NASA; Greg Menke, Columbus; Larry Shackelford, Microtel LLC; Scott Burleigh (retired), Jet Propulsion Laboratory, California Institute of Technology</p>"},{"location":"ION-Design-and-API-Overview/","title":"ION Design and API Overview","text":""},{"location":"ION-Design-and-API-Overview/#basic-philosophy","title":"Basic Philosophy","text":"<p>The development of ION began in the early 2000's, focusing on flight systems running Real-time Operating System (RTOS) with minimum resources under strict control. While these constraints might be somewhat relaxed for modern embedded systems, ION's lightweight, modular, and portable traits remain desirable to both flight and ground systems today:</p> <p>Hard Memory Allocation Limits: ION operates within a host-specified memory allocation, managing dynamic allocation internally via a private memory management system. This approach ensures efficient use of the allocated memory resources.</p> <p>Modular and Robust Operation: ION's design allows individual modules to start, stop, re-build, or possibly be replaced independently. This modular structure is implemented through separate daemons and libraries, enhancing system resilience. In a process crash, data in the process's queues/buffers can be preserved in the non-volatile SDR, preventing data loss.</p> <p>Efficient Resource Utilization: ION is optimized for environments with limited memory, storage, and processing resources. It avoids duplicate data copies during multi-stage processing by utilizing Zero-Copy Objects (ZCO) in shared memory space for fast hand-off between modules. This method, while more complex, ensures rapid data handling. Additionally, BP and CLA services operate as background daemons to minimize competition with critical spacecraft functions during nominal, high-stress, and off-nominal events.</p> <p>Independence from Native IP Socket Support: ION employs software abstraction to decouple socket-based programming from its core functionalities. This allows ION to interface the Bundle Protocol and CLAs with various underlying communication systems, such as CCSDS space links, radio communications systems, or customized processing chains that are not IP-based.</p> <p>Portability and Minimal Footprint for Static Linking: ION prioritizes portability and minimal resource footprint by building its function libraries. This approach supports static linking through the ION-core package for a specific set of modules. It reduces dependency on external libraries, thereby mitigating the risk of interference from unexercised or non-required code segments that cannot be removed from the libraries. This design also avoids potential compatibility issues between the target system\u2019s build environment and those of externally sourced libraries.</p>"},{"location":"ION-Design-and-API-Overview/#ion-modules","title":"ION Modules","text":"<p>The BP Service API document shows the default installation location of various libraries and daemons. Interactions with these daemons rely on various APIs made available through the libraries. The following diagram shows ION's modular architecture:</p> <p></p> <p>ION provides four application-layer services that utilize the underlying DTN protocols. These services are:</p> <ol> <li>AMS: Asynchronous Message Service</li> <li>DTPC: Delay-Tolerant Payload Conditioning</li> <li>CFDP: CCSDS File Delivery Protocol</li> <li>BSS: Bundle Streaming Service</li> </ol> <p>ION provides BP services based on Bundle Protocol v6 and Bundle Protocol v7, BPSec (Bundle Protocol Security), and the Interplanetary Internet (IPN) naming scheme. In addition, it offers several standardized convergence layer adaptors, namely:</p> <ol> <li>LTP: Licklider Transmission Protocol</li> <li>TCPCL: TCP Convergence Layer version 3</li> <li>UDPCL: UDP Convergence Layer</li> <li>STCP: Simplified TCP Convergence Layer</li> <li>DGR: Datagram Retransmission Convergence Layer</li> </ol> <p>ION also provides UDP-based Underlying Communication Protocol (UCP) to support testing of the LTP CLA in terrestrial systems.</p> <p>ION also supports the AMS (Asynchronous Management Architecture) by implementing both an Asynchronous Management Protocol (AMP) Agent and Manager and the associated Application Data Model (ADM) that describes both common and ION-specific DTN network management state information and commands.</p> <p>The entire ION software suite operates within a prescribed memory space. It is privately managed by ION's ICI infrastructure library functions for space allocation/deallocation, data I/O, and linked list and zero-copy object (ZCO) management. There are two types of data storage: working memory to facilitate data processing and heap in the SDR designed to store state information and data that should persist through a power cycle when implemented on a non-volatile storage medium. ION's APIs are exposed to the user through a set of C header files associated with each module's library.</p> <p></p>"},{"location":"ION-Design-and-API-Overview/#modular-packaging-ion-core","title":"Modular Packaging - ION Core","text":"<p>Due to the highly modular design of ION, it is possible to build a streamlined package that contains only the modules required for a specific system to maximize resource efficiency and reduce V&amp;V costs. ION-Core 4.1.2b package offers the ability to selectively build different sets of CLAs and bundle extensions blocks, targeting either 32-bit or 64-bit operating systems. </p>"},{"location":"ION-Design-and-API-Overview/#ion-apis","title":"ION APIs","text":"<p>For software development, ION provides several sets of APIs for interacting with services/daemons of the underlying DTN protocols, as shown below:</p> <p></p> <p>ION APIs can be roughly categorized as follows:</p> <ol> <li>BP Service API: This set of APIs enables an external application to interact with the BP service daemons to transmit and receive bundles through end-points using the IPN naming scheme.</li> <li>Convergence Layer API: This set of APIs enables developers to add custom convergence layer adaptors that can interact with BP Services to transmit and receive bundles between neighboring DTN nodes.</li> <li>Underlying Communications Protocol API: This set of APIs allows external software to transmit and receive data on behalf of LTP CLA.</li> <li>BP Extension Interface: This set of library functions provides a standard framework to add additional BP extension blocks to ION without modifying the core BP source code.</li> <li>Application Service API: These APIs are provided by AMS, CFDP, BSS, and DTPC modules of ION to deliver advanced capabilities such as messaging, file transfer, streaming data real-time and off-line playback, and in-order end-to-end delivery service to DTN applications.</li> <li>DTN Network Management API: These APIs enable external applications to interact with the AMP Managers to control and monitor local and remote ION nodes.</li> <li>Interplanetary Communication Infrastructure (ICI) API: This set of APIs performs basic administration, SDR &amp; private memory management, and platform portability translation for ION. This is the core set of APIs all software connected to ION utilize to maximize portability between OS and CPU architectures.</li> </ol>"},{"location":"ION-Guide/","title":"Interplanetary Overlay Network (ION) Design and Operation's Guide","text":"<p>Version 4.1.3 JPL D-48259</p> <p>Document Change Log</p> Ver No. Date Description Note V4.1.3 12/08/2023 converted to MarkDown V4.0.1 11/20/2020 ION 4.0.1 V3.6.2 11/19/2018 ION 3.6.2 release features Skipped V3.6.1. V3.6 12/31/2017 ION 3.6 release features Skipped V3.5. V3.4 3/28/2016 ION 3.4 release features V3.3 3/4/2015 ION 3.3 release features V3.2 12/17/2013 ION 3.2 release features V3.1 9/28/2012 ION 3.1 release features V3.0 3/22/2012 Align with ION 3.0 release V1.13 10/13/2011 Updates for Source Forge Release V1.12 6/11/2010 Updates for second open source release (2.2) V1.11 12/11/2009 BRS updates, multi-node config V1.10 10/23/2009 Final additions prior to DINET 2 experiment V1.9 6/29/2009 Add updates for DINET 2, including CFDP, ionsec V1.8 2/6/2009 Update discussion of Contact Graph Routing; document status msg formats V1.7 12/1/2008 Add documentation for OWLT simulator, BP extension V1.6 10/03/2008 Add documentation of sm_SemUnend V1.5 09/20/2008 Revisions requested SQA V1.4 07/31/2008 Add a section on optimizing ION-based network; tuning V1.3 07/08/2008 Revised some details of CGR V1.2 05/24/2008 Revised man pages for bptrace, ltprc, bprc. V1.1 05/18/2008 Some additional diagrams V1.0 04/28/2008 Initial version of ION design and ops manual"},{"location":"ION-Guide/#design","title":"Design","text":"<p>The Interplanetary Overlay Network (ION) software distribution is an implementation of Delay-Tolerant Networking (DTN) architecture as described in Internet RFC 4838. It is designed to enable inexpensive insertion of DTN functionality into embedded systems such as robotic spacecraft. The intent of ION deployment in space flight mission systems is to reduce cost and risk in mission communications by simplifying the construction and operation of automated digital data communication networks spanning space links, planetary surface links, and terrestrial links.</p> <p>A comprehensive overview of DTN is beyond the scope of this document. Very briefly, though, DTN is a digital communication networking technology that enables data to be conveyed between two communicating entities automatically and reliably even if one or more of the network links in the end-to-end path between those entities is subject to very long signal propagation latency and/or prolonged intervals of unavailability.</p> <p>The DTN architecture is much like the architecture of the Internet, except that it is one layer higher in the familiar ISO protocol \"stack\". The DTN analog to the Internet Protocol (IP), called \"Bundle Protocol\" (BP), is designed to function as an \"overlay\" network protocol that interconnects \"internets\" -- including both Internet-structured networks and also data paths that utilize only space communication links as defined by the Consultative Committee for Space Data Systems (CCSDS) -- in much the same way that IP interconnects \"subnets\" such as those built on Ethernet, SONET, etc. By implementing the DTN architecture, ION provides communication software configured as a protocol stack that looks like this:</p> <p></p> <p>Figure 1 DTN protocol stack</p> <p>Data traversing a DTN are conveyed in DTN bundles -- which are functionally analogous to IP packets -- between BP endpoints which are functionally analogous to sockets. Multiple BP endpoints may be accessed at a single DTN node -- functionally analogous to a network interface card -- and multiple nodes may reside on the same computer just as a single computer (host or router) in the Internet may have multiple network interface cards.</p> <p>BP endpoints are identified by Universal Record Identifiers (URIs), which are ASCII text strings of the general form:</p> <p>scheme_name:scheme_specific_part</p> <p>For example:</p> <p>dtn://topquark.caltech.edu/mail</p> <p>But for space flight communications this general textual representation might impose more transmission overhead than missions can afford. For this reason, ION is optimized for networks of endpoints whose IDs conform more narrowly to the following scheme:</p> <p>ipn:node_number.service_number</p> <p>This enables them to be abbreviated to pairs of unsigned binary integers via a technique called Compressed Bundle Header Encoding (CBHE). CBHE-conformant BP endpoint IDs (EIDs) are not only functionally similar to Internet socket addresses but also structurally similar: node numbers are roughly analogous to Internet node numbers (IP addresses), in that they typically identify the flight or ground data system computers on which network software executes, and service numbers are roughly analogous to TCP and UDP port numbers.</p> <p>More generally, the node numbers in CBHE-conformant BP endpoint IDs are one manifestation of the fundamental ION notion of network node number: in the ION architecture there is a natural one-to-one mapping not only between node numbers and BP endpoint node numbers but also between node numbers and:</p> <ul> <li>LTP engine IDs</li> <li>AMS continuum numbers</li> <li>CFDP entity numbers</li> </ul> <p>Starting with version 3.1 of ION, this endpoint naming rule is experimentally extended to accommodate bundle multicast, i.e., the delivery of copies of a single transmitted bundle to multiple nodes at which interest in that bundle's payload has been expressed. Multicast in ION -- \"Interplanetary Multicast\" (IMC) -- is accomplished by simply issuing a bundle whose destination endpoint ID conforms to the following scheme:</p> <p>imc:group_number.service_number</p> <p>A copy of the bundle will automatically be delivered at every node that has registered in the destination endpoint.</p> <p>(Note: for now, the operational significance of a given group number must be privately negotiated among ION users. If this multicast mechanism proves useful, IANA may at some point establish a registry for IMC group numbers. Also note that a new mechanism for bundle multicast is introduced in ION 4.0.1, along with support for Bundle Protocol version 7. This new mechanism vastly simplifies bundle multicast; chiefly, the imcadmin utility is deprecated.)</p>"},{"location":"ION-Guide/#structure-and-function","title":"Structure and function","text":"<p>The ION distribution comprises the following software packages:</p> <ul> <li>ici (Interplanetary Communication Infrastructure), a set of   general-purpose libraries providing common functionality to the   other packages. The ici package includes a security policy component   that supports the implementation of security mechanisms at multiple   layers of the protocol stack.</li> <li>ltp (Licklider Transmission Protocol), a core DTN protocol that   provides transmission reliability based on delay-tolerant   acknowledgments, timeouts, and retransmissions. The LTP   specification is defined in Internet RFC 5326.</li> <li>bp (Bundle Protocol), a core DTN protocol that provides   delay-tolerant forwarding of data through a network in which   continuous end-to-end connectivity is never assured, including   support for delay-tolerant dynamic routing. The BP specification is   defined in Internet RFC 5050.</li> <li>dgr (Datagram Retransmission), an alternative implementation of LTP   that is designed for use on the Internet. Equipped with algorithms   for TCP-like congestion control, DGR enables data to be transmitted   via UDP with reliability comparable to that provided by TCP. The dgr   system is provided primarily for the conveyance of Meta-AMS (see   below) protocol traffic in an Internet-like environment.</li> <li> <p>ams (Asynchronous Message Service), an application-layer service   that is not part of the DTN architecture but utilizes underlying DTN   protocols. AMS comprises three protocols supporting the distribution   of brief messages within a network:</p> </li> <li> <p>The core AAMS (Application AMS) protocol, which does message     distribution on both the publish/subscribe model and the     client/server model, as required by the application.</p> </li> <li>The MAMS (Meta-AMS) protocol, which distributes control     information enabling the operation of the Application AMS     protocol.</li> <li>The RAMS (Remote AMS) protocol, which performs aggregated     message distribution to end nodes that may be numerous and/or     accessible only over very expensive links, using an aggregation     tree structure similar to the distribution trees used by     Internet multicast technologies.</li> <li>cfdp (CCSDS File Delivery Protocol), another application-layer   service that is not part of the DTN architecture but utilizes   underlying DTN protocols. CFDP performs the segmentation,   transmission, reception, reassembly, and delivery of files in a   delay-tolerant manner. ION's implementation of CFDP conforms to the   \"class 1\" definition of the protocol in the CFDP standard, utilizing   DTN (BP, nominally over LTP) as its \"unitdata transport\" layer.</li> <li>bss (Bundle Streaming Service), a system for efficient data   streaming over a delay-tolerant network. The bss package   includes (a) a convergence-layer protocol (bssp) that preserves   in-order arrival of all data that were never lost en route, yet   ensures that all data arrive at the destination eventually, and (b)   a library for building delay-tolerant streaming applications, which   enables low-latency presentation of streamed data received in real   time while offering rewind/playback capability for the entire stream   including late-arriving retransmitted data.</li> <li>tc (Trusted Collective), a system for propagating critical yet   non-confidential information in a trustworthy manner. tc can be   thought of as a delay-tolerant functional analog to the servers in   client/server architectures. Multiple applications may make use of   the tc system, but currently only one tc application is bundled with   ION: dtka (delay-tolerant key administration), which provides   delay-tolerant public key infrastructure.</li> </ul> <p>Taken together, the packages included in the ION software distribution constitute a communication capability characterized by the following operational features:</p> <ul> <li>Reliable conveyance of data over a delay-tolerant network (dtnet),   i.e., a network in which it might never be possible for any node to   have reliable information about the detailed current state of any   other node.</li> <li>Built on this capability, reliable data streaming, reliable file   delivery, and reliable distribution of short messages to multiple   recipients (subscribers) residing in such a network.</li> <li> <p>Management of traffic through such a network, taking into   consideration:</p> </li> <li> <p>requirements for data security</p> </li> <li>scheduled times and durations of communication opportunities</li> <li>fluctuating limits on data storage and transmission resources</li> <li>data rate asymmetry</li> <li>the sizes of application data units</li> <li>and user-specified final destination, priority, and useful     lifetime for those data units.</li> <li>Facilities for monitoring the performance of the network.</li> <li>Robustness against node failure.</li> <li>Portability across heterogeneous computing platforms.</li> <li>High speed with low overhead.</li> <li>Easy integration with heterogeneous underlying communication   infrastructure, ranging from Internet to dedicated spacecraft   communication links.</li> </ul>"},{"location":"ION-Guide/#constraints-on-the-design","title":"Constraints on the Design","text":"<p>A DTN implementation intended to function in an interplanetary network environment -- specifically, aboard interplanetary research spacecraft separated from Earth and from one another by vast distances -- must operate successfully within two general classes of design constraints: link constraints and processor constraints.</p> <ol> <li>Link constraints</li> </ol> <p>All communications among interplanetary spacecraft are, obviously, wireless. Less obviously, those wireless links are generally slow and are usually asymmetric.</p> <p>The electrical power provided to on-board radios is limited and antennae are relatively small, so signals are weak. This limits the speed at which data can be transmitted intelligibly from an interplanetary spacecraft to Earth, usually to some rate on the order of 256 Kbps to 6 Mbps.</p> <p>The electrical power provided to transmitters on Earth is certainly much greater, but the sensitivity of receivers on spacecraft is again constrained by limited power and antenna mass allowances. Because historically the volume of command traffic that had to be sent to spacecraft was far less than the volume of telemetry the spacecraft were expected to return, spacecraft receivers have historically been engineered for even lower data rates from Earth to the spacecraft, on the order of 1 to 2 Kbps.</p> <p>As a result, the cost per octet of data transmission or reception is high and the links are heavily subscribed. Economical use of transmission and reception opportunities is therefore important, and transmission is designed to enable useful information to be obtained from brief communication opportunities: units of transmission are typically small, and the immediate delivery of even a small part (carefully delimited) of a large data object may be preferable to deferring delivery of the entire object until all parts have been acquired.</p> <ol> <li>Processor constraints</li> </ol> <p>The computing capability aboard a robotic interplanetary spacecraft is typically quite different from that provided by an engineering workstation on Earth. In part this is due, again, to the limited available electrical power and limited mass allowance within which a flight computer must operate. But these factors are exacerbated by the often intense radiation environment of deep space. In order to minimize errors in computation and storage, flight processors must be radiation-hardened and both dynamic memory and non-volatile storage (typically flash memory) must be radiation-tolerant. The additional engineering required for these adaptations takes time and is not inexpensive, and the market for radiation-hardened spacecraft computers is relatively small; for these reasons, the latest advances in processing technology are typically not available for use on interplanetary spacecraft, so flight computers are invariably slower than their Earth-bound counterparts. As a result, the cost per processing cycle is high and processors are heavily subscribed; economical use of processing resources is very important.</p> <p>The nature of interplanetary spacecraft operations imposes a further constraint. These spacecraft are wholly robotic and are far beyond the reach of mission technicians; hands-on repairs are out of the question. Therefore the processing performed by the flight computer must be highly reliable, which in turn generally means that it must be highly predictable. Flight software is typically required to meet \"hard\" real-time processing deadlines, for which purpose it must be run within a hard real-time operating system (RTOS).</p> <p>One other implication of the requirement for high reliability in flight software is that the dynamic allocation of system memory may be prohibited except in certain well-understood states, such as at system start-up. Unrestrained dynamic allocation of system memory introduces a degree of unpredictability into the overall flight system that can threaten the reliability of the computing environment and jeopardize the health of the vehicle.</p>"},{"location":"ION-Guide/#design-principles","title":"Design Principles","text":"<p>The design of the ION software distribution reflects several core principles that are intended to address these constraints.</p> <p></p> <p>Figure 2 ION inter-task communication</p> <ol> <li>Shared memory</li> </ol> <p>Since ION must run on flight processors, it had to be designed to function successfully within an RTOS. Many real-time operating systems improve processing determinism by omitting the support for protected-memory models that is provided by Unix-like operating systems: all tasks have direct access to all regions of system memory. (In effect, all tasks operate in kernel mode rather than in user mode.) ION therefore had to be designed with no expectation of memory protection.</p> <p>But universally shared access to all memory can be viewed not only as a hazard but also as an opportunity. Placing a data object in shared memory is an extremely efficient means of passing data from one software task to another.</p> <p>ION is designed to exploit this opportunity as fully as possible. In particular, virtually all inter-task data interchange in ION follows the model shown in Figure 2:</p> <ul> <li>The sending task takes a mutual exclusion semaphore (mutex)   protecting a linked list in shared memory (either DRAM or   non-volatile memory), appends a data item to the list, releases the   mutex, and gives a \"signal\" semaphore associated with the list to   announce that the list is now non-empty.</li> <li>The receiving task, which is already pending on the linked list's   associated signal semaphore, resumes execution when the semaphore is   given. It takes the associated mutex, extracts the next data item   from the list, releases the mutex, and proceeds to operate on the   data item from the sending task.</li> </ul> <p>Semaphore operations are typically extremely fast, as is the storage and retrieval of data in memory, so this inter-task data interchange model is suitably efficient for flight software.</p> <ol> <li>Zero-copy procedures</li> </ol> <p>Given ION's orientation toward the shared memory model, a further strategy for processing efficiency offers itself: if the data item appended to a linked list is merely a pointer to a large data object, rather than a copy, then we can further reduce processing overhead by eliminating the cost of byte-for-byte copying of large objects.</p> <p>Moreover, in the event that multiple software elements need to access the same large object at the same time, we can provide each such software element with a pointer to the object rather than its own copy (maintaining a count of references to assure that the object is not destroyed until all elements have relinquished their pointers). This serves to reduce somewhat the amount of memory needed for ION operations.</p> <ol> <li>Highly distributed processing</li> </ol> <p>The efficiency of inter-task communications based on shared memory makes it practical to distribute ION processing among multiple relatively simple pipelined tasks rather than localize it in a single, somewhat more complex daemon. This strategy has a number of advantages:</p> <ul> <li>The simplicity of each task reduces the sizes of the software   modules, making them easier to understand and maintain, and thus it   can somewhat reduce the incidence of errors.</li> <li>The scope of the ION operating stack can be adjusted incrementally   at run time, by spawning or terminating instances of configurable   software elements, without increasing the size or complexity of any   single task and without requiring that the stack as a whole be   halted and restarted in a new configuration. In theory, a module   could even be upgraded with new functionality and integrated into   the stack without interrupting operations.</li> <li> <p>The clear interfaces between tasks simplify the implementation of   flow control measures to prevent uncontrolled resource consumption.</p> </li> <li> <p>Portability</p> </li> </ul> <p>Designs based on these kinds of principles are foreign to many software developers, who may be far more comfortable in development environments supported by protected memory. It is typically much easier, for example, to develop software in a Linux environment than in VxWorks 5.4. However, the Linux environment is not the only one in which ION software must ultimately run.</p> <p>Consequently, ION has been designed for easy portability. POSIX\u2122 API functions are widely used, and differences in operating system support that are not concealed within the POSIX abstractions are mostly encapsulated in two small modules of platform-sensitive ION code. The bulk of the ION software runs, without any source code modification whatsoever, equally well in Linux\u2122 (Red Hat\u00ae, Fedora\u2122, and Ubuntu\u2122, so far), FreeBSD\u00ae, Solaris\u00ae 9, Microsoft Windows (the MinGW environment), OS/X\u00ae, VxWorks\u00ae 5.4, and RTEMS\u2122, on both 32-bit and 64-bit processors. Developers may compile and test ION modules in whatever environment they find most convenient.</p>"},{"location":"ION-Guide/#organizational-overview","title":"Organizational Overview","text":"<p>Two broad overviews of the organization of ION may be helpful at this point. First, here is a summary view of the main functional dependencies among ION software elements:</p> <p></p> <p>Figure 3 ION software functional dependencies</p> <p>That is, BP and LTP invoke functions provided by the sdr, zco, psm, and platform elements of the ici package, in addition to functions provided by the operating system itself; the zco functions themselves also invoke sdr, psm, and platform functions; and so on.</p> <p>Second, here is a summary view of the main line of data flow in ION's DTN protocol implementations:</p> <p></p> <p>Figure 4 Main line of ION data flow</p> <p>Note that data objects residing in shared memory, many of them in a nominally non-volatile SDR data store, constitute the central organizing principle of the design. Here as in other diagrams showing data flow in this document:</p> <ul> <li>Ordered collections of data objects are shown as cylinders.</li> <li>Darker greyscale data entities indicate data that are managed in the   SDR data store, while lighter greyscale data entities indicate data   that are managed in volatile DRAM to improve performance.</li> <li>Rectangles indicate processing elements (tasks, processes, threads),   sometimes with library references specifically identified.</li> </ul> <p>A few notes on this main line data flow:</p> <ul> <li>For simplicity, the data flow depicted here is a \"loopback\" flow in   which a single BP \"node\" is shown sending data to itself (a useful   configuration for test purposes). To depict typical operations over   a network we would need two instances of this node diagram, such   that the \\&lt;LSO&gt; task of one node is shown sending data to the   \\&lt;LSI&gt; task of the other and vice versa.</li> <li>A BP application or application service (such as Remote AMS) that   has access to the local BP node -- for our purposes, the \"sender\" --   invokes the bp_send function to send a unit of application data to a   remote counterpart. The destination of the application data unit is   expressed as a BP endpoint ID (EID). The application data unit is   encapsulated in a bundle and is queued for forwarding.</li> <li>The forwarder task identified by the \"scheme\" portion of the   bundle's destination EID removes the bundle from the forwarding   queue and computes a route to the destination EID. The first node on   the route is termed the \"proximate node\" for the computed route. The   forwarder appends the bundle to the transmission queue for the   convergence-layer manager (CLM) daemon that is responsible for   transmission to the proximate node.</li> <li>The CLM daemon removes the bundle from the transmission queue and   imposes rate control, fragments the bundle as necessary, and appends   the bundle to the transmission buffer for some underlying   \"convergence layer\" (CL) protocol interface to the proximate node,   termed an outduct. In the event that multiple outducts are   available for transmission to that node (e.g., multiple radio   frequency bands), the CLM invokes mission-supplied code to select   the appropriate duct. Each outduct is serviced by some CL-specific   output task that communicates with the proximate node -- in this   case, the LTP output task ltpclo. (Other CL protocols supported   by ION include TCP and UDP.)</li> <li>The output task for LTP transmission to the selected proximate node   removes the bundle from the transmission buffer and invokes the   ltp_send function to append it to a block that is being assembled   for transmission to the proximate node. (Because LTP acknowledgement   traffic is issued on a per-block basis, we can limit the amount of   acknowledgement traffic on the network by aggregating multiple   bundles into a single block rather than transmitting each bundle in   its own block.)</li> <li>The ltpmeter task for the selected proximate node divides the   aggregated block into multiple segments and enqueues them for   transmission by underlying link-layer transmission software, such as   an implementation of the CCSDS AOS protocol.</li> <li>Underlying link-layer software at the sending node transmits the   segments to its counterpart at the proximate node (the receiver),   where they are used to reassemble the transmission block.</li> <li>The receiving node's input task for LTP reception extracts the   bundles from the reassembled block and dispatches them: each bundle   whose final destination is some other node is queued for forwarding,   just like bundles created by local applications, while each bundle   whose final destination is the local node is queued for delivery to   whatever application \"opens\" the BP endpoint identified by the   bundle's final destination endpoint ID. (Note that a multicast   bundle may be both queued for forwarding, possibly to multiple   neighboring nodes, and also queued for delivery.)</li> <li>The destination application or application service at the receiving   node opens the appropriate BP endpoint and invokes the bp_receive   function to remove the bundle from the associated delivery queue and   extract the original application data unit, which it can then   process.</li> </ul> <p>Finally, note that the data flow shown here represents the sustained operational configuration of a node that has been successfully instantiated on a suitable computer. The sequence of operations performed to reach this configuration is not shown. That startup sequence will necessarily vary depending on the nature of the computing platform and the supporting link services. Broadly, the first step normally is to run the ionadmin utility program to initialize the data management infrastructure required by all elements of ION. Following this initialization, the next steps normally are (a) any necessary initialization of link service protocols, (b) any necessary initialization of convergence-layer protocols (e.g., LTP -- the ltpadmin utility program), and finally (c) initialization of the Bundle Protocol by means of the bpadmin utility program. BP applications should not try to commence operation until BP has been initialized.</p>"},{"location":"ION-Guide/#resource-management-in-ion","title":"Resource Management in ION","text":"<p>Successful Delay-Tolerant Networking relies on retention of bundle protocol agent state information -- including protocol traffic that is awaiting a transmission opportunity -- for potentially lengthy intervals. The nature of that state information will fluctuate rapidly as the protocol agent passes through different phases of operation, so efficient management of the storage resources allocated to state information is a key consideration in the design of ION.</p> <p>Two general classes of storage resources are managed by ION: volatile \"working memory\" and non-volatile \"heap\".</p> <ol> <li>Working Memory</li> </ol> <p>ION's \"working memory\" is a fixed-size pool of shared memory (dynamic RAM) that is allocated from system RAM at the time the bundle protocol agent commences operation. Working memory is used by ION tasks to store temporary data of all kinds: linked lists, red-black trees, transient buffers, volatile databases, etc. All intermediate data products and temporary data structures that ought not to be retained in the event of a system power cycle are written to working memory.</p> <p>Data structures residing in working memory may be shared among ION tasks or may be created and managed privately by individual ION tasks. The dynamic allocation of working memory to ION tasks is accomplished by the Personal Space Management (PSM) service, described later. All of the working memory for any single ION bundle protocol agent is managed as a single PSM \"partition\". The size of the partition is specified in the wmSize parameter of the ionconfig file supplied at the time ION is initialized.</p> <ol> <li>Heap</li> </ol> <p>ION's \"heap\" is a fixed-size pool of notionally non-volatile storage that is likewise allocated at the time the bundle protocol agent commences operation. This notionally non-volatile space may occupy a fixed-size pool of shared memory (dynamic RAM, which might or might not be battery-backed), or it may occupy only a single fixed-size file in the file system, or it may occupy both. In the latter case, all heap data are written both to memory and to the file but are read only from memory; this configuration offers the reliable non-volatility of file storage coupled with the high performance of retrieval from dynamic RAM.</p> <p>We characterize ION's heap storage as \"notionally\" non-volatile because the heap may be configured to reside only in memory (or, for that matter, in a file that resides in the file system of a RAM disk). When the heap resides only in memory, its contents are truly non-volatile only if that memory is battery-backed. Otherwise heap storage is in reality as volatile as working memory: heap contents will be lost upon a system power cycle (which may in fact be the preferred behavior for any given deployment of ION). However, the heap should not be thought of as \\\"memory\\\" even when it in fact resides only in DRAM, just as a disk device should not be thought of as \\\"memory\\\" even when it is in fact a RAM disk.</p> <p>{width=\"4.738575021872266in\" height=\"3.338542213473316in\"}</p> <p>Figure 5 ION heap space use</p> <p>The ION heap is used for storage of data that (in at least some deployments) would have to be retained in the event of a system power cycle to ensure the correct continued operation of the node. For example, all queues of bundles awaiting route computation, transmission, or delivery reside in the node's heap. So do the non-volatile databases for all of the protocols implemented within ION, together with all of the node's persistent configuration parameters.</p> <p>The dynamic allocation of heap space to ION tasks is accomplished by the Simple Data Recorder (SDR) service, described later. The entire heap for any single ION bundle protocol agent is managed as a single SDR \"data store\".</p> <p>Space within the ION heap is apportioned as shown in Figure 5. The total number of bytes of storage space in the heap is computed as the product of the size of a \"word\" on the deployment platform (normally the size of a pointer) multiplied by the value of the heapWords parameter of the ionconfig file supplied at the time ION is initialized. Of this total, 20% is normally reserved as margin and another 40% is normally reserved for various infrastructure operations. (Both of these percentages are macros that may be overridden at compile time.) The remainder is available for storage of protocol state data in the form of \"zero-copy objects\", described later. At any given moment, the data encapsulated in a zero-copy object may \"belong\" to any one of the protocols in the ION stack (AMS, CFDP, BP, LTP), depending on processing state; the available heap space is a single common resource to which all of the protocols share concurrent access.</p> <p>Because the heap is used to store queues of bundles awaiting processing, blocks of LTP data awaiting transmission or reassembly, etc., the heap for any single ION node must be large enough to contain the maximum volume of such data that the node will be required to retain during operations. Demand for heap space is substantially mitigated if most of the application data units passed to ION for transmission are file-resident, as the file contents themselves need not be copied into the heap. In general, however, computing the optimum ION heap size for a given deployment remains a research topic.</p>"},{"location":"ION-Guide/#package-overviews","title":"Package Overviews","text":""},{"location":"ION-Guide/#interplanetary-communication-infrastructure-ici","title":"Interplanetary Communication Infrastructure (ICI)","text":"<p>The ICI package in ION provides a number of core services that, from ION's point of view, implement what amounts to an extended POSIX-based operating system. ICI services include the following:</p> <p>1. Platform</p> <p>The platform system contains operating-system-sensitive code that enables ICI to present a single, consistent programming interface to those common operating system services that multiple ION modules utilize. For example, the platform system implements a standard semaphore abstraction that may invisibly be mapped to underlying POSIX semaphores, SVR4 IPC semaphores, Windows Events, or VxWorks semaphores, depending on which operating system the package is compiled for. The platform system also implements a standard shared-memory abstraction, enabling software running on operating systems both with and without memory protection to participate readily in ION's shared-memory-based computing environment.</p> <p>2. Personal Space Management (PSM)</p> <p>Although sound flight software design may prohibit the uncontrolled dynamic management of system memory, private management of assigned, fixed blocks of system memory is standard practice. Often that private management amounts to merely controlling the reuse of fixed-size rows in static tables, but such techniques can be awkward and may not make the most efficient use of available memory. The ICI package provides an alternative, called PSM, which performs high-speed dynamic allocation and recovery of variable-size memory objects within an assigned memory block of fixed size. A given PSM-managed memory block may be either private or shared memory.</p> <p>3. Memmgr</p> <p>The static allocation of privately-managed blocks of system memory for different purposes implies the need for multiple memory management regimes, and in some cases a program that interacts with multiple software elements may need to participate in the private shared-memory management regimes of each. ICI's memmgr system enables multiple memory managers -- for multiple privately-managed blocks of system memory -- to coexist within ION and be concurrently available to ION software elements.</p> <p>4. Lyst</p> <p>The lyst system is a comprehensive, powerful, and efficient system for managing doubly-linked lists in private memory. It is the model for a number of other list management systems supported by ICI; as noted earlier, linked lists are heavily used in ION inter-task communication.</p> <p>5. Llcv</p> <p>The llcv (Linked-List Condition Variables) system is an inter-thread communication abstraction that integrates POSIX thread condition variables (vice semaphores) with doubly-linked lists in private memory.</p> <p>6. Smlist</p> <p>Smlist is another doubly-linked list management service. It differs from lyst in that the lists it manages reside in shared (rather than private) DRAM, so operations on them must be semaphore-protected to prevent race conditions.</p> <p>7. SmRbt</p> <p>The SmRbt service provides mechanisms for populating and navigating \"red/black trees\" (RBTs) residing in shared DRAM. RBTs offer an alternative to linked lists: like linked lists they can be navigated as queues, but locating a single element of an RBT by its \"key\" value can be much quicker than the equivalent search through an ordered linked list.</p> <p>8. Simple Data Recorder (SDR)</p> <p>SDR is a system for managing non-volatile storage, built on exactly the same model as PSM. Put another way, SDR is a small and simple \"persistent object\" system or \"object database\" management system. It enables straightforward management of linked lists (and other data structures of arbitrary complexity) in non-volatile storage, notionally within a single file whose size is pre-defined and fixed.</p> <p>SDR includes a transaction mechanism that protects database integrity by ensuring that the failure of any database operation will cause all other operations undertaken within the same transaction to be backed out. The intent of the system is to assure retention of coherent protocol engine state even in the event of an unplanned flight computer reboot in the midst of communication activity.</p> <p>9. Sptrace</p> <p>The sptrace system is an embedded diagnostic facility that monitors the performance of the PSM and SDR space management systems. It can be used, for example, to detect memory \"leaks\" and other memory management errors.</p> <p>10. Zco</p> <p>ION's zco (zero-copy objects) system leverages the SDR system's storage flexibility to enable user application data to be encapsulated in any number of layers of protocol without copying the successively augmented protocol data unit from one layer to the next. It also implements a reference counting system that enables protocol data to be processed safely by multiple software elements concurrently -- e.g., a bundle may be both delivered to a local endpoint and, at the same time, queued for forwarding to another node -- without requiring that distinct copies of the data be provided to each element.</p> <p>11. Rfx</p> <p>The ION rfx (R/F Contacts) system manages lists of scheduled communication opportunities in support of a number of LTP and BP functions.</p> <p>12. Ionsec</p> <p>The IONSEC (ION security) system manages information that supports the implementation of security mechanisms in the other packages: security policy rules and computation keys.</p>"},{"location":"ION-Guide/#licklider-transmission-protocol-ltp","title":"Licklider Transmission Protocol (LTP)","text":"<p>The ION implementation of LTP conforms fully to RFC 5326, but it also provides two additional features that enhance functionality without affecting interoperability with other implementations:</p> <ul> <li>The service data units -- nominally bundles -- passed to LTP for   transmission may be aggregated into larger blocks before   segmentation. By controlling block size we can control the volume of   acknowledgement traffic generated as blocks are received, for   improved accommodation of highly asynchronous data rates.</li> <li>The maximum number of transmission sessions that may be concurrently   managed by LTP (a protocol control parameter) constitutes a   transmission \"window\" -- the basis for a delay-tolerant,   non-conversational flow control service over interplanetary links.</li> </ul> <p>In the ION stack, LTP serves effectively the same role that is performed by an LLC protocol (such as IEEE 802.2) in the Internet architecture, providing flow control and retransmission-based reliability between topologically adjacent bundle protocol agents.</p> <p>All LTP session state is safely retained in the ION heap for rapid recovery from a spacecraft or software fault.</p>"},{"location":"ION-Guide/#bundle-protocol-bp","title":"Bundle Protocol (BP)","text":"<p>The ION implementation of BP conforms fully to RFC 5050, including support for the following standard capabilities:</p> <ul> <li>Prioritization of data flows</li> <li>Proactive bundle fragmentation</li> <li>Bundle reassembly from fragments</li> <li>Flexible status reporting</li> <li>Custody transfer, including re-forwarding of custodial bundles upon   timeout interval expiration or failure of nominally reliable   convergence-layer transmission</li> </ul> <p>The system also provides three additional features that enhance functionality without affecting interoperability with other implementations:</p> <ul> <li>Rate control provides support for congestion forecasting and   avoidance.</li> <li>Bundle headers are encoded into compressed form (CBHE, as noted   earlier) before issuance, to reduce protocol overhead and improve   link utilization.</li> <li>Bundles may be \"multicast\" to all nodes that have registered within   a given multicast group endpoint.</li> </ul> <p>In addition, ION BP includes a system for computing dynamic routes through time-varying network topology assembled from scheduled, bounded communication opportunities. This system, called \"Contact Graph Routing,\" is described later in this Guide.</p> <p>In short, BP serves effectively the same role that is performed by IP in the Internet architecture, providing route computation, forwarding, congestion avoidance, and control over quality of service.</p> <p>All bundle transmission state is safely retained in the ION heap for rapid recovery from a spacecraft or software fault.</p>"},{"location":"ION-Guide/#asynchronous-message-service-ams","title":"Asynchronous Message Service (AMS)","text":"<p>The ION implementation of the CCSDS AMS standard conforms fully to CCSDS 735.0-B-1. AMS is a data system communications architecture under which the modules of mission systems may be designed as if they were to operate in isolation, each one producing and consuming mission information without explicit awareness of which other modules are currently operating. Communication relationships among such modules are self-configuring; this tends to minimize complexity in the development and operations of modular data systems.</p> <p>A system built on this model is a \"society\" of generally autonomous inter-operating modules that may fluctuate freely over time in response to changing mission objectives, modules' functional upgrades, and recovery from individual module failure. The purpose of AMS, then, is to reduce mission cost and risk by providing standard, reusable infrastructure for the exchange of information among data system modules in a manner that is simple to use, highly automated, flexible, robust, scalable, and efficient.</p> <p>A detailed discussion of AMS is beyond the scope of this Design Guide. For more information, please see the AMS Programmer's Guide.</p>"},{"location":"ION-Guide/#datagram-retransmission-dgr","title":"Datagram Retransmission (DGR)","text":"<p>The DGR package in ION is an alternative implementation of LTP that is designed to operate responsibly -- i.e., with built-in congestion control -- in the Internet or other IP-based networks running UDP. It is provided as a candidate \"primary transfer service\" in support of AMS operations in an Internet-like (non-delay-tolerant) environment. The DGR design combines LTP's concept of concurrent transmission transactions with congestion control and timeout interval computation algorithms adapted from TCP. DGR includes an adaptive timeout-interval-computing component that provides maximum opportunity for reception of acknowledgements, minimizing retransmission.  By monitoring changes in the rate at which message-transmission transactions  are completed, DGR detects changes in the level of congestion and  responds by imposing varying degrees of delay on the transmission of  new messages. In addition, DGR maximizes throughput by not waiting  for acknowledgement of a message before sending the next message. All  DGR communication is asynchronous, to maximize efficient utilization of  network connections. DGR manages multiple concurrent datagram transmission  and acknowledgement conversations.</p>"},{"location":"ION-Guide/#ccsds-file-delivery-protocol-cfdp","title":"CCSDS File Delivery Protocol (CFDP)","text":"<p>The ION implementation of CFDP conforms fully to Service Class 1 (Unreliable Transfer) of CCSDS 727.0-B-4, including support for the following standard capabilities:</p> <ul> <li>Segmentation of files on user-specified record boundaries.</li> <li>Transmission of file segments in protocol data units that are   conveyed by an underlying Unitdata Transfer service, in this case   the DTN protocol stack. File data segments may optionally be   protected by CRCs. When the DTN protocol stack is configured for   reliable data delivery (i.e., with BP custody transfer running over   a reliable convergence-layer protocol such as LTP), file delivery is   reliable; CFDP need not perform retransmission of lost data itself.</li> <li>Reassembly of files from received segments, possibly arriving over a   variety of routes through the delay-tolerant network. The integrity   of the delivered files is protected by checksums.</li> <li>User-specified fault handling procedures.</li> <li>Operations (e.g., directory creation, file renaming) on remote file   systems.</li> </ul> <p>All CFDP transaction state is safely retained in the ION heap for rapid recovery from a spacecraft or software fault.</p>"},{"location":"ION-Guide/#bundle-streaming-service-bss","title":"Bundle Streaming Service (BSS)","text":"<p>The BSS service provided in ION enables a stream of video, audio, or other continuously generated application data units, transmitted over a delay-tolerant network, to be presented to a destination application in two useful modes concurrently:</p> <ul> <li>In the order in which the data units were generated, with the least   possible end-to-end delivery latency, but possibly with some gaps   due to transient data loss or corruption.</li> <li>In the order in which the data units were generated, without gaps   (i.e., including lost or corrupt data units which were omitted from   the real-time presentation but were subsequently retransmitted), but   in a non-real-time \"playback\" mode.</li> </ul>"},{"location":"ION-Guide/#trusted-collective-tc","title":"Trusted Collective (TC)","text":"<p>The TC service provided in ION enables critical but non-confidential information (such as public keys, for asymmetric cryptography) to be provided in a delay-tolerant, trustworthy manner. An instance of TC comprises:</p> <ul> <li>A distributed Authority, the members of which must reach consensus   on database content and must collaborate on the proactive   distribution of that content.</li> <li> <p>Any number of Clients, which:</p> </li> <li> <p>Announce new content to the Authority via authenticated bundle     multicast, and/or</p> </li> <li>Receive trustworthy bulletins multicast by the members of the     Authority.</li> </ul>"},{"location":"ION-Guide/#acronyms","title":"Acronyms","text":"Acronyms Description BP Bundle Protocol BSP Bundle Security Protocol BSS Bundle Streaming Service CCSDS Consultative Committee for Space Data Systems CFDP CCSDS File Delivery Protocol CGR Contact Graph Routing CL convergence layer CLI convergence layer input CLO convergence layer output DTKA Delay-Tolerant Key Administration DTN Delay-Tolerant Networking ICI Interplanetary Communication Infrastructure ION Interplanetary Overlay Network LSI link service input LSO link service output LTP Licklider Transmission Protocol OWLT one-way light time RFC request for comments RFX Radio (R/F) Contacts RTT round-trip time TC Trusted Collective TTL time to live"},{"location":"ION-Guide/#network-operation-concepts","title":"Network Operation Concepts","text":"<p>A small number of network operation design elements -- fragmentation and reassembly, bandwidth management, and delivery assurance (retransmission) -- can potentially be addressed at multiple layers of the protocol stack, possibly in different ways for different reasons. In stack design it's important to allocate this functionality carefully so that the effects at lower layers complement, rather than subvert, the effects imposed at higher layers of the stack. This allocation of functionality is discussed below, together with a discussion of several related key concepts in the ION design.</p>"},{"location":"ION-Guide/#fragmentation-and-reassembly","title":"Fragmentation and Reassembly","text":"<p>To minimize transmission overhead and accommodate asymmetric links (i.e., limited \"uplink\" data rate from a ground data system to a spacecraft) in an interplanetary network, we ideally want to send \"downlink\" data in the largest possible aggregations -- coarse-grained transmission.</p> <p>But to minimize head-of-line blocking (i.e., delay in transmission of a newly presented high-priority item) and minimize data delivery latency by using parallel paths (i.e., to provide fine-grained partial data delivery, and to minimize the impact of unexpected link termination), we want to send \"downlink\" data in the smallest possible aggregations -- fine-grained transmission.</p> <p>We reconcile these impulses by doing both, but at different layers of the ION protocol stack.</p> <p>First, at the application service layer (AMS and CFDP) we present relatively small application data units (ADUs) -- on the order of 64 KB -- to BP for encapsulation in bundles. This establishes an upper bound on head-of-line blocking when bundles are de-queued for transmission, and it provides perforations in the data stream at which forwarding can readily be switched from one link (route) to another, enabling partial data delivery at relatively fine, application-appropriate granularity.</p> <p>(Alternatively, large application data units may be presented to BP and the resulting large bundles may be proactively fragmented at the time they are presented to the convergence-layer manager. This capability is meant to accommodate environments in which the convergence-layer manager has better information than the application as to the optimal bundle size, such as when the residual capacity of a contact is known to be less than the size of the bundle.)</p> <p>Then, at the BP/LTP convergence layer adapter lower in the stack, we aggregate these small bundles into blocks for presentation to LTP:</p> <p>Any continuous sequence of bundles that are to be shipped to the same LTP engine and all require assured delivery may be aggregated into a single block, to reduce overhead and minimize report traffic.</p> <p>However, this aggregation is constrained by an aggregation size limit rule: aggregation must stop and the block must be transmitted as soon as the sum of the sizes of all bundles aggregated into the block exceeds the block aggregation threshhold value declared for the applicable span (the relationship between the local node's LTP engine and the receiving LTP engine) during LTP protocol configuration via ltpadmin.</p> <p>Given a preferred block acknowledgment period -- e.g., a preferred acknowledgement traffic rate of one report per second -- the nominal block aggregation threshold is notionally computed as the amount of data that can be sent over the link to the receiving LTP engine in a single block acknowledgment period at the planned outbound data rate to that engine.</p> <p>Taken together, application-level fragmentation (or BP proactive fragmentation) and LTP aggregation place an upper limit on the amount of data that would need to be re-transmitted over a given link at next contact in the event of an unexpected link termination that caused delivery of an entire block to fail. For example, if the data rate is 1 Mbps and the nominal block size is 128 KB (equivalent to 1 second of transmission time), we would prefer to avoid the risk of having wasted five minutes of downlink in sending a 37.5 MB file that fails on transmission of the last kilobyte, forcing retransmission of the entire 37.5 MB. We therefore divide the file into, say, 1200 bundles of 32 KB each which are aggregated into blocks of 128 KB each: only a single block failed, so only that block (containing just 4 bundles) needs to be retransmitted. The cost of this retransmission is only 1 second of link time rather than 5 minutes. By controlling the cost of convergence-layer protocol failure in this way, we avoid the overhead and complexity of \"reactive fragmentation\" in the BP implementation.</p> <p>Finally, within LTP itself we fragment the block as necessary to accommodate the Maximum Transfer Unit (MTU) size of the underlying link service, typically the transfer frame size of the applicable CCSDS link protocol.</p>"},{"location":"ION-Guide/#bandwidth-management","title":"Bandwidth Management","text":"<p>The allocation of bandwidth (transmission opportunity) to application data is requested by the application task that's passing data to DTN, but it is necessarily accomplished only at the lowest layer of the stack at which bandwidth allocation decisions can be made -- and then always in the context of node policy decisions that have global effect.</p> <p>The transmission queue interface to a given neighbor in the network is actually three queues of outbound bundles rather than one: one queue for each of the defined levels of priority (\"class of service\") supported by BP. When an application presents an ADU to BP for encapsulation in a bundle, it indicates its own assessment of the ADU's priority. Upon selection of a proximate forwarding destination node for that bundle, the bundle is appended to whichever of the queues corresponds to the ADU's priority.</p> <p>Normally the convergence-layer manager (CLM) task servicing a given proximate node extracts bundles in strict priority order from the heads of the three queues. That is, the bundle at the head of the highest-priority non-empty queue is always extracted.</p> <p>However, if the ION_BANDWIDTH_RESERVED compiler option is selected at the time ION is built, the convergence-layer manager task servicing a given proximate node extracts bundles in interleaved fashion from the heads of the node's three queues:</p> <ul> <li>Whenever the priority-2 (\"express\") queue is non-empty, the bundle   at the head of that queue is the next one extracted.</li> <li>At all other times, bundles from both the priority-1 queue and the   priority-0 queue are extracted, but over a given period of time   twice as many bytes of priority-1 bundles will be extracted as bytes   of priority-0 bundles.</li> </ul> <p>Following insertion of the extracted bundles into transmission buffers, CLO tasks other than ltpclo simply segment the buffered bundles as necessary and transmit them using the underlying convergence-layer protocols. In the case of ltpclo, the output task aggregates the buffered bundles into blocks as described earlier and a second daemon task named ltpmeter waits for aggregated blocks to be completed; ltpmeter, rather than the CLO task itself, segments each completed block as necessary and passes the segments to the link service protocol that underlies LTP. Either way, the transmission ordering requested by application tasks is preserved.</p>"},{"location":"ION-Guide/#contact-plans","title":"Contact Plans","text":"<p>In the Internet, protocol operations can be largely driven by currently effective information that is discovered opportunistically and immediately, at the time it is needed, because the latency in communicating this information over the network is negligible: distances between communicating entities are small and connectivity is continuous. In a DTN-based network, however, ad-hoc information discovery would in many cases take so much time that it could not be completed before the information lost currency and effectiveness. Instead, protocol operations must be largely driven by information that is pre-placed at the network nodes and tagged with the dates and times at which it becomes effective. This information takes the form of contact plans that are managed by the R/F Contacts (rfx) services of ION's ici package.</p> <p></p> <p>Figure 6 RFX services in ION</p> <p>The structure of ION's RFX (contact plan) database, the rfx system elements that populate and use that data, and affected portions of the BP and LTP protocol state databases are shown in Figure 6. (For additional details of BP and LTP database management, see the BP/LTP discussion later in this document.)</p> <p>To clarify the notation of this diagram, which is also used in other database structure diagrams in this document:</p> <ul> <li>Data objects of defined structure are shown as circles. Dark   greyscale indicates notionally non-volatile data retained in \"heap\"   storage, while lighter greyscale indicates volatile data retained in   dynamic random access memory.</li> <li>Solid arrows connecting circles indicate one-to-many cardinality.</li> <li>A dashed arrow between circles indicates a potentially many-to-one   reference mapping.</li> <li>Arrows from processing elements (rectangles) to data entities   indicate data production, while arrows from data entities to   processing elements indicate data retrieval.</li> </ul> <p>A contact is here defined as an interval during which it is expected that data will be transmitted by DTN node A (the contact's transmitting node) and most or all of the transmitted data will be received by node B (the contact's receiving node). Implicitly, the transmitting mode will utilize some \"convergence-layer\" protocol underneath the Bundle Protocol to effect this direct transmission of data to the receiving node. Each contact is characterized by its start time, its end time, the identities of the transmitting and receiving nodes, and the rate at which data are expected to be transmitted by the transmitting node throughout the indicated time period.</p> <p>(Note that a contact is specifically not an episode of activity on a link. Episodes of activity on different links -- e.g., different radio transponders operating on the same spacecraft -- may well overlap, but contacts by definition cannot; they are bounded time intervals and as such are innately \"tiled\". For example, suppose transmission on link X from node A to node B, at data rate RX, begins at time T1 and ends at time T2; also, transmission on link Y from node A to node B, at data rate RY begins at time T3 and ends at time T4. If T1 = T3 and T2 = T4, then there is a single contact from time T1 to time T2 at data rate RX + RY. If T1 \\&lt; T3 and T2 = T4, then there are two contiguous contacts: one from T1 to T3 at data rate RX, then one from T3 to T2 at data rate RX + RY. If T1 \\&lt; T3 and T3\\&lt;T2 \\&lt; T4, then there are three contiguous contacts: one from T1 to T3 at data rate RX, then one from T3 to T2 at data rate RX + RY, then one from T2 to T4 at data rate RY. And so on.)</p> <p>A range interval is a period of time during which the displacement between two nodes A and B is expected to vary by less than 1 light second from a stated anticipated distance. (We expect this information to be readily computable from the known orbital elements of all nodes.) Each range interval is characterized by its start time, its end time, the identities of the two nodes to which it pertains, and the anticipated approximate distance between those nodes throughout the indicated time period, to the nearest light second.</p> <p>The topology timeline at each node in the network is a time-ordered list of scheduled or anticipated changes in the topology of the network. Entries in this list are of two types:</p> <p>\u2022 Contact entries characterize scheduled contacts.</p> <p>\u2022 Range entries characterize anticipated range intervals.</p> <p>Each node to which, according to the RFX database, the local node transmits data directly via some convergence-layer protocol at some time is termed a neighbor of the local node. Each neighbor is associated with one or more outduct for the applicable BP convergence-layer (CL) protocol adapter(s), so bundles that are to be transmitted directly to this neighbor can simply be queued for transmission by outduct (as discussed in the Bandwidth Management notes above).</p> <p>At startup, and at any time while the system is running, ionadmin inserts and removes Contact and Range entries in the topology timeline of the RFX database. Inserting or removing a Contact or Range entry will cause routing tables to be recomputed for the destination nodes of all subsequently forwarded bundles, as described in the discussion of Contact Graph Routing below.</p> <p>Once per second, the rfxclock task (which appears in multiple locations on the diagram to simplify the geometry) applies all topology timeline events (Contact and Range start, stop, purge) with effective time in the past. Applying a Contact event that cites a neighboring node revises the transmission or reception data rate between the local node and that Neighbor. Applying a Range event that cites a neighboring node revises the OWLT between the local node and that neighbor. Setting data rate or OWLT for a node with which the local node will at some time be in direct communication may entail creation of a Neighbor object.</p>"},{"location":"ION-Guide/#route-computation","title":"Route Computation","text":"<p>ION's computation of a route for a given bundle with a given destination endpoint is accomplished by one of several methods, depending on the destination. In every case, the result of successful routing is the insertion of the bundle into an outbound transmission queue (selected according to the bundle's priority) for one or more neighboring nodes.</p> <p>But before discussing these methods it will be helpful to establish some terminology:</p> <p><code>Egress plans</code></p> <p>ION can only forward bundles to a neighboring node by queuing them on some explicitly specified transmission queue. Specifications that associate neighboring nodes with outducts are termed egress plans. They are retained in ION's unicast forwarding database.</p> <p><code>Static routes</code></p> <p>ION can be configured to forward to some specified node all bundles that are destined for a given node to which no dynamic route can be discovered from an examination of the contact graph, as described later. Static routing is implemented by means of the \"exit\" mechanism described below.</p> <p><code>Unicast</code></p> <p>When the destination of a bundle is a single node that is registered within a known \"singleton endpoint\" (that is, an endpoint that is known to have exactly one member), then transmission of that bundle is termed unicast. For this purpose, the destination endpoint ID must be a URI formed in either the \"dtn\" scheme (e.g., dtn://bobsmac/mail) or the \"ipn\" scheme (e.g., ipn:913.11).</p> <p><code>Exits</code></p> <p>When unicast routes must be computed to nodes for which no contact plan information is known (e.g., the size of the network makes it impractical to distribute all Contact and Range information for all nodes to every node, or the destination nodes don't participate in Contact Graph Routing at all), the job of computing routes to all nodes may be partitioned among multiple exit nodes. Each exit is responsible for managing routing information (for example, a comprehensive contact graph) for some subset of the total network population -- a group comprising all nodes whose node numbers fall within the range of node numbers assigned to the exit. A bundle destined for a node for which no dynamic route can be computed from the local node's contact graph may be routed to the exit node for the group within whose range the destination's node number falls. Exits are defined in ION's unicast forwarding database. (Note that the exit implements static routes in ION in addition to improving scalability.)</p> <p><code>Multicast</code></p> <p>When the destination of a bundle is all nodes that are registered within a known \"multicast endpoint\" (that is, an endpoint that is not known to have exactly one member), then transmission of that bundle is termed multicast. For this purpose (in ION), the destination endpoint ID must be a URI formed in the \"imc\" scheme (e.g., imc:913.11).</p> <p><code>Multicast Groups</code></p> <p>A multicast group is the set of all nodes in the network that are members of a given multicast endpoint. Forwarding a bundle to all members of its destination multicast endpoint is the responsibility of all of the multicast-aware nodes of the network. These nodes are additionally configured to be nodes of a single multicast spanning tree overlaid onto the dtnet. A single multicast tree serves to forward bundles to all multicast groups: each node of the tree manages petitions indicating which of its \"relatives\" (parent and children) are currently interested in bundles destined for each multicast endpoint, either natively (due to membership in the indicated group) or on behalf of more distant relatives.</p>"},{"location":"ION-Guide/#unicast","title":"Unicast","text":"<p>We begin unicast route computation by attempting to compute a dynamic route to the bundle's final destination node. The details of this algorithm are described in the section on Contact Graph Routing, below.</p> <p>If no dynamic route can be computed, but the final destination node is a \"neighboring\" node that is directly reachable, then we assume that taking this direct route is the best strategy unless transmission to that neighbor is flagged as \"blocked\" for network operations purposes.</p> <p>Otherwise we must look for a static route. If the bundle's destination node number is in one of the ranges of node numbers assigned to exit nodes, then we forward the bundle to the exit node for the smallest such range. (If the exit node is a neighbor and transmission to that neighbor is not blocked, we simply queue the bundle for transmission to that neighbor; otherwise we similarly look up the static route for the exit node until eventually we resolve to some egress plan.)</p> <p>If we can determine neither a dynamic route nor a static route for this bundle, but the reason for this failure was transmission blockage that might be resolved in the future, then the bundle is placed in a \"limbo\" list for future re-forwarding when transmission to some node is \"unblocked.\"</p> <p>Otherwise, the bundle cannot be forwarded. If custody transfer is requested for the bundle, we send a custody refusal to the bundle's current custodian; in any case, we discard the bundle.</p>"},{"location":"ION-Guide/#multicast","title":"Multicast","text":"<p>Multicast route computation is much simpler.</p> <ul> <li>When an endpoint for the \"imc\" scheme is added on an ION node --   that is, when the node joins that multicast endpoint -- BP   administrative records noting the node's new interest in the   application topic corresponding to the endpoint's group number are   multicast to other network nodes as needed, using a \"built-in\"   multicast group of which all nodes of the network are implicitly   members. On receipt of such a record, each node notes the sending   relative's interest and forwards the record to other nodes as   necessary, and so on. (Deletion of endpoints results in similar   propagation of cancelling administrative records.)</li> <li> <p>A bundle whose destination endpoint cites a multicast group, whether   locally sourced or received from another node:</p> </li> <li> <p>Is delivered immediately, if the local node is a member of the     indicated endpoint.</p> </li> <li>Is queued for direct transmission to all other nodes in the     local \"region\" of network topology that are members of the     multicast group. Passageway nodes forward the bundle as     necessary into other regions that are topologically adjacent to     the local region.</li> </ul>"},{"location":"ION-Guide/#delivery-assurance","title":"Delivery Assurance","text":"<p>End-to-end delivery of data can fail in many ways, at different layers of the stack. When delivery fails, we can either accept the communication failure or retransmit the data structure that was transmitted at the stack layer at which the failure was detected. ION is designed to enable retransmission at multiple layers of the stack, depending on the preference of the end user application.</p> <p>At the lowest stack layer that is visible to ION, the convergence-layer protocol, failure to deliver one or more segments due to segment loss or corruption will trigger segment retransmission if a \"reliable\" convergence-layer protocol is in use: LTP \"red-part\" transmission or TCP (including Bundle Relay Service, which is based on TCP)<sup>1</sup>.</p> <p>Segment loss may be detected and signaled via NAK by the receiving entity, or it may only be detected at the sending entity by expiration of a timer prior to reception of an ACK. Timer interval computation is well understood in a TCP environment, but it can be a difficult problem in an environment of scheduled contacts as served by LTP. The round-trip time for an acknowledgment dialogue may be simply twice the one-way light time (OWLT) between sender and receiver at one moment, but it may be hours or days longer at the next moment due to cessation of scheduled contact until a future contact opportunity. To account for this timer interval variability in retransmission, the ltpclock task infers the initiation and cessation of LTP transmission, to and from the local node, from changes in the current xmit and recv data rates in the corresponding Neighbor objects. This controls the dequeuing of LTP segments for transmission by underlying link service adapter(s) and it also controls suspension and resumption of timers, removing the effects of contact interruption from the retransmission regime. For a further discussion of this mechanism, see the section below on LTP Timeout Intervals.</p> <p>Note that the current OWLT in Neighbor objects is also used in the computation of the nominal expiration times of timers and that ltpclock is additionally the agent for LTP segment retransmission based on timer expiration.</p> <p>It is, of course, possible for the nominally reliable convergence-layer protocol to fail altogether: a TCP connection might be abruptly terminated, or an LTP transmission might be canceled due to excessive retransmission activity (again possibly due to an unexpected loss of connectivity). In this event, BP itself detects the CL protocol failure and re-forwards all bundles whose acquisition by the receiving entity is presumed to have been aborted by the failure. This re-forwarding is initiated in different ways for different CL protocols, as implemented in the CL input and output adapter tasks. If immediate re-forwarding is impossible because transmission to all potentially viable neighbors is blocked, the affected bundles are placed in the limbo list for future re-forwarding when transmission to some node is unblocked.</p> <p>In addition to the implicit forwarding failure detected when a CL protocol fails, the forwarding of a bundle may be explicitly refused by the receiving entity, provided the bundle is flagged for custody transfer service. A receiving node's refusal to take custody of a bundle may have any of a variety of causes: typically the receiving node either (a) has insufficient resources to store and forward the bundle, (b) has no route to the destination, or (c) will have no contact with the next hop on the route before the bundle's TTL has expired. In any case, a \"custody refusal signal\" (packaged in a bundle) is sent back to the sending node, which must re-forward the bundle in hopes of finding a more suitable route.</p> <p>Alternatively, failure to receive a custody acceptance signal within some convergence-layer-specified or application-specified time interval may also be taken as an implicit indication of forwarding failure. Here again, when BP detects such a failure it attempts to re-forward the affected bundle, placing the bundle in the limbo list if re-forwarding is currently impossible.</p> <p>In the worst case, the combined efforts of all the retransmission mechanisms in ION are not enough to ensure delivery of a given bundle, even when custody transfer is requested. In that event, the bundle's \"time to live\" will eventually expire while the bundle is still in custody at some node: the bpclock task will send a bundle status report to the bundle's report-to endpoint, noting the TTL expiration, and destroy the bundle. The report-to endpoint, upon receiving this report, may be able to initiate application-layer retransmission of the original application data unit in some way. This final retransmission mechanism is wholly application-specific, however.</p>"},{"location":"ION-Guide/#rate-control","title":"Rate Control","text":"<p>In the Internet, the rate of transmission at a node can be dynamically negotiated in response to changes in level of activity on the link, to minimize congestion. On deep space links, signal propagation delays (distances) may be too great to enable effective dynamic negotiation of transmission rates. Fortunately, deep space links are operationally reserved for use by designated pairs of communicating entities over pre-planned periods of time at pre-planned rates. Provided there is no congestion inherent in the contact plan, congestion in the network can be avoided merely by adhering to the planned contact periods and data rates. Rate control in ION serves this purpose.</p> <p>While the system is running, transmission and reception of bundles is constrained by the current capacity in the throttle of each convergence-layer manager. Completed bundle transmission activity reduces the current capacity of the applicable throttle by the capacity consumption computed for that bundle. This reduction may cause the throttle's current capacity to become negative. Once the current capacity of the applicable throttle goes negative, activity is blocked until non-negative capacity has been restored by bpclock.</p> <p>Once per second, the bpclock task increases the current capacity of each throttle by one second's worth of traffic at the nominal data rate for transmission to that node, thus enabling some possibly blocked bundle transmission and reception to proceed.</p> <p>bpclock revises all throttles' nominal data rates once per second in accord with the current data rates in the corresponding Neighbor objects, as adjusted by rfxclock per the contact plan.</p> <p>Note that this means that, for any neighboring node for which there are planned contacts, ION's rate control system will enable data flow only while contacts are active.</p>"},{"location":"ION-Guide/#flow-control","title":"Flow Control","text":"<p>A further constraint on rates of data transmission in an ION-based network is LTP flow control. LTP is designed to enable multiple block transmission sessions to be in various stages of completion concurrently, to maximize link utilization: there is no requirement to wait for one session to complete before starting the next one. However, if unchecked this design principle could in theory result in the allocation of all memory in the system to incomplete LTP transmission sessions. To prevent complete storage resource exhaustion, we set a firm upper limit on the total number of outbound blocks that can be concurrently in transit at any given time. These limits are established by ltpadmin at node initialization time.</p> <p>The maximum number of transmission sessions that may be concurrently managed by LTP therefore constitutes a transmission \"window\" -- the basis for a delay-tolerant, non-conversational flow control service over interplanetary links. Once the maximum number of sessions are in flight, no new block transmission session can be initiated -- regardless of how much outduct transmission capacity is provided by rate control -- until some existing session completes or is canceled.</p> <p>Note that this consideration emphasizes the importance of configuring the aggregation size limits and session count limits of spans during LTP initialization to be consistent with the maximum data rates scheduled for contacts over those spans.</p>"},{"location":"ION-Guide/#storage-management","title":"Storage Management","text":"<p>Congestion in a dtnet is the imbalance between data enqueuing and dequeuing rates that results in exhaustion of queuing (storage) resources at a node, preventing continued operation of the protocols at that node.</p> <p>In ION, the affected queuing resources are allocated from notionally non-volatile storage space in the SDR data store and/or file system. The design of ION is required to prevent resource exhaustion by simply refusing to enqueue additional data that would cause it.</p> <p>However, a BP router's refusal to enqueue received data for forwarding could result in costly retransmission, data loss, and/or the \"upstream\" propagation of resource exhaustion to other nodes. Therefore the ION design additionally attempts to prevent potential resource exhaustion by forecasting levels of queuing resource occupancy and reporting on any congestion that is predicted. Network operators, upon reviewing these forecasts, may revise contact plans to avert the anticipated resource exhaustion.</p> <p>The non-volatile storage used by ION serves several purposes: it contains queues of bundles awaiting forwarding, transmission, and delivery; it contains LTP transmission and reception sessions, including the blocks of data that are being transmitted and received; it contains queues of LTP segments awaiting radiation; it may contain CFDP transactions in various stages of completion; and it contains protocol operational state information, such as configuration parameters, static routes, the contact graph, etc.</p> <p>Effective utilization of non-volatile storage is a complex problem. Static pre-allocation of storage resources is in general less efficient (and also more labor-intensive to configure) than storage resource pooling and automatic, adaptive allocation: trying to predict a reasonable maximum size for every data storage structure and then rigidly enforcing that limit typically results in underutilization of storage resources and underperformance of the system as a whole. However, static pre-allocation is mandatory for safety-critical resources, where certainty of resource availability is more important than efficient resource utilization.</p> <p>The tension between the two approaches is analogous to the tension between circuit switching and packet switching in a network: circuit switching results in underutilization of link resources and underperformance of the network as a whole (some peaks of activity can never be accommodated, even while some resources lie idle much of the time), but dedicated circuits are still required for some kinds of safety-critical communication.</p> <p>So the ION data management design combines these two approaches (see 1.5 above for additional discussion of this topic):</p> <ul> <li>A fixed percentage of the total SDR data store heap size (by   default, 40%) is statically allocated to the storage of protocol   operational state information, which is critical to the operation of   ION.</li> <li>Another fixed percentage of the total SDR data store heap size (by   default, 20%) is statically allocated to \"margin\", a reserve that   helps to insulate node management from errors in resource allocation   estimates.</li> <li>The remainder of the heap, plus all pre-allocated file system space,   is allocated to protocol traffic<sup>2</sup>.</li> </ul> <p>The maximum projected occupancy of the node is the result of computing a congestion forecast for the node, by adding to the current occupancy all anticipated net increases and decreases from now until some future time, termed the horizon for the forecast.</p> <p>The forecast horizon is indefinite -- that is, \"forever\" -- unless explicitly declared by network management via the ionadmin utility program. The difference between the horizon and the current time is termed the interval of the forecast.</p> <p>Net occupancy increases and decreases are of four types:</p> <ol> <li>Bundles that are originated locally by some application on the node,    which are enqueued for forwarding to some other node.</li> <li>Bundles that are received from some other node, which are enqueued    either for forwarding to some other node or for local delivery to an    application.</li> <li>Bundles that are transmitted to some other node, which are dequeued    from some forwarding queue.</li> <li>Bundles that are delivered locally to an application, which are    dequeued from some delivery queue.</li> </ol> <p>The type-1 anticipated net increase (total data origination) is computed by multiplying the node's projected rate of local data production, as declared via an ionadmin command, by the interval of the forecast. Similarly, the type-4 anticipated net decrease (total data delivery) is computed by multiplying the node's projected rate of local data consumption, as declared via an ionadmin command, by the interval of the forecast. Net changes of types 2 and 3 are computed by multiplying inbound and outbound data rates, respectively, by the durations of all periods of planned communication contact that begin and/or end within the interval of the forecast.</p> <p>Congestion forecasting is performed by the ionwarn utility program. ionwarn may be run independently at any time; in addition, the ionadmin utility program automatically runs ionwarn immediately before exiting if it executed any change in the contact plan, the forecast horizon, or the node's projected rates of local data production or consumption. Moreover, the rfxclock daemon program also runs ionwarn automatically whenever any of the scheduled reconfiguration events it dispatches result in contact state changes that might alter the congestion forecast.</p> <p>If the final result of the forecast computation -- the maximum projected occupancy of the node over the forecast interval -- is less than the total protocol traffic allocation, then no congestion is forecast. Otherwise, a congestion forecast status message is logged noting the time at which maximum projected occupancy is expected to equal the total protocol traffic allocation.</p> <p>Congestion control in ION, then, has two components:</p> <p>First, ION's congestion detection is anticipatory (via congestion forecasting) rather than reactive as in the Internet.</p> <p>Anticipatory congestion detection is important because the second component -- congestion mitigation -- must also be anticipatory: it is the adjustment of communication contact plans by network management, via the propagation of revised schedules for future contacts.</p> <p>(Congestion mitigation in an ION-based network is likely to remain mostly manual for many years to come, because communication contact planning involves much more than orbital dynamics: science operations plans, thermal and power constraints, etc. It will, however, rely on the automated rate control features of ION, discussed above, which ensure that actual network operations conform to established contact plans.)</p> <p>Rate control in ION is augmented by admission control. ION tracks the sum of the sizes of all zero-copy objects currently residing in the heap and file system at any moment. Whenever any protocol implementation attempts to create or extend a ZCO in such a way that total heap or file occupancy would exceed an upper limit asserted for the node, that attempt is either blocked until ZCO space becomes available or else rejected altogether.</p>"},{"location":"ION-Guide/#optimizing-an-ion-based-network","title":"Optimizing an ION-based network","text":"<p>ION is designed to deliver critical data to its final destination with as much certainty as possible (and optionally as soon as possible), but otherwise to try to maximize link utilization. The delivery of critical data is expedited by contact graph routing and bundle prioritization as described elsewhere. Optimizing link utilization, however, is a more complex problem.</p> <p>If the volume of data traffic offered to the network for transmission is less than the capacity of the network, then all offered data should be successfully delivered<sup>3</sup>. But in that case the users of the network are paying the opportunity cost of whatever portion of the network capacity was not used.</p> <p>Offering a data traffic volume that is exactly equal to the capacity of the network is in practice infeasible. TCP in the Internet can usually achieve this balance because it exercises end-to-end flow control: essentially, the original source of data is blocked from offering a message until notified by the final destination that transmission of this message can be accommodated given the current negotiated data rate over the end-to-end path (as determined by TCP's congestion control mechanisms). In a delay-tolerant network no such end-to-end negotiated data rate may exist, much less be knowable, so such precise control of data flow is impossible.<sup>4</sup></p> <p>The only alternative: the volume of traffic offered by the data source must be greater than the capacity of the network and the network must automatically discard excess traffic, shedding lower-priority data in preference to high-priority messages on the same path.</p> <p>ION discards excess traffic proactively when possible and reactively when necessary.</p> <p><code>Proactive data triage</code> occurs when ION determines that it cannot compute a route that will deliver a given bundle to its final destination prior to expiration of the bundle's Time To Live (TTL). That is, a bundle may be discarded simply because its TTL is too short, but more commonly it will be discarded because the planned contacts to whichever neighboring node is first on the path to the destination are already fully subscribed: the queue of bundles awaiting transmission to that neighbor is already so long as to consume the entire capacity of all announced opportunities to transmit to it. Proactive data triage causes the bundle to be immediately destroyed as one for which there is \"No known route to destination from here.\"</p> <p>The determination of the degree to which a contact is subscribed is based not only on the aggregate size of the queued bundles but also on the estimated aggregate size of the overhead imposed by all the convergence-layer (CL) protocol data units -- at all layers of the underlying stack -- that encapsulate those bundles: packet headers, frame headers, etc. This means that the accuracy of this overhead estimate will affect the aggressiveness of ION's proactive data triage:</p> <ul> <li>If CL overhead is overestimated, the size of the bundle transmission   backlog for planned contacts will be overstated, unnecessarily   preventing the enqueuing of additional bundles -- a potential   under-utilization of available transmission capacity in the network.</li> <li>If CL overhead is underestimated, the size of the bundle   transmission backlog for planned contacts will be understated,   enabling the enqueuing of bundles whose transmission cannot in fact   be accomplished by the network within the constraints of the current   contact plan. This will eventually result in reactive data triage.</li> </ul> <p>Essentially, all <code>reactive data triage</code> -- the destruction of bundles due to TTL expiration prior to successful delivery to the final destination -- occurs when the network conveys bundles at lower net rates than were projected during route computation. These performance shortfalls can have a variety of causes:</p> <ul> <li>As noted above, underestimating CL overhead causes CL overhead to   consume a larger fraction of contact capacity than was anticipated,   leaving less capacity for bundle transmission.</li> <li>Conversely, the total volume of traffic offered may have been   accurately estimated but the amount of contact capacity may be less   than was promised: a contact might be started late, stopped early,   or omitted altogether, or the actual data rate on the link might be   less than was advertised.</li> <li>Contacts may be more subtly shortened by the configuration of ION   itself. If the clocks on nodes are known not to be closely   synchronized then a \"maximum clock error\" of N seconds may be   declared, causing reception episodes to be started locally N seconds   earlier and stopped N seconds later than scheduled, to avoid missing   some transmitted data because it arrived earlier or later than   anticipated. But this mechanism also causes transmission episodes to   be started N seconds later and stopped N seconds earlier than   scheduled, to avoid transmitting to a neighbor before it is ready to   receive data, and this contact truncation ensures transmission of   fewer bundles than planned.</li> <li>Flow control within the convergence layer underlying the bundle   protocol may constrain the effective rate of data flow over a link   to a rate that's lower than the link's configured maximum data rate.   In particular, mis-configuration of the LTP flow control window can   leave transmission capacity unused while LTP engines are awaiting   acknowledgments.</li> <li>Even if all nodes are correctly configured, a high rate of data loss   or corruption due to unexpectedly high R/F interference or   underestimated acknowledgment round-trip times may cause an   unexpectedly high volume of retransmission traffic. This will   displace original bundle transmission, reducing the effective   \"goodput\" data rate on the link.</li> <li>Finally, custody transfer may propagate operational problems from   one part of the network to other nodes. One result of reduced   effective transmission rates is the accumulation of bundles for   which nodes have taken custody: the custodial nodes can't destroy   those bundles and reclaim the storage space they occupy until   custody has been accepted by \"downstream\" nodes, so abbreviated   contacts that prevent the flow of custody acceptances can increase   local congestion. This reduces nodes' own ability to take custody of   bundles transmitted by \"upstream\" custodians, increasing queue sizes   on those nodes, and so on. In short, custody transfer may itself   ultimately impose reactive data triage simply by propagating   congestion.</li> </ul> <p>Some level of data triage is essential to cost-effective network utilization, and proactive triage is preferable because its effects can be communicated immediately to users, improving user control over the use of the network. Optimizing an ION-based network therefore amounts to managing for a modicum of proactive data triage and as little reactive data triage as possible. It entails the following:</p> <ol> <li>Estimating convergence-layer protocol overhead as accurately as    possible, erring (if necessary) on the side of optimism -- that is,    underestimating a little.</li> </ol> <p>As an example, suppose the local node uses LTP over CCSDS Telemetry to    send bundles. The immediate convergence-layer protocol is LTP, but the    total overhead per CL \"frame\" (in this case, per LTP segment) will    include not only the size of the LTP header (nominally 5 bytes) but also    the size of the encapsulating space packet header (nominally 6 bytes)    and the overhead imposed by the outer encapsulating TM frame.</p> <p>Suppose each LTP segment is to be wrapped in a single space packet,    which is in turn wrapped in a single TM frame, and Reed-Solomon encoding    is applied. An efficient TM frame size is 1115 bytes, with an additional    160 bytes of trailing Reed-Solomon encoding and another 4 bytes of    leading pseudo-noise code. The frame would contain a 6-byte TM frame    header, a 6-byte space packet header, a 5-byte LTP segment header, and    1098 bytes of some LTP transmission block.</p> <p>So the number of \"payload bytes per frame\" in this case would be 1098    and the number of \"overhead bytes per frame\" would be 4 + 6 + 6 + 5 +    160 = 181. Nominal total transmission overhead on the link would be 181    / 1279 = about 14%. 2. Synchronizing nodes' clocks as accurately as possible, so that    timing margins configured to accommodate clock error can be kept as    close to zero as possible. 3. Setting the LTP session limit and block size limit as generously as    possible (whenever LTP is at the convergence layer), to assure that    LTP flow control does not constrain data flow to rates below those    supported by BP rate control. 4. Setting ranges (one-way light times) and queuing delays as    accurately as possible, to prevent unnecessary retransmission. Err    on the side of pessimism -- that is, overestimate a little. 5. Communicating changes in configuration -- especially contact plans    -- to all nodes as far in advance of the time they take effect as    possible. 6. Providing all nodes with as much storage capacity as possible for    queues of bundles awaiting transmission.</p>"},{"location":"ION-Guide/#bpltp-detail-how-they-work","title":"BP/LTP Detail -- How They Work","text":"<p>Although the operation of BP/LTP in ION is complex in some ways, virtually the entire system can be represented in a single diagram. The interactions among all of the concurrent tasks that make up the node -- plus a Remote AMS task or CFDP UT-layer task, acting as the application at the top of the stack -- are shown below. (The notation is as used earlier but with semaphores added. Semaphores are shown as small circles, with arrows pointing into them signifying that the semaphores are being given and arrows pointing out of them signifying that the semaphores are being taken.)</p> <p></p> <p>Figure 7 ION node functional overview</p> <p>Further details of the BP/LTP data structures and flow of control and data appear on the following pages. (For specific details of the operation of the BP and LTP protocols as implemented by the ION tasks, such as the nature of report-initiated retransmission in LTP, please see the protocol specifications. The BP specification is documented in Internet RFC 5050, while the LTP specification is documented in Internet RFC 5326.)</p>"},{"location":"ION-Guide/#databases","title":"Databases","text":"<p>Figure 8: Bundle protocol database</p> <p></p> <p>Figure 9: Licklider transmission protocol database</p>"},{"location":"ION-Guide/#control-and-data-flow","title":"Control and data flow","text":""},{"location":"ION-Guide/#bundle-protocol","title":"Bundle Protocol","text":"<p>Figure 10 BP forwarder</p> <p></p> <p>Figure 11 BP convergence layer output</p>"},{"location":"ION-Guide/#ltp","title":"LTP","text":"<p>Figure 12 LTP transmission metering</p> <p></p> <p>Figure 13 LTP link service output</p> <p></p> <p>Figure 14 LTP link service input</p>"},{"location":"ION-Guide/#contact-graph-routing-cgr-ccsds-schedule-aware-bundle-routing-sabr","title":"Contact Graph Routing (CGR) - CCSDS Schedule Aware Bundle Routing (SABR)","text":"<p>CGR is a dynamic routing system that computes routes through a time-varying topology of scheduled communication contacts in a DTN network. It is designed to support operations in a space network based on DTN, but it also could be used in terrestrial applications where operation according to a predefined schedule is preferable to opportunistic communication, as in a low-power sensor network. ION's CGR implementation complies with CCSDS Schedule Aware Bundle Routing (SABR) Specification CCSDS 734.3-B-1.</p> <p>The basic strategy of CGR is to take advantage of the fact that, since communication operations are planned in detail, the communication routes between any pair of \"bundle agents\" in a population of nodes that have all been informed of one another's plans can be inferred from those plans rather than discovered via dialogue (which is impractical over long-one-way-light-time space links).</p>"},{"location":"ION-Guide/#contact-plan-messages","title":"Contact Plan Messages","text":"<p>CGR relies on accurate contact plan information provided in the form of contact plan messages that currently are only read from ionrc files and processed by ionadmin, which retains them in a non-volatile contact plan in the RFX database, in ION's SDR data store.</p> <p>Contact plan messages are of two types: contact messages and range messages.</p> <p>Each contact message has the following content:</p> <ul> <li>The starting UTC time of the interval to which the message pertains.</li> <li>The stop time of this interval, again in UTC.</li> <li>The Transmitting node number.</li> <li>The Receiving node number.</li> <li>The planned rate of transmission from node A to node B over this   interval, in bytes per second.</li> </ul> <p>Each range message has the following content:</p> <ul> <li>The starting UTC time of the interval to which the message pertains.</li> <li>The stop time of this interval, again in UTC.</li> <li>Node number A.</li> <li>Node number B.</li> <li>The anticipated distance between A and B over this interval, in   light seconds.</li> </ul> <p>Note that range messages may be used to declare that the \"distance\" in light seconds between nodes A and B is different in the B\ud83e\udc6aA direction from the distance in the A\ud83e\udc6aB direction. While direct radio communication between A and B will not be subject to such asymmetry, it's possible for connectivity established using other convergence-layer technologies to take different physical paths in different directions, with different signal propagation delays.</p>"},{"location":"ION-Guide/#routing-tables","title":"Routing Tables","text":"<p>Each node uses Range and Contact messages in the contact plan to build a \\\"routing table\\\" data structure.</p> <p>The routing table constructed locally by each node in the network is a list of entry node lists, one route list for every other node D in the network that is cited in any Contact or Range in the contact plan. Entry node lists are computed as they are needed, and the maximum number of entry node lists resident at a given time is the number of nodes that are cited in any Contacts or Ranges in the contact plan. Each entry in the entry node list for node D is a list of the neighbors of local node X; included with each entry of the entry node list is a list one or more routes to D through the indicated neighbor, termed a route list.</p> <p>Each route in the route list for node D identifies a path to destination node D, from the local node, that begins with transmission to one of the local node's neighbors in the network-- the initial receiving node for the route, termed the route's entry node.</p> <p>For any given route, the contact from the local node to the entry node constitutes the initial transmission segment of the end-to-end path to the destination node. Additionally noted in each route object are all of the other contacts that constitute the remaining segments of the route's end-to-end path.</p> <p>Each route object also notes the forwarding cost for a bundle that is forwarded along this route. In this version of ION, CGR is configured to deliver bundles as early as possible, so best-case final delivery time is used as the cost of a route. Other metrics might be substituted for final delivery time in other CGR implementations. NOTE, however, that if different metrics are used at different nodes along a bundle's end-to-end path it becomes impossible to prevent routing loops that can result in non-delivery of the data.</p> <p>Finally, each route object also notes the route's termination time, the time after which the route will become moot due to the termination of the earliest-ending contact in the route.</p>"},{"location":"ION-Guide/#key-concepts","title":"Key Concepts","text":""},{"location":"ION-Guide/#expiration-time","title":"Expiration time","text":"<p>Every bundle transmitted via DTN has a time-to-live (TTL), the length of time after which the bundle is subject to destruction if it has not yet been delivered to its destination. The expiration time of a bundle is computed as its creation time plus its TTL. When computing the next-hop destination for a bundle that the local bundle agent is required to forward, there is no point in selecting a route that can\\'t get the bundle to its final destination prior to the bundle's expiration time.</p>"},{"location":"ION-Guide/#owlt-margin","title":"OWLT margin","text":"<p>One-way light time (OWLT) -- that is, distance -- is obviously a factor in delivering a bundle to a node prior to a given time. OWLT can actually change during the time a bundle is en route, but route computation becomes intractably complex if we can\\'t assume an OWLT \\\"safety margin\\\" -- a maximum delta by which OWLT between any pair of nodes can change during the time a bundle is in transit between them.</p> <p>We assume that the maximum rate of change in distance between any two nodes in the network is about 150,000 miles per hour, which is about 40 miles per second. (This was the speed of the Helios spacecraft, the fastest man-made object launched to date.)</p> <p>At this speed, the distance between any two nodes that are initially separated by a distance of N light seconds will increase by a maximum of 80 miles per second of transit (in the event that they are moving in opposite directions). This will result in data arrival no later than roughly (N + 2Q) seconds after transmission -- where the \"OWLT margin\" value Q is (40 * N) divided by 186,000 -- rather than just N seconds after transmission as would be the case if the two nodes were stationary relative to each other. When computing the expected time of arrival of a transmitted bundle we simply use N + 2Q, the most pessimistic case, as the anticipated total in-transit time.</p>"},{"location":"ION-Guide/#capacity","title":"Capacity","text":"<p>The capacity of a contact is the product of its data transmission rate (in bytes per second) and its duration (stop time minus start time, in seconds).</p>"},{"location":"ION-Guide/#estimated-capacity-consumption","title":"Estimated capacity consumption","text":"<p>The size of a bundle is the sum of its payload size and its header size<sup>5</sup>, but bundle size is not the only lien on the capacity of a contact. The total estimated volume consumption (or \"EVC\") for a bundle is the sum of the sizes of the bundle's payload and header and the estimated convergence-layer overhead. For a bundle whose header is of size M and whose payload is of size N, the estimated convergence-layer overhead is defined as 3% of (M+N), or 100 bytes, whichever is larger.</p>"},{"location":"ION-Guide/#residual-capacity","title":"Residual capacity","text":"<p>The residual capacity of a given contact between the local node and one of its neighbors, as computed for a given bundle, is the sum of the capacities of that contact and all prior scheduled contacts between the local node and that neighbor, less the sum of the ECCs of all bundles with priority equal to or higher than the priority of the subject bundle that are currently queued on the outduct for transmission to that neighbor.</p>"},{"location":"ION-Guide/#excluded-neighbors","title":"Excluded neighbors","text":"<p>A neighboring node C that refuses custody of a bundle destined for some remote node D is termed an excluded neighbor for (that is, with respect to computing routes to) D. So long as C remains an excluded neighbor for D, no bundles destined for D will be forwarded to C -- except that occasionally (once per lapse of the RTT between the local node and C) a custodial bundle destined for D will be forwarded to C as a \"probe bundle\". C ceases to be an excluded neighbor for D as soon as it accepts custody of a bundle destined for D.</p>"},{"location":"ION-Guide/#critical-bundles","title":"Critical bundles","text":"<p>A Critical bundle is one that absolutely has got to reach its destination and, moreover, has got to reach that destination as soon as is physically possible<sup>6</sup>.</p> <p>For an ordinary non-Critical bundle, the CGR dynamic route computation algorithm uses the routing table to select a single neighboring node to forward the bundle through. It is possible, though, that due to some unforeseen delay the selected neighbor may prove to be a sub-optimal forwarder: the bundle might arrive later than it would have if another neighbor had been selected, or it might not even arrive at all.</p> <p>For Critical bundles, the CGR dynamic route computation algorithm causes the bundle to be inserted into the outbound transmission queues for transmission to all neighboring nodes that can plausibly forward the bundle to its final destination. The bundle is therefore guaranteed to travel over the most successful route, as well as over all other plausible routes. Note that this may result in multiple copies of a Critical bundle arriving at the final destination.</p>"},{"location":"ION-Guide/#dynamic-route-selection-algorithm","title":"Dynamic Route Selection Algorithm","text":"<p>Given a bundle whose destination is node D, we proceed as follows.</p> <p>First, if no contacts in the contact plan identify transmission to node D, then we cannot use CGR to find a route for this bundle; CGR route selection is abandoned.</p> <p>Next, if the contact plan has been modified in any way since routes were computed for any nodes, we discard all routes for all nodes and authorize route recomputation. (The contact plan changes may have invalidated any or all of those earlier computations.)</p> <p>We create an empty list of Proximate Nodes (network neighbors) to send the bundle to.</p> <p>We create a list of Excluded Nodes, i.e., nodes through which we will not compute a route for this bundle. The list of Excluded Nodes is initially populated with:</p> <ul> <li>the node from which the bundle was directly received (so that we   avoid cycling the bundle between that node and the local node) --   unless the Dynamic Route Selection Algorithm is being   re-applied due to custody refusal as discussed later;</li> <li>all excluded neighbors for the bundle's final destination node.</li> </ul> <p>If all routes computed for node D have been discarded due to contact plan modification, then we must compute a new list of all routes from the local node to D. To do so:</p> <ul> <li>We construct an abstract contact graph, a directed acyclic graph   whose root is a notional contact from the local node to itself and   whose other vertices are all other contacts representing   transmission \"from\" some node such that a contact \"to\" that node   already exists in the graph, excluding contacts representing   transmission \"to\" some node such that a contact \"from\" that node   already exists in the graph. A terminal vertex is also included in   the graph, constituting a notional contact from node D to itself.</li> <li> <p>We perform several Dijkstra searches within this graph, one search   for each of the local node's neighbors. On each search we find the   lowest-cost route that begins at the root of the graph and ends at   the terminal vertex. Each time a route is computed, we add it to the   list of routes for that route's entry node and then remove from   further consideration all contacts from the local node to the entry   node of that route.</p> </li> <li> <p>The lowest-cost route computed during a search is the one that     is found to have the earliest best-case delivery time, where the     best-case delivery time characterizing a route is given by the     time at which a bundle would arrive at node D if transmitted at     the earliest possible moment of the last contact in the route     prior to the terminal vertex.</p> </li> <li>Any contact whose end time is before the earliest possible time     that the bundle could arrive at the contact's sending node is     ignored.</li> <li>The earliest possible arrival time for the bundle on a given     contact is pessimistically computed as the sum of the bundle's     earliest possible transmission time plus the range in light     seconds from the contact's sending node to its receiving node,     plus the applicable one-way light time margin.</li> <li>The earliest possible transmission time for the bundle on a     given contact is the start time of the contact or bundle's     earliest possible arrival time at the contact's sending node,     whichever is later.</li> <li>If node D's list of entry nodes (route lists) is still empty, then   we cannot use CGR to find a route for this bundle; CGR route   selection is abandoned.</li> </ul> <p>We next examine all of the routes that are currently computed for transmission of bundles to node D.</p> <ul> <li>Any route whose termination time is in the past is deleted from the   list, and all contacts in that route whose termination time is in   the past are also deleted. But we then run another Dijkstra search   to compute the best route through the affected entry node given the   remaining contacts; if this search finds a route, the new route is   inserted into the appropriate location in the list.</li> <li>Any route whose best-case final delivery time is after the bundle's   expiration time is ignored, as is any route whose entry node is in   the list of Excluded Nodes. Loopback routes are also ignored unless   the local node is the bundle's final destination.</li> <li>For each route, the aggregate radiation time for this bundle on this   route is computed by summing the product of payload size and contact   transmission rate over all contacts in the route. Any route for   which the sum of best-case delivery time and aggregate radiation   time is after the bundle's expiration time is ignored.</li> </ul> <p>For each route that is not ignored, the route's entry node is added to the list of Proximate Nodes for this bundle. Associated with the entry node number in this list entry are the best-case final delivery time of the route, the total number of \"hops\" in the route's end-to-end path, and the forfeit time for transmission to this node. Forfeit time is the route's termination time, the time by which the bundle must have been transmitted to this node in order to have any chance of being forwarded on this route.</p> <p>If, at the end of this procedure, the Proximate Nodes list is empty, then we have been unable to use CGR to find a route for this bundle; CGR route selection is abandoned.</p> <p>Otherwise:</p> <ul> <li>If the bundle is flagged as a critical bundle, then a cloned copy of   this bundle is enqueued for transmission to every node in the   Proximate Nodes list.</li> <li> <p>Otherwise, the bundle is enqueued for transmission on the outduct to   the most preferred neighbor in the Proximate Nodes list:</p> </li> <li> <p>If one of the nodes in this list is associated with a best-case     delivery time that is earlier than that of all other nodes in     the list, then it is the most preferred neighbor.</p> </li> <li>Otherwise, if one of the nodes with the earliest best-case     delivery time is associated with a smaller hop count than every     other node with the same best-case delivery time, then it is the     most preferred neighbor.</li> <li>Otherwise, the node with the smallest node number among all     nodes with the earliest best-case delivery time and smallest hop     count is arbitrarily chosen as the most preferred neighbor.</li> </ul>"},{"location":"ION-Guide/#exception-handling","title":"Exception Handling","text":"<p>Conveyance of a bundle from source to destination through a DTN can fail in a number of ways, many of which are best addressed by means of the Delivery Assurance mechanisms described earlier. Failures in Contact Graph Routing, specifically, occur when the expectations on which routing decisions are based prove to be false. These failures of information fall into two general categories: contact failure and custody refusal.</p>"},{"location":"ION-Guide/#contact-failure","title":"Contact Failure","text":"<p>A scheduled contact between some node and its neighbor on the end-to-end route may be initiated later than the originally scheduled start time, or be terminated earlier than the originally scheduled stop time, or be canceled altogether. Alternatively, the available capacity for a contact might be overestimated due to, for example, diminished link quality resulting in unexpectedly heavy retransmission at the convergence layer. In each of these cases, the anticipated transmission of a given bundle during the affected contact may not occur as planned: the bundle might expire before the contact's start time, or the contact's stop time might be reached before the bundle has been transmitted.</p> <p>For a non-Critical bundle, we handle this sort of failure by means of a timeout: if the bundle is not transmitted prior to the forfeit time for the selected Proximate Node, then the bundle is removed from its outbound transmission queue and the Dynamic Route Computation Algorithm is re-applied to the bundle so that an alternate route can be computed.</p>"},{"location":"ION-Guide/#custody-refusal","title":"Custody refusal","text":"<p>A node that receives a bundle may find it impossible to forward it, for any of several reasons: it may not have enough storage capacity to hold the bundle, it may be unable to compute a forward route (static, dynamic, or default) for the bundle, etc. Such bundles are simply discarded, but discarding any such bundle that is marked for custody transfer will cause a custody refusal signal to be returned to the bundle's current custodian.</p> <p>When the affected bundle is non-Critical, the node that receives the custody refusal re-applies the Dynamic Route Computation Algorithm to the bundle so that an alternate route can be computed -- except that in this event the node from which the bundle was originally directly received is omitted from the initial list of Excluded Nodes. This enables a bundle that has reached a dead end in the routing tree to be sent back to a point at which an altogether different branch may be selected.</p> <p>For a Critical bundle no mitigation of either sort of failure is required or indeed possible: the bundle has already been queued for transmission on all plausible routes, so no mechanism that entails re-application of CGR's Dynamic Route Computation Algorithm could improve its prospects for successful delivery to the final destination. However, in some environments it may be advisable to re-apply the Dynamic Route Computation Algorithm to all Critical bundles that are still in local custody whenever a new Contact is added to the contact graph: the new contact may open an additional forwarding opportunity for one or more of those bundles.</p>"},{"location":"ION-Guide/#remarks","title":"Remarks","text":"<p>The CGR routing procedures respond dynamically to the changes in network topology that the nodes are able know about, i.e., those changes that are subject to mission operations control and are known in advance rather than discovered in real time. This dynamic responsiveness in route computation should be significantly more effective and less expensive than static routing, increasing total data return while at the same time reducing mission operations cost and risk.</p> <p>Note that the non-Critical forwarding load across multiple parallel paths should be balanced automatically:</p> <ul> <li>Initially all traffic will be forwarded to the node(s) on what is   computed to be the best path from source to destination.</li> <li>At some point, however, a node on that preferred path may have so   much outbound traffic queued up that no contacts scheduled within   bundles' lifetimes have any residual capacity. This can cause   forwarding to fail, resulting in custody refusal.</li> <li>Custody refusal causes the refusing node to be temporarily added to   the current custodian's excluded neighbors list for the affected   final destination node. If the refusing node is the only one on the   path to the destination, then the custodian may end up sending the   bundle back to its upstream neighbor. Moreover, that custodian node   too may begin refusing custody of bundles subsequently sent to it,   since it can no longer compute a forwarding path.</li> <li>The upstream propagation of custody refusals directs bundles over   alternate paths that would otherwise be considered suboptimal,   balancing the queuing load across the parallel paths.</li> <li>Eventually, transmission and/or bundle expiration at the   oversubscribed node relieves queue pressure at that node and enables   acceptance of custody of a \"probe\" bundle from the upstream node.   This eventually returns the routing fabric to its original   configuration.</li> </ul> <p>Although the route computation procedures are relatively complex they are not computationally difficult. The impact on computation resources at the vehicles should be modest.</p>"},{"location":"ION-Guide/#ltp-timeout-intervals","title":"LTP Timeout Intervals","text":"<p>Suppose we've got Earth ground station ES that is currently in view of Mars but will be rotating out of view (\"Mars-set\") at some time T1 and rotating back into view (\"Mars-rise\") at time T3. Suppose we've also got Mars orbiter MS that is currently out of the shadow of Mars but will move behind Mars at time T2, emerging at time T4. Let's also suppose that ES and MS are 4 light-minutes apart (Mars is at its closest approach to Earth). Finally, for simplicity, let's suppose that both ES and MS want to be communicating at every possible moment (maximum link utilization) but never want to waste any electricity.</p> <p>Neither ES nor MS wants to be wasting power on either transmitting or receiving at a time when either Earth or Mars will block the signal.</p> <p>ES will therefore stop transmitting at either T1 or (T2 - 4 minutes), whichever is earlier; call this time Tet0. It will stop receiving -- that is, power off the receiver -- at either T1 or (T2 + 4 minutes), whichever is earlier; call this time Ter0. It will resume transmitting at either T3 or (T4 - 4 minutes), whichever is late, and it will resume reception at either T3 or (T4 + 4 minutes), whichever is later; call these times Tet1 and Ter1.</p> <p>Similarly, MS will stop transmitting at either T2 or (T1 - 4 minutes), whichever is earlier; call this time Tmt0. It will stop receiving -- that is, power off the receiver -- at either T2 or (T1 + 4 minutes), whichever is earlier; call this time Tmr0. It will resume transmitting at either T4 or (T3 - 4 minutes), whichever is later, and it will resume reception at either T4 or (T3 + 4 minutes), whichever is later; call these times Tmt1 and Tmr1.</p> <p>By making sure that we don't transmit when the signal would be blocked, we guarantee that anything that is transmitted will arrive at a time when it can be received. Any reception failure is due to data corruption en route.</p> <p>So the moment of transmission of an acknowledgment to any message is always equal to the moment the original message was sent plus some imputed outbound queuing delay QO1 at the sending node, plus 4 minutes, plus some imputed inbound and outbound queuing delay QI1 + QO2 at the receiving node. The nominally expected moment of reception of this acknowledgment is that moment of transmission plus 4 minutes, plus some imputed inbound queuing delay QI2 at the original sending node. That is, the timeout interval is 8 minutes + QO1 + QI1 + QO2 + QO2 -- unless this moment of acknowledgement transmission is during an interval when the receiving node is not transmitting, for whatever reason. In this latter case, we want to suspend the acknowledgment timer during any interval in which we know the remote node will not be transmitting. More precisely, we want to add to the timeout interval the time difference between the moment of message arrival and the earliest moment at which the acknowledgment could be sent, i.e., the moment at which transmission is resumed<sup>7</sup>.</p> <p>So the timeout interval Z computed at ES for a message sent to MS at time TX is given by:</p> <pre><code>Z = QO1 + 8 + QI1 + ((TA = TX + 4) &gt; Tmt0 &amp;&amp; TA &lt; Tmt1) ?\nTmt1 - TA: 0) + QI2 + QO2\n</code></pre> <p>This can actually be computed in advance (at time TX) if T1, T2, T3, and T4 are known and are exposed to the protocol engine.</p> <p>If they are not exposed, then Z must initially be estimated to be (2 * the one-way light time) + QI + QO. The timer for Z must be dynamically suspended at time Tmt0 in response to a state change as noted by ltpclock. Finally, the timer must be resumed at time Tmt1 (in response to another state change as noted by ltpclock), at which moment the correct value for Z can be computed.</p>"},{"location":"ION-Guide/#cfdp","title":"CFDP","text":"<p>The ION implementation of CFDP is very simple, because only Class-1 (Unacknowledged) functionality is implemented: the store-and-forward routing performed by Bundle Protocol makes the CFDP Extended Procedures unnecessary and the inter-node reliability provided by the CL protocol underneath BP -- in particular, by LTP -- makes the CFDP Acknowledged Procedures unnecessary. All that CFDP is required to do is segment and reassemble files, interact with the underlying Unitdata Transfer layer -- BP/LTP -- to effect the transmission and reception of file data segments, and handle CFDP metadata including filestore requests. CFDP-ION does all this, including support for cancellation of a file transfer transaction by cancellation of the transmission of the bundles encapsulating the transaction's protocol data units.</p> <p>Note that all CFDP data transmission is \"by reference\", via the ZCO system, rather than \"by value\": the retransmission buffer for a bundle containing CFDP file data is an extent of the original file itself, not a copy retained in the ION database, and data received in bundles containing CFDP PDU is written immediately to the appropriate location in the reconstituted file rather than stored in the ION database. This minimizes the space needed for the database. In general, file transmission via CFDP is the most memory-efficient way to use ION in flight operations.</p> <p>Figure 15 A CFDP-ION entity</p> <p></p>"},{"location":"ION-Guide/#list-data-structures-lyst-sdrlist-smlist","title":"List data structures (lyst, sdrlist, smlist)","text":"<p>Figure 16 ION list data structures</p> <p></p>"},{"location":"ION-Guide/#psm-partition-structure","title":"PSM Partition Structure","text":"<p>Figure 17 psm partition structure</p> <p></p>"},{"location":"ION-Guide/#psm-and-sdr-block-structures","title":"PSM and SDR Block Structures","text":"<p>Figure 18 psm and sdr block structures</p> <p></p>"},{"location":"ION-Guide/#sdr-heap-structure","title":"SDR Heap Structure","text":"<p>Figure 19 sdr heap structure</p> <p></p>"},{"location":"ION-Guide/#operation","title":"Operation","text":"<p>The ION source distribution contains a README.TXT file with details on building ION from source. For installations starts with the open source distribution ION-DTN, using the standard sequence of</p> <ul> <li> <p>./configure</p> </li> <li> <p>Note: the user needs to clear all errors reported by the     configure script before proceeding. The distribution contains a     default \"Makefile\" at the top level of the distribution for     developer use. The configure script must complete successfully     to produce an updated Makefile.</p> </li> <li>make</li> <li>sudo make install</li> </ul> <p>will build ION and install it under /usr/local.</p> <p>Users building from a clone of the repository need to use the command</p> <ul> <li>autoreconf -fi</li> </ul> <p>before starting the installation.</p> <p>The \"Build\" instructions shown in the following sections for each package are the instructions for building each package individually, for ION development purposes. The default installation target for the individual package build commands is /opt.</p> <p>One compile-time option is applicable to all ION packages: the platform selection parameters --DVXWORKS and --DRTEMS affect the manner in which most task instantiation functions are compiled. For VXWORKS and RTEMS, these functions are compiled as library functions that must be identified by name in the platform's symbol table, while for Unix-like platforms they are compiled as main()functions.</p>"},{"location":"ION-Guide/#interplanetary-communication-infrastructure-ici_1","title":"Interplanetary Communication Infrastructure (ICI)","text":""},{"location":"ION-Guide/#compile-time-options","title":"Compile-time options","text":"<p>Declaring values for the following variables, by setting parameters that are provided to the C compiler (for example, --DFSWSOURCE or --DSM_SEMBASEKEY=0xff13), will alter the functionality of ION as noted below.</p> <p><code>PRIVATE_SYMTAB</code></p> <p>This option causes ION to be built for VxWorks 5.4 or RTEMS with reliance on a small private local symbol table that is accessed by means of a function named sm_FindFunction. Both the table and the function definition are, by default, provided by the symtab.c source file, which is automatically included within the platform_sm.c source when this option is set. The table provides the address of the top-level function to be executed when a task for the indicated symbol (name) is to be spawned, together with the priority at which that task is to execute and the amount of stack space to be allocated to that task.</p> <p>PRIVATE_SYMTAB is defined by default for RTEMS but not for VxWorks 5.4.</p> <p>Absent this option, ION on VxWorks 5.4 must successfully execute the VxWorks symFindByName function in order to spawn a new task. For this purpose the entire VxWorks symbol table for the compiled image must be included in the image, and task priority and stack space allocation must be explicitly specified when tasks are spawned.</p> <p><code>FSWLOGGER</code></p> <p>This option causes the standard ION logging function, which simply writes all ION status messages to a file named ion.log in the current working directory, to be replaced (by #include) with code in the source file fswlogger.c. A file of this name must be in the inclusion path for the compiler, as defined by --Ixxxx compiler option parameters.</p> <p><code>FSWCLOCK</code></p> <p>This option causes the invocation of the standard time function within getUTCTime (in ion.c) to be replaced (by #include) with code in the source file fswutc.c, which might for example invoke a mission-specific function to read a value from the spacecraft clock. A file of this name must be in the inclusion path for the compiler.</p> <p><code>FSWWDNAME</code></p> <p>This option causes the invocation of the standard getcwd function within cfdpInit (in libcfdpP.c) to be replaced (by #include) with code in the source file wdname.c, which must in some way cause the mission-specific value of the current working directory name to be copied into cfdpdbBuf.workingDirectoryName. A file of this name must be in the inclusion path for the compiler.</p> <p><code>FSWSYMTAB</code></p> <p>If the PRIVATE_SYMTAB option is also set, then the FSWSYMTAB option causes the code in source file mysymtab.c to be included in platform_sm.c in place of the default symbol table access implementation in symtab.c. A file named mysymtab.c must be in the inclusion path for the compiler.</p> <p><code>FSWSOURCE</code></p> <p>This option simply causes FSWLOGGER, FSWCLOCK, FSWWDNAME, and FSWSYMTAB all to be set.</p> <p><code>GDSLOGGER</code></p> <p>This option causes the standard ION logging function, which simply writes all ION status messages to a file named ion.log in the current working directory, to be replaced (by #include) with code in the source file gdslogger.c. A file of this name must be in the inclusion path for the compiler, as defined by --Ixxxx compiler option parameters.</p> <p>GDSSOURCE</p> <p>This option simply causes GDSLOGGER to be set.</p> <p><code>ION_OPS_ALLOC=*xx*</code></p> <p>This option specifies the percentage of the total non-volatile storage space allocated to ION that is reserved for protocol operational state information, i.e., is not available for the storage of bundles or LTP segments. The default value is 20.</p> <p><code>ION_SDR_MARGIN=*xx*</code></p> <p>This option specifies the percentage of the total non-volatile storage space allocated to ION that is reserved simply as margin, for contingency use. The default value is 20.</p> <p>The sum of ION_OPS_ALLOC and ION_SDR_MARGIN defines the amount of non-volatile storage space that is sequestered at the time ION operations are initiated: for purposes of congestion forecasting and prevention of resource oversubscription, this sum is subtracted from the total size of the SDR \"heap\" to determine the maximum volume of space available for bundles and LTP segments. Data reception and origination activities fail whenever they would cause the total amount of data store space occupied by bundles and segments to exceed this limit.</p> <p><code>USING_SDR_POINTERS</code></p> <p>This is an optimization option for the SDR non-volatile data management system: when set, it enables the value of any variable in the SDR data store to be accessed directly by means of a pointer into the dynamic memory that is used as the data store storage medium, rather than by reading the variable into a location in local stack memory. Note that this option must not be enabled if the data store is configured for file storage only, i.e., if the SDR_IN_DRAM flag was set to zero at the time the data store was created by calling sdr_load_profile. See the ionconfig(5) man page in Appendix A for more information.</p> <p><code>NO_SDR_TRACE</code></p> <p>This option causes non-volatile storage utilization tracing functions to be omitted from ION when the SDR system is built. It disables a useful debugging option but reduces the size of the executable software.</p> <p><code>NO_PSM_TRACE</code></p> <p>This option causes memory utilization tracing functions to be omitted from ION when the PSM system is built. It disables a useful debugging option but reduces the size of the executable software.</p> <p><code>IN_FLIGHT</code></p> <p>This option controls the behavior of ION when an unrecoverable error is encountered.</p> <p>If it is set, then the status message \"Unrecoverable SDR error\" is logged and the SDR non-volatile storage management system is globally disabled: the current database access transaction is ended and (provided transaction reversibility is enabled) rolled back, and all ION tasks terminate.</p> <p>Otherwise, the ION task that encountered the error is simply aborted, causing a core dump to be produced to support debugging.</p> <p><code>SM_SEMKEY=0x*XXXX*</code></p> <p>This option overrides the default value (0xee01) of the identifying \"key\" used in creating and locating the global ION shared-memory system mutex.</p> <p><code>SVR4_SHM</code></p> <p>This option causes ION to be built using svr4 shared memory as the pervasive shared-memory management mechanism. svr4 shared memory is selected by default when ION is built for any platform other than MinGW, VxWorks 5.4, or RTEMS. (For these latter operating systems all memory is shared anyway, due to the absence of a protected-memory mode.)</p> <p><code>POSIX_NAMED_SEMAPHORES</code></p> <p>Starting with version 4.1.3, POSIX named semaphores is selected by default when ION is built for any platform other than MinGW (for which Windows event objects are used), VxWorks 5.4 (for which VxWorks native semaphores are the default choice), or RTEMS (for which POSIX semaphores are the default choice).</p> <p><code>POSIX_SEMAPHORES</code></p> <p>This option causes ION to be built using POSIX semaphores as the semaphore mechanism. POSIX semaphores are selected by default when ION is built for RTEMS but are otherwise not used or supported; this option enables the default to be overridden.</p> <p><code>SVR4_SEMAPHORES</code></p> <p>This option causes ION to be built using SVR4 semaphores as the  semaphore mechanism. Prior to version 4.1.3, SVR4 semaphores were the default choice for Linux, MacOS, and Solaris.</p> <p><code>SM_SEMBASEKEY=0x*XXXX*</code></p> <p>This option overrides the default value (0xee02) of the identifying \"key\" used in creating and locating the global ION shared-memory semaphore database, in the event that svr4 semaphores are used.</p> <p><code>SEMMNI=*xxx*</code></p> <p>This option declares to ION the total number of svr4 semaphore sets provided by the operating system, in the event that svr4 semaphores are used. It overrides the default value, which is 10 for Cygwin and 128 otherwise. (Changing this value typically entails rebuilding the O/S kernel.)</p> <p><code>SEMMSL=*xxx*</code></p> <p>This option declares to ION the maximum number of semaphores in each svr4 semaphore set, in the event that svr4 semaphores are used. It overrides the default value, which is 6 for Cygwin and 250 otherwise. (Changing this value typically entails rebuilding the O/S kernel.)</p> <p><code>SEMMNS=*xxx*</code></p> <p>This option declares to ION the total number of svr4 semaphores that the operating system can support; the maximum possible value is SEMMNI x SEMMSL. It overrides the default value, which is 60 for Cygwin and 32000 otherwise. (Changing this value typically entails rebuilding the O/S kernel.)</p> <p><code>ION_NO_DNS</code></p> <p>This option causes the implementation of a number of Internet socket I/O operations to be omitted for ION. This prevents ION software from being able to operate over Internet connections, but it prevents link errors when ION is loaded on a spacecraft where the operating system does not include support for these functions.</p> <p><code>ERRMSGS_BUFSIZE=*xxxx*</code></p> <p>This option set the size of the buffer in which ION status messages are constructed prior to logging. The default value is 4 KB.</p> <p><code>SPACE_ORDER=*x*</code></p> <p>This option declares the word size of the computer on which the compiled ION software will be running: it is the base-2 log of the number of bytes in an address. The default value is 2, i.e., the size of an address is 2^2^ = 4 bytes. For a 64-bit machine, SPACE_ORDER must be declared to be 3, i.e., the size of an address is 2^3^ = 8 bytes.</p> <p><code>NO_SDRMGT</code></p> <p>This option enables the SDR system to be used as a data access transaction system only, without doing any dynamic management of non-volatile data. With the NO_SDRMGT option set, the SDR system library can (and in fact must) be built from the sdrxn.c source file alone.</p> <p><code>DOS_PATH_DELIMITER</code></p> <p>This option causes ION_PATH_DELIMITER to be set to '\\' (backslash), for use in construction path names. The default value of ION_PATH_DELIMITER is '/' (forward slash, as is used in Unix-like operating systems).</p>"},{"location":"ION-Guide/#build","title":"Build","text":"<p>To build ICI for a given deployment platform:</p> <ol> <li> <p>Decide where you want ION's executables, libraries, header files,    etc. to be installed. The ION makefiles all install their build    products to subdirectories (named bin, lib, include,    man, man/man1, man/man3, man/man5) of an ION root    directory, which by default is the directory named /opt. If you    wish to use the default build configuration, be sure that the    default directories (/opt/bin, etc.) exist; if not, select    another ION root directory name -- this document will refer to it as    $OPT -- and create the subdirectories as needed. In any case,    make sure that you have read, write, and execute permission for all    of the ION installation directories and that:</p> </li> <li> <p>The directory /$OPT/bin is in your execution path.</p> </li> <li>The directory /$OPT/lib is in your $LD_LOADLIB_PATH.</li> <li> <p>Edit the Makefile in ion/ici:</p> </li> <li> <p>Make sure PLATFORMS is set to the appropriate platform name, e.g.,   x86-redhat, sparc-sol9, etc.</p> </li> <li> <p>Set OPT to the directory where you want to install the ici packages   you build, if other than \"/opt\" (for example: /usr/local).</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/ici\nsudo make\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure","title":"Configure","text":"<p>Three types of files are used to provide the information needed to perform global configuration of the ION protocol stack: the ION system configuration (or ionconfig) file, the ION administration command (ionrc) file, and the ION security configuration (ionsecrc) file. For details, see the man pages for ionconfig(5), ionrc(5), and ionsecrc(5) in Appendix A.</p> <p>Normally the instantiation of ION on a given computer establishes a single ION node on that computer, for which hard-coded values of wmKey and sdrName (see ionconfig(5)) are used in common by all executables to assure that all elements of the system operate within the same state space. For some purposes, however, it may be desirable to establish multiple ION nodes on a single workstation. (For example, constructing an entire self-contained DTN network on a single machine may simplify some kinds of regression testing.) ION supports this configuration option as follows:</p> <ul> <li>Multi-node operation on a given computer is enabled if and only if   the environment variable ION_NODE_LIST_DIR is defined in the   environment of every participating ION process. Moreover, the value   assigned to this variable must be the same text string in the   environments of all participating ION processes. That value must be   the name (preferably, fully qualified) of the directory in which the   ION multi-node database file \"ion_nodes\" will reside.</li> <li>The definition of ION_NODE_LIST_DIR makes it possible to establish   up to one ION node per directory rather than just one ION node on   the computer. When ionadmin is used to establish a node, the   ionInitialize() function will get that node's wmKey and sdrName from   the .ionconfig file, use them to allocate working memory and create   the SDR database, and then write a line to the ion_nodes file noting   the nodeNbr, wmKey, sdrName, and wdName for the node it just   initialized. wdName is the current working directory in which   ionadmin was running at the time ionInitialize()is called; it is   the directory within which the node resides.</li> <li>This makes it easy to connect all the node\\'s daemon processes --   running within the same current working directory -- to the correct   working memory partition and SDR database: the ionAttach() function   simply searches the ion_nodes file for a line whose wdName matches   the current working directory of the process that is trying to   attach, then uses that line\\'s wmKey and sdrName to link up.</li> <li>It is also possible to initiate a process from within a directory   other than the one in which the node resides. To do so, define the   additional environment variable ION_NODE_WDNAME in the shell from   which the new process is to be initiated. When ionAttach() is called   it will first try to get \\\"current working directory\\\" (for ION   attachment purposes only) from that environment variable; only   if ION_NODE_WDNAME is undefined will it use the actual cwd that it   gets from calling igetcwd().</li> <li>When running multiple ION instances, the first ION instance must have the largest sdr working memory specified by <code>sdrWmSize</code> or default. If any later ION instance launched with <code>sdrWmSize</code> exceeding the first ION instance, it will result in crash upon launch. It is further recommended that all ION instances running simultaneously on a single host should set their <code>sdrWmSize</code> the same.</li> </ul>"},{"location":"ION-Guide/#run","title":"Run","text":"<p>The executable programs used in operation of the ici component of ION include:</p> <ul> <li>The ionadmin system configuration utility and ionsecadmin   security configuration utility, invoked at node startup time and as   needed thereafter.</li> <li>The rfxclock background daemon, which affects scheduled network   configuration events.</li> <li>The sdrmend system repair utility, invoked as needed.</li> <li>The sdrwatch and psmwatch utilities for resource utilization   monitoring, invoked as needed.</li> </ul> <p>Each time it is executed, ionadmin computes a new congestion forecast and, if a congestion collapse is predicted, invokes the node's congestion alarm script (if any). ionadmin also establishes the node number for the local node and starts/stops the rfxclock task, among other functions. For further details, see the man pages for ionadmin(1), ionsecadmin(1), rfxclock(1), sdrmend(1), sdrwatch(1), and psmwatch(1) in Appendix A.</p>"},{"location":"ION-Guide/#test","title":"Test","text":"<p>Six test executables are provided to support testing and debugging of the ICI component of ION:</p> <ul> <li>The file2sdr and sdr2file programs exercise the SDR system.</li> <li>The psmshell program exercises the PSM system.</li> <li>The file2sm, sm2file, and smlistsh programs exercise the   shared-memory linked list system.</li> </ul> <p>For details, see the man pages for file2sdr(1), sdr2file(1), psmshell(1), file2sm(1), sm2file(1), and smlistsh(1) in Appendix A.</p>"},{"location":"ION-Guide/#licklider-transmission-protocol-ltp_1","title":"Licklider Transmission Protocol (LTP)","text":""},{"location":"ION-Guide/#build_1","title":"Build","text":"<p>To build LTP:</p> <ol> <li>Make sure that the \"ici\" component of ION has been built for the    platform on which you plan to run LTP.</li> <li> <p>Edit the Makefile in ion/ltp:</p> </li> <li> <p>As for ici, make sure PLATFORMS is set to the name of the platform   on which you plan to run LTP.</p> </li> <li> <p>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed (for example:   /usr/local).</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/ltp\nmake\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure_1","title":"Configure","text":"<p>The LTP administration command (ltprc) file provides the information needed to configure LTP on a given ION node. For details, see the man page for ltprc(5) in Appendix A.</p>"},{"location":"ION-Guide/#run_1","title":"Run","text":"<p>The executable programs used in operation of the ltp component of ION include:</p> <ul> <li>The ltpadmin protocol configuration utility, invoked at node   startup time and as needed thereafter.</li> <li>The ltpclock background daemon, which affects scheduled LTP   events such as segment retransmissions.</li> <li>The ltpmeter block management daemon, which segments blocks and   effects LTP flow control.</li> <li>The udplsi and udplso link service input and output tasks,   which handle transmission of LTP segments encapsulated in UDP   datagrams (mainly for testing purposes).</li> </ul> <p>ltpadmin starts/stops the ltpclock and ltpmeter tasks and, as mandated by configuration, the udplsi and udplso tasks.</p> <p>For details, see the man pages for ltpadmin(1), ltpclock(1), ltpmeter(1), udplsi(1), and udplso(1) in Appendix A.</p>"},{"location":"ION-Guide/#test_1","title":"Test","text":"<p>Two test executables are provided to support testing and debugging of the LTP component of ION:</p> <ul> <li>ltpdriver is a continuous source of LTP segments.</li> <li>ltpcounter is an LTP block receiver that counts blocks as they   arrive.</li> </ul> <p>For details, see the man pages for ltpdriver(1) and ltpcounter(1) in Appendix A.</p>"},{"location":"ION-Guide/#bundle-streaming-service-protocol-bssp","title":"Bundle Streaming Service Protocol (BSSP)","text":""},{"location":"ION-Guide/#build_2","title":"Build","text":"<p>To build BSSP:</p> <ol> <li>Make sure that the \"ici\" component of ION has been built for the    platform on which you plan to run BSSP.</li> <li> <p>Edit the Makefile in ion/bssp:</p> </li> <li> <p>As for ici, make sure PLATFORMS is set to the name of the platform   on which you plan to run BSSP.</p> </li> <li> <p>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed (for example:   /usr/local).</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/bssp\nmake\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure_2","title":"Configure","text":"<p>The BSSP administration command (bssprc) file provides the information needed to configure BSSP on a given ION node. For details, see the man page for bssprc(5) in Appendix A.</p> <p>The bssprc file has a command option specifying the max_block_size. This is to prevent retransmission inefficiency when the blocks size of a stream data is too large. The unit of retransmission for BSSP is the block, so if the block size is too large, it is very expensive to the network to provide retransmission. If one needs bulk data transfer, instead of streaming, one should use BP with reliability LTP instead of using BSSP. If you are using udpbso and udpbsi as the underlying convergence layer, then the max_block_size parameter for bssprc cannot be larger than 65507 bytes, because each UDP datagram can only be as large as 65507 bytes (payload) + 20 (IP Header) + 8 (UDP Header) = 65535 byte.</p>"},{"location":"ION-Guide/#run_2","title":"Run","text":"<p>The executable programs used in operation of the bssp component of ION include:</p> <ul> <li>The bsspadmin protocol configuration utility, invoked at node   startup time and as needed thereafter.</li> <li>The bsspclock background daemon, which affects scheduled BSSP   events such as segment retransmissions.</li> <li>The udpbsi and udpbso link service input and output tasks,   which handle transmission of BSSP segments encapsulated in UDP   datagrams (mainly for testing purposes; in space domain, the   appropriate CCSDS link layer will be used instead of UDP).</li> </ul> <p>bsspadmin starts/stops the bsspclock task and, as mandated by configuration, the udpbsi and udblso tasks.</p> <p>For details, see the man pages for bsspadmin(1), bsspclock(1), bsspmeter(1), udpbsi(1), and udpbso(1) in Appendix A.</p>"},{"location":"ION-Guide/#bundle-protocol-bp_1","title":"Bundle Protocol (BP)","text":""},{"location":"ION-Guide/#compile-time-options_1","title":"Compile-time options","text":"<p>Declaring values for the following variables, by setting parameters that are provided to the C compiler (for example, --DION_NOSTATS or --DBRSTERM=60), will alter the functionality of BP as noted below.</p>"},{"location":"ION-Guide/#targetffs","title":"TargetFFS","text":"<p>Setting this option adapts BP for use with the TargetFFS flash file system on the VxWorks operating system. TargetFFS apparently locks one or more system semaphores so long as a file is kept open. When a BP task keeps a file open for a sustained interval, subsequent file system access may cause a high-priority non-BP task to attempt to lock the affected semaphore and therefore block; in this event, the priority of the BP task may automatically be elevated by the inversion safety mechanisms of VxWorks. This \"priority inheritance\" can result in preferential scheduling for the BP task -- which does not need it -- at the expense of normally higher-priority tasks, and can thereby introduce runtime anomalies. BP tasks should therefore close files immediately after each access when running on a VxWorks platform that uses the TargetFFS flash file system. The TargetFFS compile-time option ensures that they do so.</p>"},{"location":"ION-Guide/#brstermxx","title":"BRSTERM=xx","text":"<p>This option sets the maximum number of seconds by which the current time at the BRS server may exceed the time tag in a BRS authentication message from a client; if this interval is exceeded, the authentication message is presumed to be a replay attack and is rejected. Small values of BRSTERM are safer than large ones, but they require that clocks be more closely synchronized. The default value is 5.</p>"},{"location":"ION-Guide/#ion_nostats","title":"ION_NOSTATS","text":"<p>Setting this option prevents the logging of bundle processing statistics in status messages.</p>"},{"location":"ION-Guide/#keepalive_periodxx","title":"KEEPALIVE_PERIOD=xx","text":"<p>This option sets the number of seconds between transmission of keep-alive messages over any TCP or BRS convergence-layer protocol connection. The default value is 15.</p>"},{"location":"ION-Guide/#ion_bandwidth_reserved","title":"ION_BANDWIDTH_RESERVED","text":"<p>Setting this option overrides strict priority order in bundle transmission, which is the default. Instead, bandwidth is shared between the priority-1 and priority-0 queues on a 2:1 ratio whenever there is no priority-2 traffic.</p>"},{"location":"ION-Guide/#enable_bpacs","title":"ENABLE_BPACS","text":"<p>This option causes Aggregate Custody Signaling source code to be included in the build. ACS is alternative custody transfer signaling mechanism that sharply reduces the volume of custody acknowledgment traffic.</p>"},{"location":"ION-Guide/#enable_imc","title":"ENABLE_IMC","text":"<p>This option causes IPN Multicast source code to be included in the build. IMC is discussed in section 1.8.4 above.</p>"},{"location":"ION-Guide/#build_3","title":"Build","text":"<p>To build BP:</p> <ol> <li>Make sure that the \"ici\", \"ltp\", \"dgr\", and \"bssp\" components of ION    have been built for the platform on which you plan to run BP.</li> <li> <p>Edit the Makefile in ion/bp:</p> </li> <li> <p>As for ici, make sure PLATFORMS is set to the name of the platform   on which you plan to run BP.</p> </li> <li> <p>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed (for example:   /usr/local).</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/bp\nmake\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure_3","title":"Configure","text":"<p>The BP administration command (bprc) file provides the information needed to configure generic BP on a given ION node. The IPN scheme administration command (ipnrc) file provides information that configures static and default routes for endpoints whose IDs conform to the \"ipn\" scheme. The DTN scheme administration command (dtn2rc) file provides information that configures static and default routes for endpoints whose IDs conform to the \"dtn\" scheme, as supported by the DTN2 reference implementation. For details, see the man pages for bprc(5), ipnrc(5), and dtn2rc(5) in Appendix A.</p>"},{"location":"ION-Guide/#run_3","title":"Run","text":"<p>The executable programs used in operation of the bp component of ION include:</p> <ul> <li>The bpadmin, ipnadmin, and dtn2admin protocol configuration   utilities, invoked at node startup time and as needed thereafter.</li> <li>The bpclock background daemon, which effects scheduled BP events   such as TTL expirations and which also implements rate control.</li> <li>The ipnfw and dtn2fw forwarding daemons, which compute   routes for bundles addressed to \"ipn\"-scheme and \"dtn\"-scheme   endpoints, respectively.</li> <li>The ipnadminep and dtn2adminep administrative endpoint   daemons, which handle custody acceptances, custody refusals, and   status messages.</li> <li>The bpclm background daemon, which selects convergence-layer   outducts by which bundles are transmitted to neighboring nodes.</li> <li>The brsscla (server) and brsccla (client) Bundle Relay   Service convergence-layer adapters.</li> <li>The tcpcli (input) TCP convergence-layer adapter, which includes   convergence-layer output functionality in privately managed threads.</li> <li>The stcpcli (input) and stcpclo (output) simplified TCP   convergence-layer adapters.</li> <li>The udpcli (input) and udpclo (output) UDP convergence-layer   adapters.</li> <li>The ltpcli (input) and ltpclo (output) LTP convergence-layer   adapters.</li> <li>The dgrcla Datagram Retransmission convergence-layer adapter.</li> <li>The bpsendfile utility, which sends a file of arbitrary size,   encapsulated in a single bundle, to a specified BP endpoint.</li> <li>The bpstats utility, which prints a snapshot of currently   accumulated BP processing statistics on the local node.</li> <li>The bptrace utility, which sends a bundle through the network to   enable a forwarding trace based on bundle status reports.</li> <li>The lgsend and lgagent utilities, which are used for remote   administration of ION nodes.</li> <li>The hmackeys utility, which can be used to create hash keys   suitable for use in bundle authentication blocks and BRS   convergence-layer protocol connections.</li> </ul> <p>bpadmin starts/stops the bpclock task and, as mandated by configuration, the ipnfw, dtn2fw, ipnadminep, dtn2adminep, bpclm, brsscla, brsccla, tcpcli, stcpcli, stcpclo, udpcli, udpclo, ltpcli, ltpclo, and dgrcla tasks.</p> <p>For details, see the man pages for bpadmin(1),ipnadmin(1), dtn2admin(1), bpclock(1), bpclm(1), ipnfw(1), dtn2fw(1), ipnadminep(1), dtn2adminep(1), brsscla(1), brsccla(1),tcpcli(1), stcpcli(1), stcpclo(1), udpcli(1), udpclo(1), ltpcli(1), ltpclo(1), dgrcla(1), bpsendfile(1), bpstats(1), bptrace(1), lgsend(1), lgagent(1), and hmackeys(1) in Appendix A.</p>"},{"location":"ION-Guide/#test_2","title":"Test","text":"<p>Five test executables are provided to support testing and debugging of the BP component of ION:</p> <ul> <li>bpdriver is a continuous source of bundles.</li> <li>bpcounter is a bundle receiver that counts bundles as they   arrive.</li> <li>bpecho is a bundle receiver that sends an \"echo\" acknowledgment   bundle back to bpdriver upon reception of each bundle.</li> <li>bpsource is a simple console-like application for interactively   sending text strings in bundles to a specified DTN endpoint,   nominally a bpsink task.</li> <li>bpsink is a simple console-like application for receiving   bundles and printing their contents.</li> </ul> <p>For details, see the man pages for bpdriver(1), bpcounter(1), bpecho(1), bpsource(1), and bpsink(1) in Appendix A.</p>"},{"location":"ION-Guide/#datagram-retransmission-dgr_1","title":"Datagram Retransmission (DGR)","text":""},{"location":"ION-Guide/#build_4","title":"Build","text":"<p>To build DGR:</p> <ol> <li>Make sure that the \"ici\" component of ION has been built for the    platform on which you plan to run DGR.</li> <li> <p>Edit the Makefile in ion/dgr:</p> </li> <li> <p>As for ici, make sure PLATFORMS is set to the name of the platform   on which you plan to run DGR.</p> </li> <li> <p>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed (for example:   /usr/local).</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/dgr\nmake\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure_4","title":"Configure","text":"<p>No additional configuration files are required for the operation of the DGR component of ION.</p>"},{"location":"ION-Guide/#run_4","title":"Run","text":"<p>No runtime executables are required for the operation of the DGR component of ION.</p>"},{"location":"ION-Guide/#test_3","title":"Test","text":"<p>Two test executables are provided to support testing and debugging of the DGR component of ION:</p> <ul> <li>file2dgr repeatedly reads a file of text lines and sends copies   of those text lines via DGR to dgr2file, which writes them to a   copy of the original file.</li> </ul> <p>For details, see the man pages for file2dgr(1) and dgr2file(1) in Appendix A.</p>"},{"location":"ION-Guide/#asynchronous-message-service-ams_1","title":"Asynchronous Message Service (AMS)","text":""},{"location":"ION-Guide/#compile-time-options_2","title":"Compile-time options","text":"<p>Note that, by default, the syntax by which AMS MIB information is presented to AMS is as documented in the \"amsrc\" man page. Alternatively it is possible to use an XML-based syntax as documented in the \"amsxml\" man page. To use the XML-based syntax instead, be sure that the \"expat\" XML interpretation system is installed and pass the argument \"--with-expat\" to \"./configure\" when building ION.</p> <p>Defining the following macros, by setting parameters that are provided to the C compiler (for example, DAMS_INDUSTRIAL), will alter the functionality of AMS as noted below.</p> <p><code>AMS_INDUSTRIAL</code></p> <p>Setting this option adapts AMS to an \"industrial\" rather than safety-critical model for memory management. By default, the memory acquired for message transmission and reception buffers in AMS is allocated from limited ION working memory, which is fixed at ION start-up time; this limits the rate at which AMS messages may be originated and acquired. When --DAMS_INDUSTRIAL is set at compile time, the memory acquired for message transmission and reception buffers in AMS is allocated from system memory, using the familiar malloc() and free() functions; this enables much higher message traffic rates on machines with abundant system memory.</p>"},{"location":"ION-Guide/#build_5","title":"Build","text":"<p>To build AMS:</p> <ol> <li>Make sure that the \"bp\" component of ION has been built for the    platform on which you plan to run AMS.</li> <li> <p>Edit the Makefile in ion/cfdp:</p> </li> <li> <p>Just as for bp, make sure PLATFORMS is set to the name of the   platform on which you plan to run AMS.</p> </li> <li> <p>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed (for example:   /usr/local).</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/ams\nmake\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure_5","title":"Configure","text":"<p>There is no central configuration of AMS; each AMS entity (configuration server, registrar, or application module) is individually configured at the time its initial MIB is loaded at startup. Note that a single MIB may be shared between multiple AMS entities without issue.</p> <p>For details of MIB file syntax, see the man pages for amsrc(5) and amsxml(5) in Appendix A.</p>"},{"location":"ION-Guide/#run_5","title":"Run","text":"<p>The executable programs used in operation of the AMS component of ION include:</p> <ul> <li>The amsd background daemon, which serves as configuration server   and/or as the registrar for a single application cell.</li> <li>The ramsgate application module, which serves as the Remote AMS   gateway for a single message space.</li> <li>The amsstop utility, which terminates all AMS operation   throughout a single message space.</li> <li>The amsmib utility, which announces supplementary MIB   information to selected subsets of AMS entities without interrupting   the operation of the message space.</li> </ul> <p>For details, see the man pages for amsd(1), ramsgate(1), amsstop(1), and amsmib(1) in Appendix A.</p>"},{"location":"ION-Guide/#test_4","title":"Test","text":"<p>Seven test executables are provided to support testing and debugging of the AMS component of ION:</p> <ul> <li>amsbenchs is a continuous source of messages.</li> <li>amsbenchr is a message receiver that calculates bundle   transmission performance statistics.</li> <li>amshello is an extremely simple AMS \"hello, world\" demo program   -- a self-contained distributed application in a single source file   of about seventy lines.</li> <li>amsshell is a simple console-like application for interactively   publishing, sending, and announcing text strings in messages.</li> <li>amslog is a simple console-like application for receiving   messages and piping their contents to stdout.</li> <li>amslogprt is a pipeline program that simply prints AMS message   contents piped to it from amslog.</li> <li>amspubsub is a pair of functions for rudimentary testing of AMS   functionality in a VxWorks environment.</li> </ul> <p>For details, see the man pages for amsbenchs(1), amsbenchr(1), amshello(1), amsshell(1), amslog(1), amslogprt(1), amspub(1), and amssub(1) in Appendix A.</p> <p>For further operational details of the AMS system, please see sections 4 and 5 of the AMS Programmer's Guide.</p>"},{"location":"ION-Guide/#ccsds-file-delivery-protocol-cfdp_1","title":"CCSDS File Delivery Protocol (CFDP)","text":""},{"location":"ION-Guide/#compile-time-options_3","title":"Compile-time options","text":"<p>Defining the following macro, by setting a parameter that is provided to the C compiler (i.e., --DTargetFFS), will alter the functionality of CFDP as noted below.</p>"},{"location":"ION-Guide/#targetffs_1","title":"TargetFFS","text":"<p>Setting this option adapts CFDP for use with the TargetFFS flash file system on the VxWorks operating system. TargetFFS apparently locks one or more system semaphores so long as a file is kept open. When a CFDP task keeps a file open for a sustained interval, subsequent file system access may cause a high-priority non-CFDP task to attempt to lock the affected semaphore and therefore block; in this event, the priority of the CFDP task may automatically be elevated by the inversion safety mechanisms of VxWorks. This \"priority inheritance\" can result in preferential scheduling for the CFDP task -- which does not need it -- at the expense of normally higher-priority tasks, and can thereby introduce runtime anomalies. CFDP tasks should therefore close files immediately after each access when running on a VxWorks platform that uses the TargetFFS flash file system. The TargetFFS compile-time option ensures that they do so.</p>"},{"location":"ION-Guide/#build_6","title":"Build","text":"<p>To build CFDP:</p> <ol> <li>Make sure that the \"bp\" component of ION has been built for the    platform on which you plan to run CFDP.</li> <li> <p>Edit the Makefile in ion/cfdp:</p> </li> <li> <p>Just as for bp, make sure PLATFORMS is set to the name of the   platform on which you plan to run CFDP.</p> </li> <li> <p>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed.</p> </li> <li> <p>Then:</p> </li> </ol> <pre><code>cd ion/cfdp\n\nmake\n\nmake install\n</code></pre>"},{"location":"ION-Guide/#configure_6","title":"Configure","text":"<p>The CFDP administration command (cfdprc) file provides the information needed to configure CFDP on a given ION node. For details, see the man page for cfdprc(5) in Appendix A.</p>"},{"location":"ION-Guide/#run_6","title":"Run","text":"<p>The executable programs used in operation of the CFDP component of ION include:</p> <ul> <li>The cfdpadmin protocol configuration utility, invoked at node   startup time and as needed thereafter.</li> <li>The cfdpclock background daemon, which affects scheduled CFDP   events such as check timer expirations. The cfdpclock task also   affects CFDP transaction cancellations, by canceling the bundles   encapsulating the transaction's protocol data units.</li> <li>The bputa UT-layer input/output task, which handles transmission   of CFDP PDUs encapsulated in bundles.</li> </ul> <p>cfdpadmin starts/stops the cfdpclock task and, as mandated by configuration, the bputa task.</p> <p>For details, see the man pages for cfdpadmin(1), cfdpclock(1), and bputa(1) in Appendix A.</p>"},{"location":"ION-Guide/#test_5","title":"Test","text":"<p>A single executable, cfdptest, is provided to support testing and debugging of the DGR component of ION. For details, see the man page for cfdptest(1) in Appendix A.</p>"},{"location":"ION-Guide/#bundle-streaming-service-bss_1","title":"Bundle Streaming Service (BSS)","text":""},{"location":"ION-Guide/#compile-time-options_4","title":"Compile-time options","text":"<p>Defining the following macro, by setting a parameter that is provided to the C compiler (e.g., --DWINDOW=10000), will alter the functionality of BSS as noted below.</p>"},{"location":"ION-Guide/#windowxx","title":"WINDOW=xx","text":"<p>Setting this option changes the maximum number of seconds by which the BSS database for a BSS application may be \"rewound\" for replay. The default value is 86400 seconds, which is 24 hours.</p>"},{"location":"ION-Guide/#build_7","title":"Build","text":"<p>To build BSS:</p> <ul> <li>Make sure that the \"bp\" component of ION has been built for the   platform on which you plan to run BSS.</li> <li>Edit the Makefile in ion/bss:</li> <li>As for ici, make sure PLATFORMS is set to the name of the platform   on which you plan to run BSS.</li> <li>Set OPT to the directory containing the bin, lib, include, etc.   directories where the ici package is installed (for example:   /usr/local).</li> <li>Then:</li> </ul> <pre><code>cd ion/bss\n\nmake\n\nsudo make install\n</code></pre>"},{"location":"ION-Guide/#configure_7","title":"Configure","text":"<p>No additional configuration files are required for the operation of the BSS component of ION.</p>"},{"location":"ION-Guide/#run_7","title":"Run","text":"<p>No runtime executables are required for the operation of the BSS component of ION.</p>"},{"location":"ION-Guide/#test_6","title":"Test","text":"<p>Four test executables are provided to support testing and debugging of the BSS component of ION:</p> <ul> <li>bssdriver sends a stream of data to bsscounter for   non-interactive testing.</li> <li>bssStreamingApp sends a stream of data to bssrecv for   graphical, interactive testing.</li> </ul> <p>For details, see the man pages for bssdriver(1), bsscounter(1), bssStreamingApp(1), and bssrecv(1) in Appendix A.</p> <ol> <li> <p>In ION, reliable convergence-layer protocols (where available) are    by default used for every bundle. The application can instead    mandate selection of \"best-effort\" service at the convergence layer    by setting the BP_BEST_EFFORT flag in the \"extended class of service    flags\" parameter, but this feature is an ION extension that is not    supported by other BP implementations at the time of this writing.\u00a0\u21a9</p> </li> <li> <p>Note that, in all occupancy figures, ION data management accounts    not only for the sizes of the payloads of all queued bundles but    also for the sizes of their headers.\u00a0\u21a9</p> </li> <li> <p>Barring data loss or corruption for which the various    retransmission mechanisms in ION cannot compensate.\u00a0\u21a9</p> </li> <li> <p>Note that ION may indeed block the offering of a message to the    network, but this is local admission control -- assuring that the    node's local buffer space for queuing outbound bundles is not    oversubscribed -- rather than end-to-end flow control. It is always    possible for there to be ample local buffer space yet insufficient    network capacity to convey the offered data to their final    destination, and vice versa.\u00a0\u21a9</p> </li> <li> <p>The minimum size of an ION bundle header is 26 bytes. Adding    extension blocks (such as those that effect the Bundle Security    Protocol) will increase this figure.\u00a0\u21a9</p> </li> <li> <p>In ION, all bundles are by default non-critical. The application    can indicate that data should be sent in a Critical bundle by    setting the BP_MINIMUM_LATENCY flag in the \"extended class of    service\" parameter, but this feature is an ION extension that is not    supported by other BP implementations at the time of this writing.\u00a0\u21a9</p> </li> <li> <p>If we wanted to be extremely accurate we could also    subtract from the timeout interval the imputed inbound    queuing delay QI, since inbound queuing would presumably be    completed during the interval in which transmission was suspended.    But since we're guessing at the queuing delays anyway, this    adjustment doesn't make a lot of sense.\u00a0\u21a9</p> </li> </ol>"},{"location":"ION-Launcher/","title":"ION Launcher","text":"<p>Last Updated: 12/27/2023</p> <p>Previous versions of ION required a good understanding of the different ION adminstrative programs, how to write RC files from them, and what the different configuration commands mean.</p> <p>The  <code>ionlauncher</code> was developed to ease the user into ION configuration by taking a few parameters that mission designer would likely know when planning a network. Using those parameters, captured in a simple JSON format, an entire ION network with defined configurations files can be created and started rather quickly.</p>"},{"location":"ION-Launcher/#simple-network-model-syntax","title":"Simple Network Model Syntax","text":"<p>This section will outline the necessary parameters needed to create a simple model for <code>ionlauncher</code>.</p>"},{"location":"ION-Launcher/#model-parameters","title":"Model Parameters","text":"<p>There are seven parameters that are needed to define a simple network model. They are as follows:</p> <pre><code>NAME: serves as the key for the other parameters and naming start scripts\nIP ADDRESS: Host IP address or domain name the node will be running on\nNODE: assigned node number, will be used for addressing with neighbor(s)\nSERVICES: Applications running on the node, currently supports CFDP, AMS, &amp; AMP\nDEST: node's neighbor(s)\nPROTOCOL: convergance layer to reach a neighbor. Currently supported options include LTP, TCP, UDP, and STCP. \n            (untested options: BSSP &amp; DCCP)\nRATE: Data rate used to communicate with neighbor(s), in bytes/s\n</code></pre>"},{"location":"ION-Launcher/#example-model","title":"Example Model","text":"<p>There are a few example models included with the <code>ionlauncher</code> prototype under example_models/. This section shows one of them and explains how it works.</p> <pre><code>{\n    \"SC\": {\n        \"IP\": \"192.168.1.115\",\n        \"NODE\": 21,\n        \"SERVICES\": [],\n        \"DEST\": [\n            \"Relay\"\n        ],\n        \"PROTOCOL\": [\n            \"ltp\"\n        ],\n        \"RATE\": [\n            100000\n        ]\n    },\n    \"Relay\": {\n        \"IP\": \"192.168.1.114\",\n        \"NODE\": 22,\n        \"SERVICES\": [],\n        \"DEST\": [\n            \"SC\",\n            \"GS\"\n        ],\n        \"PROTOCOL\": [\n            \"ltp\",\n            \"tcp\"\n        ],\n        \"RATE\": [\n            10000,\n            2500000\n        ]\n    },\n    \"GS\": {\n        \"IP\": \"192.168.1.113\",\n        \"NODE\": 23,\n        \"SERVICES\": [],\n        \"DEST\": [\n            \"Relay\"\n        ],\n        \"PROTOCOL\": [\n            \"tcp\"\n        ],\n        \"RATE\": [\n            2500000\n        ]\n    }\n}\n</code></pre> <p>This is an example of a three node setup where Relay serves as a DTN relay between SC and GS. Order is important in the lists for DEST, PROTOCOL, and RATE. They assume each element in the lists correspond to each other. For example, Relay communicates with SC via LTP at 10,000 bytes/s and Relay communicates with GS via TCP at 2,500,000 bytes/s.</p> <p>There are other two examples included with <code>ionlaucher</code>. The first is a simple two node setup over TCP. The second is a four node scenario where SC can only uplink to Relay1 and downlink from Relay2, while GS has continuous coverage of the two relays.</p>"},{"location":"ION-Launcher/#prototype-ion-413","title":"Prototype - ION 4.1.3","text":"<p>Ionlauncher is currently a prototype and may not be installed globally. Please make sure that both <code>ionlauncher</code> and <code>net_model_gen</code> in the demo folder has been copied to the execution path of ION, which is typically <code>/usr/local/bin</code> or something specified as part of the ./configure script during initial ION installation.</p> <p>Ionlauncher's simple network model file current does not handle multi-network interface configuration - this will be updated for ION 4.1.4.</p>"},{"location":"ION-Launcher/#usage","title":"Usage","text":"<p>This section will outline how to run ionlauncher and what the different parameters mean. It is assumed <code>ionlauncher</code> will be run on each host independently with the same simple model and the only parameter changing is the node name.</p> <p><code>ionlauncher [-h] -n &lt;node name&gt; -m &lt;simple model file&gt; [-d &lt;ionconfig cli directory&gt;]</code></p> <pre><code>-h: display help\n-n: node name that will be used to start ION on the host\n-m: path to simple model file, ionlauncher assumes the file \n    is in the same directory or a directory below\n-d: optional parameter that defines the path to the ION Config \n    tool CLI scripts, default is /home/$USER/ionconfig-4.8.1/cli/bin\n</code></pre> <p>Once the ION configuration files have been generate. ION will be started using the configuration files for the node passed via <code>-n</code>. Stopping the node is done via <code>ionstop</code> and if that hangs or errors out, <code>killm</code> can be used to force stop ION processes. To restart ION, <code>ionlauncher</code> can be used again, but this will overwrite the configuration files and wipe out any customization that has been added to the initial set of configuration files generated from previous run. If you did not add any customization, it is perfectly find to launch ION again in the same way. If you did make changes, then it is recommended that you use the start script in the node's working directory, <code>./start_{node_name}.sh</code> to start ION.</p>"},{"location":"ION-Launcher/#directory-structure","title":"Directory Structure","text":"<p>The <code>ionlauncher</code> and associated <code>net_model_gen</code> python scripts will be installed in the same install path for ION, therefore making them available for use from any working directory.</p> <p>For example, say the 3 node simple file is called <code>3node.json</code> and it is stored at directory <code>$WKDIR</code>. After cd into the working directory and executing the <code>ionlauncher</code>, a new directory <code>$WKDIR/3node-ion</code> will be created and it contains the following:</p> <ul> <li>ION model file in json format. Its name is the simple model filename + <code>-ion.json</code>. In this case, it will be called <code>3node-ion.json</code>. This file can be opened and edited by the ION Config Tool's browser-based GUI</li> <li>ION network model in json format. Its name is the simple model filename + <code>-net_model.json</code>. In this case, it will be called <code>3node-net_model.json</code>. This file can be opened and edited by the ION Network Model's browser-based GUI.</li> <li>For details on how to use these files, please download the ION Config Tool and the ION Network Model from GitHub.com.</li> <li>Each node will have its own subfolder: <code>$WKDIR/3node/SC</code>, <code>$WKDIR/3node/Relay</code>, and <code>$WKDIR/3node/GS</code></li> <li>Within each subfolder there will be a set of ION configutration files and a start script called <code>start_&lt;node name&gt;.sh</code>, that you can use to launch ION again.</li> </ul> <p>After the initial ionlauncher run, the ION configuration files are generated for you based on the simple network model description and a set of default settings. To activate additional features, optimize parameters settings, and refine protocol behaviors, you will need to edit the ION config files individually. For those changes to take effect, you need to stop ION and restart ION using the start script in each node's working folder.</p> <p>NOTE: If you run ionlauncher again, the ION configuration files will regenerate and over-write your custom changes. So it is recommended that you make a copy or rename the configuration to avoid this situation.</p>"},{"location":"ION-Launcher/#dependency","title":"Dependency","text":"<p>The <code>ionlaunch</code> script requires that the installation of the ION Config Tool, which is publically accessible (starting January 2024) from GitHub, and the companion tool called ION Network Model is also available for download, although it is not needed for using <code>ionlauncher</code>.</p> <p>Download the latest release of the <code>ION Config Tool</code> and note the directory of the CLI (command line interface executables). For example, if it is <code>/home/$USER/ionconfig-4.8.1/cli/bin</code>, then you don't need to provide the <code>-d</code> option to <code>ionlauncher</code>. If it is somewhere else, then you should provide the <code>-d</code> option.</p> <p>You also need to install <code>node.js</code> and make sure python version 3.6 or higher is available in your system.</p>"},{"location":"ION-Quick-Start-Guide/","title":"ION Quick Start Guide","text":""},{"location":"ION-Quick-Start-Guide/#installing-ion-on-linux-macos-solaris","title":"Installing ION on Linux, MacOS, Solaris","text":"<p>To build ION on Linux system, make sure install and update the <code>automake</code>, <code>autoconf</code>, and <code>libtool</code> packages.</p> <p>To build and install the entire ION system on a Linux, MacOS, or Solaris platform, cd into ion-open-source and enter the following commands:</p> <p><code>./configure</code></p> <p>If configure is not present run: <code>autoreconf -fi</code> first</p> <p><code>make</code></p> <p><code>sudo make install</code></p> <p><code>sudo ldconfig</code></p> <p>For MacOS,  the <code>ldconfig</code> command is not present and not necessary to run.</p>"},{"location":"ION-Quick-Start-Guide/#compile-time-switches","title":"Compile Time Switches","text":"<p>If you want to set overriding compile-time switches for a build, the place to do this is in the <code>./configure</code> command.  For details,</p> <p><code>./configure -h</code></p> <p>By default, Bundle Protocol V7 will be built and installed, but BPv6 source code is still available. The BPv6 implementation is essentially the same as that of ION 3.7.4, with only critical bugs being updated going forward. All users are encouraged to switch to BPV7.</p> <p>To build BPv6, run</p> <p><code>./configure --enable-bpv6</code></p> <p>To clean up compilation artifacts such as object files and shared libraries stored within the ION open-source directory, cd to the ION open-source directory and run:</p> <p><code>make clean</code></p> <p>To remove executables and shared libraries installed in the system, run:</p> <p><code>sudo make uninstall</code></p>"},{"location":"ION-Quick-Start-Guide/#windows","title":"Windows","text":"<p>To install ION for Windows, please download the Windows installer.</p>"},{"location":"ION-Quick-Start-Guide/#build-individual-packages","title":"Build Individual Packages","text":"<p>It's also possible to build the individual packages of ION, using a set of platform-specific development Makefiles in the package subdirectories. Currently  the only actively maintained platform-specific Makefile is for 64-bits Linux under the \"i86_48-fedora\" folder. If you choose this option, be aware of the dependencies among the packages:</p> <ul> <li>The \"ici\" package must be built (run <code>make</code> and <code>make install</code>) before any other package.</li> <li>The \"bp\" package is dependent on \"dgr\" and \"ltp\" and \"bssp\" as well as \"ici\"</li> <li>The \"cfdp\", \"ams\", \"bss\", and \"dtpc\" packages are dependent on \"bpv7\"</li> <li>The \"restart\" package is dependent on \"cfdp\", \"bp\", \"ltp\", and \"ici\"</li> </ul> <p>For more detailed instruction on building ION, see section 2 of the \"ION Design and Operation Guide\" document that is distributed with this package.</p> <p>If you have executed <code>./configure</code> already, the development <code>Makefile</code> in each individual modules as well as the top-level <code>Makefile</code> in the ION root directory will be renamed as <code>Makefile.dev</code>. Because the automake system and the manual build systems organize the libraries differently, it is important that if you plan to switch from the automake system back to the manual build using the development Makefiles, you should first run <code>make clean</code> and <code>make uninstall</code> to completely remove ION from the system. Then you can either run <code>git stash</code> to restore the old Makefiles or simply pull a fresh copy of the code from the repo. </p> <p>Also, be aware that these development Makefiles install everything into subdirectories of <code>/usr/local</code>, so make sure they are part of your execution and libary paths. To override this behavior, change the value of <code>OPT</code> in the top-level Makefile of each package.</p> <p>Additional details are provided in the README.txt files in the root directories of the subsystems.</p> <p>All Makefiles are for gmake; on a FreeBSD platform, be sure to install gmake before trying to build ION.</p>"},{"location":"ION-Quick-Start-Guide/#running-ion","title":"Running ION","text":""},{"location":"ION-Quick-Start-Guide/#check-installed-bp-and-ion-versions","title":"Check Installed BP and ION versions","text":"<p>Before running ION, let's confirm which version of Bundle Protocol is installed by running:</p> <p><code>bpversion</code></p> <p>You will see a simple string on the terminal windows indicating either \"bpv6\" or \"bpv7\".</p> <p>Also check the ION version installed by running:</p> <p><code>ionadmin</code></p> <p>At the  \":\" prompt, please enter the single character command 'v' and you should see a response like this:</p> <pre><code> $ ionadmin\n: v\nION-OPEN-SOURCE-4.1.2\n</code></pre> <p>Then type 'q' to quit ionadmin. While ionadmin quits, it may display certain error messages like this:</p> <pre><code>at line 427 of ici/library/platform_sm.c, Can't get shared memory segment: Invalid argument (0)\nat line 312 of ici/library/memmgr.c, Can't open memory region.\nat line 367 of ici/sdr/sdrxn.c, Can't open SDR working memory.\nat line 513 of ici/sdr/sdrxn.c, Can't open SDR working memory.\nat line 963 of ici/library/ion.c, Can't initialize the SDR system.\nStopping ionadmin.\n</code></pre> <p>This is normal due to the fact that ION has not launched yet.</p>"},{"location":"ION-Quick-Start-Guide/#try-the-bping-test","title":"Try the 'bping' test","text":"<p>The <code>tests</code> directory contains regression tests used by system integrator to check ION before issuing each new release. To make sure ION is operating properly after installation, you can also manually run the bping test:</p> <p>First enter the test directory: <code>cd tests</code></p> <p>Enter the command: <code>./runtests bping/</code></p> <p>This command invokes one of the simplest test whereby two ION instances are created and a ping message is sent from one to the other and an echo is returned to the sender of the ping.</p> <p>During test, ION will display the configuration files used, clean the system of existing ION instances, relaunch ION according to the test configuration files, execute bping actions, display texts that indicates what the actions are being executed in real-time, and then shutdown ION, and display the final test status message, which looks like this:</p> <pre><code>ION node ended. Log file: ion.log\nTEST PASSED!\n\npassed: 1\n    bping\n\nfailed: 0\n\nskipped: 0\n\nexcluded by OS type: 0\n\nexcluded by BP version: 0\n\nobsolete tests: 0\n</code></pre> <p>In this case, the test script confirms that ION is able to execute a bping function properly.</p>"},{"location":"ION-Quick-Start-Guide/#try-to-setup-a-udp-session","title":"Try to Setup a UDP Session","text":"<p>Under the <code>demos</code> folder of the ION code directory, there are benchmark tests for various ION configurations. These tests also provide a template of how to configure ION.</p> <p>Take the example of the <code>bench-udp</code> demo:</p> <p>Go into the <code>demos/bench-udp/</code> folder, you will see two subfolders: <code>2.bench.udp</code> and <code>3.bench.udp</code>, these folders configures two ION nodes, one with node numbers 2 and 3.</p> <p>Looking inside the <code>2.bench.udp</code> folder, you will see specific files used to configure ION. These include:</p> <pre><code>bench.bprc \nbench.ionconfig  \nbench.ionrc  \nbench.ionsecrc  \nbench.ipnrc  \nionstart  \nionstop\n</code></pre> <ul> <li><code>bench.bprc</code> is the configuration file for the bundle protocol. To study the command options contained in this file, run <code>man bprc</code>.</li> <li><code>bench.ionconfig</code> is the configuration file for the storage configuration of ION. See <code>man ionconfig</code> for details.</li> <li><code>bench.ionrc</code> is the configuration file for ION. See <code>man ionrc</code> for details.</li> <li><code>bench.ionsecrc</code> is the configuration file for ION security administration. See <code>man ionsecrc</code> for details.</li> <li><code>bench.ipnrc</code> is the configuration file for the IPN  scheme. See <code>man ipnrc</code> for details.</li> <li><code>ionstart</code> and <code>ionstop</code> are scripts to launch and shutdown ION.</li> </ul> <p>One must note that ION distribution comes with a separate, global <code>ionstart</code> and <code>ionstop</code> scripts installed in <code>/usr/local/bin</code> that can launch and stop ION. The advantage of using local script is that it allows you customize the way you launch and stop ION, for example add helpful text prompt, perform additional checks and clean up activities, etc.</p> <p>To run this demo test, first go into the test directory bench-udp, then run the dotest script:</p> <p><code>./dotest</code></p> <p>You can also study the test script to understand better what is happening.</p>"},{"location":"ION-Quick-Start-Guide/#running-multiple-ion-instances-on-a-single-host","title":"Running multiple ION instances on a single host","text":"<p>If you study the test script under the \"tests\" and the \"demos\" folders, you will realize that these tests often will launch 2 or 3 ION nodes on the same host to conduct the necessary tests. While this is necessary to simplify and better automate regression testing for ION developer and integration, it is not a typical, recommended configuration for new users.</p> <p>In order to run multiple ION instances in one host, specific, different IPCS keys must be used for each instance, and several  variables must be set properly in the shell environment. Please see the ION Deployment Guide (included with the ION distribution) for more information on how to do that.</p> <p>We recommend that most users, unless due to specific contrain that they must run multiple ION instance on one host, to run each ION instance on a separate host or (VM).</p>"},{"location":"ION-Quick-Start-Guide/#setup-udp-configuration-on-two-hosts","title":"Setup UDP Configuration on Two Hosts","text":"<p>Once you have studied these scripts, you can try to run it on two different machines running ION.</p> <p>First, install ION in host A with an IP address of, for example, 192.168.0.2, and host B with an IP address of 192.168.0.3. Verify your installation based on earlier instructions.</p> <p>Copy the <code>2.bench.udp</code> folder into host A and the <code>3.bench.udp</code> folder into host B.</p> <p>Also copy the file <code>global.ionrc</code> from the <code>bench.udp</code> folder into the same folder where you placed <code>2.bench.udp</code> and <code>3.bench.udp</code></p> <p>Then you need to modify the IP addresses in the UDP demo configuration files to match the IP addresses of hosts A and B.</p> <p>For example, the bprc files copied into host A is:</p> <pre><code>1\na scheme ipn 'ipnfw' 'ipnadminep'\na endpoint ipn:2.0 x\na endpoint ipn:2.1 x\na endpoint ipn:2.2 x\na endpoint ipn:2.64 x\na endpoint ipn:2.65 x\na protocol udp 1400 100\na induct udp 127.0.0.1:2113 udpcli\na outduct udp 127.0.0.1:3113 'udpclo 1'\nr 'ipnadmin bench.ipnrc'\ns\n</code></pre> <p>To make it work for host A, you need to replace the induct ip address <code>127.0.0.1:2113</code> to <code>192.168.0.2:2113</code> - this is where host A's ION will receive incoming UDP traffic.</p> <p>Similarly for outduct, you want to change the ip address from <code>127.0.0.1:3113</code> to <code>192.168.0.3:3113</code> - this is where UDP traffic will go out to host B.</p> <p>You can make similar modifications to the ipnrc file as well.</p> <p>In the ionconfig file, you want to comment out or delete the <code>wmKey</code> and <code>sdrName</code> entries. Since we are running these two nodes on different hosts, we always let ION use the default values for these parameters.</p> <p>If you don\u2019t do this you get an error on startup.</p> <p>Repeat the same updates for host B by appropriately substituting old IP address to that of the new hosts.</p>"},{"location":"ION-Quick-Start-Guide/#launch-ion-on-two-separate-hosts","title":"Launch ION on two separate hosts","text":"<p>After updating the configuration files on host A and B to reflect the new IP addresses and using default wmKey (by not specifying any), we are new ready to try launching ION.</p> <p>Before you try to launch ION, it is recommended that you:</p> <ol> <li>Use netcat or iperf to test the connection between host A and B. Make sure it is working properly. That means have a sufficiently high data rate and low loss rate (low single digit percent or fraction of a percent should not be a concern).</li> <li>If iperf tests show that the data rate between the two hosts are at or above 800 megabits per second, in both directions, and the UDP loss rate is no more than a few percent, then you are good to go.</li> <li>If not, then you want to reduce the data rate in the <code>global.ionrc</code> file, change the data rates for the <code>a contact</code> command down to something similar to your connection speed. Remember, the unit in the <code>global.ionrc</code> file is Bytes per second, not bits per second, which is typically what iperf test report uses.</li> <li>If the error rate is high, you may want to check both the physical connection or kernel buffer setting.</li> <li>Check firewall setting and MTU setting may help you narrow down problems.</li> <li>Using wireshark can also be helpful both for initial connection check as well as during ION testing.</li> </ol> <p>Once you are ready to launch ION on both host A and B, open a terminal and go to the directory where the configuration files are stored, and run the local ionstart script:</p> <p><code>./ionstart</code></p> <p>Note: do not run <code>ionstart</code> since that will trigger the global script in the execution PATH</p> <p>You should see some standard output confirming that ION launch has completed. For example you might see something like this:</p> <pre><code>Starting ION...\nwmSize:          5000000\nwmAddress:       0\nsdrName:        'ion2'\nsdrWmSize:       0\nconfigFlags:     1\nheapWords:       100000000\nheapKey:         -1\nlogSize:         0\nlogKey:          -1\npathName:       '/tmp'\nStopping ionadmin.\nStopping ionadmin.\nStopping ionsecadmin.\nStopping ltpadmin.\nStopping ipnadmin.\nStopping bpadmin.\n</code></pre> <p>You can also see additional status information in the <code>ion.log</code> file in the same directory.</p> <p>Launch ION on both host A and B.</p>"},{"location":"ION-Quick-Start-Guide/#run-a-bpdriver-bpcounter-test","title":"Run a bpdriver-bpcounter test","text":"<p>Now that we have launched ION on both host A and B, it's time to send some data.</p> <p>We can repeat the bping test at this point. But since you have already seen that before, let's try something different.</p> <p>Let's use the bpdriver-bpcounter test utilities. This pair of utility programs simply sends a number of data in bundles from one node to another and provides a measurement on the throughput.</p> <p>On host B, run this command:</p> <p><code>bpcounter ipn:3.2 3</code></p> <p>This command tells ION node number 3 to be ready to receive three bundles on the end-point ID <code>ipn:3.2</code> which was specified in the <code>.bprc</code> file.</p> <p>After host B has launched bpcounter, then on host A, run this command:</p> <p><code>bpdriver 3 ipn:2.2 ipn:3.2 -10000</code></p> <p>This command tells ION running in host A to send 3 bundles from EID 2.2 to EID 3.2, which is waiting for data (per bpcounter command.) And each bundle should be 10,000 bytes in size.</p> <p>Why use the \"-\" sign in front of the size parameter? It's not a typo. The \"-\" indicates that bpdriver should keep sending bundles without waiting for any response from the receiver. The feature where bpdriver waits for the receiver is available in BPv6 but no longer part of BPv7.</p> <p>When the test completed, you should see output indicating that all the data were sent, how many bundles were transmitted/received, and at what rate.</p> <p>Please note that on the sending side the transmission may appear to be almost instantaneous. That is because bpdriver, as an application, is pushing data into bundle protocol which has the ability to rate buffer the data. So as soon as the bpdriver application pushes all data into the local bundle protocol agent, it considers the transmission completed and it will report a very high throughput value, one that is far above the contact graph's data rate limit. This is not an error; it simple report the throughput as experienced by the sending application, knowing that the data has not yet delivered fully to the destination.</p> <p>Throughput reported by bpcounter, on the other hand, is quite accurate if a large number of bundles are sent. To accurately measure the time it takes to send the bundles, bpdriver program will send a \"pilot\" bundle just before sending the test data to signals to the bpcounter program to run its throughput calculation timer. This allows the user to run bpcounter and not haveing to worry about immediately send all the bundles in order to produce an accurate throughput measurement.</p> <p>If you want to emulate the action of a constant rate source, instead of having bpdriver pushing all data as fast as possible, then you can use the 'i' option to specify a data rate throttle in bits per second.</p> <p>If you want to know more about how bpdriver and bpcounter work, look up their man pages for details on syntax and command line options. Other useful ION test utility commands include <code>bpecho</code>, <code>bping</code>, <code>bpsource</code>, <code>bpsink</code>, <code>bpsendfile</code>, <code>bprecvfile</code>, etc.</p>"},{"location":"ION-Quick-Start-Guide/#check-the-ionlog","title":"Check the ion.log","text":"<p>To confirm whether ION is running properly or has experienced an error, the first thing to do is to check the ion.log, which is a file created in the directory from which ION was launched. If an ion.log file exists when ION starts, it will simply append additional log entries into that file. Each entry has a timestamp to help you determine the time and the relative order in which events occurred.</p> <p>When serious error occurs, ion.log  will have detailed messages that can pinpoint the name  and line number of the source code where the error was reported or triggered.</p>"},{"location":"ION-Quick-Start-Guide/#bpacq-and-ltpacq-files","title":"bpacq and ltpacq files","text":"<p>Sometimes after operating ION for a while, you will notice a number of files with names such as \"bpacq\" or \"ltpacq\" followed by a number. These are temporary files created by ION to stage bundles or LTP blocks during reception and processing.  Once a bundle or LTP block is completely constructed, delivered, or cancelled properly, these temporary files are automatically removed by ION. But if ION experiences an anomalous shutdown, then these files may remain and accumulate in the local directory.</p> <p>It is generally safe to remove these files between ION runs. Their presence does not automatically imply issues with ION but can indicate that ION operations were interrupted for some reason. By noting their creation time stamp, it can provide clues on when these interruptions occurred. Right now there are no ION utilty program to parse them because these files are essentially bit buckets and do not contain internal markers or structure and allows user to parse them or extract information by processes outside the bundle agents that created them in the first place.</p>"},{"location":"ION-Quick-Start-Guide/#forced-shutdown-of-ion","title":"Forced Shutdown of ION","text":"<p>Sometimes shutting down ION does not go smoothly and you can't seem to relaunch ION properly. In that case, you can use the global <code>ionstop</code> script (or the <code>killm</code> script) to kill all ION processes that did not terminate using local ionstop script. The global ionstop or killm scripts also clears out the IPC shared memory and semaphores allocations that were locked by ION processes and would not terminate otherwise.</p>"},{"location":"ION-Quick-Start-Guide/#additional-tutorials","title":"Additional Tutorials","text":""},{"location":"ION-Quick-Start-Guide/#ion-configuration-file-tutorial","title":"ION Configuration File Tutorial","text":"<p>To learn about the configuration files and the basic set of command syntax and functions: ION Config File Tutorial</p>"},{"location":"ION-Quick-Start-Guide/#ion-configuration-file-template","title":"ION Configuration File Template","text":"<p>ION Config File Template</p>"},{"location":"ION-Quick-Start-Guide/#ion-nasa-course","title":"ION NASA Course","text":"<p>To learn more about the design principle of ION and how to use it, a complete series of tutorials is available here: NASA ION Course</p> <p>The ION Dev Kit mentioned in the NASA ION Course had been deprecated. However, some additional helpful files can be found here to complete the examples: Additional DevKit Files</p>"},{"location":"ION-Quick-Start-Guide/#accessing-ion-open-source-code-repository","title":"Accessing ION Open-Source Code Repository","text":""},{"location":"ION-Quick-Start-Guide/#releases","title":"Releases","text":"<p>Use the Summary or the Files tab to download point releases</p>"},{"location":"ION-Quick-Start-Guide/#using-the-code-repository","title":"Using the code repository","text":"<ul> <li>Track the \"stable\" branch to match the ION releases</li> <li>Track the \"current\" branch for bug fixes and small updates between releases</li> </ul>"},{"location":"ION-Quick-Start-Guide/#contributing-code-to-ion","title":"Contributing Code to ION","text":""},{"location":"ION-Quick-Start-Guide/#expectations","title":"Expectations","text":"<p>If you plan to contribute to the ION project, please keep these in mind:</p> <ul> <li>Submitted code should adhere to the ION coding style found in the current code. We plan to add a more formal coding style guide in the future.</li> <li>Provide documentation describing the contributed code\u2019s features, its inputs and outputs, dependencies, behavior (provide a high-level state machine or flowchart if possible), and API description. Please provide a draft of a man page.</li> <li>Provide canned tests (ION configuration and script) that can be executed to verify and demonstrate the proper functioning of the features. Ideally it should demonstrate nominal operation and off-nominal scenarios.</li> <li> <p>The NASA team will review these contributions and determine to either</p> </li> <li> <p>incorporate the code into the baseline, or</p> </li> <li>not incorporate the code into the baseline but make it available in the /contrib folder (if possible) as experimental modules, or</li> <li>not incorporate it at all.</li> <li>All baselined features will be supported with at least bug-fixes until removed</li> <li>All /contrib folder features are provided \u201das is,\u201d and no commitment is made regarding bug-fixes.</li> <li>The contributor is expected to help with regression testing.</li> <li>Due to resource constraints, we cannot make any commitment as to response time. We will do our best to review them on a best effort basis.</li> </ul>"},{"location":"ION-Quick-Start-Guide/#if-you-want-to-contribute-code-to-ion","title":"If you want to contribute code to ION","text":"<ol> <li>Fork this repository</li> <li>Starting with the \"current\" branch, create a named feature or bugfix branch and develop/test your code in this branch</li> <li> <p>Generate a pull request (called Merge Request on Source Forge) with</p> </li> <li> <p>Your feature or bugfix branch as the Source branch</p> </li> <li>\"current\" as the destination branch</li> </ol>"},{"location":"ION-TestSet-Readme/","title":"Running the ION test set","text":""},{"location":"ION-TestSet-Readme/#directory-layout","title":"Directory layout","text":"<p>The <code>tests</code> directory under ION's root folder contains the test suite. Each test lives in its own subdirectory of this directory. Each test is conducted by a script <code>$TESTNAME/dotest</code>. Another directory that contains ION tests is the <code>demos</code> directory, which includes examples of ION configurations using different convergence layers. For this document, we focus on the usage of the <code>tests</code> directory.</p>"},{"location":"ION-TestSet-Readme/#exclude-files","title":"Exclude files","text":"<p>Exclude files are hidden files that allow for tests to be disabled based on certain conditions that may cause the test not to run correctly. If an exclude file exists, it should have a short message about why the test has been excluded.</p> <p>Exclude files can exist in any of the following formats:</p> <ul> <li> <p><code>.exclude_OS-TYPE</code>: Disables a test for an operating system that it does not run successfully on. Acceptable values to fill in for OS-TYPE are \"windows\", \"linux\", \"mac\", and \"solaris\".</p> </li> <li> <p><code>.exclude_BP-VERSION</code>: Disables a test for a version of the bundle protocol that it does not run correctly or does not make sense with. As of ION 4.0.0, the acceptable values to fill in for <code>BP-VERSION</code> are \"bpv6\" and \"bpv7\".</p> </li> <li> <p><code>.exclude_all</code>: Disables a test for all platforms.</p> </li> <li> <p><code>.exclude_expert</code>: Disables a test because of additional utilities that are required for the test. To work around this exclusion if you want to run an expert test, you can set <code>ION_RUN_EXPERT=\"yes\"</code> in your shell environment to enable all ION tests classified as expert.</p> </li> <li> <p><code>.exclude_cbased</code>: Disables a test that relies on compiling a C program to generate the dotest executable script. To exclude C-based tests, you need to define the environment variable <code>ION_EXCLUDE_CBASED</code>.</p> </li> </ul>"},{"location":"ION-TestSet-Readme/#running-the-tests","title":"Running the tests","text":"<p>The tests are run by running <code>make test-all</code> in the top-level directory, or by running <code>runtests</code> in this directory.</p> <p>An individual test can also be run: <code>./runtests &lt;test_name&gt;</code></p> <p>A file defining a set of tests can be run with <code>runtestset</code>.  The arguments to <code>runtestset</code> are files that contain globs of tests to run, for example: <code>./runtestset quicktests</code>.</p>"},{"location":"ION-TestSet-Readme/#writing-new-tests","title":"Writing new tests","text":"<p>A test directory must contain an executable file named <code>dotest</code>.  If a directory does not contain this, the test will be ignored. The <code>dotest</code> program should execute the test, possibly reporting runtime information on stdout and stderr, and indicate by its return value the result of the test as follows:</p> <pre><code>0: Success\n1: Failure\n2: Skip this test\n</code></pre> <p>The test program starts without the ION stack running.  The test program is responsible for starting ION in the ways that is appropriate for the test.</p> <p>The test program must stop the ION protocol stack before returning.</p>"},{"location":"ION-TestSet-Readme/#the-test-environment","title":"The test environment","text":"<p>The <code>dotest</code> scripts are run in their test directory. The following environment variables are set as part of the test environment:</p> <ul> <li> <p><code>IONDIR</code> is the root of the local ION source directory.</p> </li> <li> <p><code>PATH</code> begins with <code>IONDIR</code> (this is where the local executables are found.)</p> </li> </ul>"},{"location":"ION-TestSet-Readme/#for-413-and-later","title":"For 4.1.3 and later","text":"<p>The <code>runtests</code> script maintains a file called <code>tests/progress</code> that gives the start time, finish time, and final result for each test.</p> <p>If the environment variable <code>RUNTESTS_OUTPUTDIR</code> is set, as in, <code>export RUNTESTS_OUTPUTDIR=\"/tmp\"</code>, then the output from each test will be stored in <code>/tmp/results</code>, which makes it much easier to find particular text or results when debugging.</p>"},{"location":"ION-Tutorials/","title":"ION Tutorials","text":"<p>The follow tutorials will help you get started with the ION BP Suite:</p> <ul> <li>Introduction to Delay/Disruption Tolerant Networking (DTN) - Presentation, Video</li> <li>Introduction to the Interplanetary Overlay Network (ION) - Presentation, Video</li> <li>ION's Technical Details - Presentation, Video</li> <li>ION In Action - Presentation, Video</li> </ul> <p>Note: These presentations/videos were released in 2020 and has not been updated since then. Some technical details and reference materials may be outdated. Please consult the latest man pages and released documentations.</p>"},{"location":"ION-Utilities/","title":"ION Utility Programs","text":"<p>Here is a short list of utility programs that comes with ION that are frequently used by users launch, stop, and query ION/BP operation status:</p> <ul> <li><code>ionexit</code> - A program that shuts down ION with the option to preserve the SDR.</li> </ul> <p>Normally, when ION's various daemons were stopped down by calling <code>ionstop</code>,  issuing the command '.' to the administration programs, the SDR will be modified/destroyed in the process. Calling <code>ionexit</code> with an argument 'keep' allows the SDR state just prior to the execution of <code>ionexit</code> to be preserved in the non-volatile storage such as a file if ION was configured to use a file for the SDR.</p> <ul> <li>bpstats</li> <li>bplist</li> <li>bpcancel</li> <li>ionrestart</li> <li>sdrwatch</li> <li>psmwatch</li> <li>ionstart</li> <li>ionstop</li> <li>killm</li> <li>runtests</li> <li>bptrace</li> <li>owltsim</li> <li>bpstats2</li> <li>cfdptest</li> <li>bpcrash</li> </ul>"},{"location":"ION-Watch-Characters/","title":"ION Watch Characters","text":"<p>ION Version: 4.1.3</p> <p>Bundle Protocol Version:7</p> <p>Watch characters, when activated, provide immediate feedback on ION operations by printing various characters standard output (terminal). By examing the watch characters, and the order in which they appear, operators can quickly confirm proper operation or detect configuration or run-time errors.</p> <p>This document will list all watch characters currently supported by ION.</p>"},{"location":"ION-Watch-Characters/#enhanced-watch-characters-ion-413-or-later","title":"Enhanced Watch Characters (ION 4.1.3 or later)","text":"<p>Enhanced watch characters were added ION 4.1.3 to provide detailed state information at Bundle Protocol (BP) and LTP levels and can be activated at compile time by:</p> <pre><code>./configure --enable-ewchar\nor \n./configure CFLAGS=-DEWCHAR\n</code></pre> <p>Enhanced watch characters prepends additional state information to the standard watch characters inside a pair of parenthesis. In this document, we use the following notion regarding enhanced watch characters information.</p> <ul> <li><code>nnn</code> = source node number</li> <li><code>sss</code> = service number</li> <li><code>ttt</code> = bundle creation time in milliseconds Epoch(2000)</li> <li><code>ccc</code> = bundle sequence number</li> <li><code>xxx</code> (LTP session number)</li> </ul> <p>Each field can be longer or shorter than 3 digits/characters.</p>"},{"location":"ION-Watch-Characters/#logging-and-processing-of-watch-characters","title":"Logging and Processing of Watch Characters","text":"<p>Besides real-time monitoring of the watch characters on standard out, ION can redirect the watch characters to customized user applications for network monitoring purposes.Prior to and including ION 4.1.2, watch characters are single character. Starting from ION 4.1.3 release, a watch character is now generalized to a string of type <code>char*</code>.</p> <p>To activate customized processing, there are two steps:</p> <ol> <li>Create a C code <code>gdswatcher.c</code> that defines a functions to process watch characters, and pass that function to ION to handle watch character:</li> </ol> <pre><code>static void processWatchChar(char* token)\n{\n    //your code goes here\n} \n\nstatic void ionRedirectWatchCharacters()\n{ \n    setWatcher(processWatchChar);\n}\n</code></pre> <ol> <li>Then use the following compiler flag to build ION:</li> </ol> <pre><code>./configure --enable-ewchar CFLAGS=\"-DGDSWATCHER -I/&lt;path to the folder holding the gdswatcher.c file&gt;\"\n</code></pre> <ol> <li>You can also include the GDSLOGGER program, then <pre><code>./configure --enable-ewchar CFLAGS=\"-DGDSWATCHER -DGDSLOGGER -I/&lt;path to the folder holding the gdswatcher.c file&gt;\"\n</code></pre></li> </ol>"},{"location":"ION-Watch-Characters/#bundle-protocol-watch-character","title":"Bundle Protocol Watch Character","text":"<p><code>a</code> - new bundle is queued for forwarding; <code>(nnn,sss,tttt,cccc)a</code></p> <p><code>b</code> - bundle is queued for transmission; <code>(nnn,sss,ccc)b</code></p> <p><code>c</code> - bundle is popped from its transmission queue; <code>(nnn,sss,ccc)c</code></p> <p><code>m</code> - custody acceptance signal is received</p> <p><code>w</code> - custody of bundle is accepted</p> <p><code>x</code> - custody of bundle is refused</p> <p><code>y</code> - bundle is accepted upon arrival; <code>(nnn,sss,tttt,ccc)y</code></p> <p><code>z</code> - bundle is queued for delivery to an application; <code>(nnn,sss,tttt,ccc)z</code></p> <p><code>~</code> - bundle is abandoned (discarded) on attempt to forward it; <code>(nnn,sss,ccc)</code>~</p> <p><code>!</code> - bundle is destroyed due to TTL expiration; <code>(nnn,sss,ccc)!</code></p> <p><code>&amp;</code> - custody refusal signal is received</p> <p><code>#</code> - bundle is queued for re-forwarding due to CL protocol failure; <code>(nnn,sss,ccc)</code>#</p> <p><code>j</code> - bundle is placed in \\\"limbo\\\" for possible future re-forwarding; <code>(nnn,sss,ccc)</code>j</p> <p><code>k</code> - bundle is removed from \\\"limbo\\\" and queued for re-forwarding; <code>(nnn,sss,ccc)</code>k</p>"},{"location":"ION-Watch-Characters/#ltp-watch-characters","title":"LTP Watch Characters","text":"<p><code>d</code> - bundle appended to block for next session</p> <p><code>e</code> - segment of block is queued for transmission</p> <p><code>f</code> - block has been fully segmented for transmission; <code>(xxxx)f</code></p> <p><code>g</code> - segment popped from transmission queue;</p> <ul> <li> <p><code>(cpxxx)g</code> -- checkpoint, this could be a data segment or a standalone   check point</p> </li> <li> <p><code>(dsxxx)g</code> -- non-check point data segment</p> </li> <li><code>(rcpxxx)g</code> -- retransmitted checkpoint</li> <li><code>(prsxxx)g</code> -- positive report (all segments received)</li> <li><code>(nrsxxx)g</code> -- negative report (gaps)</li> <li><code>(rrsxxx)g</code> -- retransmitted report (either positive or negative)</li> <li><code>(rasxxx)g</code> -- a report ack segment</li> <li><code>(csxxx)g</code> -- cancellation by block source</li> <li><code>(crxxx)g</code> -- cancellation by block receiver</li> <li><code>(caxxx)g</code> -- cancellation ack for either CS or CR</li> </ul> <p><code>h</code> - positive ACK received for block, session ended; <code>(xxx)h</code></p> <p><code>s</code> - segment received</p> <p><code>t</code> - block has been fully received</p> <p><code>@</code> - negative ACK received for block, segments retransmitted; <code>(xxx)@</code></p> <p><code>=</code> - unacknowledged checkpoint was retransmitted; <code>(xxx)=</code></p> <p><code>+</code> - unacknowledged report segment was retransmitted; <code>(xxx)+</code></p> <p><code>{</code> - export session canceled locally (by sender)</p> <p><code>}</code> - import session canceled by remote sender</p> <p><code>[</code> - import session canceled locally (by receiver)</p> <p><code>]</code> - export session canceled by remote receiver</p>"},{"location":"ION-Watch-Characters/#bibect-watch-characters","title":"BIBECT Watch Characters","text":"<p><code>w</code> - custody request is accepted (by receiving entity)</p> <p><code>m</code> - custody acceptance signal is received (by requester)</p> <p><code>x</code> - custody of bundle has been refused</p> <p><code>&amp;</code> - custody refusal signal is received (by requester)</p> <p><code>$</code> - bundle retransmitted due to expiration of custody request timer</p>"},{"location":"ION-Watch-Characters/#bssp-watch-characters","title":"BSSP Watch Characters","text":"<p><code>D</code> - bssp send completed</p> <p><code>E</code> - bssp block constructed for issuance</p> <p><code>F</code> - bssp block issued</p> <p><code>G</code> - bssp block popped from best-efforts transmission queue</p> <p><code>H</code> - positive ACK received for bssp block, session ended</p> <p><code>S</code> - bssp block received</p> <p><code>T</code> - bssp block popped from reliable transmission queue</p> <p><code>-</code> - unacknowledged best-efforts block requeued for reliable transmission</p> <p><code>*</code> - session canceled locally by sender</p>"},{"location":"Known-Issues/","title":"Known Issues &amp; Patches","text":"<p>Here is a list of known issues that will updated on a regular basis to captures various lessons-learned relating to the configurations, testing, performance, and deployment of ION:</p>"},{"location":"Known-Issues/#convergence-layer-adaptor","title":"Convergence Layer Adaptor","text":""},{"location":"Known-Issues/#udp-cla","title":"UDP CLA","text":"<ul> <li>When using UDP CLA for data delivery, one should be aware that:</li> <li>UDP is inherently unreliable. Therefore the delivery of BP bundles may not be guaranteed, even withing a controlled, isolated network environment.</li> <li>It is best to use iperf and other performance testing tools to properly character UDP performance before using UDP CLA. UDP loss may have high loss rate due to presence of other traffic or insufficient internal buffer.</li> <li>When UDP CLA is used to deliver bundles larger than 64K, those bundle will be fragmented and reassembled at the destination. It has been observed on some platforms that UDP buffer overflow can cause a large number of 'cyclic' packet drops so that an unexpected large number of bundles are unable to be reassembled at the destination. These bundle fragments (which are themselves bundles) will take up storage and remain until either (a) the remaining fragments arrived or (b) the TTL expired.</li> </ul>"},{"location":"Known-Issues/#ltp-cla","title":"LTP CLA","text":"<ul> <li>When using LTP over the UDP-based communication services (udpcli and udpclo daemons):</li> <li>The network layer MTU and kernel buffer size should be properly configured</li> <li>The use \"WAN emulator\" to add delay and probabilistic loss to data should be careful not to filter out UDP fragments that are needed to reconstruct the LTP segments or significantly delayed them such that the UDP segment reassembly will expire.</li> </ul>"},{"location":"Known-Issues/#bundle-protocol","title":"Bundle Protocol","text":""},{"location":"Known-Issues/#crc","title":"CRC","text":"<ul> <li>ION implementation currently default will apply CRC16 to Primary Block but not the Payload Block. To apply CRC to the Payload Block, a compiler flag needs to be set when building ION. There are currently no mechanism to dynamically turn on/turn off CRC without recompiling ION.</li> </ul>"},{"location":"Known-Issues/#testing-configuration","title":"Testing &amp; Configuration","text":"<ul> <li>When developing and testing ION in a docker container with root permission while mounting to ION code residing in a user's directory on the host machine, file ownership may switch from user to <code>root</code>. This sometimes leads to build and test errors when one switches back to the host's development and testing environment. Therefore, we recommend that you execute the <code>make clean</code> and <code>git stash</code> command to remove all build and testing artifacts from ION 's source directory before exiting the container.</li> </ul>"},{"location":"Known-Issues/#sdr","title":"SDR","text":""},{"location":"Known-Issues/#sdr-transaction-reversal","title":"SDR transaction reversal","text":"<p>When SDR transaction is canceled due to anomaly, ION will attempt automatically try the following:</p> <ol> <li>Reverse transaction - if it is configured - to revert modifications to the SDR's heap space which contains both user and protocol data units. This action rolls back a series of operations on the SDR's data of the cancelled the transaction.</li> <li>Once the SDR's heap space has been restored, the \"volatile\" state of the protocols must be restored because they might be modified by the transaction as well. This is performed by the <code>ionrestart</code> utility.</li> <li>After the volatiles are reloaded, the 3rd step of restoring ION operation will need to be triggered by the users. During the anomously event that caused the transaction cancellation, some of ION's various daemons may have stopped. They can be restored by simply issuing the start ('s') command through <code>ionadmin</code> and <code>bpadmin</code>.</li> </ol>"},{"location":"Known-Issues/#init-process-pid-1","title":"'Init' Process PID 1","text":"<p>The reloading of the volatile state and restarting of daemons is necessary to ensure the ION system is in a consistent state before resuming normal operations.</p> <p>During the reloading of the volatile state, the bundle protocol schemes, inducts, and outducts are stopped by terminating the associated daemons. The restart process will wait for the daemon's to be terminated before restarting them. When running ION inside a docker container, the <code>init</code> process (PID 1) should be properly configured to reap all zombie processes because the restart process cannot proceed if a terminated daemon remains a zombie. Typically to ensure the proper <code>init</code> process, one should use the <code>--init</code> option for <code>docker run</code> command.</p>"},{"location":"Known-Issues/#permission-issue-with-named-semaphore","title":"Permission Issue with named semaphore","text":"<p>If you encounter an error reported in ion.log file such as this:</p> <pre><code>at line 3850 of ici/library/platform_sm.c, Can't initialize IPC semaphore: Permission denied (/ion:GLOBAL:ipcSem)\nat line 3868 of ici/library/platform_sm.c, Can't initialize IPC.\nat line 481 of ici/sdr/sdrxn.c, Can't initialize IPC system.\nat line 695 of ici/library/ion.c, Can't initialize the SDR system.\nat line 216 of ici/utils/ionadmin.c, ionadmin can't initialize ION.\n</code></pre> <p>It indicates that ION is unable to clean out previously left behind semaphore files. This typically occurs when the previous ION run was launched by a different user, and ION was not properly shutdown via a shutdown script - instead, the global <code>ionstop</code> or <code>killm</code> script was used. The semaphore files used by POSIX named semaphore typically only allows the owner to delete it. The work around is to clear these files out. ION-related semaphore files have the name pattern of <code>sem.ion:GLOBAL:&lt;integer&gt;</code>. For Ubuntu, it is usually found in the <code>/dev/shm</code> directory; for other Linux distribution, the location can be different.</p>"},{"location":"Known-Issues/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>ION related issues can be reported to the public GitHub page for ION-DTN or ion-core.</li> <li>ION's SourceForge page is now deprecated and issued reported there will not be monitored.</li> </ul>"},{"location":"Known-Issues/#patches","title":"Patches","text":"<p>In this section, we post patches issued between or ahead of major releases to fix bugs.</p> <p>Each patch is described as follows:</p> <ul> <li>Issue Date: this is the date when the patch is made available.</li> <li>Issue No.: GitHub issue number, if any, related to the patch.</li> <li>Issue description</li> <li>Link to the patch</li> <li>The baseline version of ION from which the patch is issued.</li> <li>The target version of ION to which the patch will incorporate. </li> </ul> Issue Date Issue # Issue Description Patch From ION ver. To ION ver. TBD 33 bpv7 extension block CRC failure TBD 4.1.3 4.1.4"},{"location":"LTP-UComm-API/","title":"LTP Underlying Communications API","text":"<p>In the Licklider Transmission Protocol (LTP) Specification issued by CCSDS 734.1-B-1, the elements of a LTP architecture is shown as follows:</p> <p></p> <p>The <code>LTP Engine</code> and <code>MIB</code> is implemented and configured by ION, and the <code>Client Service Instance</code> is either BPv6 or BPv7. The storage is provided by the host system through the ICI APIs.</p> <p>The <code>Underlying Communication Protocol</code> element is responsible for data and control message exchanges between two peered LTP Engines. It is not responsible for flow control, error correction/detection, and in-ordered delivery.</p> <p>For a spacecraft, the LTP Engine will execute the LTP protocol logic and handing the LTP segments to the underlying communication services provided in the form of a simple UDP socket or a radio frequency/optical telecommunication system. In ION, the standard underlying communications protocol is UDP since it is widely available in terrestrial computer systems. In actual deployment, the UDP protocol may need to be substituted by a different ground-based or flight communications system.</p> <p>In the document we describe a few essential APIs for any externally implemented underlying communication protocols to interface with LTP engine and perform the most basic tasks of (a) submitting a received LTP segments to the LTP Engine for processing and (b) acquiring an LTP segment from the LTP Engine for transmission to its peer.</p>"},{"location":"LTP-UComm-API/#connecting-to-the-ltp-engine","title":"Connecting to the LTP Engine","text":"<p>There are several steps for an external application to connecting to LTP:</p> <ol> <li>The ltp service must be running on the host system. The ltp service is started by the ION system and is configured by the <code>.ltprc</code> file processed <code>ltpadmin</code>. See the Configuration File Tutorial to understand how BP and LTP services are instantiated.<ul> <li>Typically, to ensure that the ltp service is running before the communications protocols try to connect to it, the underlying communication protocol service is invoked as part of LTP instantiation. See manual page for <code>ltprc</code> for more details.</li> </ul> </li> <li>The external application must make sure LTP is initialized by calling the <code>ltpInit()</code> API.</li> <li>Once <code>ltpInit</code> called returned successfully, it must obtain access to ION SDR and detemine the associated LTP <code>span</code> (based on a peer engine number) for which communication service will be provisioned.  This is done by using the <code>findSpan()</code> API. A <code>span</code> defines the communication parameters between two LTP engine peers.</li> <li>Acquire the semaphore used by the associated LTP engines - for the span - to indicate the availability of a segment for transmission. The presences of a valid semaphore is also indication that the span is currently active.</li> <li>Use the <code>ltpDequeueOUtboundSegment</code> API to acquire each available segment from the LTP Engine for transmission to the peer entity.</li> </ol> <p>In the following section we will describe the private APIs used by the underlying communication protocols. There are other APIs for external processes to use LTP as a reliable point-to-point data transmission service, but they are not described in this document; they are available in the manual pages.</p>"},{"location":"LTP-UComm-API/#ltp-data-structure","title":"LTP Data Structure","text":"<p>Here is a diagram of the major LTP data structures and their relationships. </p> <pre><code>+----------------------------------+----------------------------------+\n|                                  |                                  |\n| non-&gt;olatile (SDR heap)          |    volatile (working memory ION) |\n|                                  |                                  |\n|                                  |                                  |\n| LtpDB                            |    LtpVdb                        |\n|   +      (list)                  |     +       (list)               |\n|   +---&gt; spans +--+               |     +-----+ spans+------+        |\n|   |              |               |     |                   |        |\n|   +---&gt; seats +---------+        |     +-----+ seats+---+  |        |\n|                  |      |        |                      |  |        |\n|                  |      |        |                      |  |        |\n| LtpSpan &lt;--------+      |        |     LtpVspan &lt;----------+        |\n|   +                     |        |       +              |           |\n|   +---&gt; importSessions+----+     |       +-&gt; importSessions+--+     |\n|   |       (list)        |  |     |             (list)   |     |     |\n|   +---&gt; exportSessions+------+   |                      |     |     |\n|                         |  | |   |     LtpVseat &lt;-------+     |     |\n| LtpSeat &lt;---------------+  | |   |                            |     |\n|                            | |   |                            |     |\n|                            | |   |                            |     |\n| LtpImportSession &lt;---------+ |   |     LtpVImportSession&lt;-----+     |\n|                              |   |                                  |\n|                              |   |                                  |\n| LtpExportSession &lt;-----------+   |                                  |\n|                                  |                                  |\n+----------------------------------+----------------------------------+\n</code></pre> <ul> <li> <p><code>LtpDB</code>: The LTP database is a global database that contains the LTP configuration information for the entire system. It is a persistent data stored in the SDR's heap - assuming the SDR is implemented in a non-volatile medium such as a disk or a battery backed RAM.</p> </li> <li> <p><code>LtpSpan</code>: A span is a communication channel between two LTP engine peers. A span is defined by a unique span number and a set of communication parameters stored in a non-volatile database. Each instance of <code>LtpSpan</code> is tracked as an element in the LTP database under the <code>LtpDB.spans</code> list.</p> </li> <li> <p><code>LtpSeat</code>: A seat is the reception process for LTP and its parameters are stored under LtpSeat, and its tracked as an element in the list <code>LtpDB.seats</code>.</p> </li> <li> <p><code>LtpImportSession</code> and <code>LtpExportSession</code> are tracked by lists in the <code>LtpSpan</code> structure.</p> </li> <li> <p><code>LtpVdb</code>: The LTP volatile database is a global database that contains the LTP configuration information for the entire system. It is a volatile data stored in the working memory and not expected to persist through power reset. It tracks, in two lists, each instance of <code>LtpVspan</code> and <code>LtpVseat</code> that are currently active.</p> </li> <li> <p><code>LtpVspan</code>: contains the state information of an active span in the working memory. It is tracked as an element in the list <code>LtpVdb.spans</code>.</p> </li> <li> <p><code>LtpVseat</code>: contains the state information of an active seat in the working memory. It is tracked as an element in the list <code>LtpVdb.seats</code>.</p> </li> <li> <p><code>LtpVImportSession</code>: contains the state information of an active import session in the working memory. It is tracked as an element in the list <code>LtpVspan.importSessions</code>.</p> </li> </ul>"},{"location":"LTP-UComm-API/#ltp-apis-for-implementation-of-underlying-communication-protocol","title":"LTP APIs for implementation of underlying communication protocol","text":""},{"location":"LTP-UComm-API/#header","title":"Header","text":"<pre><code>#include \"ltpP.h\"\n</code></pre>"},{"location":"LTP-UComm-API/#ltpinit","title":"ltpInit","text":"<p>Function Prototype</p> <pre><code>extern int  ltpInit(int estMaxExportSessions);\n</code></pre> <p>Parameters</p> <ul> <li><code>estMaxExportSessions</code>: name of the endpoint</li> </ul> <p>Return Value</p> <ul> <li>0: success</li> <li>-1: any error</li> </ul> <p>Example Call</p> <pre><code>/*  Note that ltpadmin must be run before the first\n *  invocation of ltplso, to initialize the LTP database\n *  (as necessary) and dynamic database.*/\n\nif (ltpInit(0) &lt; 0)\n{\n    putErrmsg(\"aoslso can't initialize LTP.\", NULL);\n\n    /* user error handling routine here */\n}\n</code></pre> <p>Description</p> <p>This call attaches to ION and either initializes a new LTP database or loads the LTP database of an existing service. If the value of <code>estMaxExportSessions</code> is positive and no existing LTP service are found, then LTP service will be initialized with the specified maximum number of export sessions indicated. If the value of <code>estMaxExportSessions</code> is zero or negative, then <code>ltpInit</code> will load the LTP database or otherwise quit if no existing LTP service is found. NOTE: for the underlying communication protocol implementation, setting <code>ltpInit(0)</code> is appropriate since the intention is to load an existing LTP service only.</p> <p>Once a LTP service is either found or initialized, it loads the address to the LTP database object defined by <code>LtpDB</code> in <code>ltpP.h</code>.</p>"},{"location":"LTP-UComm-API/#findspan","title":"findSpan","text":"<p>Function Prototype</p> <pre><code>void findSpan(uvast engineId, LtpVspan **vspan, PsmAddress *vspanElt);\n</code></pre> <p>Parameters</p> <ul> <li><code>engineId</code>: The engine number of the peer LTP engine</li> <li><code>vspan</code>: pointer to the pointer of the LTP span object in ION working memory that encapsulates the current state of the LTP span</li> <li><code>vspanElt</code>: pointer to the address stored in a list of span in the volatile database defined by <code>LtpVdb</code></li> </ul> <p>Return Value</p> <ul> <li>none</li> </ul> <p>Example Code</p> <pre><code>sdr = getIonsdr();\nCHKZERO(sdr_begin_xn(sdr)); /*  Lock SDR.   */\nfindSpan(remoteEngineId, &amp;vspan, &amp;vspanElt);\nif (vspanElt == 0)\n{\n    sdr_exit_xn(sdr);\n    putErrmsg(\"No such engine in database.\", itoa(remoteEngineId));\n    /* user error handling routine here */\n}\n\nif (vspan-&gt;lsoPid != ERROR &amp;&amp; vspan-&gt;lsoPid != sm_TaskIdSelf())\n{\n    sdr_exit_xn(sdr);\n    putErrmsg(\"LSO task is already started for this span.\",\n        itoa(vspan-&gt;lsoPid));\n    /* user error handling routine here */\n}\n\n/* unlock the SDR */\nsdr_exit_xn(sdr);\n</code></pre> <p>Description</p> <p>This function searches the volatile database for the span that corresponds to the specified engine number. If the span is found, then the pointer to the span object is stored in the <code>vspan</code> parameter and the address of the span object in the list of spans in the volatile database is stored in the <code>vspanElt</code> parameter. If the span is not found, then <code>vspanElt</code> parameter is set to 0.</p> <p>Note: In addition to check the value of <code>vspanElt</code>, one can also check for the process ID of the LSO task (the LTP output process, i.e., the underlying communication protocol) of the span has not already been serviced by another protocol implementation.</p>"},{"location":"LTP-UComm-API/#ltpdequeueoutboundsegment","title":"ltpDequeueOutboundSegment","text":"<p>Function Prototype</p> <pre><code>extern int ltpDequeueOutboundSegment(LtpVspan *vspan, char **buf);\n</code></pre> <p>Parameters</p> <ul> <li><code>vspan</code>: address to the volatile LTP span object</li> <li><code>buf</code>: the buffer in which outbound LTP segments are stored</li> </ul> <p>Return Value</p> <ul> <li><code>length of segment</code>: success</li> <li><code>0</code>: session associated to the dequeued segment has already closed; no need to transmit any data</li> <li><code>-1</code>: any error</li> </ul> <p>Example Code</p> <pre><code>segmentLength = ltpDequeueOutboundSegment(vspan, &amp;segment);\nif (segmentLength &lt; 0)\n{\n    /* handle error */\n}\n\nif (segmentLength == 0)\n{\n    /* session is closed, take appropriate action */\n\n}\n\n/* transmit the segment */\n</code></pre> <p>Description:</p> <p>This function dequeues a LTP segment, based on the <code>segSemaphore</code> in <code>vspan</code> object, into a buffer space for the calling task to process for transmission. The returned value is the length of the LTP segment dequeue; 0 if the segment belongs to a session that already closed (therefore no action is required), and -1 if an error occurred.</p> <p>If this call is implemented in a loop, then it is suggested that the loop monitors the <code>segSemaphore</code> in <code>vspan</code> to detect the termination of the semaphore using the <code>sm_SemEnded(vspan-&gt;segSemaphore)</code> call. If the semaphore has ended, it means the span associated with the underlying communication protocol instance has ended. This is the right time to end the task itself.</p> <p>After each successful iteration in a loop, it is recommended that you call <code>sm_TaskYield()</code> to give other tasks a chance to run. A good example code to read is the <code>udplso.c</code> program.</p>"},{"location":"LTP-UComm-API/#ltphandleinboundsegment","title":"ltpHandleInboundSegment","text":"<p>Function Prototype</p> <pre><code>int ltpHandleInboundSegment(char *buf, int length)\n</code></pre> <p>Parameters</p> <ul> <li><code>buf</code>: pointer to buffer storing the received LTP segment, to be submitted to LTP engine for processing</li> <li><code>length</code>: the length of the received LTP segment</li> </ul> <p>Return Value</p> <ul> <li><code>0</code>: segment successfully handled</li> <li><code>-1</code>: any error</li> </ul> <p>Example Code</p> <pre><code>if (ltpHandleInboundSegment(buffer, segmentLength) &lt; 0)\n{\n    putErrmsg(\"Can't handle inbound segment.\", NULL);\n    /* handle error here */\n}`\n</code></pre> <p>Description</p> <p>This function submits received LTP segments to LTP engine for processing. The return value is 0 if the segment is successfully handled, and -1 if an error occurred. A successfully handled segment includes cases where the segments are ignored for several possible, non-critial, non-fatal discrepencies such as wrong LTP version number, closed session number, session under cancellation (therefore the segment was not processed) and other conditions are may occur under nominal condition.</p> <p>To develop one's own underlying communication protocol implementation to support LTP, the <code>udplsi.c</code> and <code>udplso.c</code> programs are good templates to use.</p>"},{"location":"License/","title":"License","text":"<p>NO WARRANTY:</p> <p>DISCLAIMER</p> <p>THE SOFTWARE AND/OR RELATED MATERIALS ARE PROVIDED \"AS-IS\" WITHOUT WARRANTY OF ANY KIND INCLUDING ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UCC 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE LICENSED PRODUCT, HOWEVER USED.</p> <p>IN NO EVENT SHALL CALTECH/JPL BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING BUT NOT LIMITED TO INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH/JPL SHALL BE ADVISED, HAVE REASON TO KNOW, OR IN FACT SHALL KNOW OF THE POSSIBILITY.</p> <p>USER BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF THE SOFTWARE AND/OR RELATED MATERIALS.</p> <p>Copyright 2002-2013, by the California Institute of Technology. ALL RIGHTS RESERVED. U.S. Government Sponsorship acknowledged.</p> <p>This software and/or related materials may be subject to U.S. export control laws.  By accepting this software and related materials, the user agrees to comply with all applicable U.S. export laws and regulations.  User has the responsibility to obtain export licenses or other export authority as may be required before exporting the software or related materials to foreign countries or providing access to foreign persons.</p> <p>The QCBOR code included is distributed with the following condition</p> <p>Copyright (c) 2016-2018, The Linux Foundation. Copyright (c) 2018-2019, Laurence Lundblade. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.     * Neither the name of The Linux Foundation nor the names of its contributors, nor the name \"Laurence Lundblade\" may be used to endorse or promote products derived from this software without specific prior written permission.</p> <p>THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"List-of-Papers/","title":"Publications","text":""},{"location":"List-of-Papers/#papers","title":"Papers","text":"<ul> <li>Burleigh, S., Fall, K., and E. Birrane, III, \"Bundle Protocol Version 7\", RFC 9171, DOI 10.17487/RFC9171, January 2022, https://www.rfc-editor.org/info/rfc9171.</li> <li>Birrane, III, E. and K. McKeever, \"Bundle Protocol Security (BPSec)\", RFC 9172, DOI 10.17487/RFC9172, January 2022, https://www.rfc-editor.org/info/rfc9172.</li> <li>Birrane, III, E., White, A, and Heiner, S., \"Default Security Contexts for Bundle Protocol Security (BPSec)\", RFC 9173, January 2022, https://datatracker.ietf.org/doc/rfc9173/.</li> <li>Torgerson, Leigh, et al. Delay-Tolerant Networking Architecture. Request for Comments, RFC 4838, Internet Engineering Task Force, Apr. 2007, https://doi.org/10.17487/RFC4838.</li> <li>da Silva, Aloizio Pereira, et al. Delay and Disruption Tolerant Networks: Interplanetary and Earth-Bound\u2013Architecture, Protocols, and Applications. CRC Press, 2018.</li> <li>Fraire, Juan A., et al. \u201cRouting in the Space Internet: A Contact Graph Routing Tutorial.\u201d Journal of Network and Computer Applications, vol. 174, 2021, p. 102884, https://doi.org/10.1016/j.jnca.2020.102884.</li> <li>Birrane, Edward J., et al. DTN Management Architecture. Internet Draft, draft-ietf-dtn-dtnma-03, Internet Engineering Task Force, 24 Oct. 2022, https://datatracker.ietf.org/doc/draft-ietf-dtn-dtnma-03.</li> <li>Blanchet, Marc. Delay-Tolerant Networking Bundle Protocol IANA Registries. Request for Comments, RFC 6255, Internet Engineering Task Force, May 2011, https://doi.org/10.17487/RFC6255.</li> <li>Burleigh, Scott. Compressed Bundle Header Encoding (CBHE). Request for Comments, RFC 6260, Internet Engineering Task Force, May 2011, https://doi.org/10.17487/RFC6260.</li> <li>Demmer, Michael, et al. Delay-Tolerant Networking TCP Convergence-Layer Protocol. Request for Comments, RFC 7242, Internet Engineering Task Force, June 2014, https://doi.org/10.17487/RFC7242.</li> <li>Farrell, Stephen, et al. Bundle Security Protocol Specification. Request for Comments, RFC 6257, Internet Engineering Task Force, May 2011, https://doi.org/10.17487/RFC6257.</li> <li>Kruse, Hans, et al. Datagram Convergence Layers for the Delay- and Disruption-Tolerant Networking (DTN) Bundle Protocol and Licklider Transmission Protocol (LTP). Request for Comments, RFC 7122, Internet Engineering Task Force, Mar. 2014, https://doi.org/10.17487/RFC7122.</li> <li>Scott, Keith, and Scott C. Burleigh. Bundle Protocol Specification. Request for Comments, RFC 5050, Internet Engineering Task Force, Nov. 2007, https://doi.org/10.17487/RFC5050.</li> <li>Velazco, J. \u201cAn Inter Planetary Network Enabled by SmallSats.\u201d 2020 IEEE Aerospace Conference, IEEE, 2020, pp. 1\u201310, https://doi.org/10.1109/AERO47225.2020.9172696.</li> <li>Yang, G., et al. \u201cAnalysis of Licklider Transmission Protocol for Reliable File Delivery in Space Vehicle Communications With Random Link Interruptions.\u201d IEEE Transactions on Vehicular Technology, vol. 68, no. 4, Feb. 2019, pp. 3919\u201332, https://doi.org/10.1109/TVT.2019.2897305.</li> <li>Davarian, F., et al. \u201cImproving Small Satellite Communications and Tracking in Deep Space\u2014A Review of the Existing Systems and Technologies With Recommendations for Improvement. Part II: Small Satellite Navigation, Proximity Links, and Communications Link Science.\u201d IEEE Aerospace and Electronic Systems Magazine, vol. 35, no. 7, July 2020, pp. 26\u201340, https://doi.org/10.1109/MAES.2020.2975260.</li> <li>Cosby, Matthew, and Wallace Tai. Lunar Communications Architecture Study Report. 31 Jan. 2022, https://www.ioag.org/Public%20Documents/Lunar%20communications%20architecture%20study%20report%20FINAL%20v1.3.pdf.</li> <li>Huff, John D. Performance Characteristics of the Interplanetary Overlay Network in 10 Gbps Networks. Ohio University, 2021, http://rave.ohiolink.edu/etdc/view?acc_num=ohiou1619115602389023.</li> <li>Kim, Inkyu, et al. \u201cThe Performance Analysis of Multi-Hop Relay DTN Communication System in Interplanetary Network.\u201d 2020 International Conference on Information and Communication Technology Convergence (ICTC), 2020, pp. 1136\u201341, https://doi.org/10.1109/ICTC49870.2020.9289238.</li> <li>CCSDS. Concepts and Rationale for Streaming Services over Bundle Protocol. Informational Report, CCSDS 730.2-G-1, CCSDS, Sept. 2018, https://public.ccsds.org/Pubs/730x2g1.pdf</li> <li>Paul Rosemurgy, Jay Gao, Sky DeBaun, Michael Starch, Jeffrey Levison, and Rebecca Castano, \"Enabling DTN in Spaceflight Systems: Integration of ION with the F Prime Flight Software Framework,\" Proceedings of the 2024 IEEE Aerospace Conference, Big Sky, MT, March 2024.</li> <li>J . Leigh Torgerson, Vinton Cerf, Sky U. DeBaun, Larissa C. Suzuki, \"Space System Internetworking: The Foundational Role of Delay and Disruption-Tolerant Networking,\" IEEE Journal on Selected Areas in Communications, Vol. 42, No. 5, May 2024.</li> <li>Yosuke Kaneko, Vinton Cerf, Scott Pace, Jim Green, Laura DeNardis, James Schier, Dave J. Israel, Felix Flentge, Leigh Torgerson, Scott Burleigh, Marc Blanchet, Ed Birrane, Keith Scott, Oscar Garcia, Kiyohisa Suzuki, Marius Feldmann, Laura Chappell, Ginny Spicer, Henry Danielson, Helen Tabunshchyk, \"Report: Solar System Internet Architecture and Governance\", Interplanetary Chatper, Internet Society, September 2023.</li> </ul>"},{"location":"List-of-Papers/#reference-documents","title":"Reference Documents","text":"<ul> <li>BPSec Security Policy User Manual (ION 4.0.2, archive)</li> <li>BPSec Security Policy User Manual (ION 4.1.2)</li> <li>BpSec release notes for ION 4.1.2</li> <li>Building ION from source on Windows.pdf</li> <li>Solar System Internet Architecture and Governance</li> </ul>"},{"location":"Platform-Macros-Error-Reporting/","title":"Platform Macros &amp; Error Reporting","text":"<p>From manual page for \"platform\"</p>"},{"location":"Platform-Macros-Error-Reporting/#platform-compatibility","title":"Platform Compatibility","text":"<p>The platform library \"patches\" the APIs of supported OS's to guarantee that all of the following items may be utilized by application software:</p> <pre><code>The strchr(), strrchr(), strcasecmp(), and strncasecmp() functions.\n\nThe unlink(), getpid(), and gettimeofday() functions.\n\nThe select() function.\n\nThe FD_BITMAP macro (used by select()).\n\nThe MAXHOSTNAMELEN macro.\n\nThe NULL macro.\n\nThe timer_t type definition.\n</code></pre>"},{"location":"Platform-Macros-Error-Reporting/#platform-generic-macros-functions","title":"Platform Generic Macros &amp; Functions","text":"<p>The generic macros and functions in this section may be used in place of comparable O/S-specific functions, to enhance the portability of code. (The implementations of these macros and functions are no-ops in environments in which they are inapplicable, so they're always safe to call.)</p>"},{"location":"Platform-Macros-Error-Reporting/#fdtable_size","title":"FDTABLE_SIZE","text":"<p>The FDTABLE_SIZE macro returns the total number of file descriptors defined for the process (or VxWorks target).</p>"},{"location":"Platform-Macros-Error-Reporting/#ion_path_delimiter","title":"ION_PATH_DELIMITER","text":"<p>The ION_PATH_DELIMITER macro returns the ASCII character -- either '/' or '\\' -- that is used as a directory name delimiter in path names for the file system used by the local platform.</p>"},{"location":"Platform-Macros-Error-Reporting/#ok","title":"oK","text":"<p><pre><code>oK(expression)\n</code></pre> The oK macro simply casts the value of expression to void, a way of handling function return codes that are not meaningful in this context.</p>"},{"location":"Platform-Macros-Error-Reporting/#chkerr","title":"CHKERR","text":"<pre><code>CHKERR(condition)\n</code></pre> <p>The CHKERR macro is an \"assert\" mechanism. It causes the calling function to return -1 immediately if condition is false.</p>"},{"location":"Platform-Macros-Error-Reporting/#chkzero","title":"CHKZERO","text":"<pre><code>CHKZERO(condition)\n</code></pre> <p>The CHKZERO macro is an \"assert\" mechanism. It causes the calling function to return 0 immediately if condition is false.</p>"},{"location":"Platform-Macros-Error-Reporting/#chknull","title":"CHKNULL","text":"<p><pre><code>CHKNULL(condition)\n</code></pre> The CHKNULL macro is an \"assert\" mechanism. It causes the calling function to return NULL immediately if condition is false.</p>"},{"location":"Platform-Macros-Error-Reporting/#chkvoid","title":"CHKVOID","text":"<pre><code>CHKVOID(condition)\n</code></pre> <p>The CHKVOID macro is an \"assert\" mechanism. It causes the calling function to return immediately if condition is false.</p>"},{"location":"Platform-Macros-Error-Reporting/#snooze","title":"snooze","text":"<p><pre><code>void snooze(unsigned int seconds)\n</code></pre> Suspends execution of the invoking task or process for the indicated number of seconds.</p>"},{"location":"Platform-Macros-Error-Reporting/#microsnooze","title":"microsnooze","text":"<pre><code>void microsnooze(unsigned int microseconds)\n</code></pre> <p>Suspends execution of the invoking task or process for the indicated number of microseconds.</p>"},{"location":"Platform-Macros-Error-Reporting/#getcurrenttime","title":"getCurrentTime","text":"<pre><code>void getCurrentTime(struct timeval *time)\n</code></pre> <p>Returns the current local time (ctime, i.e., Unix epoch time) in a timeval structure (see gettimeofday(3C)).</p>"},{"location":"Platform-Macros-Error-Reporting/#isprintf","title":"isprintf","text":"<pre><code>void isprintf(char *buffer, int bufSize, char *format, ...)\n</code></pre> <p>isprintf() is a safe, portable implementation of snprintf(); see the snprintf(P) man page for details. isprintf() differs from snprintf() in that it always NULL-terminates the string in buffer, even if the length of the composed string would equal or exceed bufSize. Buffer overruns are reported by log message; unlike snprintf(), isprintf() returns void.</p>"},{"location":"Platform-Macros-Error-Reporting/#istrlen","title":"istrlen","text":"<pre><code>size_t istrlen(const char *sourceString, size_t maxlen)\n</code></pre> <p>istrlen() is a safe implementation of strlen(); see the strlen(3) man page for details. istrlen() differs from strlen() in that it takes a second argument, the maximum valid length of sourceString. The function returns the number of non-NULL characters in sourceString preceding the first NULL character in sourceString, provided that a NULL character appears somewhere within the first maxlen characters of sourceString; otherwise it returns maxlen.</p>"},{"location":"Platform-Macros-Error-Reporting/#istrcpy","title":"istrcpy","text":"<pre><code>char *istrcpy(char *buffer, char *sourceString, int bufSize)\n</code></pre> <p>istrcpy() is a safe implementation of strcpy(); see the strcpy(3) man page for details. istrcpy() differs from strcpy() in that it takes a third argument, the total size of the buffer into which sourceString is to be copied. istrcpy() always NULL-terminates the string in buffer, even if the length of sourceString string would equal or exceed bufSize (in which case sourceString is truncated to fit within the buffer).</p>"},{"location":"Platform-Macros-Error-Reporting/#istrcat","title":"istrcat","text":"<pre><code>char *istrcat(char *buffer, char *sourceString, int bufSize)\n</code></pre> <p>istrcat() is a safe implementation of strcat(); see the strcat(3) man page for details. istrcat() differs from strcat() in that it takes a third argument, the total size of the buffer for the string that is being aggregated. istrcat() always NULL-terminates the string in buffer, even if the length of sourceString string would equal or exceed the sum of bufSize and the length of the string currently occupying the buffer (in which case sourceString is truncated to fit within the buffer).</p>"},{"location":"Platform-Macros-Error-Reporting/#igetcwd","title":"igetcwd","text":"<pre><code>char *igetcwd(char *buf, size_t size)\n</code></pre> <p>igetcwd() is normally just a wrapper around getcwd(3). It differs from getcwd(3) only when FSWWDNAME is defined, in which case the implementation of igetcwd() must be supplied in an included file named \"wdname.c\"; this adaptation option accommodates flight software environments in which the current working directory name must be configured rather than discovered at run time.</p>"},{"location":"Platform-Macros-Error-Reporting/#isignal","title":"isignal","text":"<pre><code>void isignal(int signbr, void (*handler)(int))\n</code></pre> <p>isignal() is a portable, simplified interface to signal handling that is functionally indistinguishable from signal(P). It assures that reception of the indicated signal will interrupt system calls in SVR4 fashion, even when running on a FreeBSD platform.</p>"},{"location":"Platform-Macros-Error-Reporting/#iblock","title":"iblock","text":"<pre><code>void iblock(int signbr)\n</code></pre> <p>iblock() simply prevents reception of the indicated signal by the calling thread. It provides a means of controlling which of the threads in a process will receive the signal cited in an invocation of isignal().</p>"},{"location":"Platform-Macros-Error-Reporting/#ifopen","title":"ifopen","text":"<pre><code>int ifopen(const char *fileName, int flags, int pmode)\n</code></pre> <p>ifopen() is a portable function for opening \"regular\" files. It operates in exactly the same way as open() except that it fails (returning -1) if fileName does not identify a regular file, i.e., it's a directory, a named pipe, etc.</p> <p>NOTE that ION also provides iopen() which is nothing more than a portable wrapper for open(). iopen() can be used to open a directory, for example.</p>"},{"location":"Platform-Macros-Error-Reporting/#igets","title":"igets","text":"<pre><code>char *igets(int fd, char *buffer, int buflen, int *lineLen)\n</code></pre> <p>igets() reads a line of text, delimited by a newline character, from fd into buffer and writes a NULL character at the end of the string. The newline character itself is omitted from the NULL-terminated text line in buffer; if the newline is immediately preceded by a carriage return character (i.e., the line is from a DOS text file), then the carriage return character is likewise omitted from the NULL-terminated text line in buffer. End of file is interpreted as an implicit newline, terminating the line. If the number of characters preceding the newline is greater than or equal to buflen, only the first (buflen - 1) characters of the line are written into buffer. On error the function sets lineLen to -1 and returns NULL. On reading end-of-file, the function sets lineLen to zero and returns NULL. Otherwise the function sets *lineLen to the length of the text line in buffer, as if from strlen(3), and returns buffer.</p>"},{"location":"Platform-Macros-Error-Reporting/#iputs","title":"iputs","text":"<pre><code>int iputs(int fd, char *string)\n</code></pre> <p>iputs() writes to fd the NULL-terminated character string at string. No terminating newline character is appended to string by iputs(). On error the function returns -1; otherwise the function returns the length of the character string written to fd, as if from strlen(3).</p>"},{"location":"Platform-Macros-Error-Reporting/#strtovast","title":"strtovast","text":"<pre><code>vast strtovast(char *string)\n</code></pre> <p>Converts the leading characters of string, skipping leading white space and ending at the first subsequent character that can't be interpreted as contributing to a numeric value, to a vast integer and returns that integer.</p>"},{"location":"Platform-Macros-Error-Reporting/#strtouvast","title":"strtouvast","text":"<pre><code>uvast strtouvast(char *string)\n</code></pre> <p>Same as strtovast() except the result is an unsigned vast integer value.</p>"},{"location":"Platform-Macros-Error-Reporting/#findtoken","title":"findToken","text":"<pre><code>void findToken(char **cursorPtr, char **token)\n</code></pre> <p>Locates the next non-whitespace lexical token in a character array, starting at cursorPtr. The function NULL-terminates that token within the array and places a pointer to the token in token. Also accommodates tokens enclosed within matching single quotes, which may contain embedded spaces and escaped single-quote characters. If no token is found, *token contains NULL on return from this function.</p>"},{"location":"Platform-Macros-Error-Reporting/#acquiresystemmemory","title":"acquireSystemMemory","text":"<pre><code>void *acquireSystemMemory(size_t size)\n</code></pre> <p>Uses memalign() to allocate a block of system memory of length size, starting at an address that is guaranteed to be an integral multiple of the size of a pointer to void, and initializes the entire block to binary zeroes. Returns the starting address of the allocated block on success; returns NULL on any error.</p>"},{"location":"Platform-Macros-Error-Reporting/#createfile","title":"createFile","text":"<pre><code>int createFile(const char *name, int flags)\n</code></pre> <p>Creates a file of the indicated name, using the indicated file creation flags. This function provides common file creation functionality across VxWorks and Unix platforms, invoking creat() under VxWorks and open() elsewhere. For return values, see creat(2) and open(2).</p>"},{"location":"Platform-Macros-Error-Reporting/#getinternetaddress","title":"getInternetAddress","text":"<pre><code>unsigned int getInternetAddress(char *hostName)\n</code></pre> <p>Returns the IP address of the indicated host machine, or zero if the address cannot be determined.</p>"},{"location":"Platform-Macros-Error-Reporting/#getinternethostname","title":"getInternetHostName","text":"<pre><code>char *getInternetHostName(unsigned int hostNbr, char *buffer)\n</code></pre> <p>Writes the host name of the indicated host machine into buffer and returns buffer, or returns NULL on any error. The size of buffer should be (MAXHOSTNAMELEN + 1).</p>"},{"location":"Platform-Macros-Error-Reporting/#getnameofhost","title":"getNameOfHost","text":"<pre><code>int getNameOfHost(char *buffer, int bufferLength)\n</code></pre> <p>Writes the first (bufferLength - 1) characters of the host name of the local machine into buffer. Returns 0 on success, -1 on any error.</p>"},{"location":"Platform-Macros-Error-Reporting/#getaddressofhost","title":"getAddressOfHost","text":"<pre><code>unsigned int getAddressOfHost()\n</code></pre> <p>Returns the IP address for the host name of the local machine, or 0 on any error.</p>"},{"location":"Platform-Macros-Error-Reporting/#parsesocketspec","title":"parseSocketSpec","text":"<pre><code>void parseSocketSpec(char *socketSpec, unsigned short *portNbr, unsigned int *hostNbr)\n</code></pre> <p>Parses socketSpec, extracting host number (IP address) and port number from the string. socketSpec is expected to be of the form \"{ @ | hostname }[:]\", where @ signifies \"the host name of the local machine\". If host number can be determined, writes it into hostNbr; otherwise writes 0 into hostNbr. If port number is supplied and is in the range 1024 to 65535, writes it into portNbr; otherwise writes 0 into portNbr."},{"location":"Platform-Macros-Error-Reporting/#printdottedstring","title":"printDottedString","text":"<pre><code>void printDottedString(unsigned int hostNbr, char *buffer)\n</code></pre> <p>Composes a dotted-string (xxx.xxx.xxx.xxx) representation of the IPv4 address in hostNbr and writes that string into buffer. The length of buffer must be at least 16.</p>"},{"location":"Platform-Macros-Error-Reporting/#getnameofuser","title":"getNameOfUser","text":"<pre><code>char *getNameOfUser(char *buffer)\n</code></pre> <p>Writes the user name of the invoking task or process into buffer and returns buffer. The size of buffer must be at least L_cuserid, a constant defined in the stdio.h header file. Returns buffer.</p>"},{"location":"Platform-Macros-Error-Reporting/#reuseaddress","title":"reUseAddress","text":"<pre><code>int reUseAddress(int fd)\n</code></pre> <p>Makes the address that is bound to the socket identified by fd reusable, so that the socket can be closed and immediately reopened and re-bound to the same port number. Returns 0 on success, -1 on any error.</p>"},{"location":"Platform-Macros-Error-Reporting/#makeiononblocking","title":"makeIoNonBlocking","text":"<pre><code>int makeIoNonBlocking(int fd)\n</code></pre> <p>Makes I/O on the socket identified by fd non-blocking; returns -1 on failure. An attempt to read on a non-blocking socket when no data are pending, or to write on it when its output buffer is full, will not block; it will instead return -1 and cause errno to be set to EWOULDBLOCK.</p>"},{"location":"Platform-Macros-Error-Reporting/#watchsocket","title":"watchSocket","text":"<pre><code>int watchSocket(int fd)\n</code></pre> <p>Turns on the \"linger\" and \"keepalive\" options for the socket identified by fd. See socket(2) for details. Returns 0 on success, -1 on any failure.</p>"},{"location":"Platform-Macros-Error-Reporting/#closeonexec","title":"closeOnExec","text":"<pre><code>void closeOnExec(int fd)\n</code></pre> <p>Ensures that fd will NOT be open in any child process fork()ed from the invoking process. Has no effect on a VxWorks platform.</p>"},{"location":"Platform-Macros-Error-Reporting/#exception-reporting","title":"Exception Reporting","text":"<p>The functions in this section offer platform-independent capabilities for reporting on processing exceptions.</p> <p>The underlying mechanism for ICI's exception reporting is a pair of functions that record error messages in a privately managed pool of static memory. These functions -- <code>postErrmsg()</code> and <code>postSysErrmsg()</code> -- are designed to return very rapidly with no possibility of failing, themselves. Nonetheless they are not safe to call from an interrupt service routing (ISR). Although each merely copies its text to the next available location in the error message memory pool, that pool is protected by a mutex; multiple processes might be queued up to take that mutex, so the total time to execute the function is non-deterministic.</p> <p>Built on top of <code>postErrmsg()</code> and <code>postSysErrmsg()</code> are the <code>putErrmsg()</code> and <code>putSysErrmsg()</code> functions, which may take longer to return. Each one simply calls the corresponding \"post\" function but then calls the <code>writeErrmsgMemos()</code> function, which calls <code>writeMemo()</code> to print (or otherwise deliver) each message currently posted to the pool and then destroys all of those posted messages, emptying the pool.</p> <p>Recommended general policy on using the ICI exception reporting functions (which the functions in the ION distribution libraries are supposed to adhere to) is as follows:</p> <pre><code>In the implementation of any ION library function or any ION\ntask's top-level driver function, any condition that prevents\nthe function from continuing execution toward producing the\neffect it is designed to produce is considered an \"error\".\n\nDetection of an error should result in the printing of an\nerror message and, normally, the immediate return of whatever\nreturn value is used to indicate the failure of the function\nin which the error was detected.  By convention this value\nis usually -1, but both zero and NULL are appropriate\nfailure indications under some circumstances such as object\ncreation.\n\nThe CHKERR, CHKZERO, CHKNULL, and CHKVOID macros are used to\nimplement this behavior in a standard and lexically terse\nmanner.  Use of these macros offers an additional feature:\nfor debugging purposes, they can easily be configured to\ncall sm_Abort() to terminate immediately with a core dump\ninstead of returning a error indication.  This option is\nenabled by setting the compiler parameter CORE_FILE_NEEDED\nto 1 at compilation time.\n\nIn the absence of either any error, the function returns a\nvalue that indicates nominal completion.  By convention this\nvalue is usually zero, but under some circumstances other\nvalues (such as pointers or addresses) are appropriate\nindications of nominal completion.  Any additional information\nproduced by the function, such as an indication of \"success\",\nis usually returned as the value of a reference argument.\n[Note, though, that database management functions and the\nSDR hash table management functions deviate from this rule:\nmost return 0 to indicate nominal completion but functional\nfailure (e.g., duplicate key or object not found) and return\n1 to indicate functional success.]\n\nSo when returning a value that indicates nominal completion\nof the function -- even if the result might be interpreted\nas a failure at a higher level (e.g., an object identified\nby a given string is not found, through no failure of the\nsearch function) -- do NOT invoke putErrmsg().\n\nUse putErrmsg() and putSysErrmsg() only when functions are\nunable to proceed to nominal completion.  Use writeMemo()\nor writeMemoNote() if you just want to log a message.\n\nWhenever returning a value that indicates an error:\n\n        If the failure is due to the failure of a system call\n        or some other non-ION function, assume that errno\n        has already been set by the function at the lowest\n        layer of the call stack; use putSysErrmsg (or\n        postSysErrmsg if in a hurry) to describe the nature\n        of the activity that failed.  The text of the error\n        message should normally start with a capital letter\n        and should NOT end with a period.\n\n        Otherwise -- i.e., the failure is due to a condition\n        that was detected within ION -- use putErrmsg (or\n        postErrmg if pressed for time) to describe the nature\n        of the failure condition.  This will aid in tracing\n        the failure through the function stack in which the\n        failure was detected.  The text of the error message\n        should normally start with a capital letter and should\n        end with a period.\n\nWhen a failure in a called function is reported to \"driver\"\ncode in an application program, before continuing or exiting\nuse writeErrmsgMemos() to empty the message pool and print a\nsimple stack trace identifying the failure.\n</code></pre>"},{"location":"Platform-Macros-Error-Reporting/#system_error_msg","title":"system_error_msg()","text":"<pre><code>char *system_error_msg( )\n</code></pre> <p>Returns a brief text string describing the current system error, as identified by the current value of errno.</p>"},{"location":"Platform-Macros-Error-Reporting/#setlogger","title":"setLogger","text":"<pre><code>void setLogger(Logger usersLoggerName)\n</code></pre> <p>Sets the user function to be used for writing messages to a user-defined \"log\" medium. The logger function's calling sequence must match the following prototype:</p> <pre><code>void    usersLoggerName(char *msg);\n</code></pre> <p>The default Logger function simply writes the message to standard output.</p>"},{"location":"Platform-Macros-Error-Reporting/#writememo","title":"writeMemo","text":"<pre><code>void writeMemo(char *msg)\n</code></pre> <p>Writes one log message, using the currently defined message logging function. To construct a more complex string, it is customary and safer to use the isprintf function to build a message string first, and then pass that string as an argument to writeMemo.</p>"},{"location":"Platform-Macros-Error-Reporting/#writememonote","title":"writeMemoNote","text":"<pre><code>void writeMemoNote(char *msg, char *note)\n</code></pre> <p>Writes a log message like writeMemo(), accompanied by the user-supplied context-specific text string in note. The text string can also be build separately using isprintf().</p>"},{"location":"Platform-Macros-Error-Reporting/#writeerrmemo","title":"writeErrMemo","text":"<pre><code>void writeErrMemo(char *msg)\n</code></pre> <p>Writes a log message like writeMemo(), accompanied by text describing the current system error.</p>"},{"location":"Platform-Macros-Error-Reporting/#itoa","title":"itoa","text":"<pre><code>char *itoa(int value)\n</code></pre> <p>Returns a string representation of the signed integer in value, nominally for immediate use as an argument to putErrmsg(). [Note that the string is constructed in a static buffer; this function is not thread-safe.]</p>"},{"location":"Platform-Macros-Error-Reporting/#utoa","title":"utoa","text":"<pre><code>char *utoa(unsigned int value)\n</code></pre> <p>Returns a string representation of the unsigned integer in value, nominally for immediate use as an argument to putErrmsg(). [Note that the string is constructed in a static buffer; this function is not thread-safe.]</p>"},{"location":"Platform-Macros-Error-Reporting/#posterrmsg","title":"postErrmsg","text":"<pre><code>void postErrmsg(char *text, char *argument)\n</code></pre> <p>Constructs an error message noting the name of the source file containing the line at which this function was called, the line number, the text of the message, and -- if not NULL -- a single textual argument that can be used to give more specific information about the nature of the reported failure (such as the value of one of the arguments to the failed function). The error message is appended to the list of messages in a privately managed pool of static memory, ERRMSGS_BUFSIZE bytes in length.</p> <p>If text is NULL or is a string of zero length or begins with a newline character (i.e., *text == '\\0' or '\\n'), the function returns immediately and no error message is recorded.</p> <p>The errmsgs pool is designed to be large enough to contain error messages from all levels of the calling stack at the time that an error is encountered. If the remaining unused space in the pool is less than the size of the new error message, however, the error message is silently omitted. In this case, provided at least two bytes of unused space remain in the pool, a message comprising a single newline character is appended to the list to indicate that a message was omitted due to excessive length.</p>"},{"location":"Platform-Macros-Error-Reporting/#postsyserrmsg","title":"postSysErrmsg","text":"<pre><code>void postSysErrmsg(char *text, char *arg)\n</code></pre> <p>Like postErrmsg() except that the error message constructed by the function additionally contains text describing the current system error. text is truncated as necessary to assure that the sum of its length and that of the description of the current system error does not exceed 1021 bytes.</p>"},{"location":"Platform-Macros-Error-Reporting/#geterrmsg","title":"getErrmsg","text":"<pre><code>int getErrmsg(char *buffer)\n</code></pre> <p>Copies the oldest error message in the message pool into buffer and removes that message from the pool, making room for new messages. Returns zero if the message pool cannot be locked for update or there are no more messages in the pool; otherwise returns the length of the message copied into buffer. Note that, for safety, the size of buffer should be ERRMSGS_BUFSIZE.</p> <p>Note that a returned error message comprising only a single newline character always signifies an error message that was silently omitted because there wasn't enough space left on the message pool to contain it.</p>"},{"location":"Platform-Macros-Error-Reporting/#writeerrmsgmemos","title":"writeErrmsgMemos","text":"<pre><code>void writeErrmsgMemos( )\n</code></pre> <p>Calls getErrmsg() repeatedly until the message pool is empty, using writeMemo() to log all the messages in the pool. Messages that were omitted due to excessive length are indicated by logged lines of the form \"[message omitted due to excessive length]\".</p>"},{"location":"Platform-Macros-Error-Reporting/#puterrmsg","title":"putErrmsg","text":"<pre><code>void putErrmsg(char *text, char *argument)\n</code></pre> <p>The putErrmsg() function merely calls postErrmsg() and then writeErrmsgMemos().</p>"},{"location":"Platform-Macros-Error-Reporting/#putsyserrmsg","title":"putSysErrmsg","text":"<pre><code>void putSysErrmsg(char *text, char *arg)\n</code></pre> <p>The putSysErrmsg() function merely calls postSysErrmsg() and then writeErrmsgMemos().</p>"},{"location":"Platform-Macros-Error-Reporting/#discarderrmsgs","title":"discardErrmsgs","text":"<pre><code>void discardErrmsgs( )\n</code></pre> <p>Calls getErrmsg() repeatedly until the message pool is empty, discarding all of the messages.</p>"},{"location":"Platform-Macros-Error-Reporting/#printstacktrace","title":"printStackTrace","text":"<pre><code>void printStackTrace( )\n</code></pre> <p>On Linux machines only, uses writeMemo() to print a trace of the process's current execution stack, starting with the lowest level of the stack and proceeding to the main() function of the executable.</p> <p>Note that (a) printStackTrace() is only implemented for Linux platforms at this time; (b) symbolic names of functions can only be printed if the -rdynamic flag was enabled when the executable was linked; (c) only the names of non-static functions will appear in the stack trace.</p> <p>For more complete information about the state of the executable at the time the stack trace snapshot was taken, use the Linux addr2line tool. To do this, cd into a directory in which the executable file resides (such as /opt/bin) and submit an addr2line command as follows:</p> <p><code>addr2line -e name_of_executable stack_frame_address</code> where both name_of_executable and stack_frame_address are taken from one of the lines of the printed stack trace. addr2line will print the source file name and line number for that stack frame.</p>"},{"location":"Use-Cases/","title":"Use Cases for ION","text":""},{"location":"Use-Cases/#current-deployment-of-ion-ion-integrated-systems","title":"\ud83d\ude80 Current Deployment of ION &amp; ION-Integrated Systems","text":"<ul> <li>NASA Deep Space Network: DTN services is currently provided by the DSN.</li> <li>NASA International Space Station: Science Payload onboard ISS as well as command/telemetry/science data relay Gateway</li> <li>KARI: Korean PathFinder Lunar Orbiter (KPLO): Operates a DTN-payload (DTNPL)</li> <li>Morehead State University 21-m Antenna: operates a ground DTN node using ION</li> <li>ION Core: a streamlined package of the core DTN features in ION excluding early prototypes and experimental features. Customizable for mission infusion and is available as a separate GitHub repo.</li> <li>F Prime Open Source Flight Software: ION BPv7 has been integrated with F Prime. A prototype is now available to the public through the F' Community on GitHub.</li> </ul>"},{"location":"Using-LTP-Config-Tool/","title":"A Guide to Configuring LTP in ION","text":"<p>Scott Burleigh, Jay Gao, and Leigh Torgerson</p> <p>Jet Propulsion Laboratory, California Institute of Technology</p> <p>Version 4.1.3</p>"},{"location":"Using-LTP-Config-Tool/#introduction","title":"Introduction","text":"<p>ION open source comes with an Excel spreadsheet to help users configure the LTP protocol to optimize performance based on each user's unique use case.</p> <p>ION's implementation of LTP is challenging to configure: there are a lot of configuration parameters to set, because the design is intended to support a very wide variety of deployment scenarios that are optimized for a variety of different figures of merit (utility metrics).</p> <p>LTP-ION is managed as a collection of \"spans\", that is, transmission/reception relationships between the local LTP engine (the engine -- or DTN \"node\" -- that you are configuring) and each other LTP engine with which the local engine can exchange LTP protocol segments. Spans are managed using functions defined in libltpP.c that are offered to the operator by the ltpadmin program.</p> <p>ltpadmin can be used to add a span, update an existing span, delete a span, provide current information on a specified span, or list all spans. The span configuration parameters that must be set when you add or update a span are as follows:</p> <ul> <li>The <code>remote LTP engine number</code> identifying the span. For ION, this   is by convention the same as the BP node number as established when   the ION database was initialized.</li> <li>The <code>maximum number of export sessions</code> that can be held open on   this span at any one time. This implements LTP flow control across   the span: since no new data can be transmitted until it is appended   to a block -- the data to be conveyed in a single export session --   and no new session can be started until the total number of open   sessions drops below the maximum, the closure of export sessions   regulates the rate at which LTP can be used to transmit data.</li> <li>The <code>maximum number of import sessions</code> that will be open on this   span at any one time. This value is simply the remote engine's own   value for the \"maximum number of export sessions\" parameter.</li> <li><code>Maximum LTP segment size</code>. This value is typically the maximum   permitted size of the payload of each link-layer protocol data unit   -- nominally a frame.</li> <li><code>Aggregation size limit</code>. This is the \"nominal\" size for blocks to   be sent over this span: normally LTP will concatenate multiple   service data units (such as BP bundles) into a single block until   the aggregate size of those service data units exceeds the   aggregation size limit, and only then will it divide the block into   segments and use the underlying link service to transmit the   segments. (Note that it is normal for the aggregation size limit to   be exceeded. In this sense, the word \"limit\" is really a misnomer;   \"threshold\" would be a better term.)</li> <li><code>Aggregation time limit</code>. This parameter establishes an alternate   means of terminating block aggregation and initiating segment   transmission: in the event that service data units are not being   presented to LTP rapidly enough to promptly fill blocks of nominal   size, LTP will arbitrarily terminate aggregation when the length of   time that the oldest service data units in the block have been   waiting for transmission exceeds the aggregation time limit.</li> <li><code>The Link Service Output command.</code> This parameter declares the   command that will be used to start the link service output task for   this span. The value of this parameter is a string, typically   enclosed in single quote marks and typically beginning with the name   of the executable object for the task. When the \"udplso\" link   service output module is to be used for a given span, the module   name is followed by the IPAddress:Port of the remote engine and   (optionally) the UDP transmission rate limit in bits per second.</li> </ul> <p>In addition, at the time you initialize LTP (normally at the start of the ltpadmin configuration file) you must set one further configuration parameter:</p> <ul> <li><code>Estimated total number of export sessions</code>, for all spans: this   value is used to size the hash table that LTP uses for storing and   retrieving export session information.</li> </ul> <p>In many cases, the best values for these configuration parameters will not be obvious to the DTN network administrator. To simplify this task, an LTP Configuration Worksheet has been developed.</p>"},{"location":"Using-LTP-Config-Tool/#worksheet-overview","title":"Worksheet overview","text":"<p>The LTP configuration worksheet is designed to aid in the configuration of a single span -- that is, the worksheet for the span between engines X and Y will provide configuration parameter values for use in commanding ltpadmin on both engine X and engine Y.</p> <p>The cells of the worksheet are of two general types, <code>Input Cells</code> and <code>Calculated Cells</code>.</p> <ul> <li><code>Input Cells</code> are cells in which the network administrator must supply   values based on project decisions. These cells are yellow-filled.</li> <li><code>Calculated Cells</code> are cells that are computed by the worksheet based   on LTP configuration principles. These cells are grey-filled. The   cells are protected from modification (though you can unprotect them   if you want by selecting \"Unprotect Sheet\" on the Excel \"Review\"   tab).</li> </ul> <p>Some of these cells are used as span configuration parameters or are figures of merit for network administrators:</p> <ul> <li>Span configuration parameters are identified by an adjacent dark   grey title cell with white text.</li> <li>Figures of merit for which the network administrator may want to   optimize the span configuration are identified by an adjacent green   title cell with red italic text.</li> </ul> <p>Note: Configuration parameters that are described in detail in this document are numbered. To ease cross referencing between this document and the worksheet, the parameter numbers are placed next to the title cells in the worksheet.*</p>"},{"location":"Using-LTP-Config-Tool/#input-parameters","title":"Input Parameters","text":"<p>This section provides guidance on the values that must be supplied by the network administrator. Global parameters affect calculated values and configuration file parameters for all spans involving the local LTP engine.</p>"},{"location":"Using-LTP-Config-Tool/#global-parameters","title":"Global Parameters","text":"<p><code>Maximum bit error rate</code> is the maximum bit error rate that the LTP should provide for in computing the maximum number of transmission efforts to initiate in the course of transmitting a given block. (Note that this computation is also sensitive to data segment size and to the size of the block that is to be transmitted.) The default value is .000001, i.e., 10^-6^, one uncorrected (but detected) bit error per million bits transmitted.</p> <p>The <code>size</code> - estimated size of an LTP report segment in bytes - may vary slightly depending on the sizes of the session numbers in use. 25 bytes is a reasonable estimate.</p>"},{"location":"Using-LTP-Config-Tool/#basic-input-parameters","title":"Basic input Parameters","text":"<p>Values for the following parameters must be provided by the network administrator in order for the worksheet to guide the configuration. Values must be provided for both engine \"X\" and engine \"Y\".</p> <ol> <li>The <code>OWLT</code> between engines (sec) is the maximum one-way light time    over this span, i.e., the distance between the engines. (Note that    this value is assumed to be symmetrical.)</li> <li>A unique <code>engine number</code> for each engine.</li> <li>The <code>IP address</code> of each engine. (Assuming udplso will be used as the    link service output daemon.)</li> <li>The <code>LTP reception port number</code> for each engine. (Again assuming    udplso will be used as the link service output daemon.)</li> <li>An estimate of the <code>mean size of the LTP service data units</code>    (nominally bundles) sent from this engine over this span.</li> <li><code>Link service overhead</code>. The expected number of bytes of link service    protocol header information per LTP segment.</li> <li><code>Aggregation size limit</code> - this is the service data unit aggregation    size limit for LTP. Note that a suggested    value for this parameter is automatically computed as described    below, based on available return channel capacity.</li> <li>The <code>scheduled transmission rate</code> (in bytes per second) at which this    engine will transmit data over this span when the two engines are in    contact.</li> <li><code>Maximum percentage of channel capacity that may be consumed by LTP report segments</code>. A warning will be displayed if other configuration    parameters cause this limit to be breached. There are no actual    mechanism to enforce this limit in ION. This only set in order to    check the estimated report traffic for the current configuration.    It is provided as an aid to LTP link designer.</li> <li>An <code>estimate of the percentage of all data sent over this span that will be red data</code>, i.e., will be subject to positive and negative    LTP acknowledgment.</li> <li> <p><code>Aggregation time limit</code>. The minimum value is 1 second. Increasing     this limit can marginally reduce the number of blocks transmitted,     and hence protocol overhead, at times of low communication activity.     However, it reduces the \"responsiveness\" of the protocol, increasing     the maximum possible delay before transmission of any given service     data unit. (This delay is referred to as \"data aggregation     latency\".)</p> <ul> <li><code>Low communication activity</code> is defined as a rate of   presentation of service data to LTP that is less than the   aggregation size limit divided by the aggregation time limit.</li> <li><code>LTP segment size</code> (bytes) is the maximum LTP segment size sent over this span by this engine. Typically, this is the maximum permitted size of the payloads of link-layer protocol data units (frames).</li> <li><code>The maximum number of export sessions</code>. This implements a form of flow control by placing a limit on the number of concurrent LTP sessions used to transmit blocks. Smaller numbers will result in slower transmission, while higher numbers increase storage resource occupancy. Note that a suggested value for this parameter is automatically computed as described below, based on transmission rate and one-way light time.</li> </ul> </li> </ol>"},{"location":"Using-LTP-Config-Tool/#further-guidance","title":"Further Guidance","text":"<p>This section provides further information on the methods used to compute the <code>Calculated Cells</code> and also guidance for <code>Input Cell</code> values.</p>"},{"location":"Using-LTP-Config-Tool/#first-order-computed-parameters","title":"First-order Computed Parameters","text":"<p>The following parameters are automatically computed based on the values of the basic input parameters.</p> <ol> <li><code>Estimated \"red\" data transmission rate (bytes/sec)</code> is simply the     scheduled transmission rate multiplied by the estimated \"red\" data     percentage.</li> <li><code>Maximum export data in transit (bytes)</code> is the product of the     estimated red data transmission rate and the round-trip light time     (which is twice the one-way light time between the engines). This is     the maximum amount of red data that cannot yet have been positively     acknowledged by the remote engine and therefore must be retained in     storage for possible retransmission.</li> </ol>"},{"location":"Using-LTP-Config-Tool/#configuration-decision-parameters","title":"Configuration decision parameters","text":"<p>Values for the following parameters must be chosen by the network administrator on the basis of (a) known project requirements or preferences. (b) the first-order computed parameters, and (c) the computed values of figures of merit that result from tentative parameter value selections, as noted.</p> <ul> <li><code>#6 Aggregation size limit</code> (revisited). Reducing this parameter   tends to increase the number of blocks transmitted, increasing total   protocol overhead. The suggested value for this parameter is   computed as follows:</li> <li>The maximum number of bytes of LTP report content that the remote   engine may transmit per second is given by the product of the remote   engine's transmission data rate and the maximum percentage of the   remote engine's channel capacity that may be allocated to LTP   reports.</li> <li>The maximum number of reports per second transmitted by the remote   engine is the maximum number of LTP report content bytes transmitted   per second divided by the mean report segment size.</li> <li>Assuming that normally all blocks are received without error, the   maximum number of blocks to be transmitted per second by the local   engine should be equal to the maximum number of reports that may be   transmitted per second by the remote engine.</li> <li> <p>The threshold block size, expressed in bytes per block, is then   given by dividing the local engine's transmission data rate (in   bytes per second) by the maximum number of blocks to be transmitted   per second.</p> </li> <li> <p><code>Est. mean export block size</code> is computed as follows:</p> <p>a.  If the mean service data unit size is so large that aggregation of multiple service data units into a block is never necessary, then that mean service data unit size will in effect determine the mean export block size (one service data unit per block).</p> <p>b.  Otherwise, the mean export block size will be determined by aggregation. If the red data transmission rate is so high that the aggregation time limit will normally never be reached, then the aggregation size limit constitutes the mean export block size. Otherwise, block size will be constrained by aggregation time limit expiration: the estimated mean export block size will be approximated by multiplying the red data transmission rate by the number of seconds in the aggregation time limit.</p> <p>c.  So estimated mean export block size is computed as larger of mean service data unit size and \"expected aggregate block size\", where expected aggregate block size is the lesser of block aggregation size limit and the product of red data transmission rate and aggregation time limit. 16. <code>Estimated blocks transmitted per second</code> are computed as <code>Estimated red data xmit rate (bytes/sec)</code> (parameter 13) divided by <code>Est. mean export block size</code> (parameter 15). 17. <code>Est. Report bytes/sec sent</code> by the remote engine in response to these transmitted blocks is computed as the product of <code>Est. blocks transmitted per second</code> (parameter 16) and <code>Size (mean) of LTP acknowledgment (bytes)</code> (a global parameter). When mean service data unit size is less than the aggregation size limit and the red data transmission rate is high enough to prevent the aggregation time limit from ever being reached, this value will be about the same as the maximum number of bytes of LTP report content that the remote engine may transmit per second as computed above.</p> <p>Note: increasing the aggregation size limit reduces the block transmission rate at the local engine, reducing the rate of transmission of acknowledgment data at the remote engine; this can be a significant consideration on highly asymmetrical links. 18. <code>Est. segments per block</code> is computed as <code>Est. mean export block size</code> (parameter 15) divided by <code>LTP segment size (bytes)</code> (parameter 11). 19. <code>Est. LTP delivery efficiency</code> on the span is calculated by dividing <code>Est. blocks delivered per second</code> by <code>Est blocks transmitted per second</code>. Reducing the aggregation size limit indirectly improves delivery efficiency by reducing block size, thus reducing the percentage of transmitted blocks that will be affected by the loss of a given number of frames.</p> <ul> <li><code>#12 Maximum number of export sessions (revisited)</code>. Increasing the maximum number of export sessions will tend to improve link bandwidth utilization but will increase the amount of storage space needed for span state retention. The suggested value for this parameter is computed as the <code>maximum export data in transit (bytes)</code> (Parameter 14) divided by <code>Est. mean export block size</code> (parameter 15) as determined above. Configuring the span for a maximum export session count that is less than this limit will make it impossible to fully utilize the link even if all blocks are of estimated mean size.</li> <li><code>Nominal export SDU's in transit</code> is computed by dividing <code>Nominal export data in transit (bytes)</code> by the <code>Size (mean) of service data units (bytes)</code> (parameter 4).</li> <li><code>Expected link utilization</code> is then computed by dividing <code>Nominal export data in transit (bytes)</code> by <code>Maximum export data in transit (bytes)</code> (parameter 14). Note that a low value of expected link utilization indicates that a high percentage of the span's transmission capacity is not being used. Utilization can be improved by increasing estimated mean export block size (e.g., by increasing aggregation size limit) or by increasing the maximum number of export sessions.</li> <li><code>Max data aggregation latency (sec)</code> is simply the value supplied for <code>Aggregation time limit (sec)</code> (parameter 10) as this time limit is never exceeded.</li> </ul> </li> </ul>"},{"location":"Using-LTP-Config-Tool/#ltp-initialization-parameters","title":"LTP Initialization Parameters","text":"<p>Finally, the remaining LTP initialization parameter can be computed when all span configuration decisions have been made.</p> <ol> <li><code>Maximum number of import sessions</code> is automatically taken from     the remote engine's maximum number of export sessions.</li> </ol> <p>This research was carried out at the Jet Propulsion Laboratory, California Institute of Technology, under a contract with the National Aeronautics and Space Administration.</p>"},{"location":"Using-LTP-Config-Tool/#updated-features-may-2021","title":"Updated Features - May 2021","text":"<p>This section describes the following features added to the configuration tool as of May 2021:</p> <ol> <li>A \"link\" worksheet has been added to set space link parameters such    as frame size and error rate and to compute parameters such as    maxBer and laboratory Ethernet-based frame loss simulation.</li> <li>Conditional formatting has been added to a few entries in the main    worksheet to provide visual cues for out-of-range parameters and    warning messages to guide parameter selection.</li> <li>A simple model to estimate the minimum required heapWord size for a    one-hop LTP link.</li> </ol>"},{"location":"Using-LTP-Config-Tool/#link-worksheet","title":"Link Worksheet","text":"<p>The recommended workflow for using the LTP configuration tool is to first establish the space link configuration using the link worksheet before attempting to generate a LTP configuration under the main worksheet. The link worksheet has the following input and computed cells:</p> <ul> <li><code>Select CCSDS Frame Size (bits) \\[user input\\]--</code> this cell allows   the user to select a standard CCSDS AOS/TM frame size from a drop   down list that includes LDPC, Turbo, and Reed-Solomon codes.</li> <li><code>CCSDS Frame Size (bytes) \\[computed\\]</code>-- converts frame size from   bits to bytes.</li> <li><code>Desired Frame Error Rate \\[user input\\]</code> -- this parameter sets   the expected frame error rate of the LTP link in operation. This   parameter could be derived from link budget analysis or a mission   requirement document.</li> <li><code>Segment size (byte) \\[user input\\]</code> -- this parameter sets the   maximum segment payload size used by LTP. The size of the segment,   in relation to the underlying CCSDS frame, will determine the   segment error rate and the probability that LTP will need to request   retransmission.</li> <li><code>Ethernet Frame Size (byte) \\[user input\\]</code> -- this is the   Ethernet frame size used in a laboratory environment to simulate   space link frame losses.</li> <li><code>Segment Error Rate Computation \\[computed\\]</code> -- this is the LTP   segment error rate derived from the frame error rate and the segment   and CCSDS frame size selections.</li> <li><code>*maxBER* Computation \\[computed\\]</code> -- this is the computed   maxBER parameter for LTP. The maxBER parameter is what LTP uses   to estimate segment error rate, which in turn will affect how LTP   handles handshaking failure and repeated retransmission requests. To   properly operate LTP, the maxBER value provided must result in the   same segment error rate as one expects to encounter in real space   link.</li> <li><code>Ethernet Error Rate Computation \\[computed\\]</code> -- this is the   recommended setting for using laboratory Ethernet frame error   software/hardware to simulate space link loss. This value is   translated from the segment error rate to Ethernet frame error to   make sure that laboratory testing provides a statistically   equivalent impact on LTP.</li> </ul>"},{"location":"Using-LTP-Config-Tool/#enhancements","title":"Enhancements","text":"<p>In the main worksheet described in Section 3, we made the following enhancements:</p> <ul> <li>Item 6: <code>Aggregation size limit (bytes)</code> -- a green icon is   displayed when the input parameter is greater or equal to the   suggested value; a red icon is displayed when this parameter is   below the suggested value. The suggested value aggregation size   limit upper bounds the LTP block rate such that the acknowledgement   traffic (report segments) from the receiver to the sender can be   supported.</li> <li>Item 10: <code>Aggregation time limit (sec)</code> -- there are two factors   affecting LTP block aggregation: time limit and size limit. The   aggregation process stops as soon as one of the two limits is   reached. A green icon is displayed if the time limit value in this   cell is sufficiently large such that the aggregation process will be   size limited, i.e., on average the LTP block aggregation process   will reach the size limit before the time limit. This is the nominal   and desired configuration unless there is a strict latency   requirement that forces one to use a very low aggregation time   limit. A red icon is displayed if the time limit will be driving,   which means the LTP block size will generally be smaller than the   aggregation size limit and the block rate will be higher than   desired. If a latency requirement forces the use of a low   aggregation time limit, one must check to make sure there is still   sufficient bandwidth to support the acknowledgement (report segment)   traffic.</li> <li>Item 17: <code>Est. report bytes/sec sent</code> - this field estimates the   bandwidth required to support LTP report segment traffic up to 95   percentile of all cases involving retransmission of missing   segments. The segment error rate was derived from the link   worksheet. The green icon indicates that estimated report bandwidth   is feasible based on current configuration.</li> </ul>"},{"location":"Using-LTP-Config-Tool/#heapword-size-estimate","title":"HeapWord Size Estimate","text":"<p>A simple HeapWord size estimate calculation is added to the main worksheet, based on the following assumptions:</p> <ol> <li>The only traffic flows in the system are those between node X and Y    using LTP.</li> <li>Heap is sized to support at least 1 contact session</li> <li>Each contact starts with a clean slate. At the beginning of a    contact, the heap space is not occupied by bundles/blocks/segments    left over from previous contact or other unfinished processes.</li> <li>Source user data is file-resident. Most ION test utility programs    such as bpsendfile and bpdriver will keep source data (or create    simulated data) in a file for as long as possible until just prior    to transmission by the underlying convergence layer adaptor when    pieces of user data are copied into each out-going convergence    layer's PDUs. Please check how your software uses the BP API to    determine how source data is handled. If in doubt, you may need to    increase the heap space allocation to hold the user's source data.</li> <li>Aggregated LTP blocks are size-limited (not time-limited).</li> </ol>"},{"location":"Using-LTP-Config-Tool/#user-input","title":"User Input:","text":"<ul> <li>Item 24: <code>Longest Expected Period to Buffer Data Period (sec)</code> --   this is the expected longest period of time one expects ION will   buffer user data. The data accumulation rate is the same as the LTP   red data data rate.</li> <li>Item 25: <code>(32/64) bit system</code> -- this is platform dependent   parameter. Heap space is specified in the number of words. For a   32-bit system, each word has 32 bits; for a 64-bit system, each word   has 64 bits.</li> <li>Item 26: <code>Additional Margin</code> -- adds more margin to the model per   user's discretion</li> </ul>"},{"location":"Using-LTP-Config-Tool/#model-output","title":"Model Output:","text":"<ul> <li>Item 27: <code>Recommended heapWords value (with 40% for ZCO)</code> -- this   is the suggested <code>heapWords</code> value for <code>ionconfig</code>.</li> <li>Item28: <code>Recommended heapWords value - iif source data completely in memory</code> -- this is the suggested <code>heapWords</code> value for   ionconfig assuming the source data is copied into heap space at   the time of bundle creation without using file-resident reference.</li> <li>Item 29: <code>wmSize recommendation</code> - this is the suggested <code>wmSize</code>   parameter to use to support the staging of large quantities of   bundles in the heap. This recommended value includes an additional   200% margin. The rationale for the calculation is derived from   analysis summarized in the <code>ION Deployment Guide</code> and based on   previous studies.</li> </ul>"},{"location":"Using-LTP-Config-Tool/#appendix","title":"Appendix","text":""},{"location":"Using-LTP-Config-Tool/#bpltp-memory-usage-analysis-summary","title":"BP/LTP Memory Usage Analysis Summary","text":"<p>In this section, we summarize the finding documented in a powerpoint presentation titled, \"ION DTN/LTP Configuration and ION Memory Usage Analysis\", dated January 2021, that is used as the basis for estimating the heap space required for BP/LTP operation in ION:</p> <ul> <li>When using file-resident data to conduct tests (e.g., bpdriver,   bpsendfile, etc) the heap space holds mostly the header information   in the data structure.</li> <li> <p>With 1 bundle in the system that is under active LTP session, the   minimum heap space needed can be approximated as: heap space =   S + base</p> </li> <li> <p>S is the bundle size / segment size x segment header size x 10</p> </li> <li>The segment header is approximated to be 19 bytes</li> <li>Base is the default usage at initial boot, before any bundles     were generated. In our experiment, it is approximately 48     Kilobyte.</li> <li>Let M equal the number of bundles that fits within TWLT-bandwidth   product, and</li> <li>Assume that the max_export_session &gt; M so efficiency can be   maximized, then</li> <li>For a burst of N bundles to be buffered in ION:</li> <li> <p>If N \\&lt;= M, heap space usage is approximately S x N + 1560 bytes x   N + base</p> </li> <li> <p>S x N is LTP related heap usage, 1560 x N is bundle level heap     usage</p> </li> <li>\"1560 bytes\" is an empirical estimate based on test     observations. It is the additional heap space needed to     accommodate each additional bundle structure and also a small     amount of data as determined by the heapmax parameter in .bprc     file (default value is 650 bytes).</li> <li> <p>If N &gt; M, heap space usage is approximately S x M + 1560 bytes x   N + base</p> </li> <li> <p>For bundle in LTP transmission, we count both LTP and bundle     level heap usage</p> </li> <li>Apply additional margin on the estimated heap space should   accommodate:</li> <li>The available heap space for storing inbound and outbound bundle   data is only 40% of the total heap space (determined by heapWords in   .ionconfig file)</li> </ul>"},{"location":"Using-LTP-Config-Tool/#acknowledgements","title":"Acknowledgements","text":"<p>Nik Ansell co-authored/contributed to the 2016 version of this document, which has been updated and revised in 2021.</p> <p>\u00a9 2016 California Institute of Technology. Government sponsorship acknowledged.</p>"},{"location":"community/Contributing-Code-to-ION/","title":"Contributing Code to ION","text":""},{"location":"community/Contributing-Code-to-ION/#expectations","title":"Expectations","text":"<p>If you plan to contribute to the ION project, please keep these in mind:</p> <ul> <li>Submitted code should adhere to the ION coding style found in the current code.</li> <li>Provide documentation describing the contributed code\u2019s features, its inputs and outputs, dependencies, behavior (provide a high-level state machine or flowchart if possible), and API description. Please provide a draft of a man page.</li> <li>Provide a canned test (ION configuration and script) that can be executed on a single host to verify the proper functioning of the feature. Ideally it should include both nominal and off-nominal operations.</li> <li> <p>The NASA team will review these contributions and determine to either</p> </li> <li> <p>Incorporate the code into the baseline, or</p> </li> <li>Make the code available in the <code>/contrib</code> folder for continued experimental use,</li> <li>Not incorporate it at all</li> <li>All baselined features will be supported with at least bug-fixes until removed</li> <li>All /contrib folder features are provided \u201das is,\u201d and no commitment is made regarding bug-fixes.</li> <li>The contributor is expected to help with regression testing</li> <li>Due to resource constraints, we cannot make any commitment as to response time. We will do our best to review them on a best effort basis.</li> </ul>"},{"location":"community/Contributing-Code-to-ION/#if-you-want-to-contribute","title":"If you want to contribute...","text":"<ol> <li>Fork this repository</li> <li>Starting with the \"current\" branch, create a named feature or bugfix branch and develop/test your code in this branch</li> <li>Generate a pull request</li> </ol>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/","title":"Running DTN on Cloud VM using a Two-Node Ring","text":"<p>This project has been developed by Dr Lara Suzuki, a Visiting Researcher at NASA JPL.</p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#introduction","title":"Introduction","text":"<p>In this project we demonstrate how to run DTN on two nodes on Cloud VM using NASA's implementation of the bundle protocol - ION.</p> <p> Two-Node Topology</p> <p>The ION (interplanetary overlay network) software is a suite of communication protocol implementations designed to support mission operation communications across an end-to-end interplanetary network, which might include on-board (flight) subnets, in-situ planetary or lunar networks, proximity links, deep space links, and terrestrial internets.</p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#dtn-on-cloud-linux-vms-101","title":"DTN on Cloud Linux VMs 101","text":"<p>We strongly recommend that you firstly get familiar with the Loopback communication of ION running on a single node on Google Cloud Platform.</p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#getting-started-with-two-linux-cloud-vms","title":"Getting Started with Two Linux Cloud VMs","text":"<p>On your preferred Cloud provider dashboard, create a Linux VM instance (e.g. for instance Debian). In this tutorial we have created one instance named <code>Golstone</code> in <code>Zone: us-central1</code> and the another instance named <code>Madrid</code> in <code>Zone: europe-west2-c</code>. The diagram below illustrates the two node communication that we will be developing in this tutorial.</p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#the-configuration-files","title":"The configuration files","text":"<p>In this section we will walk you through the creation of the <code>host1.rc</code> file. Follow the same steps to create the same file for <code>host2.rc</code>.</p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#the-ionadmin-configuration","title":"The <code>ionadmin</code> configuration","text":"<p>The <code>ionadmin</code> configuration assigns an identity (node number) to the node, optionally configures the resources that will be made available to the node, and specifies contact bandwidths and one-way transmission times. <pre><code>## begin ionadmin \n# Initialization command (command 1). \n# Set this node to be node 1 (as in ipn:1).\n# Use default sdr configuration (empty configuration file name '').\n1 1 ''\n\n# Start ion node\ns\n\n# Add a contact.\n# It will start at +1 seconds from now, ending +3600 seconds from now.\n# It will connect node 1 to itself.\n# It will transmit 100000 bytes/second.\na contact +1 +3600 1 1 100000\n\n# Add more contacts.\n# The network goes 1--2\n# Note that contacts are unidirectional, so order matters.\na contact +1 +3600 1 2 100000\na contact +1 +3600 2 1 100000\na contact +1 +3600 2 2 100000\n\n# Add a range. This is the physical distance between nodes.\n# It will start at +1 seconds from now, ending +3600 seconds from now.\n# It will connect node 1 to itself.\n# Data on the link is expected to take 1 second to reach the other\n# end (One Way Light Time).\na range +1 +3600 1 1 1\n\n# Add more ranges.\n# We will assume every range is one second.\n# Note that ranges cover both directions, so you \n#only need define one range for any combination of nodes.\na range +1 +3600 1 2 1\na range +1 +3600 2 2 1\n\n# Set this node to consume and produce a mean of 1000000 bytes/second.\nm production 1000000\nm consumption 1000000\n## end ionadmin \n</code></pre></p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#the-ltpadmin-configuration","title":"The <code>ltpadmin</code> configuration","text":"<p>The <code>ltpadmin</code> configuration specifies spans, transmission speeds, and resources for the Licklider Transfer Protocol convergence layer</p> <pre><code># Initialization command (command 1).\n1 32\n\n# Add a span. (a connection)\na span 1 10 10 1400 10000 1 'udplso `external_IP_of_node_1`:1113'\n\n# Add another span. (to host2) \n# Identify the span as engine number 2.\n# Use the command 'udplso 10.1.1.2:1113' to implement the link itself.  \na span 2 10 10 1400 10000 1 'udplso `external_IP_of_node_2`:1113'\n\n# Start command.\n# This command actually runs the link service output commands.\n# It also starts the link service INPUT task 'udplsi `internal_IP_of_node_1`:1113' \n# to listen locally on UDP port 1113 for incoming LTP traffic.\ns 'udplsi `internal_IP_of_node_1`:1113'\n## end ltpadmin \n</code></pre>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#the-bpadmin-configuration","title":"The <code>bpadmin</code> configuration","text":"<p>The <code>bpadmin</code> configuration specifies all of the open endpoints for delivery on your local end and specifies which convergence layer protocol(s) you intend to use. </p> <pre><code>## begin bpadmin \n# Initialization command (command 1).\n1\n\n# Add an EID scheme.\n# The scheme's name is ipn.\n# This scheme's forwarding engine is handled by the program 'ipnfw.'\n# This scheme's administration program (acting as the custodian\n# daemon) is 'ipnadminep.'\na scheme ipn 'ipnfw' 'ipnadminep'\n\n# Add endpoints.\n# Establish endpoints ipn:1.0, ipn:1.1, and ipn:1.2 on the local node.\n# ipn:1.0 is expected for custodian traffic.  The rest are usually\n# used for specific applications (such as bpsink).\n# The behavior for receiving a bundle when there is no application\n# currently accepting bundles, is to queue them 'q', as opposed to\n# immediately and silently discarding them (use 'x' instead of 'q' to\n# discard).\na endpoint ipn:1.0 q\na endpoint ipn:1.1 q\na endpoint ipn:1.2 q\n\n# Add a protocol. \n# Add the protocol named ltp.\n# Estimate transmission capacity assuming 1400 bytes of each frame (in\n# this case, udp on ethernet) for payload, and 100 bytes for overhead.\na protocol ltp 1400 100\n\n# Add an induct. (listen)\n# Add an induct to accept bundles using the ltp protocol.\n# The duct's name is 1 (this is for future changing/deletion of the\n# induct). \n# The induct itself is implemented by the 'ltpcli' command.\na induct ltp 1 ltpcli\n\n# Add an outduct (send to yourself).\n# Add an outduct to send bundles using the ltp protocol.\na outduct ltp 1 ltpclo\n\n# Add an outduct. (send to host2)\n# Add an outduct to send bundles using the ltp protocol.\na outduct ltp 2 ltpclo\n\n# Start bundle protocol engine, also running all of the induct, outduct,\n# and administration programs defined above\ns\n## end bpadmin \n</code></pre>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#the-ipnadmin-configuration","title":"The <code>ipnadmin</code> configuration","text":"<p>The <code>ipnadmin</code> configuration maps endpoints at \"neighboring\" (topologically adjacent, directly reachable) nodes to convergence-layer addresses. <pre><code>## begin ipnadmin \n# ipnrc configuration file for host1 in a 3node ltp/tcp test. \n# Essentially, this is the IPN scheme's routing table.\n\n# Add an egress plan.\n# Bundles to be transmitted to node number 1 (that is, yourself).\n# The plan is to queue for transmission on protocol 'ltp' using\n# the outduct identified as '1.'\na plan 1 ltp/1\n\n# Add other egress plans.\n# Bundles for elemetn 2 can be transmitted directly to host2 using\n# ltp outduct identified as '2.' \na plan 2 ltp/2\n## end ipnadmin\n</code></pre></p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#the-ionsecadmin-configuration","title":"The <code>ionsecadmin</code> configuration","text":"<p>The <code>ionsecadmin</code> enables bundle security (also avoid error messages in ion.log). <pre><code>## begin ionsecadmin\n# Enable bundle security and avoid error messages in ion.log\n1\n## end ionsecadmin\n</code></pre></p>"},{"location":"community/dtn-gcp-2nodes/ION-Two-Node-on-Cloud-Linux-VMs/#executing-the-configuration-files","title":"Executing the configuration files","text":"<p>On the terminal of <code>host 1</code> execute the command <pre><code>$ ionstart -I host1.rc\n</code></pre> Simmilarly, on the terminal of <code>host 2</code> execute the command <pre><code>$ ionstart -I host2.rc\n</code></pre> To send a message from <code>host 1</code> to <code>host 2</code>, you must firstly start <code>bpsink</code> in <code>host 2</code> by executing the command below <pre><code>$ bpsink ipn:2.1 &amp;\n</code></pre> On the terminal of <code>host 1</code>, enter the following command and hit enter <pre><code>$ echo \"hi\" | bpsource ipn:2.1\n</code></pre> After the execution of the command above you should see in the terminal of <code>host 2</code> the following message <pre><code>$ ION event: Payload delivered.\n$   payload length is 2.\n$   'hi'\n</code></pre> The image below illustrates the above scenario plus <code>host 2</code> sending a <code>hello</code> message to <code>host 1</code>.</p> <p></p>"},{"location":"community/dtn-gcp-2nodes/rc_files/host1-start-script-2node/","title":"ION Start Script Example","text":"<p>Note: place this in a file named host1.rc</p> <pre><code>## begin ionadmin \n1 1 ''\ns \n\na contact +1 +3600 1 1 100000\na contact +1 +3600 1 2 100000\na contact +1 +3600 2 1 100000\na contact +1 +3600 2 2 100000\n\na range +1 +3600 1 1 1\na range +1 +3600 1 2 1\na range +1 +3600 2 2 1\n\nm production 1000000\nm consumption 1000000\n## end ionadmin \n\n## begin ltpadmin \n1 32\n\na span 1 10 10 1400 10000 1 'udplso `external_IP_of_node_1`:1113'\na span 2 10 10 1400 10000 1 'udplso `external_IP_of_node_2`:1113'\ns 'udplsi `internal_IP_of_node_1`:1113'\n## end ltpadmin \n\n## begin bpadmin \n1\na scheme ipn 'ipnfw' 'ipnadminep'\n\na endpoint ipn:1.0 q\na endpoint ipn:1.1 q\na endpoint ipn:1.2 q\n\na protocol ltp 1400 100\na induct ltp 1 ltpcli\na outduct ltp 1 ltpclo\na outduct ltp 2 ltpclo\n\ns\n## end bpadmin \n\n## begin ipnadmin \na plan 1 ltp/1\na plan 2 ltp/2\n## end ipnadmin\n\n## begin ionsecadmin\n1\n## end ionsecadmin\n</code></pre>"},{"location":"community/dtn-gcp-2nodes/rc_files/host2-start-script-2node/","title":"ION Start Script Example","text":"<p>Note: place this in a file named host2.rc</p> <pre><code>## begin ionadmin \n1 2 ''\ns\n\na contact +1 +3600 1 1 100000\na contact +1 +3600 1 2 100000\na contact +1 +3600 2 1 100000\na contact +1 +3600 2 2 100000 \n\na range +1 +3600 1 1 1\na range +1 +3600 1 2 1\na range +1 +3600 2 2 1\n\nm production 1000000\nm consumption 1000000\n## end ionadmin \n\n## begin ltpadmin \n1 32\n\na span 1 10 10 1400 10000 1 'udplso `external_IP_of_node_1`:1113'\na span 2 10 10 1400 10000 1 'udplso `external_IP_of_node_2`:1113'\ns 'udplsi `internal_IP_of_node_2`:1113'\n## end ltpadmin \n\n## begin bpadmin \n1\na scheme ipn 'ipnfw' 'ipnadminep'\n\na endpoint ipn:2.0 q\na endpoint ipn:2.1 q\na endpoint ipn:2.2 q\n\na protocol ltp 1400 100\na induct ltp 2 ltpcli\na outduct ltp 2 ltpclo\na outduct ltp 1 ltpclo\n\ns\n## end bpadmin \n\n## begin ipnadmin \na plan 1 ltp/1\na plan 2 ltp/2\n## end ipnadmin\n\n## begin ionsecadmin\n1\n## end ionsecadmin\n</code></pre>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/","title":"Telemetry Data on Cloud Vms using Pub/Sub and DTN","text":"<p>This project has been developed by Dr Lara Suzuki, a visiting Researcher at NASA JPL.</p> <p>In this tutorial we will demonstrate how to connect a Raspberry Pi and Sensor Hat onto Google Cloud using cloud Pub/Sub on <code>host 1</code> and serving the messages over DTN to <code>host 2</code>. This tutorial follows the [Running DTN on Google Cloud using a Two-Node Ring] tutorial and uses the configurations of <code>host 1</code> and <code>host 2</code> as described in the tutorial.</p>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#setting-up-raspbberry-pi-and-the-sense-hat","title":"Setting up Raspbberry Pi and the Sense Hat","text":"<p>In this tutorial we use Raspberry Pi 4 model B (2018) and Sense Hat Version 1.0. </p> <p>The first step is to be sure your Pi can connect to the Internet. You can either plug in an ethernet cable, or if you\u2019re using WiFi, scan for networks your Pi can see. Plug your Pi in a monitor, and when it starts, at the top right corner you can find the wifi logo. Select the network you want to connect to. Once that is connected open your browser to check whether you can access the Internet.</p>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#library-dependency-setup","title":"Library dependency setup","text":"<p>The first thing to do is to make sure that the places where Raspberry Pi will be getting its libraries from is current. For this, on your Pi's terminal, run the following command: <pre><code>$ sudo apt-get update\n</code></pre> The next step is to securely connect to a Pub Sub service running locally or on a cloud provider service. For this we will use JWT to handle authentication (library <code>pyjwt</code>). The meta-model for communication  used on the cloud Pub/Sub is based on publish/subscribe messaging technology provided by the MQTT (MQ Telemetry Transport) protocol (library paho-mqtt). MQTT is a topic-based publish/subscribe communications protocol that is designed to be open, simple, lightweight, easy-to-implement, and  efficient in terms of processor, memory, and network resources.   </p> <p>On your Pi's terminal run the following commands <pre><code>$ sudo apt-get install build-essential\n$ sudo apt-get install libssl-dev\n$ sudo apt-get install python-dev\n$ sudo apt-get install libffi-dev\n$ sudo pip install paho-mqtt\n</code></pre> For encryption, run the install the <code>pyjwt</code> library and its dependency, the <code>cryptography</code> library . <pre><code>$ sudo pip install pyjwt\n$ sudo pip install cryptography\n</code></pre> For telemetry data we are using Sense Hat. Sense Hat is composed by telemetry sensors such as temperature, accelerometer, humidity and pressure. To install the library for Sense Hat, run the command: <pre><code>$ sudo apt get install sense-hat\n</code></pre></p>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#ssl-certificate-rsa-with-x509-wrapper","title":"SSL Certificate - RSA with X509 wrapper","text":"<p>In order to authenticate in Google Cloud IoT Core, we need a SSL certificate. We will create an RSA with X509 wrapper. For this, execute the following command on your Pi's terminal:</p> <pre><code>$ openssl req -x509 -newkey rsa:2048 -keyout sensing_private.pem -nodes -out demo.pub -subj \u201c/CN=unused\u201d\n</code></pre>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#setting-up-a-pubsub-servide-on-cloud","title":"Setting up a Pub/Sub servide on Cloud","text":"<p>Once your Raspberry Pi is fully set up, follow the instructions of your Cloud provider to create a Registry of your new Pub/Sub service. For your Pub/Sub 'topic', create a topic named: <code>sensing</code></p> <p>To connect your device on your cloud provider, you will likely to need to use an authentication method. In our case we use authentication using a Public Key in the format <code>RS256_X509</code>. </p> <p>To copy the content of your Pi's public key, on the Pi's terminal run: <pre><code>$ cat demo.pub\n</code></pre></p> <p>Copy everything, including the tages, between  <pre><code>-----BEGIN PUBLIC KEY-----\n-----END PUBLIC KEY-----\n</code></pre> and paste it in the <code>Public Key Value</code> textbox.</p>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#create-a-subscription-to-listen-to-the-pubsub-topic","title":"Create a Subscription to listen to the Pub/Sub Topic","text":"<p>On your cloud provide  Console, create a 'Subscription' to listen to the topic <code>sensing</code> we created in the previous steps. Now you should have all the pieces needed to send telemetry data from your Pi to a Pub/Sub service on a VM instance running on the cloud!</p>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#send-telemetry-data-from-raspberry-pi-to-linux-vm-on-the-cloud","title":"Send telemetry data from Raspberry Pi to Linux VM on the Cloud","text":"<p>The code on this repository named <code>sense.py</code> is based on the implementation of GabeWeiss. </p> <p>In the code, edit the following fields:</p> <p><pre><code>ssl_private_key_filepath = '/home/pi/sensing_private.pem'\nssl_algorithm = 'RS256'\nroot_cert_filepath = '/home/pi/roots.pem'\nproject_id = 'if you have to use a project ID identifier in your cloud service'\nregistry_id = 'name of your registry'\ndevice_id = 'name of your device'\n</code></pre> Once you have configured the above parameters in the file sense.py, on your Raspberry Pi run the command: <pre><code>$ python3 sense.py\n</code></pre></p>"},{"location":"community/dtn-gcp-iot-main/ION-and-IOT-on-Linux-VMs-running-on-Cloud-Computing/#send-telemetry-data-to-from-host-1-to-host-2-via-dtn","title":"Send telemetry data to from host 1 to host 2 via DTN","text":"<p>Log into the VM <code>host 1</code>. In the VM go to the base directory of ION and create a folder named <code>dtn</code> <pre><code>$ mkdir dtn\n</code></pre> CD into dtn directory, and clone the file named <code>iot.py</code>. In this file configure the following parameters: <pre><code>subscription_path = subscriber.subscription_path(\n  'ID_OF_YOUR_CLOUD_PROJECT', 'ID_OF_YOUR_SUBSCRIPTION')\n</code></pre> And add <code>host 2</code> as the receiver of the telemetry data: <pre><code>os.system(f'echo \"{value}\" | bpsource ipn:2.1')\n</code></pre> On the terminal of <code>host 1</code> and <code>host 2</code>, start ion: <pre><code>$ ionstart -I hostX.rc #where X is the number of the host\n</code></pre> On the terminal of <code>host 2</code>, start <code>bpsink</code> <pre><code>$ bpsink ipn:2.1 &amp;\n</code></pre> On the terminal of <code>host 1</code>, start <code>iot.py</code> <pre><code>$ python3 iot.py\n</code></pre> On the terminal of <code>host 1</code> you should see the print out of the telemetry data received as below:</p> <p></p> <p>On the terminal of <code>host 2</code> you should see the payloads delivered. Please note that messages beyond 80 characters are not shown on <code>bpsink</code>:</p> <p></p>"},{"location":"community/dtn-gcp-iot-main/iot-python-script/","title":"ION Start Script Example","text":"<p>Note: place this in a file named iot.py</p> <p>```` import os import time from google.cloud import pubsub_v1 subscriber = pubsub_v1.SubscriberClient()</p>"},{"location":"community/dtn-gcp-iot-main/iot-python-script/#the-subscription_path-method-creates-a-fully-qualified-identifier","title":"The <code>subscription_path</code> method creates a fully qualified identifier","text":""},{"location":"community/dtn-gcp-iot-main/iot-python-script/#in-the-form-projectsproject_idsubscriptionssubscription_name","title":"in the form <code>projects/{project_id}/subscriptions/{subscription_name}</code>","text":"<p>subscription_path = subscriber.subscription_path(   'ID_OF_YOUR_GOOGLE_CLOUD_PROJECT', 'ID_OF_YOUR_SUBSCRIPTION') def callback(message):   value = message.data   os.system(f'echo \"{value}\" | bpsource ipn:2.1')   print('Received message: {}'.format(value))   message.ack() # Acknowledges the receipt of the message and remove it from the topic queue subscriber.subscribe(subscription_path, callback=callback)</p>"},{"location":"community/dtn-gcp-iot-main/iot-python-script/#the-subscriber-is-non-blocking-we-must-keep-the-main-thread-from","title":"The subscriber is non-blocking. We must keep the main thread from","text":""},{"location":"community/dtn-gcp-iot-main/iot-python-script/#exiting-to-allow-it-to-process-messages-asynchronously-in-the-background","title":"exiting to allow it to process messages asynchronously in the background.","text":"<p>print('Listening for messages on {}'.format(subscription_path)) while True:   time.sleep(60)</p> <p>````</p>"},{"location":"community/dtn-gcp-iot-main/sense-python-script/","title":"ION Start Script Example","text":"<p>Note: place this in a file named sense.py</p> <p>```` from sense_hat import SenseHat import Adafruit_DHT import time import datetime import time import jwt import paho.mqtt.client as mqtt</p>"},{"location":"community/dtn-gcp-iot-main/sense-python-script/#define-some-project-based-variables-to-be-used-below-this-should-be-the-only","title":"Define some project-based variables to be used below. This should be the only","text":""},{"location":"community/dtn-gcp-iot-main/sense-python-script/#block-of-variables-that-you-need-to-edit-in-order-to-run-this-script","title":"block of variables that you need to edit in order to run this script","text":"<p>ssl_private_key_filepath = '' # The .pem file of your Pi ssl_algorithm = 'RS256'  root_cert_filepath = '' # The .pem file of Google project_id = '' # The project ID on Google Cloud gcp_location = '' # The zone where your project is deployed registry_id = '' # The ID of your registry on Google IoT Core device_id = '' # The ID of your Pi as set up on Google IoT Core</p> <p>cur_time = datetime.datetime.utcnow()</p> <p>DHT_SENSOR = Adafruit_DHT.DHT11 DHT_PIN = 4</p> <p>def create_jwt():   token = {       'iat': cur_time,       'exp': cur_time + datetime.timedelta(minutes=60),       'aud': project_id   }</p> <p>with open(ssl_private_key_filepath, 'r') as f:     private_key = f.read()</p> <p>return jwt.encode(token, private_key, ssl_algorithm)</p> <p>_CLIENT_ID = 'projects/{}/locations/{}/registries/{}/devices/{}'.format(project_id, gcp_location, registry_id, device_id) _MQTT_TOPIC = '/devices/{}/events'.format(device_id)</p> <p>client = mqtt.Client(client_id=_CLIENT_ID) client.username_pw_set(     username='unused',     password=create_jwt())def error_str(rc):     return '{}: {}'.format(rc, mqtt.error_string(rc))</p> <p>def on_connect(unusued_client, unused_userdata, unused_flags, rc):     print('on_connect', error_str(rc))</p> <p>def on_publish(unused_client, unused_userdata, unused_mid):     print('on_publish')</p> <p>client.on_connect = on_connect client.on_publish = on_publish</p> <p>client.tls_set(ca_certs=root_cert_filepath) client.connect('mqtt.googleapis.com', 8883) client.loop_start()</p>"},{"location":"community/dtn-gcp-iot-main/sense-python-script/#could-set-this-granularity-to-whatever-we-want-based-on-device-monitoring-needs-etc","title":"Could set this granularity to whatever we want based on device, monitoring needs, etc","text":"<p>temperature = 0 humidity = 0 pressure = 0</p> <p>sense = SenseHat()</p> <p>while True:   cur_temp = sense.get_temperature()   cur_pressure = sense.get_pressure()   cur_humidity = sense.get_humidity()   if cur_temp == temperature and cur_humidity == humidity and cur_pressure == pressure:     time.sleep(1)     continue   temperature = cur_temp   pressure = cur_pressure   humidity = cur_humidity</p> <p>payload = '{{ \"ts\": {}, \"temperature\": {}, \"pressure\": {}, \"humidity\": {} }}'.format(cur_time, \"%.1f C\" % temperature,\"%.2f Millibars\" %  press$</p> <p>client.publish(_MQTT_TOPIC, payload, qos=1)</p> <p>print(\"{}\\n\".format(payload))</p> <p>sense.set_rotation(180) # Set LED matrix to scroll from right to left</p> <p>sense.show_message(\"%.1f C\" % temperature, scroll_speed=0.10, text_colour=[0, 255, 0]) # Show the temperature on the LED Matrix</p> <p>time.sleep(10)</p> <p>````</p>"},{"location":"community/dtn-gcp-ltp-tcp-main/ION-LTP-TCP-on-Azure/","title":"Three-Node Network communication via DTN on Google Cloud Platform and Windows Azure","text":"<p>This project has been developed by Dr Lara Suzuki, a Visiting Researcher at NASA JPL.</p>"},{"location":"community/dtn-gcp-ltp-tcp-main/ION-LTP-TCP-on-Azure/#introduction","title":"Introduction","text":"<p>This is the third tutorial on a series of DTN on Google Cloud tutorials. In this tutorial we will introduce you to Windows Azure, and how to configure a 3-node network using ION. The figure below shows the network we will be building. Note that this example network uses two different convergence layers: TCP and LTP. This can illustrates the case of a terrestrial connection with two interplanetary internet nodes.</p> <p></p>"},{"location":"community/dtn-gcp-ltp-tcp-main/ION-LTP-TCP-on-Azure/#getting-started-on-windows-azure","title":"Getting Started on Windows Azure","text":"<p>Sign up for a free account on Windows Azure. Once your free account is set up, log into the Azure Portal. Under <code>Azure Services</code>, click <code>Virtual Machines</code>. In the Virtual Machines window, click <code>Add</code> and follow the steps below. 1. Click <code>Add</code> then <code>Virtual Machine</code> 2. Subscription <code>free trial</code> 3. In <code>Resource Group</code> select <code>Create New</code> and name it <code>dtn</code> 4. In <code>Virtual Machine name</code> give it a name. In our example it is named <code>Canberra</code> 5. In Region select the region closest to you or of your choice. In our example it is <code>Australia Central</code> 6. In <code>Image</code> select <code>Debian 10 \"Buster\" Gen 1</code> 7. <code>Size</code> leave it as <code>Standard</code> 8. Under <code>Administrator Account</code> select either the use of SSH public key or Password 9. For <code>Select inbound ports</code> leave SSH(22) 10. Click <code>Review and Create</code>, then click <code>Create</code></p> <p>To get ION working you must enable the inbound traffic to port 1113 and port 4556 - IANA assigned default DTN TCP port. To enable inbound traffic in those ports, at the top right of your window, hit <code>Home</code>, then <code>Virtual Machines</code>. Click on the Virtual Machine you have just created. On the new loaded page, under <code>Settings</code> click <code>Networking</code> as shown in the image below. </p> <p></p> <p>On the networking page, click <code>Add inbound port rule</code>. Select Source as <code>Any</code>, on <code>Source port ranges</code> add the port numbers you want to allow inbound traffic, select the Protocol, the Action (Allow), and add a high <code>Priority</code> (e.g. 380). Give it a name and hit <code>Add</code>. You now can execute ION and the induct and outducts will work.</p>"},{"location":"community/dtn-gcp-ltp-tcp-main/ION-LTP-TCP-on-Azure/#three-node-network","title":"Three-Node Network","text":"<p>In this section, we assume that <code>host 3</code> has an IP address of <code>10.0.0.3</code>. Please modify this for your uses. Please note that in this tutorial we are not covering routing, therefore, <code>host2</code> cannot communicate with <code>host3</code>. The routing tutorial can be found here.</p> <p>This network is created by running the following command on <code>host 1</code> <pre><code>ionstart -I host1.rc\n</code></pre> This command is run on <code>host 2</code>: <pre><code>ionstart -I host2.rc\n</code></pre> Finally, this command is run on <code>host 3</code> <pre><code>ionstart -I host3.rc\n</code></pre></p>"},{"location":"community/dtn-gcp-ltp-tcp-main/ION-LTP-TCP-on-Azure/#the-host3rc-configuration-file-tcp","title":"The host3.rc configuration file - TCP","text":"<p>For the configuration files <code>host 1</code> and <code>host 2</code>, follow the examples given in the tutorial Running DTN on Google Cloud using a Two-Node Ring</p> <p>. Remember to add <code>contact</code>, <code>range</code>, <code>span</code>, <code>outduct</code> and a <code>plan</code> for <code>host 3</code>. Below is the configuration file <code>host3.rc</code>.</p> <p>The <code>ionadmin</code> configuration uses tcp from <code>host 2</code> to <code>host 3</code> <pre><code>## begin ionadmin \n# ionrc configuration file for host3 in a 3node tcp/ltp test.\n# This uses tcp from 1 to 3.\n# \n# Initialization command (command 1). \n# Set this node to be node 3 (as in ipn:3).\n# Use default sdr configuration (empty configuration file name '').\n1 3 ''\n# start ion node\ns\n# Add a contact.\n# It will start at +1 seconds from now, ending +3600 seconds from now.\n# It will connect node 3 to itself\n# It will transmit 100000 bytes/second.\na contact +1 +3600 3 3 100000\n\n# Add more contacts.\n# They will connect 2 to 3, 3 to 2, and 3 to itself\n# Note that contacts are unidirectional, so order matters.\na contact +1 +3600 3 2 100000\na contact +1 +3600 2 3 100000\na contact +1 +3600 2 2 100000\n\n# Add a range. This is the physical distance between nodes.\na range +1 +3600 3 3 1\n\n# Add more ranges.\na range +1 +3600 2 2 1\na range +1 +3600 2 3 1\n\n# set this node to consume and produce a mean of 1000000 bytes/second.\nm production 1000000\nm consumption 1000000\n## end ionadmin \n</code></pre></p> <p>The <code>bpadmin</code> configuration uses adds the endpoints and the protocol <code>tcp</code>. In the protocol section, it estimates transmission capacity assuming 1400 bytes of each frame (in this case, tcp on ethernet) for payload, and 100 bytes for overhead. The induct and outduct will listen on <code>port 4556</code>, the IANA assigned default DTN TCP convergence layer port. The induct itself is implemented by the <code>tcpcli</code> command and the outduct is implemented by the <code>tcpclo</code> <pre><code>## begin bpadmin \n# bprc configuration file for host3 in a 3node test.\n# Initialization command (command 1).\n1\n\n# Add an EID scheme.\na scheme ipn 'ipnfw' 'ipnadminep'\n\n# Add endpoints.\na endpoint ipn:3.0 q\na endpoint ipn:3.1 q\na endpoint ipn:3.2 q\n\n# Add a protocol. \n# Add the protocol named tcp.\na protocol tcp 1400 100\n\n# Add an induct. (listen)\na induct tcp 10.0.0.3:4556 tcpcli\n\n# Add an outduct (send to yourself).\na outduct tcp 10.0.0.3:4556 tcpclo\n\n# Add an outduct. (send to host2)\na outduct tcp external_ip_of_host_2:4556 tcpclo\n\n# Start bundle protocol engine, also running all of the induct, outduct,\n# and administration programs defined above.\ns\n## end bpadmin \n</code></pre></p> <p>The <code>ipnadmin</code> configuration adds the egress plans (to host 3 itself and to host 2) using <code>tcp</code>. <pre><code>## begin ipnadmin \n# ipnrc configuration file for host1 in the 3node tcp network.\n# Add an egress plan (to yourself).\na plan 2 tcp/10.0.0.3:4556\n# Add an egress plan (to the host 2).\na plan 2 tcp/external_IP_of_node_2:4556\n## end ipnadmin\n</code></pre></p> <p>The <code>ionsecadmin</code> configuration enables bundle security <pre><code>## begin ionsecadmin\n1\n## end ionsecadmin\n</code></pre></p>"},{"location":"community/dtn-gcp-ltp-tcp-main/host3-start-script/","title":"ION Start Script Example","text":"<p>Note: place this in a file named host3.rc</p> <pre><code>## begin ionadmin \n# ionrc configuration file for host3 in a 3node tcp/ltp test.\n# This uses tcp from 1 to 3.\n# \n# Initialization command (command 1). \n# Set this node to be node 3 (as in ipn:3).\n# Use default sdr configuration (empty configuration file name '').\n1 3 ''\n# start ion node\ns\n# Add a contact.\n# It will start at +1 seconds from now, ending +3600 seconds from now.\n# It will connect node 3 to itself\n# It will transmit 100000 bytes/second.\na contact +1 +3600 3 3 100000\n\n# Add more contacts.\n# They will connect 2 to 3, 3 to 2, and 3 to itself\n# Note that contacts are unidirectional, so order matters.\na contact +1 +3600 3 2 100000\na contact +1 +3600 2 3 100000\na contact +1 +3600 2 2 100000\n\n# Add a range. This is the physical distance between nodes.\na range +1 +3600 3 3 1\n\n# Add more ranges.\na range +1 +3600 2 2 1\na range +1 +3600 2 3 1\n\n# set this node to consume and produce a mean of 1000000 bytes/second.\nm production 1000000\nm consumption 1000000\n## end ionadmin \n\n## begin bpadmin \n# bprc configuration file for host3 in a 3node test.\n# Initialization command (command 1).\n1\n\n# Add an EID scheme.\na scheme ipn 'ipnfw' 'ipnadminep'\n\n# Add endpoints.\na endpoint ipn:3.0 q\na endpoint ipn:3.1 q\na endpoint ipn:3.2 q\n\n# Add a protocol. \n# Add the protocol named tcp.\na protocol tcp 1400 100\n\n# Add an induct. (listen)\na induct tcp 10.0.0.3:4556 tcpcli\n\n# Add an outduct (send to yourself).\na outduct tcp 10.0.0.3:4556 tcpclo\n\n# Add an outduct. (send to host2)\na outduct tcp external_ip_of_host_2:4556 tcpclo\n\n# Start bundle protocol engine, also running all of the induct, outduct,\n# and administration programs defined above.\ns\n## end bpadmin \n\n## begin ipnadmin \n# ipnrc configuration file for host1 in the 3node tcp network.\n# Add an egress plan (to yourself).\na plan 2 tcp/10.0.0.3:4556\n# Add an egress plan (to the host 2).\na plan 2 tcp/external_IP_of_node_2:4556\n## end ipnadmin\n\n## begin ionsecadmin\n1\n## end ionsecadmin\n</code></pre>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/","title":"DTN 101 - Running the Interplanetary Internet on Cloud VM","text":"<p>This project has been developed by Dr Lara Suzuki, a visiting researcher at NASA JPL.</p>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#introduction","title":"Introduction","text":"<p>In this project we demonstrate how to run DTN on a cloud VM using NASA's implementation of the bundle protocol - ION. DTN stands for delay-tolerant and disruption-tolerant networks.</p> <p>\"It is an evolution of the architecture originally designed for the Interplanetary Internet, a communication system envisioned to provide Internet-like services across interplanetary distances in support of deep space exploration\" Cerf et al, 2007. </p> <p>The ION (interplanetary overlay network) software is a suite of communication protocol implementations designed to support mission operation communications across an end-to-end interplanetary network, which might include on-board (flight) subnets, in-situ planetary or lunar networks, proximity links, deep space links, and terrestrial internets.</p>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#getting-started-with-cloud-linux-vms","title":"Getting Started with Cloud Linux VMs","text":"<p>On your preferred Cloud provider dashboard, create a Linux VM (e.g. Debian).</p> <p>When prompted, select the reagion closest to you. If you are prompted to select the machine type, select the configuration that will suit your needs. I have selected the a machine which has 2 virtual CPUs and 4 GB memory.</p> <p>For boot disk, in this tutorial we are using Debian GNU/Linux 10 (buster). In firewall configurations, I have selected it Allow HTTP and HTTPS.</p> <p>Once the VM is started you can <code>SSH</code> directly into the VM.</p>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#ssh-in-the-cloud-linux-vm-instance","title":"SSH in the Cloud Linux VM Instance","text":"<p>Mac and Linux support SSH connection natively. You just need to generate an SSH key pair (public key/private key) to connect securely to the virtual machine.</p> <p>To generate the SSH key pair to connect securely to the virtual machine, follow these steps:</p> <ol> <li>Enter the following command in Terminal: <code>ssh-keygen -t rsa .</code> </li> <li>It will start the key generation process. </li> <li>You will be prompted to choose the location to store the SSH key pair. </li> <li>Press <code>ENTER</code> to accept the default location</li> <li>Now run the following command: <code>cat ~/.ssh/id_rsa.pub .</code> </li> <li>It will display the public key in the terminal. </li> <li>Highlight and copy this key</li> </ol> <p>Back in the Cloud VM tools, follow your provider's direction on how to SSH into the VM. If you are requested to provide your SSH Keys, locate the SSH key file in your computer and inform it here.</p> <p>Now you can just open your terminal on your Mac or Linux machine and type <code>ssh IP.IP.IP.IP</code> and you will be on the VM (IP.IP.IP.IP is the external IP of the VM).</p>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#getting-started-with-ion","title":"Getting Started with  ION","text":"<p>This example uses ION version 4.0.1, which can be downloaded here. ION 4.0.1 uses the version 7 of the Bundle Protocol.</p> <p>On your VM execute the following commands</p> <pre><code>$ sudo apt update\n$ sudo apt install build-essential -y\n$ sudo apt-get install wget -y\n$ wget https://sourceforge.net/projects/ion-dtn/files/ion-open-source-4.0.1.tar.gz/download\n$ tar xzvf download\n</code></pre>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#compiling-ion-using-autotools","title":"Compiling ION using autotools","text":"<p>Follow the standard autoconf method for compiling the project. In the base ION directory run:</p> <p><pre><code>$ ./configure\n</code></pre> Then compile with: <pre><code>$ make\n````\nFinally, install (requires root privileges):\n</code></pre> $ sudo make install ```</p> <p>For Linux based systems, you may need to run <code>sudo ldconfig</code> with no arguments after install.</p>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#programs-in-ion","title":"Programs in ION","text":"<p>The following tools are a few examples of programs availale to you after ION is built:</p> <p>1. Daemon and Configuration: - <code>ionadmin</code> is the administration and configuration interface for the local ION node contacts and manages shared memory resources used by ION. - <code>ltpadmin</code> is the administration and configuration interface for LTP operations on the local ION node. - <code>bsspadmin</code> is the administrative interface for operations of the Bundle Streaming Service Protocol on the local ion node. - <code>bpadmin</code> is the administrative interface for bundle protocol operations on the local ion node. - <code>ipnadmin</code> is the administration and configuration interface for the IPN addressing system and routing on the ION node. (ipn:) - <code>ionstart</code> is a script which completely configures an ION node with the proper configuration file(s). - <code>ionstop</code> is a script which cleanly shut down all of the daemon processes. - <code>killm</code> is a script which releases all of the shared-memory resources that had been allocated to the state of the node.  This actually destroys the node and enables a subsequent clean new start (the \u201cionstart\u201d script) to succeed. - <code>ionscript</code> is a script which aides in the creation and management of configuration files to be used with ionstart.</p> <p>2. Simple Sending and Receiving: - <code>bpsource</code> and <code>bpsink</code> are for testing basic connectivity between endpoints. bpsink listens for and then displays messages sent by bpsource. - <code>bpsendfile</code> and <code>bprecvfile</code> are used to send files between ION nodes.</p> <p>3. Testing and Benchmarking: - <code>bpdriver</code> benchmarks a connection by sending bundles in two modes: request-response and streaming. - <code>bpecho</code> issues responses to bpdriver in request-response mode. - <code>bpcounter</code> acts as receiver for streaming mode, outputting markers on receipt of data from bpdriver and computing throughput metrics.</p> <p>4. Logging: - By default, the administrative programs will all trigger the creation of a log file called <code>ion.log</code> in the directory where the program is called. This means that write-access in your current working directory is required. The log file itself will contain the expected log information from administrative daemons, but it will also contain error reports from simple applications such as bpsink. </p>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#the-configuration-files","title":"The Configuration Files","text":"<p>Below we present the configuration files that you should be aware and configure for ION to execute correctly. </p> <ol> <li> <p><code>ionadmin's</code> configuration file, assigns an identity (node number) to the node, optionally configures the resources that will be made available to the node, and specifies contact bandwidths and one-way transmission times. Specifying the \"contact plan\" is important in deep-space scenarios where the bandwidth must be managed and where acknowledgments must be timed according to propagation delays. It is also vital to the function of contact-graph routing - How To</p> </li> <li> <p><code>ltpadmin's</code> configuration file, specifies spans, transmission speeds, and resources for the Licklider Transfer Protocol convergence layer - How To</p> </li> <li> <p><code>bpadmin's</code> configuration file, specifies all of the open endpoints for delivery on your local end and specifies which convergence layer protocol(s) you intend to use. With the exception of LTP, most convergence layer adapters are fully configured in this file - How To</p> </li> <li> <p><code>ipnadmin's</code> configuration file, maps endpoints at \"neighboring\" (topologically adjacent, directly reachable) nodes to convergence-layer addresses. This file populates the ION analogue to an ARP cache for the \"ipn\" naming scheme - How To</p> </li> <li> <p><code>ionsecadmin's</code> configuration file, enables bundle security to avoid error messages in ion.log - How To</p> </li> </ol>"},{"location":"community/dtn-gcp-main/ION-One-Node-on-Cloud-Linux-VM/#testing-and-stopping-your-connection","title":"Testing and Stopping your Connection","text":"<p>Assuming no errors occur with the configuration files above, we are now ready to test loopback communications, and also learn how to properly stop ION nodes. The below items are covered in this How To page.</p> <ol> <li>Testing your connection</li> <li>Stopping the Daemon</li> <li>Creating a single configuration file</li> </ol>"},{"location":"community/dtn-gcp-main/Running-ION/","title":"Testing your connection","text":"<p>A script has been created which allows a more streamlined configuration and startup of an ION node. This script is called <code>ionstart</code>, and it has the following syntax. Don't run it yet; we still have to configure it!</p> <pre><code>ionstart -I &lt;rc filename &gt;\n</code></pre> <ul> <li><code>filename</code>: This is the name for configuration file which the script will attempt to use for the various configuration commands. The script will perform a sanity check on the file, splitting it into command sections appropriate for each of the administration programs.  </li> <li> <p>Configuration information (such as routes, connections, etc) can be specified one of two ways for any of the individual administration programs:</p> </li> <li> <p>(Recommended) Creating a configuration file and passing it to ionadmin, bpadmin, ipnadmin, ltpadmin, etc. either directly or via the ionstart helper script.</p> </li> <li>Manually typing configuration commands into the terminal for each administration program.</li> </ul>"},{"location":"community/dtn-gcp-main/Running-ION/#loopback-communication","title":"Loopback communication","text":"<p>Assuming no errors occur with the configuration above, we are now ready to test loopback communications. In one terminal, we have to run the start script alongside the configuration files. </p> <pre><code>ionstart -i host1.ionrc -l host1.ltprc -b host1.bprc -p host1.ipnrc\n</code></pre> <p>This command will run the appropriate administration programs, in order, with the appropriate configuration files. Don't worry that the command is lengthy and unwieldly; we will show you how to make a more clean single configuration file later. The image below illustrates the start of the administration programs.</p> <p></p> <p>Once the daemon is started, run:</p> <pre><code>bpsink ipn:1.1 &amp;\n</code></pre> <p>This will begin constantly listening on the Endpoint ID with the endpoint_number 1 on service_number 1, which is used for testing.</p> <p>Now run the command:</p> <pre><code>bpsource ipn:1.1\n</code></pre> <p>This will begin sending messages you type to the Endpoint ID ipn:1.1, which is currently being listened to by bpsink. Type messages into bpsource, press enter, and see if they are reported by bpsink. In the example below I am using the Endpoint ID ipn:2.1.</p> <p></p>"},{"location":"community/dtn-gcp-main/Running-ION/#stopping-the-daemon","title":"Stopping the Daemon","text":"<p>As the daemon launches many ducts and helper applications, it can be complicated to turn it all off. The script similar to <code>ionstart</code> exists called <code>ionstop</code>, which tears down the ion node in one step. You can call it like so:</p> <p><pre><code>ionstop\n</code></pre> The commands part of the <code>ionstop</code> script is shown below.</p> <pre><code># shell script to stop node\n#!/bin/bash\nbpadmin         .\nsleep 1\nltpadmin        .\nsleep 1\nionadmin        .\n</code></pre> <p>After stopping the daemon, you can start fresh with a brand-new node.  To do that, you first need to run the <code>killm</code> script (to destroy all of the persistent state objects in shared memory); after that, you can run your <code>ionstart</code> script again, whether with changes or not. Do remember that the <code>ion.log</code> file is still present, and will just keep growing as you experiment with ION. You can of course periodically delete entries out of the ion.log file.</p> <p></p>"},{"location":"community/dtn-gcp-main/Running-ION/#creating-a-single-configuration-file","title":"Creating a single configuration file","text":"<p>To create a single file host1.rc out of the various configuration files defined in the previous section, run this command:</p> <pre><code>ionscript -i host1.ionrc -p host1.ipnrc -l host1.ltprc -b host1.bprc -O host1.rc\n</code></pre> <p>Once you have a single configuration file, starting the ION node is a single command:</p> <pre><code>ionstart -I host1.rc\n</code></pre>"},{"location":"community/dtn-gcp-main/Running-ION/#loopback-testing-using-ltp","title":"Loopback testing using LTP","text":"<p>Assuming no errors occur with the configuration files above, we are now ready to test a <code>Loopback</code> communication, and also learn how to properly stop the ION node. The single rc file for <code>host 1</code> can be found here.</p> <p>The execution of the host should be performed using the command</p> <pre><code>$ ionstart -I host1.rc\n</code></pre> <p>The image below illustrates the loopback communication using <code>bpsink</code> and <code>bpsource</code>.</p> <p></p> <p>To stop ION in the VM instance, use the command </p> <pre><code>$ ionstop. \n</code></pre>"},{"location":"community/dtn-gcp-main/bp-config/","title":"The Bundle Protocol Configuration File","text":"<p>Given to bpadmin either as a file or from the daemon command line, this file configures the endpoints through which this node's Bundle Protocol Agent (BPA) will communicate. We will assume the local BPA's node number is 1; as for LTP, in ION node numbers are used to identify bundle protocol agents.</p>"},{"location":"community/dtn-gcp-main/bp-config/#initialise-the-bundle-protocol","title":"Initialise the bundle protocol","text":"<p><pre><code>1\n````. \n\n`1` refers to this being the initialization or ''first'' command.\n\n## Add support for a new Endpoint Identifier (EID) scheme\n</code></pre> a scheme ipn 'ipnfw' 'ipnadminep' <pre><code>`a` means that this command will add something.\n\n`scheme` means that this command will add a scheme.\n\n`ipn` is the name of the scheme to be added.\n\n`'ipnfw'` is the name of the IPN scheme's forwarding engine daemon.\n\n`'ipnadminep'` is the name of the IPN scheme's custody transfer management daemon.\n\n## Establishes the BP node's membership in a BP endpoint\n</code></pre> a endpoint ipn:1.0 q <pre><code>`a` means that this command will add something.\n\n`endpoint` means that this command adds an endpoint.\n\n`ipn` is the scheme name of the endpoint.\n\n`1.0` is the scheme-specific part of the endpoint. For the IPN scheme the scheme-specific part always has the form nodenumber:servicenumber. Each node must be a member of the endpoint whose node number is the node's own node number and whose service number is 0, indicating administrative traffic.\n\n`q` means that the behavior of the engine, upon receipt of a new bundle for this endpoint, is to queue it until an application accepts the bundle. The alternative is to silently discard the bundle if no application is actively listening; this is specified by replacing q with x.\n\n\n## Specify two more endpoints that will be used for test traffic\n</code></pre> a endpoint ipn:1.1 q a endpoint ipn:1.2 q <pre><code>## Add support for a convergence-layer protocol\n</code></pre> a protocol ltp 1400 100 <pre><code>`a` means that this command will add something.\n\n`protocol` means that this command will add a convergence-layer protocol.\n\n`ltp` is the name of the convergence-layer protocol.\n\n`1400` is the estimated size of each convergence-layer protocol data unit (in bytes); in this case, the value is based on the size of a UDP/IP packet on Ethernet.\n\n`100` is the estimated size of the protocol transmission overhead (in bytes) per convergence-layer procotol data unit sent.\n\n\n## Add an induct, through which incoming bundles can be received from other nodes\n</code></pre> a induct ltp 1 ltpcli <pre><code>`a` means that this command will add something.\n\n`induct` means that this command will add an induct.\n\n`ltp` is the convergence layer protocol of the induct.\n\n`1` is the identifier of the induct, in this case the ID of the local LTP engine.\n\n`ltpcli` is the name of the daemon used to implement the induct.\n\n\n\n## Add an outduct, through which outgoing bundles can be sent to other nodes\n</code></pre> a outduct ltp 1 ltpclo <pre><code>`a` means that this command will add something.\n\n`outduct` means that this command will add an outduct.\n\n`ltp` is the convergence layer protocol of the outduct.\n\n`1` is the identifier of the outduct, the ID of the convergence-layer protocol induct of some remote node. \n\n`ltpclo` is the name of the daemon used to implement the outduct.\n\n\n## Start the bundle engine including all daemons for the inducts and outducts\n</code></pre> s <pre><code>## Final configuration file - `host1.bprc`\n</code></pre></p>"},{"location":"community/dtn-gcp-main/bp-config/#begin-bpadmin","title":"begin bpadmin","text":"<p>1 a scheme ipn 'ipnfw' 'ipnadminep' a endpoint ipn:1.0 q a endpoint ipn:1.1 q a endpoint ipn:1.2 q a protocol ltp 1400 100 a induct ltp 1 ltpcli a outduct ltp 1 ltpclo s</p>"},{"location":"community/dtn-gcp-main/bp-config/#end-bpadmin","title":"end bpadmin","text":"<p>````</p>"},{"location":"community/dtn-gcp-main/host1-start-script/","title":"ION Start Script Example","text":"<p>Note: place this in a file named host1.rc</p> <pre><code>## begin ionadmin\n1 1 ''\ns\n# Define contact plan\na contact +1 +3600 1 1 100000\n\n# Define 1sec OWLT between nodes\na range +1 +3600 1 1 1\nm production 1000000\nm consumption 1000000\n## end ionadmin\n\n## begin ltpadmin\n1 32\na span 1 32 32 1400 10000 1 'udplso 127.0.0.1:1113' 300\n# Start listening for incoming LTP traffic - assigned to the IP internal\ns 'udplsi 127.0.0.1:1113'\n## end ltpadmin\n\n## begin bpadmin\n1\n# Use the ipn eid naming scheme\na scheme ipn 'ipnfw' 'ipnadminep'\n# Create a endpoints\na endpoint ipn:1.0 q\na endpoint ipn:1.1 q\na endpoint ipn:1.2 q\n# Define ltp as the protocol used\na protocol ltp 1400 100\n# Listen \na induct ltp 1 ltpcli\n# Send to yourself\na outduct ltp 1 ltpclo\ns\n## end bpadmin\n\n## begin ipnadmin\n# Send to yourself\na plan 1 ltp/1\n## end ipnadmin\n\n## begin ionsecadmin\n# Enable bundle security to avoid error messages in ion.log\n1\n## end ionsecadmin\n</code></pre>"},{"location":"community/dtn-gcp-main/ion-config/","title":"The ION Configuration File","text":"<p>Given to ionadmin either as a file or from the daemon command line, this file configures contacts for the ION node. We will assume that the local node's identification number is <code>1</code>.</p> <p>This file specifies contact times and one-way light times between nodes. This is useful in deep-space scenarios: for instance, Mars may be 20 light-minutes away, or 8. Though only some transport protocols make use of this time (currently, only LTP), it must be specified for all links nonetheless. Times may be relative (prefixed with a + from current time) or absolute. Absolute times, are in the format <code>yyyy/mm/dd-hh:mm:ss</code>. By default, the contact-graph routing engine will make bundle routing decisions based on the contact information provided.</p> <p>The configuration file lines are as follows:</p>"},{"location":"community/dtn-gcp-main/ion-config/#initialize-the-ion-node-to-be-node-number-1","title":"Initialize the ion node to be node number 1","text":"<pre><code>1 1 ''\n</code></pre> <p><code>1</code> refers to this being the initialization or <code>first</code> command.</p> <p><code>1</code> specifies the node number of this ion node. (IPN node 1).</p> <p><code>''</code> specifies the name of a file of configuration commands for the node's use of shared memory and other resources (suitable defaults are applied if you leave this argument as an empty string).</p>"},{"location":"community/dtn-gcp-main/ion-config/#start-the-ion-node","title":"Start the ION node","text":"<p><code>s</code></p> <p>This will start the ION node. It mostly functions to officially \"start\" the node in a specific instant; it causes all of ION's protocol-independent background daemons to start running.</p>"},{"location":"community/dtn-gcp-main/ion-config/#specify-a-transmission-opportunity","title":"Specify a transmission opportunity","text":"<pre><code>a contact +1 +3600 1 1 100000\n</code></pre> <p>specifies a transmission opportunity for a given time duration between two connected nodes (or, in this case, a loopback transmission opportunity).</p> <p><code>a</code> adds this entry in the configuration table.</p> <p><code>contact</code> specifies that this entry defines a transmission opportunity.</p> <p><code>+1</code> is the start time for the contact (relative to when the s command is issued).</p> <p><code>+3600</code> is the end time for the contact (relative to when the s command is issued).</p> <p><code>1</code> is the source node number.</p> <p><code>1</code> is the destination node number.</p> <p><code>100000</code> is the maximum rate at which data is expected to be transmitted from the source node to the destination node during this time period (here, it is 100000 bytes / second).</p>"},{"location":"community/dtn-gcp-main/ion-config/#specify-a-distance-between-nodes","title":"Specify a distance between nodes","text":"<pre><code>a range +1 +3600 1 1 1\n</code></pre> <p>specifies a distance between nodes, expressed as a number of light seconds, where each element has the following meaning:</p> <p><code>a</code> adds this entry in the configuration table.</p> <p><code>range</code> declares that what follows is a distance between two nodes.</p> <p><code>+1</code> is the earliest time at which this is expected to be the distance between these two nodes (relative to the time s was issued).</p> <p><code>+3600</code> is the latest time at which this is still expected to be the distance between these two nodes (relative to the time s was issued).</p> <p><code>1</code> is one of the two nodes in question.</p> <p><code>1</code> is the other node.</p> <p><code>1</code> is the distance between the nodes, measured in light seconds, also sometimes called the \"one-way light time\" (here, one light second is the expected distance).</p>"},{"location":"community/dtn-gcp-main/ion-config/#specify-the-maximum-rate-at-which-data-will-be-produced-by-the-node","title":"Specify the maximum rate at which data will be produced by the node","text":"<pre><code>m production 1000000\n</code></pre> <p><code>m</code> specifies that this is a management command.</p> <p><code>production</code> declares that this command declares the maximum rate of data production at this ION node.</p> <p><code>1000000</code> specifies that at most 1000000 bytes/second will be produced by this node.</p>"},{"location":"community/dtn-gcp-main/ion-config/#specify-the-maximum-rate-at-which-data-can-be-consumed-by-the-node","title":"Specify the maximum rate at which data can be consumed by the node","text":"<pre><code>m consumption 1000000\n</code></pre> <p><code>m</code> specifies that this is a management command.</p> <p><code>consumption</code> declares that this command declares the maximum rate of data consumption at this ION node.</p> <p><code>1000000</code> specifies that at most 1000000 bytes/second will be consumed by this node.</p>"},{"location":"community/dtn-gcp-main/ion-config/#final-configuration-file-host1ionrc","title":"Final configuration file - <code>host1.ionrc</code>","text":"<pre><code>## begin ionadmin\n1 1 ''\ns\na contact +1 +3600 1 1 100000\na range +1 +3600 1 1 1\nm production 1000000\nm consumption 1000000\n## end ionadmin\n</code></pre>"},{"location":"community/dtn-gcp-main/ionsec-config/","title":"ION Security Admin Configuration File","text":"<p>The <code>ionsecadmin</code> section is used to enable bundle security. Adding it will also avoid error messages in ion.log.</p>"},{"location":"community/dtn-gcp-main/ionsec-config/#enable-the-security-of-the-bundle","title":"Enable the security of the bundle","text":"<p><code>1</code> enables the bundle security</p>"},{"location":"community/dtn-gcp-main/ionsec-config/#final-configuration-file-ionsecrc","title":"Final configuration file - <code>ionsec.rc</code>","text":"<pre><code>## begin ionsecadmin\n1\n## end ionsecadmin\n</code></pre>"},{"location":"community/dtn-gcp-main/ipn-config/","title":"IPN Routing Configuration","text":"<p>As noted earlier, this file is used to build ION's analogue to an ARP cache, a table of <code>egress plans</code>. It specifies which outducts to use in order to forward bundles to the local node's neighbors in the network. Since we only have one outduct, for forwarding bundles to one place (the local node), we only have one egress plan.</p>"},{"location":"community/dtn-gcp-main/ipn-config/#define-an-egress-plan-for-bundles-to-be-transmitted-to-the-local-node","title":"Define an egress plan for bundles to be transmitted to the local node:","text":"<pre><code>a plan 1 ltp/1\n</code></pre> <p><code>a</code> means this command adds something. <code>plan</code> means this command adds an egress plan. <code>1</code> is the node number of the remote node. In this case, that is the local node's own node number; we're configuring for loopback. <code>ltp/1</code> is the identifier of the outduct through which to transmit bundles in order to convey them to this ''remote'' node.</p>"},{"location":"community/dtn-gcp-main/ipn-config/#final-configuration-file-host1ipnrc","title":"Final configuration file - <code>host1.ipnrc</code>","text":"<pre><code>## begin ipnadmin\na plan 1 ltp/1\n## end ipnadmin\n</code></pre>"},{"location":"community/dtn-gcp-main/ltp-config/","title":"The Licklider Transfer Protocol Configuration File","text":"<p>Given to ltpadmin as a file or from the command line, this file configures the LTP engine itself. We will assume the local IPN node number is 1; in ION, node numbers are used as the LTP engine numbers.</p>"},{"location":"community/dtn-gcp-main/ltp-config/#initialize-the-ltp-engine","title":"Initialize the LTP engine","text":"<pre><code>1 32    \n</code></pre> <p><code>1</code> refers to this being the initialization or ''first'' command.</p> <p><code>32</code> is an estimate of the maximum total number of LTP ''block'' transmission sessions - for all spans - that will be concurrently active in this LTP engine. It is used to size a hash table for session lookups.</p>"},{"location":"community/dtn-gcp-main/ltp-config/#defines-an-ltp-engine-span","title":"Defines an LTP engine 'span'","text":"<pre><code>a span 1 32 32 1400 10000 1 'udplso localhost:1113'\n</code></pre> <p><code>a</code> indicates that this will add something to the engine.</p> <p><code>span</code> indicates that an LTP span will be added.</p> <p><code>1</code> is the engine number for the span, the number of the remote engine to which LTP segments will be transmitted via this span. In this case, because the span is being configured for loopback, it is the number of the local engine, i.e., the local node number.</p> <p><code>32</code> specifies the maximum number of LTP ''block'' transmission sessions that may be active on this span. The product of the mean block size and the maximum number of transmission sessions is effectively the LTP flow control ''window'' for this span: if it's less than the bandwidth delay product for traffic between the local LTP engine and this spa's remote LTP engine then you'll be under-utilizing that link. We often try to size each block to be about one second's worth of transmission, so to select a good value for this parameter you can simply divide the span's bandwidth delay product (data rate times distance in light seconds) by your best guess at the mean block size.</p> <p>The second <code>32</code> specifies the maximum number of LTP ''block'' reception sessions that may be active on this span. When data rates in both directions are the same, this is usually the same value as the maximum number of transmission sessions.</p> <p><code>1400</code> is the number of bytes in a single segment. In this case, LTP runs atop UDP/IP on ethernet, so we account for some packet overhead and use 1400.</p> <p><code>1000</code> is the LTP aggregation size limit, in bytes. LTP will aggregate multiple bundles into blocks for transmission. This value indicates that the block currently being aggregated will be transmitted as soon as its aggregate size exceeds 10000 bytes.</p> <p><code>1</code> is the LTP aggregation time limit, in seconds. This value indicates that the block currently being aggregated will be transmitted 1 second after aggregation began, even if its aggregate size is still less than the aggregation size limit.</p> <p><code>'udplso localhost:1113'</code> is the command used to implement the link itself. The link is implemented via UDP, sending segments to the localhost Internet interface on port 1113 (the IANA default port for LTP over UDP).</p>"},{"location":"community/dtn-gcp-main/ltp-config/#starts-the-ltp-engine-itself","title":"Starts the ltp engine itself","text":"<pre><code>s 'udplsi localhost:1113'\n</code></pre> <p><code>s</code> starts the ltp engine.</p> <p><code>'udplsi localhost:1113'</code> is the link service input task. In this case, the input ''duct' is a UDP listener on the local host using port 1113.</p>"},{"location":"community/dtn-gcp-main/ltp-config/#the-final-configuration-file-host1ltprc","title":"The final configuration file - <code>host1.ltprc</code>","text":"<pre><code>## begin ltpadmin\n1 32\na span 1 32 32 1400 10000 1 'udplso localhost:1113'\ns 'udplsi localhost:1113'\n## end ltpadmin\n</code></pre>"},{"location":"community/dtn-multicasting-main/Multicasting-over-ION/","title":"Multicasting over the Interplanetary Internet :rocket:","text":"<p>This project has been developed by Dr Lara Suzuki, a visiting Researcher at NASA JPL.</p> <p>NOTE to reader: After ION 4.1, the <code>imc</code> multicasting implementation has changed its configuration and no longer requires the <code>imcadmin</code> program for configuration. Please see ION 4.1.2 man pages for more information. This tutorial is based on earlier version of ION's imc multicasting. The proper adaptation to latest ION version is left as an exercise for the reader.</p>"},{"location":"community/dtn-multicasting-main/Multicasting-over-ION/#multicasting-using-ion","title":"Multicasting using ION","text":"<p>Multicasting over the Interplanetary Internet uses version 7 of the Bundle Protocol. In a multicasting scenario, we send messages to a multicasting end point and the messages are propagated across the nodes of the network, removing the need to send data to individual nodes one at a time.</p> <p>Use multicasting when the messages you are sending should be delivered to all the known nodes of the network.</p>"},{"location":"community/dtn-multicasting-main/Multicasting-over-ION/#executing-multicasting","title":"Executing Multicasting","text":"<p>This tutorial presents the configurations of one host. To create additional hosts, you just need to copy the same configurations and alter the configuraation documents with the appropriate data as explained in our first tutorial.</p> <p>To execute multicasting:</p> <ol> <li> <p>Execute the \"execute\" file to get ion started <pre><code>$ ./execute\n</code></pre></p> </li> <li> <p>When performing multicasting, the eid naming scheme is  imc 'imcfw' 'imcadminep'</p> </li> <li> <p>Once ION is started you can run the commands to open bpsink to listen to packages sent over DTN. Simply run on your terminal the command below. This command will leave bpsink running on the background. In our configuration file host.bprc.2 we define interplanetary multicasting EID as 19.0. Messages sent to this EID will be delivered to all the hosts running the same configuration. <pre><code>$ bpsink imc:19.0 &amp;\n</code></pre> Messages sent on bpsource imc:19.0 will be delivered to all end points registered in the interplanetary multicasting eid. Note that you can also use bprecvfile and bpsendfile to send images and videos over multicasting.</p> </li> </ol> <pre><code>$ bpsendfile ipn:1.1 imc:19.0 image.jpeg\n$ bprecvfile imc:19.0 1\n</code></pre>"},{"location":"community/dtn-multicasting-main/Multicasting-over-ION/#why-ion-digital-communication-in-interplanetary-scenarios","title":"Why ION? Digital Communication in Interplanetary Scenarios","text":"<p>In this section I will give a little overview of the basic concepts of the Interplanetary Overlay Network from Nasa.</p> <p>Digital communication between interplanetary spacecraft and space flight control centres on Earth is subject to constraints that differ in some ways from those that characterize terrestrial communications. </p>"},{"location":"community/dtn-multicasting-main/Multicasting-over-ION/#basic-concepts-of-interplanetary-overlay-network","title":"Basic Concepts of Interplanetary Overlay Network","text":"<p>Delay-Disruption Tolerant Networking (DTN) is NASA\u2019s solution for reliable, automated network communications in space missions. The DTN2 reference implementation of the Delay-Tolerant Networking (DTN) RFC 4838 and the current version of the Bundle Protocol (BP) is the foundation for a wide range of current DTN industrial and research applications. </p> <p>The Jet Propulsion Laboratory (JPL) has developed an alternative implementation of BP, named \u201cInterplanetary Overlay Network\u201d (ION). ION addresses those constraints and enables delay-tolerant network communications in interplanetary mission operations. </p>"},{"location":"community/dtn-multicasting-main/Multicasting-over-ION/#space-communication-challenges","title":"Space communication challenges","text":"<ul> <li>Extreme distances and high rates of data loss due to radio signal interference make communicating between Earth and interplanetary spacecraft a challenge.</li> <li>Constant orbital movement of the satellites,  the link handovers and the acquisition and loss of signal as satellites come into and out of visibility of the ground antena, and discontinuous vehicle operations make the challenge even more difficult, even in near-Earth space.</li> </ul> <p>To give you a sense of signal propagation -&gt; send a message and receive a response (RRT) back: 1. A typical round trip time between two points on the internet is 100ms to 300ms 2. Distance to ISS (throught TDRS - Tracking and Data Relay Satellite) approx 71322km -&gt; round trip time is approx 1200 ms on Ku Link 3. Distance to the moon approx 384400 km - rrt 2560 ms -2,5 seconds 4. Minimun distance to mars: approx 54.6 million km - rrt of approx 6 min 5. Average distance to mars: approx 225 million km - rrt of approx 25 mins 6. Farthest distance to mars: approx 401 million km - rtt of approc 44.6 min</p> <p>The internet architecture is based on the assumption that network nodes are continuously connected. The following assumptions are valid for the terrestrial Internet architecture: - Networks have short signal propagation delays - Data links are symmetric and bidirectional - Bit error rates are low</p> <p>These assumptions are not valid in the space environment - a new sort of network is needed. In a space environment:  - Connections can be routinely interrupted - Interplanetary distances impose delays - Link data rates are often asymmetric and some links are simplex - Bit error rates can be very high</p> <p>To communicate across these vast distances, NASA manages three communication networks consisting of distributed ground stations and space relay satellites for data transmission and reception that support both NASA and non-NASA missions. These are: - the Deep Space Network (DSN) - the Near Earth Network (NEN) - the Space Network (SN). </p> <p>Communication opportunities are scheduled, based on orbit dynamics and operation plans. Sometimes a spacecraft is on the far side of a planet and you cannot communicate with it. Transmission and reception episodes are individually configured, started and ended by command. Reliability over deeps space links is by management: on loss of data, command retransmission. More recently for Mars missions we have managed forwarding through relay points so that data from these surface vehicles is relayed thought Odyssey and other orbiting mars vehicles.</p>"},{"location":"community/dtn-multicasting-main/Host1/execute/","title":"Execute","text":"<pre><code>#!/usr/bin/bash\necho \"starting ION...\"\nionadmin host.ionrc\n./ionstart\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/host.bprc1/","title":"Host.bprc1","text":"<pre><code>## begin bpadmin\n1\n#       Use the ipn eid naming scheme\na scheme ipn 'ipnfw' 'ipnadminep'\n#       Create a endpoints\na endpoint ipn:1.0 q\na endpoint ipn:1.1 q\na endpoint ipn:1.2 q\n#       Define ltp as the protocol used\na scheme imc 'imcfw' 'imcadminep'\n#a endpoint imc:19.0 q\na protocol ltp 1400 100\n#       Listen\na induct ltp 1 ltpcli\n#       Send to yourself\na outduct ltp 1 ltpclo\n#       Send to server2\na outduct ltp 2 ltpclo\na outduct ltp 3 ltpclo\nw 1\ns\n## end bpadmin\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/host.bprc2/","title":"Host.bprc2","text":"<pre><code>a endpoint imc:19.0 q\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/host.ionrc/","title":"Host.ionrc","text":"<pre><code>## begin ionadmin\n1 1 ''\ns\n#       Define contact plan\na contact +1 +3600 1 1 100000\na contact +1 +3600 1 2 100000\na contact +1 +3600 2 1 100000\na contact +1 +3600 2 2 100000\n\n#       Define 1sec OWLT between nodes\na range +1 +3600 1 1 1\na range +1 +3600 1 2 1\na range +1 +3600 2 1 1\na range +1 +3600 2 2 1\nm production 1000000\nm consumption 1000000\n## end ionadmin\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/host.ionsecrc/","title":"Host.ionsecrc","text":"<pre><code>1\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/host.ipnrc/","title":"Host.ipnrc","text":"<pre><code>## begin ipnadmin\n#       Send to yourself#\na plan 1 ltp/1\n#       Send to server 2\na plan 2 ltp/2\n## end ipnadmin\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/host.ltprc/","title":"Host.ltprc","text":"<pre><code>1 32\n#a span peer_engine_nbr\n#       [queuing_latency]\n#       Create a span to tx\na span 1 32 32 1400 10000 1 'udplso external_ip_host1:1113' 300\na span 2 32 32 1400 10000 1 'udplso external_ip_host2:1113' 300\n#       Start listening for incoming LTP traffic - assigned to the IP internal\ns 'udplsi internal_ip:1113'\n## end ltpadmin\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/ionstart/","title":"Ionstart","text":"<pre><code>#!/bin/bash\n# shell script to get node running\n\nionsecadmin     host.ionsecrc\nsleep 1\nltpadmin        host.ltprc\nsleep 1\nbpadmin         host.bprc.1\nsleep 1\nipnadmin        host.ipnrc\nsleep 2\nbpadmin         host.bprc.2\necho \"Started Host 1.\"\n</code></pre>"},{"location":"community/dtn-multicasting-main/Host1/ionstop/","title":"Ionstop","text":"<pre><code>#!/bin/bash\n#\n# ionstop\n# David Young\n# Aug 20, 2008\n#\n# will quickly and completely stop an ion node.\n\nION_OPEN_SOURCE=1\n\necho \"IONSTOP will now stop ion and clean up the node for you...\"\nbpversion\nif [ $? -eq 6 ]; then\necho \"acsadmin .\"\nacsadmin .\nsleep 1\nfi\necho \"bpadmin .\"\nbpadmin .\nsleep 1\nif [ \"$ION_OPEN_SOURCE\" == \"1\" ]; then\necho \"cfdpadmin .\"\ncfdpadmin .\nsleep 1\nfi\necho \"ltpadmin .\"\nltpadmin .\nsleep 1\necho \"ionadmin .\"\nionadmin .\nsleep 1\necho \"killm\"\nkillm\necho \"ION node ended. Log file: ion.log\"\n</code></pre>"},{"location":"community/dtn-video-intelligence-main/Video-Intelligence/","title":"Using GCP Video Intelligence over the Interplanetary Internet","text":"<p>This project has been developed by Dr Lara Suzuki, a visiting researcher at NASA JPL.</p> <p>In this tutorial I will demonstrate how to connect use GCP Video Intelligence over the Interplanetary Internet. </p>"},{"location":"community/dtn-video-intelligence-main/Video-Intelligence/#setting-up-the-interplanetary-internet","title":"Setting up the Interplanetary Internet","text":"<p>Please follow tutorial Multicasting over the Interplanetary Internet to set up your nodes. </p> <p>As noted in the multicasting tutorial, current ION <code>imc</code> multicasting operation has been updated and adaptation is required to make this tutorial work.</p> <p>Once the hosts are configured you can run the command to get ionstart running:</p> <pre><code>$ ./execute\n</code></pre>"},{"location":"community/dtn-video-intelligence-main/Video-Intelligence/#google-cloud-video-intelligence","title":"Google Cloud Video Intelligence","text":"<p>Cloud Video Intelligence API allows you to process frames of videos with a simple API call  from anywhere. With GCP Video Intelligence you can:</p> <ol> <li> <p>Quickly understand video content by encapsulating powerful machine learning models in an easy to use REST API. </p> </li> <li> <p>Accurately annotate videos stored in Google Cloud Storage with video and frame-level (1 fps) contextual information. </p> </li> <li> <p>Make sense of large amount of video files in a very short amount of time.</p> </li> <li> <p>Utilise the technology via an easy to use REST API to analyze videos stored anywhere, or integrate with your image storage on Google Cloud Storage. </p> </li> </ol>"},{"location":"community/dtn-video-intelligence-main/Video-Intelligence/#executing-google-cloud-video-intelligence","title":"Executing Google Cloud Video Intelligence","text":"<p>In the Interplanetary host you choose to run the excecution of the Video Intelligence API, install the library:</p> <pre><code>$ pip install --upgrade google-cloud-videointelligence\n</code></pre> <p>To use the Video Intelligence API you must be Authenticated. To do that, please follow the instructions in this GCP Tutorial. After you've created your service account, Provide authentication credentials to your application code by setting the environment variable GOOGLE_APPLICATION_CREDENTIALS.</p> <pre><code>$ export GOOGLE_APPLICATION_CREDENTIALS=\"/home/user/Downloads/my-key.json\"\n</code></pre> <p>On the host that will run the Video Intelligence, execute: </p> <pre><code>python\npython3 video_processing.py\n</code></pre>"},{"location":"community/dtn-video-intelligence-main/video-processing-script/","title":"Video processing script","text":"<pre><code>import argparse\nfrom google.cloud import videointelligence\n\nvideo_client = videointelligence.VideoIntelligenceServiceClient()\nfeatures = [videointelligence.Feature.LABEL_DETECTION]\noperation = video_client.annotate_video(\nrequest={\"features\": features, \"input_uri\":'gs://test_bucket_pi/video1_pi.mp4'})\nprint(\"Processing video for label annotations:\")\n\nresult = operation.result(timeout=90)\nprint(\"\\nFinished processing.\")\n\nsegment_labels = result.annotation_results[0].segment_label_annotations\nfor i, segment_label in enumerate(segment_labels):\n  print(\"Video label description: {}\".format(segment_label.entity.description))\n  for category_entity in segment_label.category_entities:\n    print( \"\\tLabel category description: {}\".format(category_entity.description)\n            )\n\n  for i, segment in enumerate(segment_label.segments):\n    start_time = (\n      segment.segment.start_time_offset.seconds\n      + segment.segment.start_time_offset.microseconds / 1e6\n      )\n    end_time = (\n      segment.segment.end_time_offset.seconds\n      + segment.segment.end_time_offset.microseconds / 1e6\n      )\n    positions = \"{}s to {}s\".format(start_time, end_time)\n    confidence = segment.confidence\n    print(\"\\tSegment {}: {}\".format(i, positions))\n    print(\"\\tConfidence: {}\".format(confidence))\n    print(\"\\n\")\n</code></pre>"},{"location":"man/ams/","title":"Index of Man Pages","text":"<ul> <li>ams</li> <li>amsbenchr</li> <li>amsbenchs</li> <li>amsd</li> <li>amshello</li> <li>amslog</li> <li>amslogprt</li> <li>amsmib</li> <li>amspub</li> <li>amsrc</li> <li>amsshell</li> <li>amsstop</li> <li>amssub</li> <li>amsxml</li> <li>petition_log</li> <li>ramsgate</li> </ul>"},{"location":"man/ams/ams/","title":"NAME","text":"<p>ams - CCSDS Asynchronous Message Service(AMS) communications library</p>"},{"location":"man/ams/ams/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"ams.h\"\n\ntypedef void                (*AmsMsgHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int continuumNbr,\n                                    int unitNbr,\n                                    int moduleNbr,\n                                    int subjectNbr,\n                                    int contentLength,\n                                    char *content,\n                                    int context,\n                                    AmsMsgType msgType,\n                                    int priority,\n                                    unsigned char flowLabel);\n\ntypedef void                (*AmsRegistrationHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int unitNbr,\n                                    int moduleNbr,\n                                    int roleNbr);\n\ntypedef void                (*AmsUnregistrationHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int unitNbr,\n                                    int moduleNbr);\n\ntypedef void                (*AmsInvitationHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int unitNbr,\n                                    int moduleNbr,\n                                    int domainRoleNbr,\n                                    int domainContinuumNbr,\n                                    int domainUnitNbr,\n                                    int subjectNbr,\n                                    int priority,\n                                    unsigned char flowLabel,\n                                    AmsSequence sequence,\n                                    AmsDiligence diligence);\n\ntypedef void                (*AmsDisinvitationHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int unitNbr,\n                                    int moduleNbr,\n                                    int domainRoleNbr,\n                                    int domainContinuumNbr,\n                                    int domainUnitNbr,\n                                    int subjectNbr);\n\ntypedef void                (*AmsSubscriptionHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int unitNbr,\n                                    int moduleNbr,\n                                    int domainRoleNbr,\n                                    int domainContinuumNbr,\n                                    int domainUnitNbr,\n                                    int subjectNbr,\n                                    int priority,\n                                    unsigned char flowLabel,\n                                    AmsSequence sequence,\n                                    AmsDiligence diligence);\n\ntypedef void                (*AmsUnsubscriptionHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int unitNbr,\n                                    int moduleNbr,\n                                    int domainRoleNbr,\n                                    int domainContinuumNbr,\n                                    int domainUnitNbr,\n                                    int subjectNbr);\n\ntypedef void                (*AmsUserEventHandler)(AmsModule module,\n                                    void *userData,\n                                    AmsEvent *eventRef,\n                                    int code,\n                                    int dataLength,\n                                    char *data);\n\ntypedef void                (*AmsMgtErrHandler)(void *userData,\n                                    AmsEvent *eventRef);\n\ntypedef struct\n{\n    AmsMsgHandler                   msgHandler;\n    void                            *msgHandlerUserData;\n    AmsRegistrationHandler          registrationHandler;\n    void                            *registrationHandlerUserData;\n    AmsUnregistrationHandler        unregistrationHandler;\n    void                            *unregistrationHandlerUserData;\n    AmsInvitationHandler            invitationHandler;\n    void                            *invitationHandlerUserData;\n    AmsDisinvitationHandler         disinvitationHandler;\n    void                            *disinvitationHandlerUserData;\n    AmsSubscriptionHandler          subscriptionHandler;\n    void                            *subscriptionHandlerUserData;\n    AmsUnsubscriptionHandler        unsubscriptionHandler;\n    void                            *unsubscriptionHandlerUserData;\n    AmsUserEventHandler             userEventHandler;\n    void                            *userEventHandlerUserData;\n    AmsMgtErrHandler                errHandler;\n    void                            *errHandlerUserData;\n} AmsEventMgt;\n\ntypedef enum\n{\n    AmsArrivalOrder = 0,\n    AmsTransmissionOrder\n} AmsSequence;\n\ntypedef enum\n{\n    AmsBestEffort = 0,\n    AmsAssured\n} AmsDiligence;\n\ntypedef enum\n{\n    AmsRegistrationState,\n    AmsInvitationState,\n    AmsSubscriptionState\n} AmsStateType;\n\ntypedef enum\n{\n    AmsStateBegins = 1,\n    AmsStateEnds\n} AmsChangeType;\n\ntypedef enum\n{\n    AmsMsgUnary = 0,\n    AmsMsgQuery,\n    AmsMsgReply,\n    AmsMsgNone\n} AmsMsgType;\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ams/ams/#description","title":"DESCRIPTION","text":"<p>The ams library provides functions enabling application software to use AMS to send and receive brief messages, up to 65000 bytes in length.  It conforms to AMS Blue Book, including support for Remote AMS (RAMS).</p> <p>In the ION implementation of RAMS, the \"RAMS network protocol\" may be either the DTN Bundle Protocol (RFC 5050) or -- mainly for testing purposes -- the User Datagram Protocol (RFC 768).  BP is the default.  When BP is used as the RAMS network protocol, endpoints are by default assumed to conform to the \"ipn\" endpoint identifier scheme with node number set to the AMS continuum number and service number set to the AMS venture number.</p> <p>Note that RAMS functionality is enabled by instantiating a ramsgate daemon, which is simply an AMS application program that acts as a gateway between the local AMS message space and the RAMS network.</p> <p>AMS differs from other ION packages in that there is no utilization of non-volatile storage (aside from the BP functionality in RAMS, if applicable). Since there is no non-volatile AMS database, there is no AMS administration program and there are no library functions for attaching to or detaching from such a database.  AMS is instantiated by commencing operation of the AMS real-time daemon amsd; once amsd is running, AMS application programs (\"modules\") can be started.  All management of AMS operational state is performed automatically in real time.</p> <p>However, amsd and the AMS application programs all require access to a common store of configuration data at startup in order to load their Management Information Bases.  This configuration data must reside in a readable file, which may take either of two forms: a file of XML statements conforming to the scheme described in the amsxml(5) man page, or a file of simple but less powerful configuration statements as described in the amsrc(5) man page.  The amsxml alternative requires that the expat XML parsing system be installed; the amsrc alternative was developed to simplify deployment of AMS in environments in which expat is not readily supported. Selection of the configuration file format is a compile-time decision, implemented by setting (or not setting) the -DNOEXPAT compiler option.</p> <p>The path name of the applicable configuration file may be passed as a command-line parameter to amsd and as a registration function parameter by any AMS application program.  Note, though, that ramsgate and the AMS test and utility programs included in ION always assume that the configuration file resides in the current working directory and that it is named \"mib.amsrc\" if AMS was built with -DNOEXPAT, \"amsmib.xml\" otherwise.</p> <p>The transport services that are made available to AMS communicating entities are declared by the transportServiceLoaders array in the libams.c source file.  This array is fixed at compile time.  The order of preference of the transport services in the array is hard-coded, but the inclusion or omission  of individual transport services is controlled by setting compiler options. The \"udp\" transport service -- nominally the most preferred because it imposes the least processing and transmission overhead -- is included by setting the -DUDPTS option.  The \"dgr\" service is included by setting the -DDGRTS option.  The \"vmq\" (VxWorks message queue) service, supported only on VxWorks, is included by setting the -DVMQTS option.  The \"tcp\" transport service -- selected only when its quality of service is required -- is included by setting the -DTCPTS option.</p> <p>The operating state of any single AMS application program is managed in an opaque AmsModule object.  This object is returned when the application begins AMS operations (that is, registers) and must be provided as an argument to most AMS functions.</p> <ul> <li> <p>int ams_register(char *mibSource, char *tsorder, char *applicationName, char *authorityName, char *unitName, char *roleName, AmsModule *module)</p> <p>Registers the application within a cell (identified by unitName) of a message space that is that portion of the venture identified by applicationName and authorityName that runs within the local AMS continuum.  roleName identifies the role that this application will perform in this venture.  The operating state of the registered application is returned in module.</p> <p>The application module's identifying parameters are validated against the configuration information in the applicable Management Information Base, which is automatically loaded from the file whose pathname is provided in mibSource.  If mibSource is the zero-length string (\"\") then the default configuration file name is used as noted above.  If mibSource is NULL then a rudimentary hard-coded default MIB, useful for basic testing purposes, is loaded.  This default MIB defines a single venture for application \"amsdemo\" and authority \"test\", using only the \"dgr\" transport service, with the configuration server residing on the local host machine; subject \"text\" and roles \"shell\", \"log\", \"pitch\", and \"catch\" are defined.</p> <p>The tsorder argument is normally NULL.  If non-NULL it must be a NULL-terminated string of ASCII numeric digits '0' through '9' identifying an alternative transport service preference order that overrides the standard transport service preference order defined by the hard-coded array of transportServiceLoaders in the libams.c source file.  Each character of the tsorder string must represent the index position of one of the transport services within the array.  For example, if services \"udp\", \"dgr\", \"vmq\", and \"tcp\" are all available in the array, a tsorder string of \"32\"  would indicate that this application will only communicate using the tcp and vmq services; services 0 (udp) and 1 (dgr) will not be used, and tcp is preferred to vmq when both are candidate services for transmission of a given message.</p> <p>Returns 0 on success.  On any error, sets module to NULL and returns -1.</p> </li> <li> <p>int ams_unregister(AmsModule module)</p> <p>Reverses the operation of ams_unregister(), destroying module.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_invite(AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr, int priority, unsigned char flowLabel, AmsSequence sequence, AmsDiligence diligence)</p> <p>Announces this module's agreement to receive messages on the subject identified by subjectNbr.</p> <p>The invitation is extended only to modules registered in the role identified by roleNbr (where 0 indicates \"all roles\"), operating in the continuum identifed by continuumNbr (where 0 indicates \"all continua\"), and registered within the unit identified by unitNbr (where 0 indicates the venture's root unit) or any of that unit's subunits.  These parameters define the \"domain\" of the invitation.</p> <p>Such messages should be sent at the priority indicated by priority with flow label as indicated by flowLabel and with quality of service as indicated by sequence and diligence.  priority must be an integer in the range 1-15, where priority 1 indicates the greatest urgency.  Flow labels are passed through to transport services and are opaque to AMS itself; in the absence of defined flow labels, a value of 0 is typically used.  These parameters define the \"class of service\" of the invitation.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_disinvite(AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr)</p> <p>Rescinds the invitation characterized by the indicated subject and domain.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_subscribe(AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr, int priority, unsigned char flowLabel, AmsSequence sequence, AmsDiligence diligence)</p> <p>Announces this module's subscription to messages on the indicated subject, constrained by the indicated domain, and transmitted subject to the indicated class of service.  Note that subscriptions differ from invitations in that  reception of these messages is actively solicited, not just permitted.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_unsubscribe(AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr)</p> <p>Cancels the subscription characterized by the indicated subject and domain.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_publish(AmsModule module, int subjectNbr, int priority, unsigned char flowLabel, int contentLength, char *content, int context)</p> <p>Publishes contentLength bytes of data starting at content as the content of a message that is sent to all modules whose subscriptions to subjectNbr are characterized by a domain that includes this module.  priority and flowLabel, if non-zero, override class of service as requested in the subscriptions.  context is an opaque \"hint\" to the receiving modules; its use is application-specific.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_send(AmsModule module, int continuumNbr, int unitNbr, int moduleNbr, int subjectNbr, int priority, unsigned char flowLabel, int contentLength, char *content, int context)</p> <p>Sends contentLength bytes of data starting at content as the content of a message that is transmitted privately to the module in the continuum identified by continuumNbr (where 0 indicates \"the local continuum\") that is identified by unitNbr and moduleNbr -- provided that module is in the domain of one of that module's invitations on subjectNbr. priority and flowLabel, if non-zero, override class of service as requested in the invitation.  context is an opaque \"hint\" to the receiving module; its use is application-specific.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_query(AmsModule module, int continuumNbr, int unitNbr, int moduleNbr, int subjectNbr, int priority, unsigned char flowLabel, int contentLength, char *content, int context, int term, AmsEvent *event)</p> <p>Sends a message exactly is described above for ams_send(), but additionally suspends the delivery and processing of newly received messages until either (a) a \"reply\" message sent in response to this message is received or (b) the time interval indicated by term, in seconds, expires.  The event (reply or timeout) that ends the suspension of processing is provided in event (as if from ams_get_event() when the function returns. </p> <p>If term is AMS_BLOCKING then the timeout interval is indefinite; only reception of a reply message enables the function to return.  If term is AMS_POLL then the function returns immediately, without waiting for a reply message.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_reply(AmsModule module, AmsEvent msg, int subjectNbr, int priority, unsigned char flowLabel, int contentLength, char *content)</p> <p>Sends a message exactly is described above for ams_send(), except that the destination of the message is the sender of the message identified by msg and the \"context\" value included in the message is the context that was provided in msg.  This message is identified as a \"reply\" message that will end the processing suspension resulting from transmission of msg if that message was issued by means of ams_query() rather than ams_send().</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_announce(AmsModule module, int roleNbr, int continuumNbr, int unitNbr, int subjectNbr, int priority, unsigned char flowLabel, int contentLength, char *content, int context)</p> <p>Sends a message exactly is described above for ams_send(), except that one copy of the message is sent to every module in the domain of this function (role, continuum, unit) whose invitation for messages on this subject is itself characterized by a domain that includes the the sending module, rather than to any specific module.  </p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_get_event(AmsModule module, int term, AmsEvent *event)</p> <p>Returns in event the next event in the queue of AMS events pending delivery to this module.  If the event queue is empty at the time this function is called, processing is suspended until either an event is queued or the time interval indicated by term, in seconds, expires.  See ams_query() above for the semantics of term.  When the function returns on expiration of term, an event of type TIMEOUT_EVT is returned in event.  Otherwise the event will be of type AMS_MSG_EVT (indicating arrival of a message), NOTICE_EVT (indicating a change in the configuration of the message space), or USER_DEFINED_EVT (indicating that application code posted an event).</p> <p>The nature of the event returned by ams_get_event() can be determined by passing event to ams_get_event_type() as described below.  Event type can then be used to determine whether the information content of the event must be obtained by calling ams_parse_msg(), ams_parse_notice(), or ams_parse_user_event().  </p> <p>In any case, the memory occupied by event must be released after the event object is no longer needed.  The ams_recycle_event() function is invoked for this purpose.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_get_event_type(AmsEvent event)</p> <p>Returns the event type of event, or -1 on any error.</p> </li> <li> <p>int ams_parse_msg(AmsEvent event, int *continuumNbr, int *unitNbr, int *moduleNbr, int *subjectNbr, int *contentLength, char **content, int *context, AmsMsgType *msgType, int *priority, unsigned char *flowLabel);</p> <p>Extracts all relevant information pertaining to the AMS message encapsulated in event, populating the indicated fields.  Must only be called when the event type of event is known to be AMS_MSG_EVT.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_parse_notice(AmsEvent event, AmsStateType *state, AmsChangeType *change, int *unitNbr, int *moduleNbr, int *roleNbr, int *domainContinuumNbr, int *domainUnitNbr, int *subjectNbr, int *priority, unsigned char *flowLabel, AmsSequence *sequence, AmsDiligence *diligence)</p> <p>Extracts all relevant information pertaining to the AMS configuration change notice encapsulated in event, populating the relevant fields.  Must only be called when the event type of event is known to be NOTICE_EVT.</p> <p>Note that different fields will be populated depending on the nature of the notice in event.  state will be set to AmsRegistrationState, AmsInvitationState, or AmsSubscription state depending on whether the notice pertains to a change in module registration, a change in invitations, or a change in subscriptions.  change will be set to AmsStateBegins or AmsStateEnds depending on whether the notice pertains to the initiation or termination of a registration, invitation, or subscription.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_post_user_event(AmsModule module, int userEventCode, int userEventDataLength, char *userEventData, int priority)</p> <p>Posts a \"user event\" whose content is the userEventDataLength bytes of data starting at userEventData.  userEventCode is an application-specific value that is opaque to AMS.  priority determines the event's position in the queue of events pending delivery to this module; it may be any integer in the range 0-15, where 0 indicates the greatest urgency.  (Note that user events can be delivered ahead of all message reception events if necessary.)</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_parse_user_event(AmsEvent event, int *code, int *dataLength, char **data)</p> <p>Extracts all relevant information pertaining to the user event encapsulated in event, populating the indicated fields.  Must only be called when the event type of event is known to be USER_DEFINED_EVT.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_recycle_event(AmsEvent event)</p> <p>Releases all memory occupied by event.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_set_event_mgr(AmsModule module, AmsEventMgt *rules)</p> <p>Starts a background thread that processes events queued for this module, handling each event in the manner indicated by rules.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void ams_remove_event_mgr(AmsModule module)</p> <p>Terminates the background thread established to process events queued for this module.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int ams_get_module_nbr(AmsModule module)</p> <p>Returns the module number assigned to this module upon registration, or -1 on any error.</p> </li> <li> <p>int ams_get_unit_nbr(AmsModule module)</p> <p>Returns the unit number assigned to the unit within which this module registered, or -1 on any error.</p> </li> <li> <p>Lyst ams_list_msgspaces(AmsModule module)</p> <p>Returns a dynamically allocated linked list of all message spaces identified in the MIB for this module, or -1 on any error.  See lyst(3) for operations that can be performed on the returned linked list.</p> </li> <li> <p>int ams_get_continuum_nbr()</p> <p>Returns the continuum number assigned to the continuum within which this module operates, or -1 on any error.</p> </li> <li> <p>int ams_rams_net_is_tree(AmsModule module)</p> <p>Returns 1 if the RAMS net for the venture in which this module is registered is configured as a tree, 0 if that RAMS net is configured as a mesh, -1 on any error.</p> </li> <li> <p>int ams_continuum_is_neighbor(int continuumNbr)</p> <p>Returns 1 if continuumNbr identifies a continuum whose RAMS gateways are immediate neighbors (within the applicable RAMS networks) of the RAMS gateways in the local continuum.  Returns 0 otherwise.</p> </li> <li> <p>char *ams_get_role_name(AmsModule module, int unitNbr, int moduleNbr)</p> <p>Returns the name of the role in which the module identified by unitNbr and moduleNbr registered, or NULL on any error.</p> </li> <li> <p>int ams_subunit_of(AmsModule module, int argUnitNbr, int refUnitNbr)</p> <p>Returns 1 if argUnitNbr identifies a unit that is wholly contained within the unit identified by refUnitNbr, in the venture within which this module is registered.  Returns 0 otherwise.</p> </li> <li> <p>int ams_lookup_unit_nbr(AmsModule module, char *unitName)</p> <p>Returns the number assigned to the unit identified by unitName, in the venture within which this module is registered, or -1 on any error.</p> </li> <li> <p>int ams_lookup_role_nbr(AmsModule module, char *roleName)</p> <p>Returns the number assigned to the role identified by roleName, in the venture within which this module is registered, or -1 on any error.</p> </li> <li> <p>int ams_lookup_subject_nbr(AmsModule module, char *subjectName)</p> <p>Returns the number assigned to the subject identified by subjectName, in the venture within which this module is registered, or -1 on any error.</p> </li> <li> <p>int ams_lookup_continuum_nbr(AmsModule module, char *continuumName)</p> <p>Returns the number of the continuum identified by continuumName, or -1 on any error.</p> </li> <li> <p>char *ams_lookup_unit_name(AmsModule module, int unitNbr)</p> <p>Returns the name of the unit identified by unitNbr, in the venture within which this module is registered, or -1 on any error.</p> </li> <li> <p>char *ams_lookup_role_name(AmsModule module, int roleNbr)</p> <p>Returns the name of the role identified by roleNbr, in the venture within which this module is registered, or -1 on any error.</p> </li> <li> <p>char *ams_lookup_subject_name(AmsModule module, int subjectNbr)</p> <p>Returns the name of the subject identified by subjectNbr, in the venture within which this module is registered, or -1 on any error.</p> </li> <li> <p>char *ams_lookup_continuum_name(AmsModule module, int continuumNbr)</p> <p>Returns the name of the continuum identified by continuumNbr, or -1 on any error.</p> </li> </ul>"},{"location":"man/ams/ams/#see-also","title":"SEE ALSO","text":"<p>amsd(1), ramsgate(1), amsxml(5), amsrc(5)</p>"},{"location":"man/ams/amsbenchr/","title":"NAME","text":"<p>amsbenchr - Asynchronous Message Service (AMS) benchmarking meter</p>"},{"location":"man/ams/amsbenchr/#synopsis","title":"SYNOPSIS","text":"<p>amsbenchr</p>"},{"location":"man/ams/amsbenchr/#description","title":"DESCRIPTION","text":"<p>amsbenchr is a test program that simply subscribes to subject \"bench\" and receives messages published by amsbenchs until all messages in the test - as indicated by the count of remaining messages, in in the first four bytes of each message - have been received.  Then it stops receiving messages, calculates and prints performance statistics, and terminates.</p> <p>amsbenchr will register as an application module in the root unit of the venture identified by application name \"amsdemo\" and authority name \"test\".  A configuration server for the local continuum and a registrar for the root unit of that venture (which may both be instantiated in a single amsd daemon task) must be running in order for amsbenchr to commence operations.</p>"},{"location":"man/ams/amsbenchr/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>-1</p> <p>amsbenchr failed, for reasons noted in the ion.log file.</p> </li> <li> <p>\"0\"</p> <p>amsbenchr terminated normally.</p> </li> </ul>"},{"location":"man/ams/amsbenchr/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amsbenchr/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amsbenchr/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>amsbenchr can't register.</p> <p>amsbenchr failed to register, for reasons noted in the ion.log file.</p> </li> <li> <p>amsbenchr: subject 'bench' is unknown.</p> <p>amsbenchr can't subscribe to test messages; probably an error in the MIB initialization file.</p> </li> <li> <p>amsbenchr can't subscribe.</p> <p>amsbenchr failed to subscribe, for reasons noted in the ion.log file.</p> </li> <li> <p>amsbenchr can't get event.</p> <p>amsbenchr failed to receive a message, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amsbenchr/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amsbenchr/#see-also","title":"SEE ALSO","text":"<p>amsrc(5)</p>"},{"location":"man/ams/amsbenchs/","title":"NAME","text":"<p>amsbenchs - Asynchronous Message Service (AMS) benchmarking driver</p>"},{"location":"man/ams/amsbenchs/#synopsis","title":"SYNOPSIS","text":"<p>amsbenchs count size</p>"},{"location":"man/ams/amsbenchs/#description","title":"DESCRIPTION","text":"<p>amsbenchs is a test program that simply publishes count messages of size bytes each on subject \"bench\", then waits while all published messages are transmitted, terminating when the user uses ^C to interrupt the program.  The remaining number of messages to be published in the test is written into the first four octets of each message.</p> <p>amsbenchs will register as an application module in the root unit of the venture identified by application name \"amsdemo\" and authority name \"test\".  A configuration server for the local continuum and a registrar for the root unit of that venture (which may both be instantiated in a single amsd daemon task) must be running in order for amsbenchs to commence operations.</p>"},{"location":"man/ams/amsbenchs/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>-1</p> <p>amsbenchs failed, for reasons noted in the ion.log file.</p> </li> <li> <p>\"0\"</p> <p>amsbenchs terminated normally.</p> </li> </ul>"},{"location":"man/ams/amsbenchs/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amsbenchs/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amsbenchs/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>No memory for amsbenchs.</p> <p>Insufficient available memory for a message content buffer of the indicated size.</p> </li> <li> <p>amsbenchs can't register.</p> <p>amsbenchs failed to register, for reasons noted in the ion.log file.</p> </li> <li> <p>amsbenchs can't set event manager.</p> <p>amsbenchs failed to start its background event management thread, for reasons noted in the ion.log file.</p> </li> <li> <p>amsbenchs: subject 'bench' is unknown.</p> <p>amsbenchs can't publish test messages; probably an error in the MIB initialization file.</p> </li> <li> <p>amsbenchs can't publish message.</p> <p>amsbenchs failed to publish, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amsbenchs/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amsbenchs/#see-also","title":"SEE ALSO","text":"<p>amsrc(5)</p>"},{"location":"man/ams/amsd/","title":"NAME","text":"<p>amsd - AMS configuration server and/or registrar daemon</p>"},{"location":"man/ams/amsd/#synopsis","title":"SYNOPSIS","text":"<p>amsd { @ | MIB_source_name } { . | @ | config_server_endpoint_spec } [application_name authority_name registrar_unit_name]</p>"},{"location":"man/ams/amsd/#description","title":"DESCRIPTION","text":"<p>amsd is a background \"daemon\" task that functions as an AMS \"configuration server\" in the local continuum, as an AMS \"registrar\" in a specified cell, or both.</p> <p>If MIB_source_name is specified, it must name a MIB initialization file in the correct format for amsd, either amsrc(5) or amsxml(5), depending on whether or not -DNOEXPAT was set at compile time.  Otherwise @ is required; in this case, the built-in default MIB is loaded.</p> <p>If this amsd task is NOT to run as a configuration server then the second command-line argument must be a '.' character.  Otherwise the second command-line argument must be either '@' or config_server_endpoint_spec. If '@' then the endpoint specification for this configuration server is automatically computed as the default endpoint specification for the primary transport service as noted in the MIB: \"hostname:2357\".</p> <p>If an AMS module is NOT to be run in a background thread for this daemon (enabling shutdown by amsstop(1) and/or runtime MIB update by amsmib(1)),  then either the last three command-line arguments must be omitted or else the \"amsd\" role must not be defined in the MIB loaded for this daemon.  Otherwise the application_name and authority_name arguments are required and the \"amsd\" role must be defined in the MIB.</p> <p>If this amsd task is NOT to run as a registrar then the last command-line argument must be omitted.  Otherwise the last three command-line arguments are required and they must identify a unit in an AMS venture for the indicated application and authority that is known to operate in the local continuum, as noted in the MIB.  Note that the unit name for the \"root unit\" of a venture is the zero-length string \"\".</p>"},{"location":"man/ams/amsd/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>amsd terminated without error.</p> </li> <li> <p>-1</p> <p>amsd terminated due to an anomaly as noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and restart amsd.</p> </li> </ul>"},{"location":"man/ams/amsd/#files","title":"FILES","text":"<p>If MIB source name is specified, then a file of this name must be present. Otherwise a MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amsd/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amsd/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>amsd can't load MIB.</p> <p>MIB initialization file was missing, unreadable, or invalid.</p> </li> <li> <p>amsd can't start CS.</p> <p>Configuration server initialization failed for reasons noted in ion.log file.</p> </li> <li> <p>amsd can't start RS.</p> <p>Registrar initialization failed for reasons noted in ion.log file.</p> </li> </ul>"},{"location":"man/ams/amsd/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amsd/#see-also","title":"SEE ALSO","text":"<p>amsmib(1), amsstop(1), amsrc(5), amsxml(5)</p>"},{"location":"man/ams/amshello/","title":"NAME","text":"<p>amshello - Asynchronous Message Service (AMS) demo program for UNIX</p>"},{"location":"man/ams/amshello/#synopsis","title":"SYNOPSIS","text":"<p>amshello</p>"},{"location":"man/ams/amshello/#description","title":"DESCRIPTION","text":"<p>amshello is a sample program designed to demonstrate that an entire (very simple) distributed AMS application can be written in just a few lines of C code.  When started, amshello forks a second process and initiates transmission of a \"Hello\" text message from one process to the other, after which both processes unregister and terminate.</p> <p>The amshello processes will register as application modules in the root unit of the venture identified by application name \"amsdemo\" and authority name \"test\".  A configuration server for the local continuum and a registrar for the root unit of that venture (which may both be instantiated in a single amsd daemon task) must be running in order for the amshello processes to run.</p>"},{"location":"man/ams/amshello/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>amshello terminated normally.</p> </li> </ul>"},{"location":"man/ams/amshello/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amshello/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amshello/#diagnostics","title":"DIAGNOSTICS","text":"<p>No diagnostics apply.</p>"},{"location":"man/ams/amshello/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amshello/#see-also","title":"SEE ALSO","text":"<p>amsrc(5)</p>"},{"location":"man/ams/amslog/","title":"NAME","text":"<p>amslog - Asynchronous Message Service (AMS) test message receiver</p>"},{"location":"man/ams/amslog/#synopsis","title":"SYNOPSIS","text":"<p>amslog unit_name role_name application_name authority_name [{ s | i }]</p>"},{"location":"man/ams/amslog/#description","title":"DESCRIPTION","text":"<p>amslog is a message reception program designed to test AMS functionality.</p> <p>When amslog is started, it registers as an application module in the unit identified by unit_name of the venture identified by application_name and authority_name; the role in which it registers must be indicated in role_name.  A configuration server for the local continuum and a registrar for the indicated unit of the indicated venture (which may both be instantiated in a single amsd daemon task) must be running in order for amslog to run.</p> <p>amslog runs as two threads: a background thread that receives AMS messages and logs them to standard output, together with a foreground thread that acquires operating parameters in lines of console input to control the flow of messages to the background thread.</p> <p>When the first character of a line of input from stdin to the amslog foreground thread is '.' (period), amslog immediately terminates. Otherwise, the first character of each line of input from stdin must be either '+' indicating assertion of interest in a message subject or '-' indicating cessation of interest in a subject.  In each case, the name of the subject in question must begin in the second character of the input line.  Note that \"everything\" is a valid subject name.</p> <p>By default, amslog runs in \"subscribe\" mode: when interest in a message subject is asserted, amslog subscribes to that subject; when interest in a message subject is rescinded, amslog unsubscribes to that subject. This behavior can be overridden by providing a third command-line argument to amslog - a \"mode\" indicator.  When mode is 'i', amslog runs in \"invite\" mode.  In \"invite\" mode, when interest in a message subject is asserted, amslog invites messages on that subject; when interest in a message subject is rescinded, amslog cancels its invitation for messages on that subject.</p> <p>The \"domain\" of a subscription or invitation can optionally be specified immediately after the subject name, on the same line of console input:</p> <p>Domain continuum name may be specified, or the place-holder domain continuum name \"_\" may be specified to indicate \"all continua\".</p> <p>If domain continuum name (\"_\" or otherwise) is specified, then domain unit name may be specified or the place-holder domain unit name \"_\" may be specified to indicate \"the root unit\" (i.e., the entire venture).</p> <p>If domain unit name (\"_\" or otherwise) is specified, then domain role name may be specified.</p> <p>When amslog runs in VxWorks or RTEMS, the subject and content of each message are simply written to standard output in a text line for display on the console.  When amslog runs in a UNIX environment, the subject name length (a binary integer), subject name (ASCII text), content length (a binary integer), and content (ASCII text) are written to standard output for redirection either to a file or to a pipe to amslogprt.</p> <p>Whenever a received message is flagged as a Query, amslog returns a reply message whose content is the string \"Got \" followed by the first 128 bytes of the content of the Query message, enclosed in single quote marks and followed by a period.</p>"},{"location":"man/ams/amslog/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>-1</p> <p>amslog terminated with an error as noted in the ion.log file.</p> </li> <li> <p>\"0\"</p> <p>amslog terminated normally.</p> </li> </ul>"},{"location":"man/ams/amslog/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amslog/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amslog/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>amslog can't register.</p> <p>amslog failed to register, for reasons noted in the ion.log file.</p> </li> <li> <p>amslog can't set event manager.</p> <p>amslog failed to start its background thread, for reasons noted in the ion.log file.</p> </li> <li> <p>amslog can't read from stdin</p> <p>amslog foreground thread failed to read console input, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amslog/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amslog/#see-also","title":"SEE ALSO","text":"<p>amsshell(1), amslogprt(1), amsrc(5)</p>"},{"location":"man/ams/amslogprt/","title":"NAME","text":"<p>amslogprt - UNIX utility program for printing AMS log messages from amslog</p>"},{"location":"man/ams/amslogprt/#synopsis","title":"SYNOPSIS","text":"<p>amslogprt</p>"},{"location":"man/ams/amslogprt/#description","title":"DESCRIPTION","text":"<p>amslogprt simply reads AMS activity log messages from standard input (nominally written by amslog and prints them.  When the content of a logged message is judged not to be an ASCII text string, the content is printed in hexadecimal.</p> <p>amslogprt terminates at the end of input.</p>"},{"location":"man/ams/amslogprt/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>amslogprt terminated normally.</p> </li> </ul>"},{"location":"man/ams/amslogprt/#files","title":"FILES","text":"<p>No files are needed by amslogprt.</p>"},{"location":"man/ams/amslogprt/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amslogprt/#diagnostics","title":"DIAGNOSTICS","text":"<p>None.</p>"},{"location":"man/ams/amslogprt/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amslogprt/#see-also","title":"SEE ALSO","text":"<p>amsrc(5)</p>"},{"location":"man/ams/amsmib/","title":"NAME","text":"<p>amsmib - Asynchronous Message Service (AMS) MIB update utility</p>"},{"location":"man/ams/amsmib/#synopsis","title":"SYNOPSIS","text":"<p>amsmib application_name authority_name role_name continuum_name unit_name file_name</p>"},{"location":"man/ams/amsmib/#description","title":"DESCRIPTION","text":"<p>amsmib is a utility program that announces relatively brief Management Information Base (MIB) updates to a select population of AMS modules.  Because amsd processes may run AAMS modules in background threads, and because a single MIB is shared in common among all threads of any process, amsmib may update the MIBs used by registrars and/or configuration servers as well.</p> <p>MIB updates can only be propagated to modules for which the subject \"amsmib\" was defined in the MIB initialization files cited at module registration time.  All ION AMS modules implicitly invite messages on subject \"amsmib\" (from all modules registered in role \"amsmib\" in all continua of the same venture) at registration time if subject \"amsmib\" and role \"amsmib\" are defined in the MIB.</p> <p>amsmib registers in the root cell of the message space identified by application_name and authority_name, within the local continuum.  It registers in the role \"amsmib\"; if this role is not defined in the (initial) MIB loaded by amsmib at registration time, then registration fails and amsmib terminates.</p> <p>amsmib then reads into a memory buffer up to 4095 bytes of MIB update text from the file identified by file_name.  The MIB update text must conform to amsxml(5) or amsrc(5) syntax, depending on whether or not the intended recipient modules were compiled with the -DNOEXPAT option.</p> <p>amsmib then \"announces\" (see ams_announce() in ams(3)) the contents of the memory buffer to all modules of this same venture (identified by application_name and authority_name) that registered in the indicated role, in the indicated unit of the indicated continuum.  If continuum_name is \"\" then the message will be sent to modules in all continua.  If role_name is \"\" then all modules will be eligible to receive the message, regardless of the role in which they registered.  If unit_name is \"\" (the root unit) then all modules will be eligible to receive the message, regardless of the unit in which they registered.</p> <p>Upon reception of the announced message, each destination module will apply all of the MIB updates in the content of the message, in exactly the same way that its original MIB was loaded from the MIB initialization file when the module started running.</p> <p>If multiple modules are running in the same memory space (e.g., in different threads of the same process, or in different tasks on the same VxWorks target) then the updates will be applied multiple times, because all modules in the same memory space share a single MIB.  MIB updates are idempotent, so this is harmless (though some diagnostics may be printed).</p> <p>Moreover, an amsd daemon will have a relevant \"MIB update\" module running in a background thread if application_name and authority_name were cited  on the command line that started the daemon (provided the role \"amsd\" was defined in the initial MIB loaded at the time amsd began running).  The MIB exposed to the configuration server and/or registrar running in that daemon will likewise be updated upon reception of the announced message.</p> <p>The name of the subject of the announced mib update message is \"amsmib\"; if this subject is not defined in the (initial) MIB loaded by amsmib then the message cannot be announced.  Nor can any potential recipient module receive the message if subject \"amsmib\" is not defined in that module's MIB.</p>"},{"location":"man/ams/amsmib/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>amsmib terminated normally.</p> </li> <li> <p>\"1\"</p> <p>An anomalous exit status, indicating that amsmib failed to register.</p> </li> </ul>"},{"location":"man/ams/amsmib/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5) and amsxml(5)) must be present.</p>"},{"location":"man/ams/amsmib/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amsmib/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>amsmib subject undefined.</p> <p>The amsmib utility was unable to announce the MIB update message.</p> </li> <li> <p>amsmib domain role unknown.</p> <p>The amsmib utility was unable to announce the MIB update message.</p> </li> <li> <p>amsmib domain continuum unknown.</p> <p>The amsmib utility was unable to announce the MIB update message.</p> </li> <li> <p>amsmib domain unit unknown.</p> <p>The amsmib utility was unable to announce the MIB update message.</p> </li> <li> <p>amsmib can't open MIB file.</p> <p>The amsmib utility was unable to construct the MIB update message.</p> </li> <li> <p>MIB file length &gt; 4096.</p> <p>The MIB update text file was too long to fit into the amsmib message buffer.</p> </li> <li> <p>Can't seek to end of MIB file.</p> <p>I/O error in processing the MIB update text file.</p> </li> <li> <p>Can't read MIB file.</p> <p>I/O error in processing the MIB update text file.</p> </li> <li> <p>amsmib can't announce 'amsmib' message.</p> <p>The amsmib utility was unable to announce the MIB update message, for reasons noted in the log file.</p> </li> <li> <p>amsmib can't register.</p> <p>The amsmib utility failed to register, for reasons noted in the log file.</p> </li> </ul>"},{"location":"man/ams/amsmib/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amsmib/#see-also","title":"SEE ALSO","text":"<p>amsd(1), ams(3), amsrc(5), amsxml(5)</p>"},{"location":"man/ams/amspub/","title":"NAME","text":"<p>amspub - Asynchronous Message Service (AMS) test driver for VxWorks</p>"},{"location":"man/ams/amspub/#synopsis","title":"SYNOPSIS","text":"<p>amspub \"application_name\", \"authority_name\", \"subject_name\", \"message_text\"</p>"},{"location":"man/ams/amspub/#description","title":"DESCRIPTION","text":"<p>amspub is a message publication program designed to test AMS functionality in a VxWorks environment.  When an amspub task is started, it registers as an application module in the root unit of the venture identified by application_name and authority_name, looks up the subject number for subject_name, publishes a single message with content message_text on that subject, unregisters, and terminates.</p> <p>A configuration server for the local continuum and a registrar for the root unit of the indicated venture (which may both be instantiated in a single amsd daemon task) must be running in order for amspub to run.</p>"},{"location":"man/ams/amspub/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>-1</p> <p>amspub terminated with an error as noted in the ion.log file.</p> </li> <li> <p>\"0\"</p> <p>amspub terminated normally.</p> </li> </ul>"},{"location":"man/ams/amspub/#files","title":"FILES","text":"<p>The amspub source code is in the amspubsub.c source file.</p> <p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amspub/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amspub/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>amspub can't register.</p> <p>amspub failed to register, for reasons noted in the ion.log file.</p> </li> <li> <p>amspub: subject is unknown</p> <p>amspub can't publish test messages on the specified subject; possibly an error in the MIB initialization file.</p> </li> <li> <p>amspub can't publish message.</p> <p>amspub failed to publish, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amspub/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amspub/#see-also","title":"SEE ALSO","text":"<p>amssub(1), amsrc(5)</p>"},{"location":"man/ams/amsrc/","title":"NAME","text":"<p>amsrc - CCSDS Asynchronous Message Service MIB initialization file</p>"},{"location":"man/ams/amsrc/#description","title":"DESCRIPTION","text":"<p>The Management Information Base (MIB) for an AMS communicating entity (either amsd or an AMS application module) must contain enough information to enable the entity to initiate participation in AMS message exchange, such as the network location of the configuration server and the roles and message subjects defined for some venture.</p> <p>AMS entities automatically load their MIBs from initialization files at startup.  When AMS is built with the -DNOEXPAT compiler option set, the MIB initialization file must conform to the amsrc syntax described below; otherwise the expat XML parsing library must be linked into the AMS executable and the MIB initialization file must conform to the amsxml syntax described in amsxml(5).</p> <p>The MIB initialization file lists elements of MIB update information, each of which may have one or more attributes.  An element may also have sub-elements that are listed within the declaration of the parent element, and so on.</p> <p>The declaration of an element may occupy a single line of text in the MIB initialization file or may extend across multiple lines.  A single-line element declaration is indicated by a '*' in the first character of the line.  The beginning of a multi-line element declaration is indicated by a '+' in the first character of the line, while the end of that declaration is indicated by a '-' in the first character of the line.  In every case, the type of element must be indicated by an element-type name beginning in the second character of the line and terminated by whitespace.  Every start-of-element line must be matched by a subsequent end-of-element line that precedes the start of any other element that is not a nested sub-element of this element.</p> <p>Attributes are represented by whitespace-terminated &lt;name&gt;=&lt;value&gt; expressions immediately following the element-type name on a '*' or '+' line.  An attribute value that contains whitespace must be enclosed within a pair of single-quote (') characters.</p> <p>Two types of elements are recognized in the MIB initialization file: control elements and configuration elements.  A control element establishes the update context within which the configuration elements nested within it are processed, while a configuration element declares values for one or more items of AMS configuration information in the MIB.</p> <p>Note that an aggregate configuration element (i.e., one which may contain other interior configuration elements; venture, for example) may be presented outside of any control element, simply to establish the context in which  subsequent control elements are to be interpreted.</p>"},{"location":"man/ams/amsrc/#control-elements","title":"CONTROL ELEMENTS","text":"<ul> <li> <p>ams_mib_init</p> <p>Initializes an empty MIB.  This element must be declared prior to the declaration of any other element.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>continuum_nbr</p> <p>Identifies the local continuum.</p> </li> <li> <p>ptsname</p> <p>Identifies the primary transport service for the continuum.  Valid values include \"dgr\" and \"udp\".</p> </li> <li> <p>pubkey</p> <p>This is the name of the public key used for validating the digital signatures of meta-AMS messages received from the configuration server for this continuum.  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> <li> <p>privkey</p> <p>This is the name of the private key used for constructing the digital signatures of meta-AMS messages sent by the configuration server for this continuum.  This attribute should only be present in the MIB initialization file for amsd().  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> </ul> </li> <li> <p>ams_mib_add</p> <p>This element contains a list of configuration items that are to be added to the MIB.</p> </li> <li> <p>ams_mib_change</p> <p>This element contains a list of configuration items that are to be revised in the MIB.</p> </li> <li> <p>ams_mib_delete</p> <p>This element contains a list of configuration items that are to be deleted from the MIB.</p> </li> </ul>"},{"location":"man/ams/amsrc/#configuration-elements","title":"CONFIGURATION ELEMENTS","text":"<ul> <li> <p>continuum</p> <p>Identifies a known remote continuum.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>nbr</p> <p>Identifies the remote continuum.</p> </li> <li> <p>name</p> <p>Identifies the remote continuum.</p> </li> <li> <p>neighbor</p> <p>1 if the continuum is a neighbor of the local continuum, zero otherwise.</p> </li> <li> <p>desc</p> <p>A textual description of this continuum.</p> </li> </ul> </li> <li> <p>csendpoint</p> <p>Identifies one of the network locations at which the configuration server may be reachable.  If the configuration server might be running at any one of several locations, the number of other locations that are preferred to this one is noted; in this case, csendpoints must be listed within the ams_mib_add element in descending order of preference, i.e., with the most preferred network location listed first.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>epspec</p> <p>Identifies the endpoint at which the configuration server may be reachable.  The endpoint specification must conform to the endpoint specification syntax defined for the continuum's primary transport service; see the AMS Blue Book for details.</p> </li> <li> <p>after</p> <p>If present, indicates the number of other configuration server network locations that are considered preferable to this one.  This attribute is used to ensure that csendpoints are listed in descending order of preference.</p> </li> </ul> </li> <li> <p>amsendpoint</p> <p>Normally the specifications of the transport service endpoints at which an AMS application module can receive messages are computed automatically using standard transport-service-specific rules.  However, in some cases it might be necessary for a module to receive messages at one or more non-standard endpoints; in these cases, amsendpoint elements can be declared in order to override the standard endpoint specification rules.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>tsname</p> <p>Identifies the transport service for which a non-standard endpoint specification is being supplied.</p> </li> <li> <p>epspec</p> <p>Identifies an endpoint at which the application module will be reachable, in the context of the named transport service.  The endpoint specification must conform to the endpoint specification syntax defined for the named transport service; see the AMS Blue Book for details.</p> </li> </ul> </li> <li> <p>application</p> <p>Identifies one of the applications supported within this continuum.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>name</p> <p>Identifies the application.</p> </li> <li> <p>pubkey</p> <p>This is the name of the public key used for validating the digital signatures of meta-AMS messages received from the registrars for all cells of any message space in this continuum that is characterized by this application name.  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> <li> <p>privkey</p> <p>This is the name of the private key used for constructing the digital signatures of meta-AMS messages sent by the registrars for all cells of any message space in this continuum that is characterized by this application name.  This attribute should only be present in the MIB initialization file for amsd().  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> </ul> </li> <li> <p>venture</p> <p>Identifies one of the ventures operating within the local continuum.</p> <p>Sub-elements: role, subject, unit, msgspace</p> <p>Attributes:</p> <ul> <li> <p>nbr</p> <p>Identifies the venture.</p> </li> <li> <p>appname</p> <p>Identifies the application addressed by this venture.</p> </li> <li> <p>authname</p> <p>Identifies the authority under which the venture operates, distinguishing this venture from all other ventures that address the same application.</p> </li> <li> <p>gweid</p> <p>Identifies the RAMS network endpoint ID of the RAMS gateway module for this venture's message space in the local continuum.  Gateway endpoint ID is expressed as &lt;protocol_name&gt;@&lt;eid_string&gt; where protocol_name is either \"bp\" or \"udp\".  If protocol name is \"bp\" then eid_string must be a valid Bundle Protocol endpoint ID; otherwise, eid_string must be of the form &lt;hostname&gt;:&lt;port_number&gt;.  If the gweid attribute is omitted, the RAMS gateway module's RAMS network endpoint ID defaults to \"bp@ipn:&lt;local_continuum_number&gt;.&lt;venture_number&gt;\".</p> </li> <li> <p>net_config</p> <p>Has the value \"tree\" if the RAMS network supporting this venture is configured as a tree; otherwise \"mesh\", indicating that the RAMS network supporting this venture is configured as a mesh.</p> </li> <li> <p>root_cell_resync_period</p> <p>Indicates the number of seconds in the period on which resynchronization is performed for the root cell of this venture's message space in the local continuum.  If this attribute is omitted, resynchronization in that cell is disabled.</p> </li> </ul> </li> <li> <p>role</p> <p>Identifies one of the functional roles in the venture that is the element that's currently being configured.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>nbr</p> <p>Identifies the role.</p> </li> <li> <p>name</p> <p>Identifies the role.</p> </li> <li> <p>authname</p> <p>Identifies the authority under which the venture operates, distinguishing this venture from all other ventures that address the same application.</p> </li> <li> <p>pubkey</p> <p>This is the name of the public key used for validating the digital signatures of meta-AMS messages received from all application modules that register in this functional role.  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> <li> <p>privkey</p> <p>This is the name of the private key used for constructing the digital signatures of meta-AMS messages sent by all application modules that register in this functional role.  This attribute should only be present in the MIB initialization file for application modules that register in this role.  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> </ul> </li> <li> <p>subject</p> <p>Identifies one of the subjects on which messages may be sent, within the venture that is the element that's currently being configured.</p> <p>Sub-elements: sender, receiver</p> <p>Attributes:</p> <ul> <li> <p>nbr</p> <p>Identifies the subject.</p> </li> <li> <p>name</p> <p>Identifies the subject.</p> </li> <li> <p>desc</p> <p>A textual description of this message subject.</p> </li> <li> <p>symkey</p> <p>This is the name of the symmetric key used for both encrypting and decrypting the content of messages on this subject; if omitted, messages on this subject are not encrypted by AMS.  If authorized senders and receivers are defined for this subject, then this attribute should only be present in the MIB initialization file for application modules that register in roles that appear in the subject's lists of authorized senders and/or receivers.  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> <li> <p>marshal</p> <p>This is the name associated with the content marshaling function defined for this message subject.  If present, whenever a message on this subject is issued the associated function is automatically called to convert the supplied content data to a platform-independent representation for transmission; this conversion occurs before any applicable content encryption is performed.  If omitted, content data are transmitted without conversion to a platform-independent representation.  Marshaling functions are defined in the marshalRules table in the marshal.c source file.</p> </li> <li> <p>unmarshal</p> <p>This is the name associated with the content unmarshaling function defined for this message subject.  If present, whenever a message on this subject is received the associated function is automatically called to convert the transmitted content to local platform-specific representation; this conversion occurs after any applicable content decryption is performed.  If omitted, received content data are delivered without conversion to a local platform-specific representation. Unmarshaling functions are defined in the unmarshalRules table in the marshal.c source file.</p> </li> </ul> </li> <li> <p>sender</p> <p>Identifies one of the roles in which application modules must register in order to be authorized senders of messages on the subject that is the element that's currently being configured.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>name</p> <p>Identifies the sender.  The value of this attribute must be the name of a role that has been defined for the venture that is currently being configured.</p> </li> </ul> </li> <li> <p>receiver</p> <p>Identifies one of the roles in which application modules must register in order to be authorized receivers of messages on the subject that is the element that's currently being configured.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>name</p> <p>Identifies the receiver.  The value of this attribute must be the name of a role that has been defined for the venture that is currently being configured.</p> </li> </ul> </li> <li> <p>unit</p> <p>Identifies one of the organizational units within the venture that is the element that's currently being configured.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>nbr</p> <p>Identifies the unit.</p> </li> <li> <p>name</p> <p>Identifies the unit.</p> </li> <li> <p>resync_period</p> <p>Indicates the number of seconds in the period on which resynchronization is performed, for the cell of this venture's message space that is the portion of the indicated unit which resides in the local continuum.  If this attribute is omitted, resynchronization in that cell is disabled.</p> </li> </ul> </li> <li> <p>msgspace</p> <p>Identifies one of the message spaces in remote continua that are encompassed by the venture that is the element that's currently being configured.</p> <p>Sub-elements: none</p> <p>Attributes:</p> <ul> <li> <p>nbr</p> <p>Identifies the remote continuum within which the message space operates.</p> </li> <li> <p>gweid</p> <p>Identifies the RAMS network endpoint ID of the RAMS gateway module for this message space.  Gateway endpoint ID is expressed as &lt;protocol_name&gt;@&lt;eid_string&gt; where protocol_name is either \"bp\" or \"udp\".  If protocol name is \"bp\" then eid_string must be a valid Bundle Protocol endpoint ID; otherwise, eid_string must be of the form &lt;hostname&gt;:&lt;port_number&gt;.  If the gweid attribute is omitted, the RAMS network endpoint ID of the message space's RAMS gateway module defaults to \"bp@ipn:&lt;remote_continuum_number&gt;.&lt;venture_number&gt;\".</p> </li> <li> <p>symkey</p> <p>This is the name of the symmetric key used for both encrypting and decrypting all messages to and from modules in the remote message space that are forwarded between the local RAMS gateway server and modules in the local message space; if omitted, these messages are not encrypted.  The value of this attribute (if present) must identify a key that has been loaded into the ION security database, nominally by ionsecadmin(1).</p> </li> </ul> </li> </ul>"},{"location":"man/ams/amsrc/#example","title":"EXAMPLE","text":"<p>*ams_mib_init continuum_nbr=2 ptsname=dgr</p> <p>+ams_mib_add</p> <p>*continuum nbr=1 name=apl desc=APL</p> <p>*csendpoint epspec=beaumont.stepsoncats.com:2357</p> <p>*application name=amsdemo</p> <p>+venture nbr=1 appname=amsdemo authname=test</p> <p>*role nbr=2 name=shell</p> <p>*role nbr=3 name=log</p> <p>*role nbr=4 name=pitch</p> <p>*role nbr=5 name=catch</p> <p>*role nbr=6 name=benchs</p> <p>*role nbr=7 name=benchr</p> <p>*role nbr=96 name=amsd</p> <p>*role nbr=97 name=amsmib</p> <p>*role nbr=98 name=amsstop</p> <p>*subject nbr=1 name=text desc='ASCII text'</p> <p>*subject nbr=2 name=noise desc='more ASCII text'</p> <p>*subject nbr=3 name=bench desc='numbered msgs'</p> <p>*subject nbr=97 name=amsmib desc='MIB updates'</p> <p>*subject nbr=98 name=amsstop desc='shutdown'</p> <p>*unit nbr=1 name=orbiters</p> <p>*unit nbr=2 name=orbiters.near</p> <p>*unit nbr=3 name=orbiters.far</p> <p>*msgspace nbr=2</p> <p>-venture</p> <p>-ams_mib_add</p>"},{"location":"man/ams/amsrc/#see-also","title":"SEE ALSO","text":"<p>amsxml(5)</p>"},{"location":"man/ams/amsshell/","title":"NAME","text":"<p>amsshell - Asynchronous Message Service (AMS) test message sender (UNIX)</p>"},{"location":"man/ams/amsshell/#synopsis","title":"SYNOPSIS","text":"<p>amsshell unit_name role_name application_name authority_name [{ p | s | q | a }]</p>"},{"location":"man/ams/amsshell/#description","title":"DESCRIPTION","text":"<p>amsshell is a message issuance program designed to test AMS functionality.</p> <p>When amsshell is started, it registers as an application module in the unit identified by unit_name of the venture identified by application_name and authority_name; the role in which it registers must be indicated in role_name.  A configuration server for the local continuum and a registrar for the indicated unit of the indicated venture (which may both be instantiated in a single amsd daemon task) must be running in order for amsshell to run.</p> <p>amsshell runs as two threads: a background thread that receives watches for AMS configuration events (including shutdown), together with a foreground thread that acquires operating parameters and message content in lines of console input to control the issuance of messages.</p> <p>The first character of each line of input from stdin to the amsshell indicates the significance of that line:</p> <ul> <li> <p>=</p> <p>Sets the name of the subject on which all messages are to be issued, until superseded by another \"=\" line.  The subject name must begin at the second character of this line.  Optionally, subject name may be followed by a single ' ' (space) character and then the text of the first message to be issued on this subject, which is to be issued immediately.</p> </li> <li> <p>r</p> <p>Sets the number of the role constraining the domain of message issuance. The role number must begin at the second character of this line.</p> </li> <li> <p>c</p> <p>Sets the number of the continuum constraining the domain of message issuance. The continuum number must begin at the second character of this line.</p> </li> <li> <p>u</p> <p>Sets the number of the unit constraining the domain of message issuance. The unit number must begin at the second character of this line.</p> </li> <li> <p>m</p> <p>Sets the number of the module to which subsequent messages are to be issued. The module number must begin at the second character of this line.</p> </li> <li> <p>.</p> <p>Terminates amsshell.</p> </li> </ul> <p>When the first character of a line of input from stdin is none of the above, the entire line is taken to be the text of a message that is to be issued immediately, on the previously specified subject, to the previously specified module (if applicable), and subject to the previously specified domain (if applicable).</p> <p>By default, amsshell runs in \"publish\" mode: when a message is to be issued, it is simply published.  This behavior can be overridden by providing a fifth command-line argument to amsshell - a \"mode\" indicator.  The supported modes are as follows:</p> <ul> <li> <p>p</p> <p>This is \"publish\" mode.  Every message is published.</p> </li> <li> <p>s</p> <p>This is \"send\" mode.  Every message is sent privately to the application module identified by the specified module, unit, and continuum numbers.</p> </li> <li> <p>q</p> <p>This is \"query\" mode.  Every message is sent privately to the application module identified by the specified module, unit, and continuum numbers, and amsshell then waits for a reply message before continuing.</p> </li> <li> <p>a</p> <p>This is \"announce\" mode.  Every message is announced to all modules in the domain established by the previously specified role, unit, and continuum numbers.</p> </li> </ul>"},{"location":"man/ams/amsshell/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>-1</p> <p>amsshell terminated with an error as noted in the ion.log file.</p> </li> <li> <p>\"0\"</p> <p>amsshell terminated normally.</p> </li> </ul>"},{"location":"man/ams/amsshell/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amsshell/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amsshell/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>amsshell can't register.</p> <p>amsshell failed to register, for reasons noted in the ion.log file.</p> </li> <li> <p>amsshell can't set event manager.</p> <p>amsshell failed to start its background thread, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amsshell/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amsshell/#see-also","title":"SEE ALSO","text":"<p>amslog(1), amsrc(5)</p>"},{"location":"man/ams/amsstop/","title":"NAME","text":"<p>amsstop - Asynchronous Message Service (AMS) message space shutdown utility</p>"},{"location":"man/ams/amsstop/#synopsis","title":"SYNOPSIS","text":"<p>amsstop application_name authority_name</p>"},{"location":"man/ams/amsstop/#description","title":"DESCRIPTION","text":"<p>amsstop is a utility program that terminates the operation of all registrars and all application modules running in the message space which is that portion of the indicated AMS venture that is operating in the local continuum.  If one of the amsd tasks that are functioning as registrars for this venture is also functioning as the configuration server for the local continuum, then that configuration server is also terminated.</p> <p>application_name and authority_name must identify an AMS venture that is known to operate in the local continuum, as noted in the MIB for the amsstop application module.</p> <p>A message space can only be shut down by amsstop if the subject \"amsstop\" is defined in the MIBs of all modules in the message spaces.</p>"},{"location":"man/ams/amsstop/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>amsstop terminated normally.</p> </li> <li> <p>\"1\"</p> <p>An anomalous exit status, indicating that amsstop was unable to register and therefore failed to shut down its message space, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amsstop/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5) and amsxml(5)) must be present.</p>"},{"location":"man/ams/amsstop/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amsstop/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>amsstop can't register.</p> <p>This message indicates that amsstop was unable to register, possibly because the \"amsstop\" role is not defined in the MIB initialization file.</p> </li> <li> <p>amsstop subject undefined.</p> <p>This message indicates that amsstop was unable to stop the message space because the \"amsstop\" subject is not defined in the MIB initialization file.</p> </li> <li> <p>amsstop can't publish 'amsstop' message.</p> <p>This message indicates that amsstop was unable to publish a message on subject 'amsstop' for reasons noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/ams/amsstop/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amsstop/#see-also","title":"SEE ALSO","text":"<p>amsrc(5)</p>"},{"location":"man/ams/amssub/","title":"NAME","text":"<p>amssub - Asynchronous Message Service (AMS) test message receiver for VxWorks</p>"},{"location":"man/ams/amssub/#synopsis","title":"SYNOPSIS","text":"<p>amssub \"application_name\", \"authority_name\", \"subject_name\"</p>"},{"location":"man/ams/amssub/#description","title":"DESCRIPTION","text":"<p>amssub is a message reception program designed to test AMS functionality in a VxWorks environment.  When an amssub task is started, it registers as an application module in the root unit of the venture identified by application_name and authority_name, looks up the subject number for subject_name, subscribes to that subject, and begins receiving and printing messages on that subject until terminated by amsstop.</p> <p>A configuration server for the local continuum and a registrar for the root unit of the indicated venture (which may both be instantiated in a single amsd daemon task) must be running in order for amssub to run.</p>"},{"location":"man/ams/amssub/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>-1</p> <p>amssub terminated with an error as noted in the ion.log file.</p> </li> <li> <p>\"0\"</p> <p>amssub terminated normally.</p> </li> </ul>"},{"location":"man/ams/amssub/#files","title":"FILES","text":"<p>The amssub source code is in the amspubsub.c source file.</p> <p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p>"},{"location":"man/ams/amssub/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/amssub/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>amssub can't register.</p> <p>amssub failed to register, for reasons noted in the ion.log file.</p> </li> <li> <p>amssub: subject is unknown</p> <p>amssub can't subscribe to messages on the specified subject; possibly an error in the MIB initialization file.</p> </li> <li> <p>amssub can't subscribe.</p> <p>amssub failed to subscribe, for reasons noted in the ion.log file.</p> </li> <li> <p>amssub can't get event.</p> <p>amssub failed to receive message, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/amssub/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/amssub/#see-also","title":"SEE ALSO","text":"<p>amspub(1), amsrc(5)</p>"},{"location":"man/ams/amsxml/","title":"NAME","text":"<p>amsxml - CCSDS Asynchronous Message Service MIB initialization XML file</p>"},{"location":"man/ams/amsxml/#description","title":"DESCRIPTION","text":"<p>The Management Information Base (MIB) for an AMS communicating entity (either amsd or an AMS application module) must contain enough information to enable the entity to initiate participation in AMS message exchange, such as the network location of the configuration server and the roles and message subjects defined for some venture.</p> <p>AMS entities automatically load their MIBs from initialization files at startup.  When AMS is built with the -DNOEXPAT compiler option set, the MIB initialization file must conform to the amsrc syntax described in amsrc(5); otherwise the expat XML parsing library must be linked into the AMS executable and the MIB initialization file must conform to the amsxml syntax described below.</p> <p>The XML statements in the MIB initialization file constitute elements of MIB update information, each of which may have one or more attributes.  An element may also have sub-elements that are listed within the declaration of the parent element, and so on.</p> <p>Two types of elements are recognized in the MIB initialization file: control elements and configuration elements.  A control element establishes the update context within which the configuration elements nested within it are processed, while a configuration element declares values for one or more items of AMS configuration information in the MIB.</p> <p>For a discussion of the recognized control elements and configuration elements of the MIB initialization file, see the amsrc(5) man page.  NOTE, though, that all elements of an XML-based MIB initialization file must be sub-elements of a single sub-element of the XML extension type ams_load_mib in order for the file to be parsed successfully by expat.</p>"},{"location":"man/ams/amsxml/#example","title":"EXAMPLE","text":"<p>&lt;?xml version=\"1.0\" standalone=\"yes\"?&gt;</p> <p>&lt;ams_mib_load&gt;</p> <pre><code>    &lt;ams_mib_init continuum_nbr=\"2\" ptsname=\"dgr\"/&gt;\n\n    &lt;ams_mib_add&gt;\n\n            &lt;continuum nbr=\"1\" name=\"apl\" desc=\"APL\"/&gt;\n\n            &lt;csendpoint epspec=\"beaumont.stepsoncats.com:2357\"/&gt;\n\n            &lt;application name=\"amsdemo\" /&gt;\n\n            &lt;venture nbr=\"1\" appname=\"amsdemo\" authname=\"test\"&gt;\n\n                    &lt;role nbr=\"2\" name=\"shell\"/&gt;\n\n                    &lt;role nbr=\"3\" name=\"log\"/&gt;\n\n                    &lt;role nbr=\"4\" name=\"pitch\"/&gt;\n\n                    &lt;role nbr=\"5\" name=\"catch\"/&gt;\n\n                    &lt;role nbr=\"6\" name=\"benchs\"/&gt;\n\n                    &lt;role nbr=\"7\" name=\"benchr\"/&gt;\n\n                    &lt;role nbr=\"96\" name=\"amsd\"/&gt;\n\n                    &lt;role nbr=\"97\" name=\"amsmib\"/&gt;\n\n                    &lt;role nbr=\"98\" name=\"amsstop\"/&gt;\n\n                    &lt;subject nbr=\"1\" name=\"text\" desc=\"ASCII text\"/&gt;\n\n                    &lt;subject nbr=\"2\" name=\"noise\" desc=\"more ASCII text\"/&gt;\n\n                    &lt;subject nbr=\"3\" name=\"bench\" desc=\"numbered msgs\"/&gt;\n\n                    &lt;subject nbr=\"97\" name=\"amsmib\" desc=\"MIB updates\"/&gt;\n\n                    &lt;subject nbr=\"98\" name=\"amsstop\" desc=\"shutdown\"/&gt;\n\n                    &lt;unit nbr=\"1\" name=\"orbiters\"/&gt;\n\n                    &lt;unit nbr=\"2\" name=\"orbiters.near\"/&gt;\n\n                    &lt;unit nbr=\"3\" name=\"orbiters.far\"/&gt;\n\n                    &lt;msgspace nbr=\"2\"/&gt;\n\n            &lt;/venture&gt;\n\n    &lt;/ams_mib_add&gt;\n</code></pre> <p>&lt;/ams_mib_load&gt;</p>"},{"location":"man/ams/amsxml/#see-also","title":"SEE ALSO","text":"<p>amsrc(5)</p>"},{"location":"man/ams/petition_log/","title":"NAME","text":"<p>petition.log - Remote AMS petition log</p>"},{"location":"man/ams/petition_log/#description","title":"DESCRIPTION","text":"<p>The Remote AMS daemon ramsgate records all \"petitions\" (requests for data on behalf of AMS modules in other continua) in a file named petition.log. At startup, the ramsgate daemon automatically reads and processes all petitions in the petition.log file just as if they were received in real time, to re-establish the petition state that was in effect at the time the ramsgate daemon shut down.  Note that this means that you can cause petitions to be, in effect, \"pre-received\" by simply editing this file prior to startup.  This can be an especially effective way to configure a RAMS network in which long signal propagation times would otherwise retard real-time petitioning and thus delay the onset of fully functional message exchange.</p> <p>Entries in petition.log are simple ASCII text lines, with parameters separated by spaces. Each line of petition.log has the following parameters:</p> <ul> <li> <p>protocolId</p> <p>This is a number that identifies the RAMS network protocol characterizing the network on which the petition was received: 1 == DTN Bundle Protocol, 2 = UDP.</p> </li> <li> <p>gatewayID</p> <p>This is a string that identifies the remote RAMS gateway node that issued this petition.</p> </li> <li> <p>controlCode</p> <p>This is a number that indicates whether the petition described by this line is one that is being asserted (2) or canceled (3).</p> </li> <li> <p>subject</p> <p>A number that identifies the subject of the traffic to which the petition pertains.</p> </li> <li> <p>continuumNumber</p> <p>Identifies the continuum for the domain of the petition.</p> </li> <li> <p>unitNumber</p> <p>Identifies the unit for the domain of the petition.</p> </li> <li> <p>roleNumber</p> <p>Identifies the role for the domain of the petition.</p> </li> </ul>"},{"location":"man/ams/petition_log/#see-also","title":"SEE ALSO","text":"<p>ramsgate(1), ams(3)</p>"},{"location":"man/ams/ramsgate/","title":"NAME","text":"<p>ramsgate - Remote AMS gateway daemon</p>"},{"location":"man/ams/ramsgate/#synopsis","title":"SYNOPSIS","text":"<p>ramsgate application_name authority_name [bundles_TTL]</p>"},{"location":"man/ams/ramsgate/#description","title":"DESCRIPTION","text":"<p>ramsgate is a background \"daemon\" task that functions as a Remote AMS gateway.  application_name and authority_name must identify an AMS venture that is known to operate in the local continuum, as noted in the MIB for the ramsgate application module.</p> <p>ramsgate will register as an application module in the root unit of the indicated venture, so a configuration server for the local continuum and a registrar for the root unit of the indicated venture (which may both be instantiated in a single amsd daemon task) must be running in order for ramsgate to commence operations.</p> <p>ramsgate with communicate with other RAMS gateway modules in other continua by means of the RAMS network protocol noted in the RAMS gateway endpoint ID for the local continuum, as identified (explicitly or implicitly) in the MIB.</p> <p>If the RAMS network protocol is \"bp\" (i.e., the DTN Bundle Protocol), then an ION Bundle Protocol node must be operating on the local computer and that node must be registered in the BP endpoint identified by the RAMS gateway endpoint ID for the local continuum.  Moreover, in this case the value of bundles_TTL - if specified - will be taken as the lifetime in seconds that is to be declared for all \"bundles\" issued by ramsgate; bundles_TTL defaults to 86400 seconds (one day) if omitted.</p>"},{"location":"man/ams/ramsgate/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ramsgate terminated normally.</p> </li> <li> <p>\"1\"</p> <p>ramsgate failed, for reasons noted in the ion.log file; the task terminated.</p> </li> </ul>"},{"location":"man/ams/ramsgate/#files","title":"FILES","text":"<p>A MIB initialization file with the applicable default name (see amsrc(5)) must be present.</p> <p>ramsgate records all \"petitions\" (requests for data on behalf of AMS modules in other continua) in a file named \"petition.log\".  At startup, the ramsgate daemon automatically reads and processes all petitions in the petition.log file just as if they were received in real time.  Note that this means that you can cause petitions to be, in effect, \"pre-received\" by simply editing this file prior to startup.  This can be an especially effective way to configure a RAMS network in which long signal propagation times would otherwise retard real-time petitioning and thus delay the onset of fully functional message exchange.</p>"},{"location":"man/ams/ramsgate/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ams/ramsgate/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ramsgate can't run.</p> <p>RAMS gateway functionality failed, for reasons noted in the ion.log file.</p> </li> </ul>"},{"location":"man/ams/ramsgate/#bugs","title":"BUGS","text":"<p>Note that the AMS design principle of receiving messages immediately and enqueuing them for eventual ingestion by the application module - rather than imposing application-layer flow control on AMS message traffic - enables high performance but makes ramsgate vulnerable to message spikes.  Since production and transmission of bundles is typically slower than AMS message reception over TCP service, the ION working memory and/or heap space available for AMS event insertion and/or bundle production can be quickly exhausted if a high rate of application message production is sustained for a long enough time.  Mechanisms for defending against this sort of failure are under study, but for now the best mitigations are simply to (a) build with compiler option -DAMS_INDUSTRIAL=1, (b) allocate as much space as possible to ION working memory and SDR heap (see ionconfig(5)) and (c) limit the rate of AMS message issuance.</p> <p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ams/ramsgate/#see-also","title":"SEE ALSO","text":"<p>amsrc(5), petition_log(5)</p>"},{"location":"man/bpv6/","title":"Index of Man Pages","text":"<ul> <li>acsadmin</li> <li>acslist</li> <li>acsrc</li> <li>bibeclo</li> <li>bp</li> <li>bpadmin</li> <li>bpcancel</li> <li>bpchat</li> <li>bpclm</li> <li>bpclock</li> <li>bpcounter</li> <li>bpdriver</li> <li>bpecho</li> <li>bpextensions</li> <li>bping</li> <li>bplist</li> <li>bpnmtest</li> <li>bprc</li> <li>bprecvfile</li> <li>bpsecadmin</li> <li>bpsecrc</li> <li>bpsendfile</li> <li>bpsink</li> <li>bpsource</li> <li>bpstats</li> <li>bpstats2</li> <li>bptrace</li> <li>bptransit</li> <li>brsccla</li> <li>brsscla</li> <li>cgrfetch</li> <li>dccpcli</li> <li>dccpclo</li> <li>dgrcli</li> <li>dgrclo</li> <li>dtn2admin</li> <li>dtn2adminep</li> <li>dtn2fw</li> <li>dtn2rc</li> <li>hmackeys</li> <li>imcadmin</li> <li>imcfw</li> <li>imcrc</li> <li>ipnadmin</li> <li>ipnadminep</li> <li>ipnd</li> <li>ipnfw</li> <li>ipnrc</li> <li>lgagent</li> <li>lgfile</li> <li>lgsend</li> <li>ltpcli</li> <li>ltpclo</li> <li>stcpcli</li> <li>stcpclo</li> <li>tcpcli</li> <li>tcpclo</li> <li>udpcli</li> <li>udpclo</li> </ul>"},{"location":"man/bpv6/acsadmin/","title":"NAME","text":"<p>acsadmin - ION Aggregate Custody Signal (ACS) administration interface</p>"},{"location":"man/bpv6/acsadmin/#synopsis","title":"SYNOPSIS","text":"<p>acsadmin [ commands_filename ]</p>"},{"location":"man/bpv6/acsadmin/#description","title":"DESCRIPTION","text":"<p>acsadmin configures aggregate custody signal behavior for the local ION node.</p> <p>It operates in response to ACS configuration commands found in the file commands_filename, if provided; if not, acsadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from acsadmin with the 'h' or '?' commands at the prompt.  The commands are documented in acsrc(5).</p>"},{"location":"man/bpv6/acsadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of ACS administration.</li> </ul>"},{"location":"man/bpv6/acsadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>acsadmin</p> <p>Enter interactive ACS configuration command entry mode.</p> </li> <li> <p>acsadmin host1.acs</p> <p>Execute all configuration commands in host1.acs, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv6/acsadmin/#files","title":"FILES","text":"<p>See acsrc(5) for details of the ACS configuration commands.</p>"},{"location":"man/bpv6/acsadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/acsadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the acsrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to acsadmin.  Otherwise acsadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>acsadmin can't attach to ION.</p> <p>There is no SDR data store for acsadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause acsadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see acsrc(5) for details.</p>"},{"location":"man/bpv6/acsadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/acsadmin/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1), bpadmin(1), acsrc(5)</p>"},{"location":"man/bpv6/acslist/","title":"NAME","text":"<p>acslist - Aggregate Custody Signals (ACS) utility for checking custody IDs.</p>"},{"location":"man/bpv6/acslist/#synopsis","title":"SYNOPSIS","text":"<p>acslist [-s|--stdout]</p>"},{"location":"man/bpv6/acslist/#description","title":"DESCRIPTION","text":"<p>acslist is a utility program that lists all mappings from bundle ID to custody ID currently in the local bundle agent's ACS ID database, in no specific order.  A bundle ID (defined in RFC5050) is the tuple of (source EID, creation time, creation count, fragment offset, fragment length). A custody ID (defined in draft-jenkins-aggregate-custody-signals) is an integer that the local bundle agent will be able to map to a bundle ID for the purposes of aggregating and compressing custody signals.</p> <p>The format for mappings is:</p> <p>(ipn:13.1,333823688,95,0,0)-&gt;(26)</p> <p>While listing, acslist also checks the custody ID database for self-consistency, and if it detects any errors it will print a line starting with \"Mismatch:\" and describing the error.</p> <p>-s|--stdout tells acslist to print results to stdout, rather than to the ION log.</p>"},{"location":"man/bpv6/acslist/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>acslist terminated after verifying the consistency of the custody ID database.</p> </li> <li> <p>\"1\"</p> <p>acslist was unable to attach to the ACS database, or it detected an inconsistency.</p> </li> </ul>"},{"location":"man/bpv6/acslist/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/acslist/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/acslist/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued:</p> <ul> <li> <p>Can't attach to ACS.</p> <p>acsadmin has not yet initialized ACS operations.</p> </li> <li> <p>Mismatch: (description of the mismatch)</p> <p>acslist detected an inconsistency in the database; this is a bug in ACS.</p> </li> </ul>"},{"location":"man/bpv6/acslist/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/acslist/#see-also","title":"SEE ALSO","text":"<p>acsadmin(1), bplist(1)</p>"},{"location":"man/bpv6/acsrc/","title":"NAME","text":"<p>acsrc - Aggregate Custody Signal management commands file</p>"},{"location":"man/bpv6/acsrc/#description","title":"DESCRIPTION","text":"<p>Aggregate Custody Signal management commands are passed to acsadmin either in a file of text lines or interactively at acsadmin's command prompt (:). Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the Aggregate Custody Signal management commands are described below.</p>"},{"location":"man/bpv6/acsrc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by acsadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1 &lt;logLevel&gt; [&lt;heapWords&gt;]</p> <p>The initialize command.  Until this command is executed, Aggregate Custody Signals are not in operation on the local ION node and most acsadmin commands will fail.</p> <p>The logLevel argument specifies at which log level the ACS appending and transmitting implementation should record its activity to the ION log file. This argument is the bitwise \"OR\" of the following log levels:</p> <ul> <li> <p>0x01  ERROR</p> <p>Errors in ACS programming are logged.</p> </li> <li> <p>0x02  WARN</p> <p>Warnings like \"out of memory\" that don't cause ACS to fail but may change behavior are logged.</p> </li> <li> <p>0x04  INFO</p> <p>Informative information like \"this custody signal is a duplicate\" is logged.</p> </li> <li> <p>0x08  DEBUG</p> <p>Verbose information like the state of the pending ACS tree is logged.</p> </li> </ul> <p>The optional heapWords argument informs ACS to allocate that many heap words in its own DRAM SDR for constructing pending ACS.  If not supplied, the  default value 10000 is used.  Once all ACS SDR is allocated, any incoming custodial bundles that would trigger an ACS will trigger a normal, non-aggregate custody signal instead, until ACS SDR is freed.  If your node intermittently emits non-aggregate custody signals when it should emit ACS, you should increase heapWords.</p> <p>Since ACS uses SDR only for emitting Aggregate Custody Signals, ION can still receive ACS even if this command is not executed, or all ACS SDR memory is allocated.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> <li> <p>s &lt;minimumCustodyId&gt;</p> <p>This command sets the minimum custody ID that the local bundle agent may use in custody transfer enhancement blocks that it emits.  These custody IDs must be unique in the network (for the lifetime of the bundles to which they refer).</p> <p>The minimumCustodyId provided is stored in SDR, and incremented every time a new custody ID is required.  So, this command should be used only when the local bundle agent has discarded its SDR and restarted.</p> </li> <li> <p>t &lt;acsBundleLifetime&gt;</p> <p>This command sets the lifetime that will be asserted for every ACS bundle subsequently issued by the local bundle agent.  The new acsBundleLifetime is stored in SDR.</p> </li> </ul>"},{"location":"man/bpv6/acsrc/#custodian-commands","title":"CUSTODIAN COMMANDS","text":"<ul> <li> <p>a custodianEid acsSize [acsDelay]</p> <p>The add custodian command.  This command provides information about the ACS characteristics of a remote custodian.  custodianEid is the custodian EID for which this command is providing information.  acsSize is the preferred size of ACS bundles sent to custodianEid; ACS bundles this implementation sends to custodianEid will aggregate until ACS are at most acsSize bytes (if acsSize is smaller than 19 bytes, some ACS containing only one signal will exceed acsSize and be sent anyways; setting acsSize to 0 causes \"aggregates\" of only 1 signal to be sent).</p> <p>acsDelay is the maximum amount of time to delay an ACS destined for this custodian before sending it, in seconds; if not specified, the default value 15 will be used.</p> </li> </ul>"},{"location":"man/bpv6/acsrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a ipn:15.0 100 27</p> <p>Informs ACS on the local node that the local node should send ACS bundles destined for the custodian ipn:15.0 whenever they are 100 bytes in size or have been delayed for 27 seconds, whichever comes first.</p> </li> </ul>"},{"location":"man/bpv6/acsrc/#see-also","title":"SEE ALSO","text":"<p>acsadmin(1)</p>"},{"location":"man/bpv6/bibeclo/","title":"NAME","text":"<p>bibeclo - BP convergence layer output task using bundle-in-bundle encapsulation</p>"},{"location":"man/bpv6/bibeclo/#synopsis","title":"SYNOPSIS","text":"<p>bibeclo peer_node_eid destination_node_eid</p>"},{"location":"man/bpv6/bibeclo/#description","title":"DESCRIPTION","text":"<p>bibeclo is a background \"daemon\" task that extracts bundles from the queues of bundles ready for transmission to destination_node_eid via bundle-in-bundle encapsulation (BIBE), encapsulates them in BP administrative records of (non-standard) record type 7 (BP_ENCAPSULATED_BUNDLE), and sends those administrative records to the DTN node identified by peer_node_eid. The receiving node is expected to process these received administrative records by simply dispatching the encapsulated bundles as if they had been received from neighboring nodes in the normal course of operations.</p> <p>bibeclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  bibeclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the BIBE convergence layer protocol.</p>"},{"location":"man/bpv6/bibeclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bibeclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart bibeclo.</p> </li> <li> <p>\"1\"</p> <p>bibeclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart bibeclo.</p> </li> </ul>"},{"location":"man/bpv6/bibeclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bibeclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bibeclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bibeclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such bibe duct.</p> <p>No BIBE outduct with duct name destination_node_eid has been added to the BP database.  Use bpadmin to stop the BIBE convergence-layer protocol, add the outduct, and then restart the BIBE protocol.</p> </li> <li> <p>No such bcla.</p> <p>No BIBE convergence layer adapter named peer_node_eid has been added to the BIBE database.  Use bibeadmin to add the BCLA.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of bibeclo.</p> </li> <li> <p>Can't prepend header; CLO stopping.</p> <p>This is a system error.  Check ION log, correct problem, and restart BIBE.</p> </li> <li> <p>Can't send encapsulated bundle; CLO stopping.</p> <p>This is a system error.  Check ION log, correct problem, and restart BIBE.</p> </li> <li> <p>[!] Encapsulated bundle not sent.</p> <p>Malformed bundle issuance request, which might be a software error.  Contact technical support.</p> </li> </ul>"},{"location":"man/bpv6/bibeclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bibeclo/#see-also","title":"SEE ALSO","text":"<p>bibeadmin(1), bp(3), biberc(5)</p>"},{"location":"man/bpv6/bp/","title":"NAME","text":"<p>bp - Bundle Protocol communications library</p>"},{"location":"man/bpv6/bp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"bp.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/bpv6/bp/#description","title":"DESCRIPTION","text":"<p>The bp library provides functions enabling application software to use Bundle Protocol to send and receive information over a delay-tolerant network.  It conforms to the Bundle Protocol specification as documented in Internet RFC 5050.</p> <ul> <li> <p>int bp_attach( )</p> <p>Attaches the application to BP functionality on the local computer.  Returns 0 on success, -1 on any error.</p> <p>Note that all ION libraries and applications draw memory dynamically, as needed, from a shared pool of ION working memory.  The size of the pool is established when ION node functionality is initialized by ionadmin(1).  This is a precondition for initializing BP functionality by running bpadmin(1), which in turn is required in order for bp_attach() to succeed.</p> </li> <li> <p>Sdr bp_get_sdr( )</p> <p>Returns handle for the SDR data store used for BP, to enable creation and interrogation of bundle payloads (application data units).</p> </li> <li> <p>void bp_detach( )</p> <p>Terminates all access to BP functionality on the local computer.</p> </li> <li> <p>int bp_open(char *eid, BpSAP *ionsapPtr)</p> <p>Opens the application's access to the BP endpoint identified by eid, so that the application can take delivery of bundles destined for the indicated endpoint.  This SAP can also be used for sending bundles whose source is the indicated endpoint; all bundles sent via this SAP will be subject to immediate destruction upon transmission, i.e., no bundle addresses will be returned by bp_send() for use in tracking, suspending/resuming, or cancelling transmission of these bundles.  On success, places a value in *ionsapPtr that can be supplied to future bp function invocations and returns 0.  Returns -1 on any error.</p> </li> <li> <p>int bp_open_source(char *eid, BpSAP *ionsapPtr, detain)</p> <p>Opens the application's access to the BP endpoint identified by eid, so that the application can send bundles whose source is the indicated endpoint.  If and only if the value of detain is non-zero, citing this SAP in an invocation of bp_send() will cause the address of the newly issued bundle to be returned for use in tracking, suspending/resuming, or cancelling transmission of this bundle.  USE THIS FEATURE WITH GREAT CARE: such a bundle will continue to occupy storage resources until it is explicitly released by an invocation of bp_release() or until its time to live expires, so bundle detention increases the risk of resource exhaustion. (If the value of detain is zero, all bundles sent via this SAP will be subject to immediate destruction upon transmission.)  On success, places a value in *ionsapPtr that can be supplied to future bp function invocations and returns 0.  Returns -1 on any error.</p> </li> <li> <p>int bp_send(BpSAP sap, char *destEid, char *reportToEid, int lifespan, int classOfService, BpCustodySwitch custodySwitch, unsigned char srrFlags, int ackRequested, BpAncillaryData *ancillaryData, Object adu, Object *newBundle)</p> <p>Sends a bundle to the endpoint identified by destEid, from the source endpoint as provided to the bp_open() call that returned sap. When sap is NULL, the transmitted bundle is anonymous, i.e., the source of the bundle is not identified.  This is legal, but anonymous bundles cannot be uniquely identified; custody transfer and status reporting therefore cannot be requested for an anonymous bundle.</p> <p>reportToEid identifies the endpoint to which any status reports pertaining to this bundle will be sent; if NULL, defaults to the source endpoint.</p> <p>lifespan is the maximum number of seconds that the bundle can remain in-transit (undelivered) in the network prior to automatic deletion.</p> <p>classOfService is simply priority for now: BP_BULK_PRIORITY, BP_STD_PRIORITY, or BP_EXPEDITED_PRIORITY.  If class-of-service flags are defined in a future version of Bundle Protocol, those flags would be OR'd with priority.</p> <p>custodySwitch indicates whether or not custody transfer is requested for this bundle and, if so, whether or not the source node itself is required to be the initial custodian.  The valid values are SourceCustodyRequired, SourceCustodyOptional, NoCustodyRequired.  Note that custody transfer is possible only for bundles that are uniquely identified, so it cannot be requested for bundles for which BP_MINIMUM_LATENCY is requested, since BP_MINIMUM_LATENCY may result in the production of multiple identical copies of the same bundle.  Similarly, custody transfer should never be requested for a \"loopback\" bundle, i.e., one whose destination node is the same as the source node: the received bundle will be identical to the source bundle, both residing in the same node, so no custody acceptance signal can be applied to the source bundle and the source bundle will remain in storage until its TTL expires.</p> <p>srrFlags, if non-zero, is the logical OR of the status reporting behaviors requested for this bundle: BP_RECEIVED_RPT, BP_CUSTODY_RPT, BP_FORWARDED_RPT, BP_DELIVERED_RPT, BP_DELETED_RPT.</p> <p>ackRequested is a Boolean parameter indicating whether or not the recipient application should be notified that the source application requests some sort of application-specific end-to-end acknowledgment upon receipt of the bundle.</p> <p>ancillaryData, if not NULL, is used to populate the Extended Class Of Service block for this bundle.  The block's ordinal value is used to provide fine-grained ordering within \"expedited\" traffic: ordinal values from 0 (the default) to 254 (used to designate the most urgent traffic) are valid, with 255 reserved for custody signals.  The value of the block's flags is the logical OR of the applicable extended class-of-service flags:</p> <pre><code>BP\\_MINIMUM\\_LATENCY designates the bundle as \"critical\" for the\npurposes of Contact Graph Routing.\n\nBP\\_BEST\\_EFFORT signifies that non-reliable convergence-layer protocols, as\navailable, may be used to transmit the bundle.  Notably, the bundle may be\nsent as \"green\" data rather than \"red\" data when issued via LTP.\n\nBP\\_DATA\\_LABEL\\_PRESENT signifies whether or not the value of _dataLabel_\nin _ancillaryData_ must be encoded into the ECOS block when the bundle is\ntransmitted.\n</code></pre> <p>adu is the \"application data unit\" that will be conveyed as the payload of the new bundle.  adu must be a \"zero-copy object\" (ZCO).  To ensure orderly access to transmission buffer space for all applications, adu must be created by invoking ionCreateZco(), which may be configured either to block so long as insufficient ZCO storage space is available for creation of the requested ZCO or to fail immediately if insufficient ZCO storage space is available.</p> <p>The function returns 1 on success, 0 on user error, -1 on any system error.  If 0 is returned, then an invalid argument value was passed to bp_send(); a message to this effect will have been written to the log file. If 1 is returned, then either the destination of the bundle was \"dtn:none\" (the bit bucket) or the ADU has been accepted and queued for transmission in a bundle.  In the latter case, if and only if sap was a reference to a BpSAP returned by an invocation of bp_open_source() that had a non-zero value in the detain parameter, then newBundle must be non-NULL and the address of the newly created bundle within the ION database is placed in newBundle.  This address can be used to track, suspend/resume, or cancel transmission of the bundle.</p> </li> <li> <p>int bp_track(Object bundle, Object trackingElt)</p> <p>Adds trackingElt to the list of \"tracking\" references in bundle. trackingElt must be the address of an SDR list element -- whose data is the address of this same bundle -- within some list of bundles that is privately managed by the application.  Upon destruction of the bundle this list element will automatically be deleted, thus removing the bundle from the application's privately managed list of bundles.  This enables the application to keep track of bundles that it is operating on without risk of inadvertently de-referencing the address of a nonexistent bundle. </p> </li> <li> <p>void bp_untrack(Object bundle, Object trackingElt)</p> <p>Removes trackingElt from the list of \"tracking\" references in bundle, if it is in that list.  Does not delete trackingElt itself.</p> </li> <li> <p>int bp_memo(Object bundle, unsigned int interval)</p> <p>Implements custodial retransmission.  This function inserts a \"custody-acceptance due\" event into the timeline.  The event causes the indicated bundle to be re-forwarded if it is still in the database (i.e., it has not yet been accepted by another custodian) as of the time computed by adding the indicated interval to the current time.</p> </li> <li> <p>int bp_suspend(Object bundle)</p> <p>Suspends transmission of bundle.  Has no effect if bundle is \"critical\" (i.e., has got extended class of service BP_MINIMUM_LATENCY flag set) or if the bundle is already suspended.  Otherwise, reverses the enqueuing of the bundle to its selected transmission outduct and places it in the \"limbo\" queue until the suspension is lifted by calling bp_resume.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_resume(Object bundle)</p> <p>Terminates suspension of transmission of bundle.  Has no effect if bundle is \"critical\" (i.e., has got extended class of service BP_MINIMUM_LATENCY flag set) or is not suspended.  Otherwise, removes the bundle from the \"limbo\" queue and queues it for route re-computation and re-queuing.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_cancel(Object bundle)</p> <p>Cancels transmission of bundle.  If the indicated bundle is currently queued for forwarding, transmission, or retransmission, it is removed from the relevant queue and destroyed exactly as if its Time To Live had expired.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_release(Object bundle)</p> <p>Releases a detained bundle for destruction when all retention constraints have been removed.  After a detained bundle has been released, the application can no longer track, suspend/resume, or cancel its transmission.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_receive(BpSAP sap, BpDelivery *dlvBuffer, int timeoutSeconds)</p> <p>Receives a bundle, or reports on some failure of bundle reception activity.</p> <p>The \"result\" field of the dlvBuffer structure will be used to indicate the outcome of the data reception activity.</p> <p>If at least one bundle destined for the endpoint for which this SAP is opened has not yet been delivered to the SAP, then the payload of the oldest such bundle will be returned in dlvBuffer-&gt;adu and dlvBuffer-&gt;result will be set to BpPayloadPresent.  If there is no such bundle, bp_receive() blocks for up to timeoutSeconds while waiting for one to arrive.</p> <p>If timeoutSeconds is BP_POLL (i.e., zero) and no bundle is awaiting delivery, or if timeoutSeconds is greater than zero but no bundle arrives before timeoutSeconds have elapsed, then dlvBuffer-&gt;result will be set to BpReceptionTimedOut.  If timeoutSeconds is BP_BLOCKING (i.e., -1) then bp_receive() blocks until either a bundle arrives or the function is interrupted by an invocation of bp_interrupt().</p> <p>dlvBuffer-&gt;result will be set to BpReceptionInterrupted in the event that the calling process received and handled some signal other than SIGALRM while waiting for a bundle.</p> <p>dlvBuffer-&gt;result will be set to BpEndpointStopped in the event that the operation of the indicated endpoint has been terminated.</p> <p>The application data unit delivered in the data delivery structure, if any, will be a \"zero-copy object\" reference.  Use zco reception functions (see zco(3)) to read the content of the application data unit.</p> <p>Be sure to call bp_release_delivery() after every successful invocation of bp_receive().</p> <p>The function returns 0 on success, -1 on any error.</p> </li> <li> <p>void bp_interrupt(BpSAP sap)</p> <p>Interrupts a bp_receive() invocation that is currently blocked.  This function is designed to be called from a signal handler; for this purpose, sap may need to be obtained from a static variable.</p> </li> <li> <p>void bp_release_delivery(BpDelivery *dlvBuffer, int releaseAdu)</p> <p>Releases resources allocated to the indicated delivery.  releaseAdu is a Boolean parameter: if non-zero, the ADU ZCO reference in dlvBuffer (if any) is destroyed, causing the ZCO itself to be destroyed if no other references to it remain.</p> </li> <li> <p>void bp_close(BpSAP sap)</p> <p>Terminates the application's access to the BP endpoint identified by the eid cited by the indicated service access point.  The application relinquishes its ability to take delivery of bundles destined for the indicated endpoint and to send bundles whose source is the indicated endpoint.</p> </li> </ul>"},{"location":"man/bpv6/bp/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), lgsend(1), lgagent(1), bpextensions(3), bprc(5), lgfile(5)</p>"},{"location":"man/bpv6/bpadmin/","title":"NAME","text":"<p>bpadmin - ION Bundle Protocol (BP) administration interface</p>"},{"location":"man/bpv6/bpadmin/#synopsis","title":"SYNOPSIS","text":"<p>bpadmin [ commands_filename | . | ! ]</p>"},{"location":"man/bpv6/bpadmin/#description","title":"DESCRIPTION","text":"<p>bpadmin configures, starts, manages, and stops bundle protocol operations for the local ION node.</p> <p>It operates in response to BP configuration commands found in the file commands_filename, if provided; if not, bpadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to bpadmin -- that is, the ION node's bpclock task,  forwarder tasks, and convergence layer adapter tasks are stopped. If commands_filename is an exclamation point (!), that effect is reversed: the ION node's bpclock task, forwarder tasks, and convergence layer adapter tasks are restarted.</p> <p>The format of commands for commands_filename can be queried from bpadmin with the 'h' or '?' commands at the prompt.  The commands are documented in bprc(5).</p>"},{"location":"man/bpv6/bpadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of BP administration.</li> </ul>"},{"location":"man/bpv6/bpadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>bpadmin</p> <p>Enter interactive BP configuration command entry mode.</p> </li> <li> <p>bpadmin host1.bp</p> <p>Execute all configuration commands in host1.bp, then terminate immediately.</p> </li> <li> <p>bpadmin .</p> <p>Stop all bundle protocol operations on the local node.</p> </li> </ul>"},{"location":"man/bpv6/bpadmin/#files","title":"FILES","text":"<p>See bprc(5) for details of the BP configuration commands.</p>"},{"location":"man/bpv6/bpadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the bprc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to bpadmin.  Otherwise bpadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>ION can't set custodian EID information.</p> <p>The custodial_endpoint_id specified in the BP initialization ('1') command is malformed.  Remember that the format for this argument is  ipn:element_number.0 and that the final 0 is required, as  custodial/administration service is always service 0.  Additional detail for this error is provided if one of the following other errors is present:</p> <pre><code>Malformed EID.\n\nMalformed custodian EID.\n</code></pre> </li> <li> <p>bpadmin can't attach to ION.</p> <p>There is no SDR data store for bpadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause bpadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see bprc(5) for details.</p>"},{"location":"man/bpv6/bpadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpadmin/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1), bprc(5), ipnadmin(1), ipnrc(5), dtnadmin(1), dtnrc(5)</p>"},{"location":"man/bpv6/bpcancel/","title":"NAME","text":"<p>bpcancel - Bundle Protocol (BP) bundle cancellation utility</p>"},{"location":"man/bpv6/bpcancel/#synopsis","title":"SYNOPSIS","text":"<p>bpcancel source_EID creation_seconds [creation_count [fragment_offset [fragment_length]]]</p>"},{"location":"man/bpv6/bpcancel/#description","title":"DESCRIPTION","text":"<p>bpcancel attempts to locate the bundle identified by the command-line parameter values and cancel transmission of this bundle.  Bundles for which multiple copies have been queued for transmission can't be canceled, because one or more of those copies might already have been transmitted.  Transmission of a bundle that has never been cloned and that is still in local bundle storage is cancelled by simulation of an immediate time-to-live expiration.</p>"},{"location":"man/bpv6/bpcancel/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpcancel has terminated.</p> </li> </ul>"},{"location":"man/bpv6/bpcancel/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpcancel/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpcancel/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>bpcancel failed finding bundle.</p> <p>The attempt to locate the subject bundle failed due to some serious system error.  It will probably be necessary to terminate and re-initialize the local ION node.</p> </li> <li> <p>bpcancel failed destroying bundle.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bpcancel failed.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> </ul>"},{"location":"man/bpv6/bpcancel/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpcancel/#see-also","title":"SEE ALSO","text":"<p>bplist(1)</p>"},{"location":"man/bpv6/bpchat/","title":"NAME","text":"<p>bpchat - Bundle Protocol chat test program</p>"},{"location":"man/bpv6/bpchat/#synopsis","title":"SYNOPSIS","text":"<p>bpchat sourceEID destEID [ct]</p>"},{"location":"man/bpv6/bpchat/#description","title":"DESCRIPTION","text":"<p>bpchat uses Bundle Protocol to send input text in bundles, and display the payload of received bundles as output.  It is similar to the talk utility, but operates over the Bundle Protocol.  It operates like a combination of the bpsource and bpsink utilities in one program (unlike bpsource,  bpchat emits bundles with a sourceEID).</p> <p>If the sourceEID and destEID are both bpchat applications, then two users can chat with each other over the Bundle Protocol: lines that one user types on the keyboard will be transported over the network in bundles and displayed on the screen of the other user (and the reverse).</p> <p>bpchat terminates upon receiving the SIGQUIT signal, i.e., ^C from the keyboard.</p>"},{"location":"man/bpv6/bpchat/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpchat has terminated normally.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>bpchat has terminated due to a BP transmit or reception failure.  Details should be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bpchat/#options","title":"OPTIONS","text":"<ul> <li> \\[ct\\] <p>If the string \"ct\" is appended as the last argument, then bundles will be sent with custody transfer requested.</p> </li> </ul>"},{"location":"man/bpv6/bpchat/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpchat/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpchat/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpchat are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpchat bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpchat can't send echo bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bpchat/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpchat/#see-also","title":"SEE ALSO","text":"<p>bpecho(1), bpsource(1), bpsink(1), bp(3)</p>"},{"location":"man/bpv6/bpclm/","title":"NAME","text":"<p>bpclm - DTN bundle protocol convergence layer management daemon</p>"},{"location":"man/bpv6/bpclm/#synopsis","title":"SYNOPSIS","text":"<p>bpclm neighboring_node_ID</p>"},{"location":"man/bpv6/bpclm/#description","title":"DESCRIPTION","text":"<p>bpclm is a background \"daemon\" task that manages the transmission of bundles to a single designated neighboring node (as constrained by an \"egress plan\" data structure for that node) by one or more convergence-layer (CL) adapter output daemons (via buffer structures called \"outducts\").</p> <p>bpclm is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  bpclm can also be spawned and terminated in response to commands that START and STOP the corresponding node's egress plan.</p>"},{"location":"man/bpv6/bpclm/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpclm terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the egress plan for this node.</p> </li> <li> <p>\"1\"</p> <p>bpclm terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the egress plan for this node.</p> </li> </ul>"},{"location":"man/bpv6/bpclm/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpclm/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpclm/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpclm can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No egress plan for this node</p> <p>No egress plan for the node identified by neighboring_node_ID has been added to the BP database.  Use bpadmin to add and start the plan.</p> </li> <li> <p>bpclm task is already started for this node</p> <p>Redundant initiation of bpclm.</p> </li> </ul>"},{"location":"man/bpv6/bpclm/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpclm/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv6/bpclock/","title":"NAME","text":"<p>bpclock - Bundle Protocol (BP) daemon task for managing scheduled events</p>"},{"location":"man/bpv6/bpclock/#synopsis","title":"SYNOPSIS","text":"<p>bpclock</p>"},{"location":"man/bpv6/bpclock/#description","title":"DESCRIPTION","text":"<p>bpclock is a background \"daemon\" task that periodically performs scheduled Bundle Protocol activities.  It is spawned automatically by bpadmin in response to the 's' command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.</p> <p>Once per second, bpclock takes the following action:</p> <p>First it (a) destroys all bundles whose TTLs have expired, (b) enqueues for re-forwarding all bundles that were expected to have been transmitted (by convergence-layer output tasks) by now but are still stuck in their assigned transmission queues, and (c) enqueues for re-forwarding all bundles for which custody has not yet been taken that were expected to have been received and acknowledged by now (as noted by invocation of the bpMemo() function by some convergence-layer adapter that had CL-specific insight into the appropriate interval to wait for custody acceptance).</p> <p>Then bpclock adjusts the transmission and reception \"throttles\" that control rates of LTP transmission to and reception from neighboring nodes, in response to data rate changes as noted in the RFX database by rfxclock.</p> <p>bpclock then checks for bundle origination activity that has been blocked due to insufficient allocated space for BP traffic in the ION data store: if space for bundle origination is now available, bpclock gives the bundle production throttle semaphore to unblock that activity.</p> <p>Finally, bpclock applies rate control to all convergence-layer protocol inducts and outducts:</p> <p>For each induct, bpclock increases the current capacity of the duct by the applicable nominal data reception rate.  If the revised current capacity is greater than zero, bpclock gives the throttle's semaphore to unblock data acquisition (which correspondingly reduces the current capacity of the duct) by the associated convergence layer input task.</p> <p>For each outduct, bpclock increases the current capacity of the duct by the applicable nominal data transmission rate.  If the revised current capacity is greater than zero, bpclock gives the throttle's semaphore to unblock data transmission (which correspondingly reduces the current capacity of the duct) by the associated convergence layer output task.</p>"},{"location":"man/bpv6/bpclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart bpclock.</p> </li> <li> <p>\"1\"</p> <p>bpclock was unable to attach to Bundle Protocol operations, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv6/bpclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpclock can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't dispatch events.</p> <p>An unrecoverable database error was encountered.  bpclock terminates.</p> </li> <li> <p>Can't adjust throttles.</p> <p>An unrecoverable database error was encountered.  bpclock terminates.</p> </li> </ul>"},{"location":"man/bpv6/bpclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpclock/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), rfxclock(1)</p>"},{"location":"man/bpv6/bpcounter/","title":"NAME","text":"<p>bpcounter - Bundle Protocol reception test program</p>"},{"location":"man/bpv6/bpcounter/#synopsis","title":"SYNOPSIS","text":"<p>bpcounter ownEndpointId [maxCount]</p>"},{"location":"man/bpv6/bpcounter/#description","title":"DESCRIPTION","text":"<p>bpcounter uses Bundle Protocol to receive application data units from a remote bpdriver application task.  When the total number of application data units it has received exceeds maxCount, it terminates and prints its reception count.  If maxCount is omitted, the default limit is 2 billion application data units.</p>"},{"location":"man/bpv6/bpcounter/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpcounter has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bpcounter/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpcounter/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpcounter/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpcounter are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpcounter bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bpcounter/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpcounter/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpdriver(1), bpecho(1), bp(3)</p>"},{"location":"man/bpv6/bpdriver/","title":"NAME","text":"<p>bpdriver - Bundle Protocol transmission test program</p>"},{"location":"man/bpv6/bpdriver/#synopsis","title":"SYNOPSIS","text":"<p>bpdriver nbrOfCycles ownEndpointId destinationEndpointId [length] [t_TTL_]</p>"},{"location":"man/bpv6/bpdriver/#description","title":"DESCRIPTION","text":"<p>bpdriver uses Bundle Protocol to send nbrOfCycles application data units of length indicated by length, to a counterpart application task that has opened the BP endpoint identified by destinationEndpointId.</p> <p>If omitted, length defaults to 60000.  </p> <p>TTL indicates the number of seconds the bundles may remain in the network, undelivered, before they are automatically destroyed. If omitted, TTL defaults to 300 seconds.</p> <p>bpdriver normally runs in \"echo\" mode: after sending each bundle it waits for an acknowledgment bundle before sending the next one.  For this purpose, the counterpart application task should be bpecho.</p> <p>Alternatively bpdriver can run in \"streaming\" mode, i.e., without expecting or receiving acknowledgments.  Streaming mode is enabled when length is specified as a negative number, in which case the additive inverse of length is used as the effective value of length.  For this purpose, the counterpart application task should be bpcounter.</p> <p>If the effective value of length is 1, the sizes of the transmitted service data units will be randomly selected multiples of 1024 in the range 1024 to 62464.</p> <p>bpdriver normally runs with custody transfer disabled.  To request custody transfer for all bundles sent by bpdriver, specify nbrOfCycles as a negative number; the additive inverse of nbrOfCycles will be used as its effective value in this case.</p> <p>When all copies of the file have been sent, bpdriver prints a performance report.</p>"},{"location":"man/bpv6/bpdriver/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpdriver has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bpdriver/#files","title":"FILES","text":"<p>The service data units transmitted by bpdriver are sequences of text obtained from a file in the current working directory named \"bpdriverAduFile\", which bpdriver creates automatically.</p>"},{"location":"man/bpv6/bpdriver/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpdriver/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpdriver are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>Can't create ADU file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Error writing to ADU file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>bpdriver can't create file ref.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpdriver can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpdriver can't send message</p> <p>Bundle Protocol service to the remote endpoint has been stopped.</p> </li> <li> <p>bpdriver reception failed</p> <p>bpdriver is in \"echo\" mode, and Bundle Protocol delivery service has been stopped.</p> </li> </ul>"},{"location":"man/bpv6/bpdriver/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpdriver/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpcounter(1), bpecho(1), bp(3)</p>"},{"location":"man/bpv6/bpecho/","title":"NAME","text":"<p>bpecho - Bundle Protocol reception test program</p>"},{"location":"man/bpv6/bpecho/#synopsis","title":"SYNOPSIS","text":"<p>bpecho ownEndpointId</p>"},{"location":"man/bpv6/bpecho/#description","title":"DESCRIPTION","text":"<p>bpecho uses Bundle Protocol to receive application data units from a remote bpdriver application task.  In response to each received application data unit it sends back an \"echo\" application data unit of length 2, the NULL-terminated string \"x\".</p> <p>bpecho terminates upon receiving the SIGQUIT signal, i.e., ^C from the keyboard.</p>"},{"location":"man/bpv6/bpecho/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpecho has terminated normally.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>bpecho has terminated due to a BP reception failure.  Details should be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bpecho/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpecho/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpecho/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpecho are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpecho bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpecho can't send echo bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bpecho/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpecho/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpdriver(1), bpcounter(1), bp(3)</p>"},{"location":"man/bpv6/bpextensions/","title":"NAME","text":"<p>bpextensions - interface for adding extensions to Bundle Protocol</p>"},{"location":"man/bpv6/bpextensions/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"bpextensions.c\"\n</code></pre>"},{"location":"man/bpv6/bpextensions/#description","title":"DESCRIPTION","text":"<p>ION's interface for extending the Bundle Protocol enables the definition of external functions that insert extension blocks into outbound bundles (either before or after the payload block), parse and record extension blocks in inbound bundles, and modify extension blocks at key points in bundle processing.  All extension-block handling is statically linked into ION at build time, but the addition of an extension never requires that any standard ION source code be modified.</p> <p>Standard structures for recording extension blocks -- both in transient storage [memory] during bundle acquisition (AcqExtBlock) and in persistent storage [the ION database] during subsequent bundle processing (ExtensionBlock) -- are defined in the bei.h header file.  In each case, the extension block structure comprises a block type code, block processing flags, possibly a list of EID references, an array of bytes (the serialized form of the block, for transmission), the length of that array, optionally an extension-specific opaque object whose structure is designed to characterize the block in a manner that's convenient for the extension processing functions, and the size of that object.</p> <p>The definition of each extension is asserted in an ExtensionDef structure, also as defined in the bei.h header file.  Each ExtensionDef must supply:</p> <p>The name of the extension.  (Used in some diagnostic messages.)</p> <p>The extension's block type code.</p> <p>A pointer to an offer function.</p> <p>A pointer to a function to be called when forwarding a bundle containing this sort of block.</p> <p>A pointer to a function to be called when taking custody of a bundle containing this sort of block.</p> <p>A pointer to a function to be called when enqueuing for transmission a bundle containing this sort of block.</p> <p>A pointer to a function to be called when a convergence-layer adapter dequeues a bundle containing this sort of block, before serializing it.</p> <p>A pointer to a function to be called immediately before a convergence-layer adapter transmits a bundle containing this sort of block, after the bundle has been serialized.</p> <p>A pointer to a release function.</p> <p>A pointer to a copy function.</p> <p>A pointer to an acquire function.</p> <p>A pointer to a decrypt function.</p> <p>A pointer to a parse function.</p> <p>A pointer to a check function.</p> <p>A pointer to a record function.</p> <p>A pointer to a clear function.</p> <p>All extension definitions must be coded into an array of ExtensionDef structures named extensionDefs.</p> <p>An array of ExtensionSpec structures named extensionSpecs is also required.  Each ExtensionSpec provides the specification for producing an outbound extension block: block definition (identified by block type number), three discriminator tags whose semantics are block-type-specific, and a list index value indicating whether the extension block is to be inserted before or after the Payload block. The order of appearance of extension specifications in the extensionSpecs array determines the order in which extension blocks will be inserted into locally sourced bundles.</p> <p>The standard extensionDefs array -- which is empty -- is in the noextensions.c prototype source file.  The procedure for extending the Bundle Protocol in ION is as follows:</p> <p>1.  Specify -DBP_EXTENDED in the Makefile's compiler command line when building the libbpP.c library module.</p> <p>2.  Create a copy of the prototype extensions file, named \"bpextensions.c\", in a directory that is made visible to the Makefile's libbpP.c compilation command line (by a -I parameter).</p> <p>3.  In the \"external function declarations\" area of \"bpextensions.c\", add \"extern\" function declarations identifying the functions that will implement your extension (or extensions).</p> <p>4.  Add one or more ExtensionDef structure initialization lines to the extensionDefs array, referencing those declared functions.</p> <p>5.  Add one or more ExtensionSpec structure initialization lines to the extensionSpecs array, referencing those extension definitions.</p> <p>6.  Develop the implementations of the extension implementation functions in one or more new source code files.</p> <p>7.  Add the object file or files for the new extension implementation source file (or files) to the Makefile's command line for linking libbpP.so.</p> <p>The function pointers supplied in each ExtensionDef must conform to the following specifications.  NOTE that any function that modifies the bytes member of an ExtensionBlock or AckExtBlock must set the corresponding length to the new length of the bytes array, if changed.</p> <ul> <li> <p>int (*BpExtBlkOfferFn)(ExtensionBlock *blk, Bundle *bundle)</p> <p>Populates all fields of the indicated ExtensionBlock structure for inclusion in the indicated outbound bundle.  This function is automatically called when a new bundle is locally sourced or upon acquisition of a remotely sourced bundle that does not contain an extension block of this type.  The values of the extension block are typically expected to be a function of the state of the bundle, but this is extension-specific.  If it is not appropriate to offer an extension block of this type as part of this bundle, then the size, length, object, and bytes members of blk must all be set to zero.  If it is appropriate to offer such a block but no internal object representing the state of the block is needed, the object and size members of blk must be set to zero.  The type, blkProcFlags, and dataLength members of blk must be populated by the implementation of the \"offer\" function, but the length and bytes members are typically populated by calling the BP library function serializeExtBlk(), which must be passed the block to be serialized (with type, blkProcFlags and dataLength already set), a Lyst of EID references (two list elements -- offsets -- per EID reference, if applicable; otherwise NULL), and a pointer to the extension-specific block data.  The block's bytes array and object (if present) must occupy space allocated from the ION database heap.  Return zero on success, -1 on any system failure.</p> </li> <li> <p>int (*BpExtBlkProcessFn)(ExtensionBlock *blk, Bundle *bundle, void *context)</p> <p>Performs some extension-specific transformation of the data encapsulated in blk based on the state of bundle.  The transformation to be performed will typically vary depending on whether the identified function is the one that is automatically invoked upon forwarding the bundle, upon taking custody of the bundle, upon enqueuing the bundle for transmission, upon removing the bundle from the transmission queue, or upon transmitting the serialized bundle.  The context argument may supply useful supplemental information; in particular, the context provided to the ON_DEQUEUE function will comprise the name of the protocol for the duct from which the bundle has been dequeued, together with the EID of the neighboring node endpoint to which the bundle will be directly transmitted when serialized.  The block-specific data in blk is located within bytes immediately after the header of the extension block; the length of the block's header is the difference between length and dataLength.  Whenever the block's blkProcFlags, EID extensions, and/or block-specific data are altered, the serializeExtBlk() function should be called again to recalculate the size of the extension block and rebuild the bytes array.  Return zero on success, -1 on any system failure.</p> </li> <li> <p>void (*BpExtBlkReleaseFn)(ExtensionBlock *blk)</p> <p>Releases all ION database space occupied by the object member of blk. This function is automatically called when a bundle is destroyed.  Note that incorrect implementation of this function may result in a database space leak.</p> </li> <li> <p>int (*BpExtBlkCopyFn)(ExtensionBlock *newblk, ExtensionBlock *oldblk)</p> <p>Copies the object member of oldblk to ION database heap space and places the address of that new non-volatile object in the object member of newblk, also sets size in newblk.  This function is automatically called when two copies of a bundle are needed, e.g., in the event that it must both be delivered to a local client and also fowarded to another node. Return zero on success, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkAcquireFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Populates the indicated AcqExtBlock structure with size and object for retention as part of the indicated inbound bundle.  (The type, blkProcFlags, EID references (if any), dataLength, length, and bytes values of the structure are pre-populated with data as extracted from the serialized bundle.)  This function is only to be provided for extension blocks that are never encrypted; a extension block that may be encrypted should have a BpAcqExtBlkParseFn callback instead.  The function is automatically called when an extension block of this type is encountered in the course of parsing and acquiring a bundle for local delivery and/or forwarding.  If no internal object representing the state of the block is needed, the object member of acqblk must be set to NULL and the size member must be set to zero.  If an object is needed for this block, it must occupy space that is allocated from ION working memory using MTAKE and its size must be indicated in blk.  Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if the block is successfully parsed, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkDecryptFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Decrypts some other extension block that has been acquired but not yet parsed, nominally using encapsulated ciphersuite information.  Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if no error in decryption was encountered, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkParseFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Populates the indicated AcqExtBlock structure with size and object for retention as part of the indicated inbound bundle.  (The type, blkProcFlags, EID references (if any), dataLength, length, and bytes values of the structure are pre-populated with data as extracted from the serialized bundle.)  This function is provided for extension blocks that may be encrypted; a extension block that can never be encrypted should have a BpAcqExtBlkAcquireFn callback instead.  The function is automatically called when an extension block of this type is encountered in the course of parsing and acquiring a bundle for local delivery and/or forwarding.  If no internal object representing the state of the block is needed, the object member of acqblk must be set to NULL and the size member must be set to zero.  If an object is needed for this block, it must occupy space that is allocated from ION working memory using MTAKE and its size must be indicated in blk.  Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if the block is successfully parsed, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkCheckFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Examines the bundle in work to determine whether or not it is authentic, in the context of the indicated extension block.  Return 1 if the block is determined to be inauthentic (this will cause the bundle to be discarded), zero if no inauthenticity is detected, -1 on any system failure.</p> </li> <li> <p>int (*BpExtBlkRecordFn)(ExtensionBlock *blk, AcqExtBlock *acqblk)</p> <p>Copies the object member of acqblk to ION database heap space and places the address of that non-volatile object in the object member of blk; also sets size in blk.  This function is automatically called when an acquired bundle is accepted for forwarding and/or delivery.  Return zero on success, -1 on any system failure.</p> </li> <li> <p>void (*BpAcqExtBlkClearFn)(AcqExtBlock *acqblk)</p> <p>Uses MRELEASE to release all ION working memory occupied by the object member of acqblk.  This function is automatically called when acquisition of a bundle is completed, whether or not the bundle is accepted.  Note that incorrect implementation of this function may result in a working memory leak.</p> </li> </ul>"},{"location":"man/bpv6/bpextensions/#utility-functions-for-extension-processing","title":"UTILITY FUNCTIONS FOR EXTENSION PROCESSING","text":"<ul> <li> <p>void discardExtensionBlock(AcqExtBlock *blk)</p> <p>Deletes this block from the bundle acquisition work area prior to the recording of the bundle in the ION database.</p> </li> <li> <p>void scratchExtensionBlock(ExtensionBlock *blk)</p> <p>Deletes this block from the bundle after the bundle has been recorded in the ION database.</p> </li> <li> <p>Object findExtensionBlock(Bundle *bundle, unsigned int type, unsigned int listIdx)</p> <p>On success, returns the address of the ExtensionBlock in bundle for the indicated type and listIdx.  If no such extension block exists, returns zero.</p> </li> <li> <p>int serializeExtBlk(ExtensionBlock *blk, Lyst eidReferences, char *blockData)</p> <p>Constructs an RFC5050-conformant serialized representation of this extension block in blk-&gt;bytes.  Returns 0 on success, -1 on an unrecoverable system error.</p> </li> <li> <p>void suppressExtensionBlock(ExtensionBlock *blk)</p> <p>Causes blk to be omitted when the bundle to which it is attached is serialized for transmission.  This suppression remains in effect until it is reversed by restoreExtensionBlock();</p> </li> <li> <p>void restoreExtensionBlock(ExtensionBlock *blk)</p> <p>Reverses the effect of suppressExtensionBlock(), enabling the block to be included when the bundle to which it is attached is serialized.</p> </li> </ul>"},{"location":"man/bpv6/bpextensions/#see-also","title":"SEE ALSO","text":"<p>bp(3)</p>"},{"location":"man/bpv6/bping/","title":"NAME","text":"<p>bping - Send and receive Bundle Protocol echo bundles.</p>"},{"location":"man/bpv6/bping/#synopsis","title":"SYNOPSIS","text":"<p>bping [-c count] [-i interval] [-p priority] [-q wait] [-r flags] [-t ttl] srcEID destEID [reporttoEID]</p>"},{"location":"man/bpv6/bping/#description","title":"DESCRIPTION","text":"<p>bping sends bundles from srcEID to destEID.  If the destEID echoes the bundles back (for instance, it is a bpecho endpoint), bping will print the round-trip time.  When complete, bping will print statistics before exiting.  It is very similar to ping, except it works with the bundle protocol.</p> <p>bping terminates when one of the following happens: it receives the SIGINT signal (Ctrl+C), it receives responses to all of the bundles it sent, or it has sent all count of its bundles and waited wait seconds.</p> <p>When bping is executed in a VxWorks or RTEMS environment, its runtime arguments are presented positionally rather than by keyword, in this order: count, interval, priority, wait, flags, TTL, verbosity (a Boolean, defaulting to zero), source EID, destination EID, report-to EID.</p> <p>Source EID and destination EID are always required.</p>"},{"location":"man/bpv6/bping/#exit-status","title":"EXIT STATUS","text":"<p>These exit statuses are taken from ping.</p> <ul> <li> <p>\"0\"</p> <p>bping has terminated normally, and received responses to all the packets it sent.</p> </li> <li> <p>\"1\"</p> <p>bping has terminated normally, but it did not receive responses to all the packets it sent.</p> </li> <li> <p>\"2\"</p> <p>bping has terminated due to an error.  Details should be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bping/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bping/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bping/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bping are written to the ION log file ion.log and printed to standard error.  Diagnostic messages that don't cause bping to terminate indicate a failure parsing an echo response bundle.  This means that destEID isn't an echo endpoint: it's responding with some other bundle message of an unexpected format.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bping bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bping can't send echo bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bping/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bping/#see-also","title":"SEE ALSO","text":"<p>bpecho(1), bptrace(1), bpadmin(1), bp(3), ping(8)</p>"},{"location":"man/bpv6/bplist/","title":"NAME","text":"<p>bplist - Bundle Protocol (BP) utility for listing queued bundles</p>"},{"location":"man/bpv6/bplist/#synopsis","title":"SYNOPSIS","text":"<p>bplist [{count | detail} [destination_EID[/priority]]]</p>"},{"location":"man/bpv6/bplist/#description","title":"DESCRIPTION","text":"<p>bplist is a utility program that reports on bundles that currently reside in the local node, as identified by entries in the local bundle agent's \"timeline\" list.</p> <p>Either a count of bundles or a detailed list of bundles (noting primary block information together with hex and ASCII dumps of the payload and all extension blocks, in expiration-time sequence) may be requested.</p> <p>Either all bundles or just a subset of bundles - restricted to bundles for a single destination endpoint, or to bundles of a given level of priority that are all destined for some specified endpoint - may be included in the report.</p> <p>By default, bplist prints a detailed list of all bundles residing in the local node.</p>"},{"location":"man/bpv6/bplist/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bplist terminated, for reasons noted in the ion.log file.</p> </li> <li> <p>\"1\"</p> <p>bplist was unable to attach to Bundle Protocol operations, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv6/bplist/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bplist/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bplist/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv6/bplist/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bplist/#see-also","title":"SEE ALSO","text":"<p>bpclock(1)</p>"},{"location":"man/bpv6/bpnmtest/","title":"NAME","text":"<p>bpnmtest - Bundle Protocol (BP) network management statistics test</p>"},{"location":"man/bpv6/bpnmtest/#synopsis","title":"SYNOPSIS","text":"<p>bpnmtest</p>"},{"location":"man/bpv6/bpnmtest/#description","title":"DESCRIPTION","text":"<p>bpnmtest simply prints to stdout messages containing the current values of all BP network management tallies, then terminates.</p>"},{"location":"man/bpv6/bpnmtest/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpnmtest has terminated.</p> </li> </ul>"},{"location":"man/bpv6/bpnmtest/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpnmtest/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpnmtest/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv6/bpnmtest/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bprc/","title":"NAME","text":"<p>bprc - Bundle Protocol management commands file</p>"},{"location":"man/bpv6/bprc/#description","title":"DESCRIPTION","text":"<p>Bundle Protocol management commands are passed to bpadmin either in a file of text lines or interactively at bpadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the Bundle Protocol management commands are described below.</p>"},{"location":"man/bpv6/bprc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by bpadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed and the crypto suite BP was compiled with.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1</p> <p>The initialize command.  Until this command is executed, Bundle Protocol is not in operation on the local ION node and most bpadmin commands will fail.</p> </li> <li> <p>r 'command_text'</p> <p>The run command.  This command will execute command_text as if it had been typed at a console prompt.  It is used to, for example, run another administrative program.</p> </li> <li> <p>s</p> <p>The start command.  This command starts all schemes and all protocols on the local node.</p> </li> <li> <p>m heapmax max_database_heap_per_acquisition</p> <p>The manage heap for bundle acquisition command.  This command declares the maximum number of bytes of SDR heap space that will be occupied by any single bundle acquisition activity (nominally the acquisition of a single bundle, but this is at the discretion of the convergence-layer input task). All data acquired in excess of this limit will be written to a temporary file pending extraction and dispatching of the acquired bundle or bundles.  Default is the minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimum SDR heap space occupancy in the event that all acquisition is into a file.</p> </li> <li> <p>m maxcount max_value_of_bundle_ID_sequence_nbr</p> <p>The manage maximum bundle ID sequence number command.  This command sets the maximum value that will be assigned as the sequence number in a bundle ID for any bundle sourced at a node that lacks a synchronized clock (such that the creation time in the ID of every locally sourced bundle is always zero). The default value is -1, i.e., unlimited.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops all schemes and all protocols on the local node.</p> </li> <li> <p>w { 0 | 1 | activity_spec }</p> <p>The BP watch command.  This command enables and disables production of a continuous stream of user-selected Bundle Protocol activity indication characters.  A watch parameter of \"1\" selects all BP activity indication characters; \"0\" de-selects all BP activity indication characters; any other activity_spec such as \"acz~\" selects all activity indication characters in the string, de-selecting all others.  BP will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>a   new bundle is queued for forwarding</p> <p>b   bundle is queued for transmission</p> <p>c   bundle is popped from its transmission queue</p> <p>m   custody acceptance signal is received</p> <p>w   custody of bundle is accepted</p> <p>x   custody of bundle is refused</p> <p>y   bundle is accepted upon arrival</p> <p>z   bundle is queued for delivery to an application</p> <p>~   bundle is abandoned (discarded) on attempt to forward it</p> <p>!   bundle is destroyed due to TTL expiration</p> <p>&amp;   custody refusal signal is received</p> <p>#   bundle is queued for re-forwarding due to CL protocol failure</p> <p>j   bundle is placed in \"limbo\" for possible future re-forwarding</p> <p>k   bundle is removed from \"limbo\" and queued for re-forwarding</p> <p>$   bundle's custodial retransmission timeout interval expired</p> <p>Note that a slightly amended interpretation should be applied to watch characters printed in the course of multicast transmission.  The '~' character, meaning Abandoned (node did not forward this bundle), is printed by a node that is a leaf of the multicast tree, i.e., a node with no children; it cannot forward the bundle because it's got nobody to forward it to.  The '!' character, meaning Destroyed (node destroyed a physical copy of a bundle), is printed by a node that has forwarded copies of the bundle to all of its children and no longer needs to retain the original - so it does an immediate permanent bundle destruction just as if the bundle's time to live had expired. Neither condition is anomalous.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#scheme-commands","title":"SCHEME COMMANDS","text":"<ul> <li> <p>a scheme scheme_name 'forwarder_command' 'admin_app_command'</p> <p>The add scheme command.  This command declares an endpoint naming \"scheme\" for use in endpoint IDs, which are structured as URIs: scheme_name:scheme-specific_part.  forwarder_command will be executed when the scheme is started on this node, to initiate operation of a forwarding daemon for this scheme.  admin_app_command will also be executed when the scheme is started on this node, to initiate operation of a daemon that opens a custodian endpoint identified within this scheme so that it can receive and process custody signals and bundle status reports.</p> </li> <li> <p>c scheme scheme_name 'forwarder_command' 'admin_app_command'</p> <p>The change scheme command.  This command sets the indicated scheme's  forwarder_command and admin_app_command to the strings provided as arguments.</p> </li> <li> <p>d scheme scheme_name</p> <p>The delete scheme command.  This command deletes the scheme identified by scheme_name.  The command will fail if any bundles identified in this scheme are pending forwarding, transmission, or delivery.</p> </li> <li> <p>i scheme scheme_name</p> <p>This command will print information (number and commands) about the endpoint naming scheme identified by scheme_name.</p> </li> <li> <p>l scheme</p> <p>This command lists all declared endpoint naming schemes.</p> </li> <li> <p>s scheme scheme_name</p> <p>The start scheme command.  This command starts the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.</p> </li> <li> <p>x scheme scheme_name</p> <p>The stop scheme command.  This command stops the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#endpoint-commands","title":"ENDPOINT COMMANDS","text":"<ul> <li> <p>a endpoint endpoint_ID { q | x } ['recv_script']</p> <p>The add endpoint command.  This command establishes a DTN endpoint named endpoint_ID on the local node.  The remaining parameters indicate what is to be done when bundles destined for this endpoint arrive at a time when no application has got the endpoint open for bundle reception.  If 'x', then such bundles are to be discarded silently and immediately.  If 'q', then such bundles are to be enqueued for later delivery and, if recv_script is provided, recv_script is to be executed.</p> </li> <li> <p>c endpoint endpoint_ID { q | x } ['recv_script']</p> <p>The change endpoint command.  This command changes the action that is to be taken when bundles destined for this endpoint arrive at a time when no application has got the endpoint open for bundle reception, as described above.</p> </li> <li> <p>d endpoint endpoint_ID</p> <p>The delete endpoint command.  This command deletes the endpoint identified by endpoint_ID.  The command will fail if any bundles are currently pending delivery to this endpoint.</p> </li> <li> <p>i endpoint endpoint_ID</p> <p>This command will print information (disposition and script) about the endpoint identified by endpoint_ID.</p> </li> <li> <p>l endpoint</p> <p>This command lists all local endpoints, regardless of scheme name.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#protocol-commands","title":"PROTOCOL COMMANDS","text":"<ul> <li> <p>a protocol protocol_name payload_bytes_per_frame overhead_bytes_per_frame [protocol_class]</p> <p>The add protocol command.  This command establishes access to the named convergence layer protocol at the local node.  The payload_bytes_per_frame and overhead_bytes_per_frame arguments are used in calculating the estimated transmission capacity consumption of each bundle, to aid in route computation and congestion forecasting.</p> <p>The optional protocol_class argument indicates the reliability of the protocol.  The value 1 indicates that the protocol natively supports bundle streaming; currently the only protocol in class 1 is BSSP.  The value 2 indicates that the protocol performs no retransmission; an example is UDP. The value 8 (which is the default) indicates that the protocol detects data loss and automatically retransmits data accordingly; an example is TCP. Protocol class need not be specified when protocol_name is bssp, udp, tcp, stcp, brss, brsc, or ltp, as the protocol classes for these well-known protocols are hard-coded in ION.</p> </li> <li> <p>d protocol protocol_name</p> <p>The delete protocol command.  This command deletes the convergence layer protocol identified by protocol_name.  The command will fail if any ducts are still locally declared for this protocol.</p> </li> <li> <p>i protocol protocol_name</p> <p>This command will print information about the convergence layer protocol identified by protocol_name.</p> </li> <li> <p>l protocol</p> <p>This command lists all convergence layer protocols that can currently be utilized at the local node.</p> </li> <li> <p>s protocol protocol_name</p> <p>The start protocol command.  This command starts all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.</p> </li> <li> <p>x protocol protocol_name</p> <p>The stop protocol command.  This command stops all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#induct-commands","title":"INDUCT COMMANDS","text":"<ul> <li> <p>a induct protocol_name duct_name 'CLI_command'</p> <p>The add induct command.  This command establishes a \"duct\" for reception of bundles via the indicated CL protocol.  The duct's data acquisition structure is used and populated by the \"induct\" task whose operation is initiated by CLI_command at the time the duct is started.</p> </li> <li> <p>c induct protocol_name duct_name 'CLI_command'</p> <p>The change induct command.  This command changes the command that is used to initiate operation of the induct task for the indicated duct.</p> </li> <li> <p>d induct protocol_name duct_name</p> <p>The delete induct command.  This command deletes the induct identified by protocol_name and duct_name.  The command will fail if any bundles are currently pending acquisition via this induct.</p> </li> <li> <p>i induct protocol_name duct_name</p> <p>This command will print information (the CLI command) about the induct identified by protocol_name and duct_name.</p> </li> <li> <p>l induct [protocol_name]</p> <p>If protocol_name is specified, this command lists all inducts established locally for the indicated CL protocol.  Otherwise it lists all locally established inducts, regardless of protocol.</p> </li> <li> <p>s induct protocol_name duct_name</p> <p>The start induct command.  This command starts the indicated induct  task as defined for the indicated CL protocol on the local node.</p> </li> <li> <p>x induct protocol_name duct_name</p> <p>The stop induct command.  This command stops the indicated induct  task as defined for the indicated CL protocol on the local node.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#outduct-commands","title":"OUTDUCT COMMANDS","text":"<ul> <li> <p>a outduct protocol_name duct_name 'CLO_command' [max_payload_length]</p> <p>The add outduct command.  This command establishes a \"duct\" for transmission of bundles via the indicated CL protocol.  The duct's data transmission structure is serviced by the \"outduct\" task whose operation is initiated by CLO_command at the time the duct is started.  A value of zero for max_payload_length indicates that bundles of any size can be accommodated; this is the default.</p> </li> <li> <p>c outduct protocol_name duct_name 'CLO_command' [max_payload_length]</p> <p>The change outduct command.  This command sets new values for the indicated duct's payload size limit and the command that is used to initiate operation of the outduct task for this duct.</p> </li> <li> <p>d outduct protocol_name duct_name</p> <p>The delete outduct command.  This command deletes the outduct identified by protocol_name and duct_name.  The command will fail if any bundles are currently pending transmission via this outduct.</p> </li> <li> <p>i outduct protocol_name duct_name</p> <p>This command will print information (the CLO command) about the outduct identified by protocol_name and duct_name.</p> </li> <li> <p>l outduct [protocol_name]</p> <p>If protocol_name is specified, this command lists all outducts established locally for the indicated CL protocol.  Otherwise it lists all locally established outducts, regardless of protocol.</p> </li> <li> <p>s outduct protocol_name duct_name</p> <p>The start outduct command.  This command starts the indicated outduct  task as defined for the indicated CL protocol on the local node.</p> </li> <li> <p>x outduct protocol_name duct_name</p> <p>The stop outduct command.  This command stops the indicated outduct  task as defined for the indicated CL protocol on the local node.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#egress-plan-commands","title":"EGRESS PLAN COMMANDS","text":"<ul> <li> <p>a plan endpoint_name [transmission_rate]</p> <p>The add plan command.  This command establishes an egress plan governing transmission to the neighboring node[s] identified by endpoint_name.  The plan is functionally enacted by a bpclm(1) daemon dedicated to managing bundles queued for transmission to the indicated neighboring node[s].</p> <p>NOTE that these \"plan\" commands supersede and generalize the egress plan commands documented in the ipnrc(5) and dtn2rc(5) man pages, which are retained for backward compatibility.  The syntax of the egress plan commands consumed by bpadmin is DIFFERENT from that of the commands consumed by ipnadmin and dtn2admin.  The endpoint_name identifying an egress plan is normally the node ID for a single node but may instead be \"wild-carded\".  That is, when the last character of an endpoint name ID is either '*' or '~' (these two wild-card characters are equivalent for this purpose), the plan applies to all nodes whose IDs are identical to the wild-carded node name up to the wild-card character.  For example, a bundle whose destination EID name is \"dtn://foghorn\" would be routed by plans citing the following node IDs: \"dtn://foghorn\", \"dtn://fogh*\", \"dtn://fog~\", \"//*\".  When multiple plans are all applicable to the same destination EID, the one citing the longest (i.e., most narrowly targeted) node ID will be applied.</p> <p>An egress plan may direct that bundles queued for transmission to the node[s] matching endpoint_name be transmitted using one of the convergence-layer protocol \"outducts\" that have been attached to the plan, or instead that those bundles be routed to some other \"gateway\" endpoint (resulting in transmission according to some other egress plan).  In the event that both a gateway endpoint and one or more outducts have been declared for a given plan, the gateway declaration prevails.</p> <p>A transmission_rate may be asserted for an egress plan; this rate is used as the basis for transmission rate control in the absence of applicable contacts (in the node's contact plan, as per ionrc(5)).  A transmission rate of zero (absent applicable contacts) disables rate control completely; this is the default.</p> </li> <li> <p>c plan endpoint_name [transmission_rate]</p> <p>The change plan command.  This command sets a new value for the indicated plan's transmission rate.</p> </li> <li> <p>d plan endpoint_name</p> <p>The delete plan command.  This command deletes the outduct identified by endpoint_name.  The command will fail if any bundles are currently pending transmission per this plan.</p> </li> <li> <p>i plan endpoint_name</p> <p>This command will print information (the transmission rate) about the plan identified by endpoint_name.</p> </li> <li> <p>l plan</p> <p>This command lists all locally established egress plans.</p> </li> <li> <p>s plan endpoint_name</p> <p>The start plan command.  This command starts the bpclm(1) task for the indicated egress plan.</p> </li> <li> <p>x plan endpoint_name</p> <p>The stop plan command.  This command stops the bpclm(1) task for the indicated egress plan. </p> </li> <li> <p>b plan endpoint_name</p> <p>The block plan command.  This command disables transmission of bundles queued for transmission to the indicated node and reforwards all non-critical bundles currently queued for transmission to this node.  This may result in some or all of these bundles being enqueued for transmission (actually just retention) to the pseudo-node \"limbo\".</p> </li> <li> <p>u plan endpoint_name</p> <p>The unblock plan command.  This command re-enables transmission of bundles to the indicated node and reforwards all bundles in \"limbo\" in the hope that the unblocking of this egress plan will enable some of them to be transmitted.</p> </li> <li> <p>g plan endpoint_name gateway_endpoint_name</p> <p>The declare gateway command.  This command declares the name of the endpoint to which bundles queued for transmission to the node[s] identified by endpoint_name must be re-routed.  Declaring gateway_endpoint_name to be the zero-length string \"''\" disables re-routing: bundles will instead be transmitted using the plan's attached convergence-layer protocol outduct[s].</p> </li> <li> <p>a planduct endpoint_name protocol_name duct_name</p> <p>The attach outduct command.  This command declares that the indicated convergence-layer protocol outduct is now a viable device for transmitting bundles to the node[s] identified by endpoint_name.</p> </li> <li> <p>d planduct protocol_name duct_name</p> <p>The detach outduct command.  This command declares that the indicated convergence-layer protocol outduct is no longer a viable device for transmitting bundles to the node[s] to which it is currently assigned.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a scheme ipn 'ipnfw' 'ipnadminep'</p> <p>Declares the \"ipn\" scheme on the local node.</p> </li> <li> <p>a protocol udp 1400 100 16384</p> <p>Establishes access to the \"udp\" convergence layer protocol on the local node, estimating the number of payload bytes per ultimate (lowest-layer) frame to be 1400 with 100 bytes of total overhead (BP, UDP, IP, AOS) per lowest-layer frame, and setting the default nominal data rate to be 16384 bytes per second.</p> </li> <li> <p>r 'ipnadmin flyby.ipnrc'</p> <p>Runs the administrative program ipnadmin from within bpadmin.</p> </li> </ul>"},{"location":"man/bpv6/bprc/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), ipnadmin(1), dtn2admin(1)</p>"},{"location":"man/bpv6/bprecvfile/","title":"NAME","text":"<p>bprecvfile - Bundle Protocol (BP) file reception utility</p>"},{"location":"man/bpv6/bprecvfile/#synopsis","title":"SYNOPSIS","text":"<p>bprecvfile own_endpoint_ID [max_files]</p>"},{"location":"man/bpv6/bprecvfile/#description","title":"DESCRIPTION","text":"<p>bprecvfile is intended to serve as the counterpart to bpsendfile.  It uses bp_receive() to receive bundles containing file content.  The content of each bundle is simply written to a file named \"testfileN\" where N is the total number of bundles received since the program began running.</p> <p>If a max_files value of N (where N &gt; 0) is provided, the program will terminate automatically upon completing its Nth file reception.  Otherwise it will run indefinitely; use ^C to terminate the program.</p>"},{"location":"man/bpv6/bprecvfile/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bprecvfile has terminated.</p> </li> </ul>"},{"location":"man/bpv6/bprecvfile/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bprecvfile/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bprecvfile/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>bprecvfile bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't open test file</p> <p>File system error.  bprecvfile terminates.</p> </li> <li> <p>bprecvfile: can't receive bundle content.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't write to test file</p> <p>File system error.  bprecvfile terminates.</p> </li> <li> <p>bprecvfile cannot continue.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't handle bundle delivery.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bprecvfile/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bprecvfile/#see-also","title":"SEE ALSO","text":"<p>bpsendfile(1), bp(3)</p>"},{"location":"man/bpv6/bpsecadmin/","title":"NAME","text":"<p>bpsecadmin - BP security policy administration interface</p>"},{"location":"man/bpv6/bpsecadmin/#synopsis","title":"SYNOPSIS","text":"<p>bpsecadmin [ commands_filename ]</p>"},{"location":"man/bpv6/bpsecadmin/#description","title":"DESCRIPTION","text":"<p>bpsecadmin configures and manages BP security policy on the local computer.</p> <p>It configures and manages BP security policy on the local computer in response to BP configuration commands found in commands_filename, if provided; if not, bpsecadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from bpsecadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in bpsecrc(5).</p>"},{"location":"man/bpv6/bpsecadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of BP security policy administration.</p> </li> </ul>"},{"location":"man/bpv6/bpsecadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>bpsecadmin</p> <p>Enter interactive ION security policy administration command entry mode.</p> </li> <li> <p>bpsecadmin host1.bpsecrc</p> <p>Execute all configuration commands in host1.bpsecrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv6/bpsecadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from bpsecadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which bpsecadmin was run.  The log file is typically named ion.log.</p> <p>See also bpsecrc(5).</p>"},{"location":"man/bpv6/bpsecadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpsecadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ionrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to bpsecadmin.  Otherwise bpsecadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause bpsecadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see bpsecrc(5) for details.</p>"},{"location":"man/bpv6/bpsecadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpsecadmin/#see-also","title":"SEE ALSO","text":"<p>bpsecrc(5)</p>"},{"location":"man/bpv6/bpsecrc/","title":"NAME","text":"<p>bpsecrc - BP security policy management commands file</p>"},{"location":"man/bpv6/bpsecrc/#description","title":"DESCRIPTION","text":"<p>BP security policy management commands are passed to bpsecadmin either in a file of text lines or interactively at bpsecadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the BP security policy management commands are described below.</p> <p>A parameter identifed as an eid_expr is an \"endpoint ID expression.\"  For all commands, whenever the last character of an endpoint ID expression is the wild-card character '*', an applicable endpoint ID \"matches\" this EID expression if all characters of the endpoint ID expression prior to the last one are equal to the corresponding characters of that endpoint ID.  Otherwise an applicable endpoint ID \"matches\" the EID expression only when all characters of the EID and EID expression are identical.</p> <p>ION supports the proposed \"streamlined\" Bundle Security Protocol (currently posted as CCSDS Red Book 734.5-R-1) in place of the standard Bundle Security Protocol (RFC 6257).  Since SBSP is not yet a published standard, ION's Bundle Protocol security mechanisms will not necessarily interoperate with those of other BP implementations.  This is unfortunate but (we hope) temporary, as SBSP represents a major improvement in bundle security. It is possible that the SBSP specification will change somewhat between now and the time SBSP is published as a CCSDS standard and eventually an RFC, and ION will be revised as necessary to conform to those changes, but in the meantime we believe that the advantages of SBSP make it more suitable than RFC 6257 as a foundation for the development and deployment of secure DTN applications.</p>"},{"location":"man/bpv6/bpsecrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by bpsecadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>a bspbibrule source_eid_expr destination_eid_expr block_type_number { '' | ciphersuite_name key_name }</p> <p>The add bspbibrule command.  This command adds a rule specifying the manner in which Block Integrity Block (BIB) validation will be applied to blocks of type block_type_number for all bundles sourced at any node whose administrative endpoint ID matches source_eid_expr and destined for any node whose administrative endpoint ID ID matches destination_eid_expr.</p> <p>If a zero-length string ('') is indicated instead of a ciphersuite_name then BIB validation is disabled for this source/destination EID expression pair: blocks of the type indicated by block_type_number in all bundles sourced at nodes with matching administrative endpoint IDs and destined for nodes with matching administrative endpoint IDs will be immediately deemed valid.  Otherwise, a block of the indicated type that is attached to a bundle sourced at a node with matching administrative endpoint ID and destined for a node with matching administrative endpoint ID will only be deemed valid if the bundle contains a corresponding BIB computed via the ciphersuite named by ciphersuite_name using a key value that is identical to the current value of the key named key_name in the local security policy database.</p> </li> <li> <p>c bspbibrule source_eid_expr destination_eid_expr block_type_number { '' | ciphersuite_name key_name }</p> <p>The change bspbibrule command.  This command changes the ciphersuite name and/or key name for the BIB rule pertaining to the source/destination EID expression pair identified by source_eid_expr and destination_eid_expr and the block identified by block_type_number. Note that the _eid_expr_s must exactly match those of the rule that is to be modified, including any terminating wild-card character.  </p> </li> <li> <p>d bspbibrule source_eid_expr destination_eid_expr block_type_number</p> <p>The delete bspbibrule command.  This command deletes the BIB rule pertaining to the source/destination EID expression pair identified by sender_eid_expr and receiver_eid_expr and the block identified by block_type_number.  Note that the _eid_expr_s must exactly match those of the rule that is to be deleted, including any terminating wild-card character.</p> </li> <li> <p>i bspbibrule source_eid_expr destination_eid_expr block_type_number</p> <p>This command will print information (the ciphersuite and key names) about the BIB rule pertaining to source_eid_expr, destination_eid_expr, and block_type_number.</p> </li> <li> <p>l bspbibrule</p> <p>This command lists all BIB rules in the security policy database.</p> </li> <li> <p>a bspbcbrule source_eid_expr destination_eid_expr block_type_number { '' | ciphersuite_name key_name }</p> <p>The add bspbcbrule command.  This command adds a rule specifying the manner in which Block Confidentiality Block (BCB) encryption will be applied to blocks of type block_type_number for all bundles sourced at any node whose administrative endpoint ID matches source_eid_expr and destined for any node whose administrative endpoint ID ID matches destination_eid_expr.</p> <p>If a zero-length string ('') is indicated instead of a ciphersuite_name then BCB encryption is disabled for this source/destination EID expression pair: blocks of the type indicated by block_type_number in all bundles sourced at nodes with matching administrative endpoint IDs and destined for nodes with matching administrative endpoint IDs will be sent in plain text.  Otherwise, a block of the indicated type that is attached to a bundle sourced at a node with matching administrative endpoint ID and destined for a node with matching administrative endpoint ID can only be deemed decrypted if the bundle contains a corresponding BCB computed via the ciphersuite named by ciphersuite_name using a key value that is identical to the current value of the key named key_name in the local security policy database.</p> </li> <li> <p>c bspbcbrule source_eid_expr destination_eid_expr block_type_number { '' | ciphersuite_name key_name }</p> <p>The change bspbcbrule command.  This command changes the ciphersuite name and/or key name for the BCB rule pertaining to the source/destination EID expression pair identified by source_eid_expr and destination_eid_expr and the block identified by block_type_number. Note that the _eid_expr_s must exactly match those of the rule that is to be modified, including any terminating wild-card character.  </p> </li> <li> <p>d bspbcbrule source_eid_expr destination_eid_expr block_type_number</p> <p>The delete bspbcbrule command.  This command deletes the BCB rule pertaining to the source/destination EID expression pair identified by sender_eid_expr and receiver_eid_expr and the block identified by block_type_number.  Note that the _eid_expr_s must exactly match those of the rule that is to be deleted, including any terminating wild-card character.</p> </li> <li> <p>i bspbcbrule source_eid_expr destination_eid_expr block_type_number</p> <p>This command will print information (the ciphersuite and key names) about the BCB rule pertaining to source_eid_expr, destination_eid_expr, and block_type_number.</p> </li> <li> <p>l bspbcbrule</p> <p>This command lists all BCB rules in the security policy database.</p> </li> <li> <p>x [ { ~ | sender_eid_expr } [ { ~ | receiver_eid_expr} [ { ~ | bib | bcb } ] ] ]</p> <p>This command will clear all rules for the indicated type of bundle security block between the indicated security source and security destination.  If block type is omitted it defaults to ~ signifying \"all SBSP blocks\".  If both block type and security destination are omitted, security destination defaults to ~ signifying \"all SBSP security destinations\".  If all three command-line parameters are omitted, then security source defaults to ~ signifying \"all SBSP security sources\".</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv6/bpsecrc/#see-also","title":"SEE ALSO","text":"<p>bpsecadmin(1)</p>"},{"location":"man/bpv6/bpsendfile/","title":"NAME","text":"<p>bpsendfile - Bundle Protocol (BP) file transmission utility</p>"},{"location":"man/bpv6/bpsendfile/#synopsis","title":"SYNOPSIS","text":"<p>bpsendfile own_endpoint_ID destination_endpoint_ID file_name [class_of_service [time_to_live (seconds) ]]</p>"},{"location":"man/bpv6/bpsendfile/#description","title":"DESCRIPTION","text":"<p>bpsendfile uses bp_send() to issue a single bundle to a designated destination endpoint, containing the contents of the file identified by file_name, then terminates.  The bundle is sent with no custody transfer requested.  When class_of_service is omitted, the bundle is sent at standard priority; for details of the class_of_service parameter, see bptrace(1).  time_to_live, if not specified, defaults to 300 seconds (5 minutes).  NOTE that time_to_live is specified AFTER class_of_service, rather than before it as in bptrace(1).</p>"},{"location":"man/bpv6/bpsendfile/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpsendfile has terminated.</p> </li> </ul>"},{"location":"man/bpv6/bpsendfile/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpsendfile/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpsendfile/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>Can't stat the file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>bpsendfile can't create file ref.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bpsendfile can't create ZCO.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bpsendfile can't send file in bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bpsendfile/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpsendfile/#see-also","title":"SEE ALSO","text":"<p>bprecvfile(1), bp(3)</p>"},{"location":"man/bpv6/bpsink/","title":"NAME","text":"<p>bpsink - Bundle Protocol reception test program</p>"},{"location":"man/bpv6/bpsink/#synopsis","title":"SYNOPSIS","text":"<p>bpsink ownEndpointId</p>"},{"location":"man/bpv6/bpsink/#description","title":"DESCRIPTION","text":"<p>bpsink uses Bundle Protocol to receive application data units from a remote bpsource application task.  For each application data unit it receives, it prints the ADU's length and -- if length is less than 80 -- its text.</p> <p>bpsink terminates upon receiving the SIGQUIT signal, i.e., ^C from the keyboard.</p>"},{"location":"man/bpv6/bpsink/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpsink has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bpsink/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpsink/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpsink/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpsink are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpsink bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't receive payload.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't handle delivery.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bpsink/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpsink/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpsource(1), bp(3)</p>"},{"location":"man/bpv6/bpsource/","title":"NAME","text":"<p>bpsource - Bundle Protocol transmission test shell</p>"},{"location":"man/bpv6/bpsource/#synopsis","title":"SYNOPSIS","text":"<p>bpsource destinationEndpointId [\"text\"] [-t_TTL_]</p>"},{"location":"man/bpv6/bpsource/#description","title":"DESCRIPTION","text":"<p>When text is supplied, bpsource simply uses Bundle Protocol to send text to a counterpart bpsink application task that has opened the BP endpoint identified by destinationEndpointId, then terminates.</p> <p>Otherwise, bpsource offers the user an interactive \"shell\" for testing Bundle Protocol data transmission.  bpsource prints a prompt string (\": \") to stdout, accepts a string of text from stdin, uses Bundle Protocol to send the string to a counterpart bpsink application task that has opened the BP endpoint identified by destinationEndpointId, then prints another prompt string and so on.  To terminate the program, enter a string consisting of a single exclamation point (!) character.</p> <p>TTL indicates the number of seconds the bundles may remain in the network, undelivered, before they are automatically destroyed. If omitted, TTL defaults to 300 seconds.</p> <p>The source endpoint ID for each bundle sent by bpsource is the null endpoint ID, i.e., the bundles are anonymous.  All bundles are sent standard priority with no custody transfer and no status reports requested.</p>"},{"location":"man/bpv6/bpsource/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpsource has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv6/bpsource/#files","title":"FILES","text":"<p>The service data units transmitted by bpsource are sequences of text obtained from a file in the current working directory named \"bpsourceAduFile\", which bpsource creates automatically.</p>"},{"location":"man/bpv6/bpsource/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpsource/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpsource are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>bpsource fgets failed</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpsource can't send ADU</p> <p>Bundle Protocol service to the remote endpoint has been stopped.</p> </li> </ul>"},{"location":"man/bpv6/bpsource/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpsource/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpsink(1), bp(3)</p>"},{"location":"man/bpv6/bpstats/","title":"NAME","text":"<p>bpstats - Bundle Protocol (BP) processing statistics query utility</p>"},{"location":"man/bpv6/bpstats/#synopsis","title":"SYNOPSIS","text":"<p>bpstats</p>"},{"location":"man/bpv6/bpstats/#description","title":"DESCRIPTION","text":"<p>bpstats simply logs messages containing the current values of all BP processing statistics accumulators, then terminates.</p>"},{"location":"man/bpv6/bpstats/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpstats has terminated.</p> </li> </ul>"},{"location":"man/bpv6/bpstats/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpstats/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpstats/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpstats can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv6/bpstats/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpstats/#see-also","title":"SEE ALSO","text":"<p>ion(3)</p>"},{"location":"man/bpv6/bpstats2/","title":"NAME","text":"<p>bpstats2 - Bundle Protocol (BP) processing statistics query utility via bundles</p>"},{"location":"man/bpv6/bpstats2/#synopsis","title":"SYNOPSIS","text":"<p>bpstats2 sourceEID [default destEID] [ct]</p>"},{"location":"man/bpv6/bpstats2/#description","title":"DESCRIPTION","text":"<p>bpstats2 creates bundles containing the current values of all BP processing statistics accumulators.  It creates these bundles when:</p> <ul> <li>an interrogation bundle is delivered to sourceEID: the contents of the bundle are discarded, a new statistics bundle is generated and sent to the source of the interrogation bundle.  The format of the interrogation bundle is irrelevant.</li> <li>a SIGUSR1 signal is delivered to the bpstats2 application: a new statistics bundle is generated and sent to default destEID.</li> </ul>"},{"location":"man/bpv6/bpstats2/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpstats2 has terminated. Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>bpstats2 failed to start up or receive bundles.  Diagnose the issue  reported in the ion.log file and try again.</p> </li> </ul>"},{"location":"man/bpv6/bpstats2/#options","title":"OPTIONS","text":"<ul> <li> \\[ct\\] <p>If the string \"ct\" is appended as the last argument, then statistics bundles will be sent with custody transfer requested.</p> </li> </ul>"},{"location":"man/bpv6/bpstats2/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bpstats2/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bpstats2/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpstats2 can't bp_attach().</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>bpstats2 can't open own endpoint.</p> <p>Another BP application has opened that endpoint; close it and try again.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpstats2 can't send stats bundle.</p> <p>Bundle Protocol service to the remote endpoint has been stopped.</p> </li> <li> <p>Can't send stats: bad dest EID (dest EID)</p> <p>The destination EID printed is an invalid destination EID.  The destination EID may be specified in default destEID or the source EID of the interrogation bundle.  Ensure that default destEID is an EID that  is valid for ION, and that the interrogator is a source EID that is also a valid destination EID.  Note that \"dtn:none\" is not a valid destination EID, but is a valid source EID.</p> </li> </ul>"},{"location":"man/bpv6/bpstats2/#notes","title":"NOTES","text":"<p>A very simple interrogator is bpchat which can repeatedly interrogate bpstats2 by just striking the enter key.</p>"},{"location":"man/bpv6/bpstats2/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bpstats2/#see-also","title":"SEE ALSO","text":"<p>bpstats(1), bpchat(1)</p>"},{"location":"man/bpv6/bptrace/","title":"NAME","text":"<p>bptrace - Bundle Protocol (BP) network trace utility</p>"},{"location":"man/bpv6/bptrace/#synopsis","title":"SYNOPSIS","text":"<p>bptrace own_endpoint_ID destination_endpoint_ID report-to_endpoint_ID TTL class_of_service \"trace_text\" [status_report_flags]</p>"},{"location":"man/bpv6/bptrace/#description","title":"DESCRIPTION","text":"<p>bptrace uses bp_send() to issue a single bundle to a designated destination endpoint, with status reporting options enabled as selected by the user, then terminates.  The status reports returned as the bundle makes its way through the network provide a view of the operation of the network as currently configured.</p> <p>TTL indicates the number of seconds the trace bundle may remain in the network, undelivered, before it is automatically destroyed.</p> <p>class_of_service is custody-requested.priority[.ordinal[.unreliable.critical[.data-label]]], where custody-requested must be 0 or 1 (Boolean), priority must be 0 (bulk) or 1 (standard) or 2 (expedited), ordinal must be 0-254, unreliable must be 0 or 1 (Boolean), critical must also be 0 or 1 (Boolean), and data-label may be any unsigned integer.  ordinal is ignored if priority is not 2.  Setting class_of_service to \"0.2.254\" or \"1.2.254\" gives a bundle the highest possible priority.  Setting unreliable to 1 causes BP to forego retransmission in the event of data loss, both at the BP layer and at the convergence layer. Setting critical to 1 causes contact graph routing to forward the bundle on all plausible routes rather than just the \"best\" route it computes; this may result in multiple copies of the bundle arriving at the destination endpoint, but when used in conjunction with priority 2.254 it ensures that the bundle will be delivered as soon as physically possible.</p> <p>trace_text can be any string of ASCII text; alternatively, if we want to send a file, it can be \"@\" followed by the file name.</p> <p>status_report_flags must be a sequence of status report flags, separated by commas, with no embedded whitespace.  Each status report flag must be one of the following: rcv, ct, fwd, dlv, del.</p>"},{"location":"man/bpv6/bptrace/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bptrace has terminated.</p> </li> </ul>"},{"location":"man/bpv6/bptrace/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bptrace/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bptrace/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bptrace can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>bptrace can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>No space for bptrace text.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bptrace can't create ZCO.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bptrace can't send message.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv6/bptrace/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bptrace/#see-also","title":"SEE ALSO","text":"<p>bp(3)</p>"},{"location":"man/bpv6/bptransit/","title":"NAME","text":"<p>bptransit - Bundle Protocol (BP) daemon task for forwarding received bundles</p>"},{"location":"man/bpv6/bptransit/#synopsis","title":"SYNOPSIS","text":"<p>bptransit</p>"},{"location":"man/bpv6/bptransit/#description","title":"DESCRIPTION","text":"<p>bptransit is a background \"daemon\" task that is responsible for presenting to ION's forwarding daemons any bundles that were received from other nodes (i.e., bundles whose payloads reside in Inbound ZCO space) and are destined for yet other nodes.  In doing so, it migrates these bundles from Inbound buffer space to Outbound buffer space on the same prioritized basis as the insertion of locally sourced outbound bundles.</p> <p>Management of the bptransit daemon is automatic.  It is spawned automatically by bpadmin in response to the 's' command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.</p> <p>Whenever a received bundle is determined to have a destination other than the local node, a pointer to that bundle is appended to one of two queues of  \"in-transit\" bundles, one for bundles whose forwarding is provisional (depending on the availability of Outbound ZCO buffer space; bundles in this queue are potentially subject to congestion loss) and one for bundles whose forwarding is confirmed.  Bundles received via convergence-layer adapters that can sustain flow control, such as STCP, are appended to the \"confirmed\" queue, while those from CLAs that cannot sustain flow control (such as LTP) are appended to the \"provisional\" queue.</p> <p>bptransit comprises two threads, one for each in-transit queue.  The confirmed in-transit thread dequeues bundles from the \"confirmed\" queue and moves them from Inbound to Outbound ZCO buffer space, blocking (if necessary) until space becomes available.  The provisional in-transit queue dequeues bundles from the \"provisional\" queue and moves them from Inbound to Outbound ZCO buffer space if Outbound space is available, discarding (\"abandoning\") them if it is not.</p>"},{"location":"man/bpv6/bptransit/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bptransit terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart bptransit.</p> </li> <li> <p>\"1\"</p> <p>bptransit was unable to attach to Bundle Protocol operations, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv6/bptransit/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/bptransit/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/bptransit/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bptransit can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv6/bptransit/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/bptransit/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1)</p>"},{"location":"man/bpv6/brsccla/","title":"NAME","text":"<p>brsccla - BRSC-based BP convergence layer adapter (input and output) task</p>"},{"location":"man/bpv6/brsccla/#synopsis","title":"SYNOPSIS","text":"<p>brsccla server_hostname[:server_port_nbr]_own_node_nbr</p>"},{"location":"man/bpv6/brsccla/#description","title":"DESCRIPTION","text":"<p>BRSC is the \"client\" side of the Bundle Relay Service (BRS) convergence layer protocol for BP.  It is complemented by BRSS, the \"server\" side of the BRS convergence layer protocol for BP.  BRS clients send bundles directly only to the server, regardless of their final destinations, and the server forwards them to other clients as necessary.</p> <p>brsccla is a background \"daemon\" task comprising three threads: one that connects to the BRS server, spawns the other threads, and then handles BRSC protocol output by transmitting bundles over the connected socket to the BRS server; one that simply sends periodic \"keepalive\" messages over the connected socket to the server (to assure that local inactivity doesn't cause the connection to be lost); and one that handles BRSC protocol input from the connected server.</p> <p>The output thread connects to the server's TCP socket at server_hostname and server_port_nbr, sends over the connected socket the client's own_node_nbr (in SDNV representation) followed by a 32-bit time tag and a 160-bit HMAC-SHA1 digest of that time tag, to authenticate itself; checks the authenticity of the 160-bit countersign returned by the server; spawns the keepalive and receiver threads; and then begins extracting bundles from the queues of bundles ready for transmission via BRSC and transmitting those bundles over the connected socket to the server.  Each transmitted bundle is preceded by its length, a 32-bit unsigned integer in network byte order.  The default value for server_port_nbr, if omitted, is 80.</p> <p>The reception thread receives bundles over the connected socket and passes them to the bundle protocol agent on the local ION node.  Each bundle received on the connection is preceded by its length, a 32-bit unsigned integer in network byte order.</p> <p>The keepalive thread simply sends a \"bundle length\" value of zero (a 32-bit unsigned integer in network byte order) to the server once every 15 seconds.</p> <p>brsccla is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  brsccla can also be spawned and terminated in response to START and STOP commands that pertain specifically to the BRSC convergence layer protocol.</p>"},{"location":"man/bpv6/brsccla/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>brsccla terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the BRSC protocol.</p> </li> <li> <p>\"1\"</p> <p>brsccla terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the BRSC protocol.</p> </li> </ul>"},{"location":"man/bpv6/brsccla/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/brsccla/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/brsccla/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>brsccla can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such brsc induct.</p> <p>No BRSC induct with duct name matching server_hostname, own_node_nbr, and server_port_nbr has been added to the BP database.  Use bpadmin to stop the BRSC convergence-layer protocol, add the induct, and then restart the BRSC protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of brsccla.</p> </li> <li> <p>No such brsc outduct.</p> <p>No BRSC outduct with duct name matching server_hostname, own_node_nbr, and server_port_nbr has been added to the BP database.  Use bpadmin to stop the BRSC convergence-layer protocol, add the outduct, and then restart the BRSC protocol.</p> </li> <li> <p>Can't connect to server.</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSC.</p> </li> <li> <p>Can't register with server.</p> <p>Configuration error.  Authentication has failed, probably because (a) the client and server are using different HMAC/SHA1 keys or (b) the clocks of the client and server differ by more than 5 seconds.  Update security policy database(s), as necessary, and assure that the clocks are synchronized.</p> </li> <li> <p>brsccla can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSC.</p> </li> <li> <p>brsccla can't create keepalive thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSC.</p> </li> </ul>"},{"location":"man/bpv6/brsccla/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/brsccla/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), brsscla(1)</p>"},{"location":"man/bpv6/brsscla/","title":"NAME","text":"<p>brsscla - BRSS-based BP convergence layer adapter (input and output) task</p>"},{"location":"man/bpv6/brsscla/#synopsis","title":"SYNOPSIS","text":"<p>brsscla local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv6/brsscla/#description","title":"DESCRIPTION","text":"<p>BRSS is the \"server\" side of the Bundle Relay Service (BRS) convergence layer protocol for BP.  It is complemented by BRSC, the \"client\" side of the BRS convergence layer protocol for BP.</p> <p>brsscla is a background \"daemon\" task that spawns 2*N threads: one that handles BRSS client connections and spawns sockets for continued data interchange with connected clients; one that handles BRSS protocol output by transmitting over those spawned sockets to the associated clients; and two thread for each spawned socket, an input thread to handle BRSS protocol input from the associated connected client and an output thread to forward BRSS protocol output to the associated connected client.</p> <p>The connection thread simply accepts connections on a TCP socket bound to local_hostname and local_port_nbr and spawns reception threads.  The default value for local_port_nbr, if omitted, is 80.</p> <p>Each reception thread receives over the socket connection the node number of the connecting client (in SDNV representation), followed by a 32-bit time tag and a 160-bit HMAC-SHA1 digest of that time tag.  The receiving thread checks the time tag, requiring that it differ from the current time by no more than BRSTERM (default value 5) seconds.  It then recomputes the digest value using the HMAC-SHA1 key named \"node_number.brs\" as recorded in the ION security database (see ionsecrc(5)), requiring that the supplied and computed digests be identical.  If all registration conditions are met, the receiving thread sends the client a countersign -- a similarly computed HMAC-SHA1 digest, for the time tag that is 1 second later than the provided time tag -- to assure the client of its own authenticity, then commences receiving bundles over the connected socket.  Each bundle received on the connection is preceded by its length, a 32-bit unsigned integer in network byte order.  The received bundles are passed to the bundle protocol agent on the local ION node.</p> <p>Each output thread extracts bundles from the queues of bundles ready for transmission via BRSS to the corresponding connected client and transmits the bundles over the socket to that client.  Each transmitted bundle is preceded by its length, a 32-bit unsigned integer in network byte order.</p> <p>brsscla is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  brsscla can also be spawned and terminated in response to START and STOP commands that pertain specifically to the BRSS convergence layer protocol.</p>"},{"location":"man/bpv6/brsscla/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>brsscla terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the BRSS protocol.</p> </li> <li> <p>\"1\"</p> <p>brsscla terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the BRSS protocol.</p> </li> </ul>"},{"location":"man/bpv6/brsscla/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/brsscla/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/brsscla/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>brsscla can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such brss induct.</p> <p>No BRSS induct with duct name matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the BRSS convergence-layer protocol, add the induct, and then restart the BRSS protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of brsscla.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>Can't open TCP socket</p> <p>Operating system error -- unable to open TCP socket for accepting connections. Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>Can't initialize socket (note: must be root for port 80)</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>brsscla can't create sender thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>brsscla can't create access thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> </ul>"},{"location":"man/bpv6/brsscla/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/brsscla/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), brsccla(1)</p>"},{"location":"man/bpv6/cgrfetch/","title":"NAME","text":"<p>cgrfetch - Visualize CGR simulations</p>"},{"location":"man/bpv6/cgrfetch/#synopsis","title":"SYNOPSIS","text":"<p>cgrfetch [OPTIONS] DEST-NODE</p>"},{"location":"man/bpv6/cgrfetch/#description","title":"DESCRIPTION","text":"<p>cgrfetch uses CGR to simulate sending a bundle from the local node to DEST-NODE. It traces the execution of CGR to generate graphs of the routes that were considered and the routes that were ultimately chosen to forward along. No bundle is sent during the simulation.</p> <p>A JSON representation of the simulation is output to OUTPUT-FILE. The representation includes parameters of the simulation and a structure for each considered route, which in turn includes calculated parameters for the route and an image of the contact graph.</p> <p>The dot(1) tool from the Graphviz package is used to generate the contact graph images and is required for cgrfetch(1). The base64(1) tool from coreutils is used to embed the images in the JSON and is also required.</p> <p>Note that a trace of the route computation logic performed by CGR is printed to stderr; there is currently no cgrfetch option for redirecting this output to a file.</p>"},{"location":"man/bpv6/cgrfetch/#options","title":"OPTIONS","text":"<ul> <li> <p>DEST-NODE</p> <p>The final destination to route to. To be useful, it should be a node that exists in the contact plan.</p> </li> <li> <p>-q</p> <p>Disable trace message output.</p> </li> <li> <p>-j</p> <p>Disable JSON output.</p> </li> <li> <p>-m</p> <p>Use a minimum-latency extended COS for the bundle. This ends up sending the bundle to all proximate nodes.</p> </li> <li> <p>-t DISPATCH-OFFSET</p> <p>Request a dispatch time of DISPATCH-OFFSET seconds from the time the command is run (default: 0).</p> </li> <li> <p>-e EXPIRATION-OFFSET</p> <p>Set the bundle expiration time to EXPIRATION-OFFSET seconds from the time the command is run (default: 3600).</p> </li> <li> <p>-s BUNDLE-SIZE</p> <p>Set the bundle payload size to BUNDLE-SIZE bytes (default: 0).</p> </li> <li> <p>-o OUTPUT-FILE</p> <p>Send JSON to OUTPUT-FILE (default: stdout).</p> </li> <li> <p>-d PROTO:NAME</p> <p>Use PROTO as the outduct protocol and NAME as the outduct name (default: udp:*). Use list to list all available outducts.</p> </li> </ul>"},{"location":"man/bpv6/cgrfetch/#examples","title":"EXAMPLES","text":"<ul> <li> <p>cgrfetch 8</p> <p>Simulate CGR with destination node 8 and dispatch time equal to the current time.</p> </li> <li> <p>cgrfetch 8 -t 60</p> <p>Do the same with a dispatch time 60 seconds in the future.</p> </li> <li> <p>cgrfetch -d list</p> <p>List all available outducts.</p> </li> </ul>"},{"location":"man/bpv6/cgrfetch/#see-also","title":"SEE ALSO","text":"<p>dot(1), base64(1)</p>"},{"location":"man/bpv6/dccpcli/","title":"NAME","text":"<p>dccpcli - DCCP-based BP convergence layer input task</p>"},{"location":"man/bpv6/dccpcli/#synopsis","title":"SYNOPSIS","text":"<p>dccpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv6/dccpcli/#description","title":"DESCRIPTION","text":"<p>dccpcli is a background \"daemon\" task that receives DCCP datagrams via a DCCP socket bound to local_hostname and local_port_nbr, extracts bundles from those datagrams, and passes them to the bundle protocol agent on the local ION node.</p> <p>If not specified, port number defaults to 4556.</p> <p>Note that dccpcli has no fragmentation support at all. Therefore, the largest bundle that can be sent via this convergence layer is limited to just under the link's MTU (typically 1500 bytes).</p> <p>The convergence layer input task is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"dccp\" convergence layer protocol is added to the BP database.  The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  dccpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DCCP convergence layer protocol.</p>"},{"location":"man/bpv6/dccpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dccpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dccpcli.</p> </li> <li> <p>\"1\"</p> <p>dccpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dccpcli.</p> </li> </ul>"},{"location":"man/bpv6/dccpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/dccpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dccpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dccpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such dccp duct.</p> <p>No DCCP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the DCCP convergence-layer protocol, add the induct, and then restart the DCCP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of dccpcli.</p> </li> <li> <p>dccpcli can't get IP address for host.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> <li> <p>CLI can't open DCCP socket. This probably means DCCP is not supported on your system.</p> <p>Operating system error. This probably means that you are not using an operating system that supports DCCP. Make sure that you are using a current Linux kernel and that the DCCP modules are being compiled. Check errtext,  correct problem, and restart dccpcli.</p> </li> <li> <p>CLI can't initialize socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> <li> <p>dccpcli can't get acquisition work area.</p> <p>ION system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> <li> <p>dccpcli can't create new thread.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> </ul>"},{"location":"man/bpv6/dccpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dccpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), dccpclo(1)</p>"},{"location":"man/bpv6/dccpclo/","title":"NAME","text":"<p>dccpclo - DCCP-based BP convergence layer output task</p>"},{"location":"man/bpv6/dccpclo/#synopsis","title":"SYNOPSIS","text":"<p>dccpclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv6/dccpclo/#description","title":"DESCRIPTION","text":"<p>dccpclo is a background \"daemon\" task that connects to a remote node's DCCP socket at remote_hostname and remote_port_nbr. It then begins extracting bundles from the queues of bundles ready for transmission via DCCP to this remote bundle protocol agent and transmitting those bundles as DCCP datagrams to the remote host.</p> <p>If not specified, remote_port_nbr defaults to 4556.</p> <p>Note that dccpclo has no fragmentation support at all. Therefore, the largest bundle that can be sent via this convergence layer is limited to just under the link's MTU (typically 1500 bytes).</p> <p>dccpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dccpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DCCP convergence layer protocol.</p>"},{"location":"man/bpv6/dccpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dccpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dccpclo.</p> </li> <li> <p>\"1\"</p> <p>dccpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dccpclo.</p> </li> </ul>"},{"location":"man/bpv6/dccpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/dccpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dccpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dccpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No memory for DCCP buffer in dccpclo.</p> <p>ION system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>No such dccp duct.</p> <p>No DCCP outduct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the DCCP convergence-layer protocol, add the outduct, and then restart dccpclo.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of dccpclo.</p> </li> <li> <p>dccpclo can't get IP address for host.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>dccpclo can't create thread.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>CLO can't open DCCP socket. This probably means DCCP is not supported on your system.</p> <p>Operating system error. This probably means that you are not using an operating system that supports DCCP. Make sure that you are using a current Linux kernel and that the DCCP modules are being compiled. Check errtext,  correct problem, and restart dccpclo.</p> </li> <li> <p>CLO can't initialize socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>CLO send() error on socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>Bundle is too big for DCCP CLO.</p> <p>Configuration error: bundles that are too large for DCCP transmission (i.e., larger than the MTU of the link or 65535 bytes--whichever is smaller) are being enqueued for dccpclo.  Change routing or use smaller bundles.</p> </li> </ul>"},{"location":"man/bpv6/dccpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dccpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), dccpcli(1)</p>"},{"location":"man/bpv6/dgrcli/","title":"NAME","text":"<p>dgrcli - DGR-based BP convergence layer reception task</p>"},{"location":"man/bpv6/dgrcli/#synopsis","title":"SYNOPSIS","text":"<p>dgrcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv6/dgrcli/#description","title":"DESCRIPTION","text":"<p>dgrcli is a background \"daemon\" task that handles DGR convergence layer protocol input.</p> <p>The daemon receives DGR messages via a UDP socket bound to local_hostname and local_port_nbr, extracts bundles from those messages, and passes them to the bundle protocol agent on the local ION node. (local_port_nbr defaults to 1113 if not specified.)</p> <p>dgrcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dgrcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DGR convergence layer protocol.</p>"},{"location":"man/bpv6/dgrcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dgrcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dgrcli.</p> </li> <li> <p>\"1\"</p> <p>dgrcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dgrcli.</p> </li> </ul>"},{"location":"man/bpv6/dgrcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/dgrcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dgrcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dgrcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such dgr induct.</p> <p>No DGR induct with duct name matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the DGR convergence-layer protocol, add the induct, and then restart the DGR protocol.</p> </li> <li> <p>CLI task is already started for this engine.</p> <p>Redundant initiation of dgrcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> <li> <p>dgrcli can't open DGR service access point.</p> <p>DGR system error.  Check prior messages in ion.log log file, correct problem, and then stop and restart the DGR protocol.</p> </li> <li> <p>dgrcli can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> </ul>"},{"location":"man/bpv6/dgrcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dgrcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv6/dgrclo/","title":"NAME","text":"<p>dgrclo - DGR-based BP convergence layer transmission task</p>"},{"location":"man/bpv6/dgrclo/#synopsis","title":"SYNOPSIS","text":"<p>dgrclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv6/dgrclo/#description","title":"DESCRIPTION","text":"<p>dgrclo is a background \"daemon\" task that spawns two threads, one that handles DGR convergence layer protocol input (positive and negative acknowledgments) and a second that handles DGR convergence layer protocol output.</p> <p>The output thread extracts bundles from the queues of bundles ready for transmission via DGR to a remote bundle protocol agent, encapsulates them in DGR messages, and uses a randomly configured local UDP socket to send those messages to the remote UDP socket bound to remote_hostname and remote_port_nbr.  (local_port_nbr defaults to 1113 if not specified.)</p> <p>The input thread receives DGR messages via the same local UDP socket and uses them to manage DGR retransmission of transmitted datagrams.</p> <p>dgrclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dgrclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DGR convergence layer protocol.</p>"},{"location":"man/bpv6/dgrclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dgrclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dgrclo.</p> </li> <li> <p>\"1\"</p> <p>dgrclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dgrclo.</p> </li> </ul>"},{"location":"man/bpv6/dgrclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/dgrclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dgrclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dgrclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>CLI task is already started for this engine.</p> <p>Redundant initiation of dgrclo.</p> </li> <li> <p>No such dgr outduct.</p> <p>No DGR outduct with duct name matching remote_hostname and remote_port_nbr has been added to the BP database.  Use bpadmin to stop the DGR convergence-layer protocol, add the outduct, and then restart the DGR protocol.</p> </li> <li> <p>dgrclo can't open DGR service access point.</p> <p>DGR system error.  Check prior messages in ion.log log file, correct problem, and then stop and restart the DGR protocol.</p> </li> <li> <p>dgrclo can't create sender thread</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> <li> <p>dgrclo can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> </ul>"},{"location":"man/bpv6/dgrclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dgrclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv6/dtn2admin/","title":"NAME","text":"<p>dtn2admin - baseline \"dtn\" scheme administration interface</p>"},{"location":"man/bpv6/dtn2admin/#synopsis","title":"SYNOPSIS","text":"<p>dtn2admin [ commands_filename ]</p>"},{"location":"man/bpv6/dtn2admin/#description","title":"DESCRIPTION","text":"<p>dtn2admin configures the local ION node's routing of bundles to endpoints whose IDs conform to the dtn endpoint ID scheme.  dtn is a non-CBHE-conformant scheme.  The structure of dtn endpoint IDs remains somewhat in flux at the time of this writing, but endpoint IDs in the dtn scheme historically have been strings of the form \"dtn://node_name[/demux_token]\", where node_name normally identifies a computer somewhere on the network and demux_token normally identifies a specific application processing point.  Although the dtn endpoint ID scheme imposes more transmission overhead than the ipn scheme, ION provides support for dtn endpoint IDs to enable interoperation with other implementations of Bundle Protocol.</p> <p>dtn2admin operates in response to \"dtn\" scheme configuration commands found in the file commands_filename, if provided; if not, dtn2admin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from dtn2admin with the 'h' or '?' commands at the prompt.  The commands are documented in dtn2rc(5).</p>"},{"location":"man/bpv6/dtn2admin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of \"dtn\" scheme administration.</li> <li>\"1\" Unsuccessful completion of \"dtn\" scheme administration, due to inability to attach to the Bundle Protocol system or to initialize the \"dtn\" scheme.</li> </ul>"},{"location":"man/bpv6/dtn2admin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>dtn2admin</p> <p>Enter interactive \"dtn\" scheme configuration command entry mode.</p> </li> <li> <p>dtn2admin host1.dtn2rc</p> <p>Execute all configuration commands in host1.dtn2rc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv6/dtn2admin/#files","title":"FILES","text":"<p>See dtn2rc(5) for details of the DTN scheme configuration commands.</p>"},{"location":"man/bpv6/dtn2admin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dtn2admin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the dtn2rc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to dtn2admin.  Otherwise dtn2admin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>dtn2admin can't attach to BP.</p> <p>Bundle Protocol has not been initialized on this computer.  You need to run bpadmin(1) first.</p> </li> <li> <p>dtn2admin can't initialize routing database.</p> <p>There is no SDR data store for dtn2admin to use.  Please run ionadmin(1) to start the local ION node.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause dtn2admin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see dtn2rc(5) for details.</p>"},{"location":"man/bpv6/dtn2admin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dtn2admin/#see-also","title":"SEE ALSO","text":"<p>dtn2rc(5)</p>"},{"location":"man/bpv6/dtn2adminep/","title":"NAME","text":"<p>dtn2adminep - administrative endpoint task for the \"dtn\" scheme</p>"},{"location":"man/bpv6/dtn2adminep/#synopsis","title":"SYNOPSIS","text":"<p>dtn2adminep</p>"},{"location":"man/bpv6/dtn2adminep/#description","title":"DESCRIPTION","text":"<p>dtn2adminep is a background \"daemon\" task that receives and processes administrative bundles (all custody signals and, nominally, all bundle status reports) that are sent to the \"dtn\"-scheme administrative endpoint on the local ION node, if and only if such an endpoint was established by bpadmin.  It is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dtn2adminep can also be spawned and terminated in response to START and STOP commands that pertain specifically to the \"dtn\" scheme.</p> <p>dtn2adminep responds to custody signals as specified in the Bundle Protocol specification, RFC 5050.  It responds to bundle status reports by logging ASCII text messages describing the reported activity.</p>"},{"location":"man/bpv6/dtn2adminep/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dtn2adminep terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dtn2adminep.</p> </li> <li> <p>\"1\"</p> <p>dtn2adminep was unable to attach to Bundle Protocol operations or was unable to load the \"dtn\" scheme database, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv6/dtn2adminep/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/dtn2adminep/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dtn2adminep/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dtn2adminep can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>dtn2adminep can't load routing database.</p> <p>dtn2admin has not yet initialized the \"dtn\" scheme.</p> </li> <li> <p>dtn2adminep can't get admin EID.</p> <p>dtn2admin has not yet initialized the \"dtn\" scheme.</p> </li> <li> <p>dtn2adminep crashed.</p> <p>An unrecoverable database error was encountered.  dtn2adminep terminates.</p> </li> </ul>"},{"location":"man/bpv6/dtn2adminep/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dtn2adminep/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), dtn2admin(1).</p>"},{"location":"man/bpv6/dtn2fw/","title":"NAME","text":"<p>dtn2fw - bundle route computation task for the \"dtn\" scheme</p>"},{"location":"man/bpv6/dtn2fw/#synopsis","title":"SYNOPSIS","text":"<p>dtn2fw</p>"},{"location":"man/bpv6/dtn2fw/#description","title":"DESCRIPTION","text":"<p>dtn2fw is a background \"daemon\" task that pops bundles from the queue of bundle destined for \"dtn\"-scheme endpoints, computes proximate destinations for those bundles, and appends those bundles to the appropriate queues of bundles pending transmission to those computed proximate destinations.</p> <p>For each possible proximate destination (that is, neighboring node) there is a separate queue for each possible level of bundle priority: 0, 1, 2.  Each outbound bundle is appended to the queue matching the bundle's designated priority.</p> <p>Proximate destination computation is affected by static routes as configured by dtn2admin(1).</p> <p>dtn2fw is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dtn2fw can also be spawned and terminated in response to START and STOP commands that pertain specifically to the \"dtn\" scheme.</p>"},{"location":"man/bpv6/dtn2fw/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dtn2fw terminated, for reasons noted in the ion.log log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dtn2fw.</p> </li> <li> <p>\"1\"</p> <p>dtn2fw could not commence operations, for reasons noted in the ion.log log file.  Investigate and solve the problem identified in the log file, then use bpadmin to restart dtn2fw.</p> </li> </ul>"},{"location":"man/bpv6/dtn2fw/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/dtn2fw/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/dtn2fw/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dtn2fw can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>dtn2fw can't load routing database.</p> <p>dtn2admin has not yet initialized the \"dtn\" scheme.</p> </li> <li> <p>Can't create lists for route computation.</p> <p>An unrecoverable database error was encountered.  dtn2fw terminates.</p> </li> <li> <p>'dtn' scheme is unknown.</p> <p>The \"dtn\" scheme was not added when bpadmin initialized BP operations.  Use bpadmin to add and start the scheme.</p> </li> <li> <p>Can't take forwarder semaphore.</p> <p>ION system error.  dtn2fw terminates.</p> </li> <li> <p>Can't enqueue bundle.</p> <p>An unrecoverable database error was encountered.  dtn2fw terminates.</p> </li> </ul>"},{"location":"man/bpv6/dtn2fw/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/dtn2fw/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), dtn2admin(1), bprc(5), dtn2rc(5).</p>"},{"location":"man/bpv6/dtn2rc/","title":"NAME","text":"<p>dtn2rc - \"dtn\" scheme configuration commands file</p>"},{"location":"man/bpv6/dtn2rc/#description","title":"DESCRIPTION","text":"<p>\"dtn\" scheme configuration commands are passed to dtn2admin either in a file of text lines or interactively at dtn2admin's command prompt (:). Commands are interpreted line-by line, with exactly one command per line.</p> <p>\"dtn\" scheme configuration commands establish static routing rules for forwarding bundles to \"dtn\"-scheme destination endpoints, identified by node ID.  (Each node ID is simply a BP endpoint ID.)</p> <p>Static routes are expressed as plans in the \"dtn\"-scheme routing database. A plan that is established for a given node name associates a routing directive with the named node.  Each directive is a string of one of two possible forms:</p> <p>f endpoint_ID</p> <p>...or...</p> <p>x protocol_name/outduct_name</p> <p>The former form signifies that the bundle is to be forwarded to the indicated endpoint, requiring that it be re-queued for processing by the forwarder for that endpoint (which might, but need not, be identified by another \"dtn\"-scheme endpoint ID).  The latter form signifies that the bundle is to be queued for transmission via the indicated convergence layer protocol outduct.</p> <p>The node IDs cited in dtn2rc plans may be \"wild-carded\".  That is, when the last character of a node ID is either '*' or '~' (these two wild-card characters are equivalent for this purpose), the plan applies to all nodes whose IDs are identical to the wild-carded node name up to the wild-card character.  For example, a bundle whose destination EID name is \"dtn://foghorn\" would be routed by plans citing the following node IDs: \"dtn://foghorn\", \"dtn://fogh*\", \"dtn://fog~\", \"//*\".  When multiple plans are all applicable to the same destination EID, the one citing the longest (i.e., most narrowly targeted) node ID will be applied.</p> <p>The formats and effects of the DTN scheme configuration commands are described below.</p>"},{"location":"man/bpv6/dtn2rc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by dtn2admin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv6/dtn2rc/#plan-commands","title":"PLAN COMMANDS","text":"<ul> <li> <p>a plan node_ID directive [nominal_xmit_rate]</p> <p>The add plan command.  This command establishes a static route for the bundles destined for the node(s) identified by node_ID.  The nominal_xmit_rate is the assumed rate of transmission to this node in the absence of contact plan information.  A nominal_data_rate of zero (the default) in the absence of contact plan information completely disables rate control.</p> <p>Note that the plan commands consumed by dtn2admin are a simplified shortcut for submitting plan commands as consumed by bpadmin (see bprc(5)). The syntax of these commands is DIFFERENT from that of the more general and more powerful bpadmin commands.</p> </li> <li> <p>c plan node_ID [directive] [nominal_xmit_rate]</p> <p>The change plan command.  This command revises the directive and/or nominal_data_rate of the static route for the node(s) identified by node_ID.</p> </li> <li> <p>d plan node_ID</p> <p>The delete plan command.  This command deletes the static route for the node(s) identified by node_ID.</p> </li> <li> <p>i plan node_ID</p> <p>This command will print information about the static route for the node(s) identified by node_ID.</p> </li> <li> <p>l plan</p> <p>This command lists all static routes established in the DTN database for the local node.</p> </li> </ul>"},{"location":"man/bpv6/dtn2rc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a plan dtn://bbn2 f ipn:8.41</p> <p>Declares a static route from the local node to node \"//bbn2\".  Any bundle destined for any endpoint whose node name is \"//bbn2\" will be forwarded to endpoint \"ipn:8.41\".</p> </li> <li> <p>a plan dtn://mitre1* x ltp/6</p> <p>Declares a static route from the local node to node \"//mitre1\".  Any bundle destined for any endpoint whose node ID begins with \"mitre1\" will be queued for transmission on LTP outduct 6.</p> </li> </ul>"},{"location":"man/bpv6/dtn2rc/#see-also","title":"SEE ALSO","text":"<p>dtn2admin(1)</p>"},{"location":"man/bpv6/hmackeys/","title":"NAME","text":"<p>hmackeys - utility program for generating good HMAC-SHA1 keys</p>"},{"location":"man/bpv6/hmackeys/#synopsis","title":"SYNOPSIS","text":"<p>hmackeys [ keynames_filename ]</p>"},{"location":"man/bpv6/hmackeys/#description","title":"DESCRIPTION","text":"<p>hmackeys writes files containing randomized 160-bit key values suitable for use by HMAC-SHA1 in support of Bundle Authentication Block processing, Bundle Relay Service connections, or other functions for which symmetric hash computation is applicable.  One file is written for each key name presented to hmackeys; the content of each file is 20 consecutive randomly selected 8-bit integer values, and the name given to each file is simply \"keyname.hmk\".</p> <p>hmackeys operates in response to the key names found in the file keynames_filename, one name per file text line, if provided; if not, hmackeys prints a simple prompt (:) so that the user may type key names directly into standard input.</p> <p>When the program is run in interactive mode, either enter 'q' or press ^C to terminate.</p>"},{"location":"man/bpv6/hmackeys/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Completion of key generation.</li> </ul>"},{"location":"man/bpv6/hmackeys/#examples","title":"EXAMPLES","text":"<ul> <li> <p>hmackeys</p> <p>Enter interactive HMAC/SHA1 key generation mode.</p> </li> <li> <p>hmackeys host1.keynames</p> <p>Create a key file for each key name in host1.keynames, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv6/hmackeys/#files","title":"FILES","text":"<p>No other files are used in the operation of hmackeys.</p>"},{"location":"man/bpv6/hmackeys/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/hmackeys/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>Can't open keynames file...</p> <p>The keynames_filename specified in the command line doesn't exist.</p> </li> </ul>"},{"location":"man/bpv6/hmackeys/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/hmackeys/#see-also","title":"SEE ALSO","text":"<p>brsscla(1), ionsecadmin(1)</p>"},{"location":"man/bpv6/imcadmin/","title":"NAME","text":"<p>imcadmin - Interplanetary Multicast (IMC) scheme administration interface</p>"},{"location":"man/bpv6/imcadmin/#synopsis","title":"SYNOPSIS","text":"<p>imcadmin [ commands_filename ]</p>"},{"location":"man/bpv6/imcadmin/#description","title":"DESCRIPTION","text":"<p>imcadmin configures the local ION node's routing of bundles to endpoints whose IDs conform to the imc endpoint ID scheme.  imc is a CBHE-conformant scheme; that is, every endpoint ID in the imc scheme is a string of the form \"imc:group_number.service_number\" where group_number (an IMC multicast group number) serves as a CBHE \"node number\" and service_number identifies a specific application processing point.</p> <p>imcadmin operates in response to IMC scheme configuration commands found in the file commands_filename, if provided; if not, imcadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from imcadmin with the 'h' or '?' commands at the prompt.  The commands are documented in imcrc(5).</p>"},{"location":"man/bpv6/imcadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of IMC scheme administration.</li> <li>\"1\" Unsuccessful completion of IMC scheme administration, due to inability to attach to the Bundle Protocol system or to initialize the IMC scheme.</li> </ul>"},{"location":"man/bpv6/imcadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>imcadmin</p> <p>Enter interactive IMC scheme configuration command entry mode.</p> </li> <li> <p>imcadmin host1.imcrc</p> <p>Execute all configuration commands in host1.imcrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv6/imcadmin/#files","title":"FILES","text":"<p>See imcrc(5) for details of the IMC scheme configuration commands.</p>"},{"location":"man/bpv6/imcadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/imcadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the imcrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to imcadmin.  Otherwise imcadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>imcadmin can't attach to BP.</p> <p>Bundle Protocol has not been initialized on this computer.  You need to run bpadmin(1) first.</p> </li> <li> <p>imcadmin can't initialize routing database.</p> <p>There is no SDR data store for imcadmin to use.  Please run ionadmin(1) to start the local ION node.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause imcadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see imcrc(5) for details.</p>"},{"location":"man/bpv6/imcadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/imcadmin/#see-also","title":"SEE ALSO","text":"<p>imcrc(5)</p>"},{"location":"man/bpv6/imcfw/","title":"NAME","text":"<p>imcfw - bundle route computation task for the IMC scheme</p>"},{"location":"man/bpv6/imcfw/#synopsis","title":"SYNOPSIS","text":"<p>imcfw</p>"},{"location":"man/bpv6/imcfw/#description","title":"DESCRIPTION","text":"<p>imcfw is a background \"daemon\" task that pops bundles from the queue of bundle destined for IMC-scheme (Interplanetary Multicast) endpoints, determines which \"relatives\" on the IMC multicast tree to forward the bundles to, and appends those bundles to the appropriate queues of bundles pending transmission to those proximate destinations.</p> <p>For each possible proximate destination (that is, neighboring node) there is a separate queue for each possible level of bundle priority: 0, 1, 2.  Each outbound bundle is appended to the queue matching the bundle's designated priority.</p> <p>Proximate destination computation is determined by multicast group membership as resulting from nodes' registration in multicast endpoints, governed by multicast tree structure as configured by imcadmin(1).</p> <p>imcfw is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  imcfw can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IMC scheme.</p>"},{"location":"man/bpv6/imcfw/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>imcfw terminated, for reasons noted in the ion.log log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart imcfw.</p> </li> <li> <p>\"1\"</p> <p>imcfw could not commence operations, for reasons noted in the ion.log log file.  Investigate and solve the problem identified in the log file, then use bpadmin to restart imcfw.</p> </li> </ul>"},{"location":"man/bpv6/imcfw/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/imcfw/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/imcfw/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>imcfw can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>imcfw can't load routing database.</p> <p>ipnadmin has not yet initialized the IPN scheme.</p> </li> <li> <p>Can't create lists for route computation.</p> <p>An unrecoverable database error was encountered.  imcfw terminates.</p> </li> <li> <p>'imc' scheme is unknown.</p> <p>The IMC scheme was not added when bpadmin initialized BP operations.  Use bpadmin to add and start the scheme.</p> </li> <li> <p>Can't take forwarder semaphore.</p> <p>ION system error.  imcfw terminates.</p> </li> <li> <p>Can't exclude sender from routes.</p> <p>An unrecoverable database error was encountered.  imcfw terminates.</p> </li> <li> <p>Can't enqueue bundle.</p> <p>An unrecoverable database error was encountered.  imcfw terminates.</p> </li> </ul>"},{"location":"man/bpv6/imcfw/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/imcfw/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), imcadmin(1), bprc(5), imcrc(5)</p>"},{"location":"man/bpv6/imcrc/","title":"NAME","text":"<p>imcrc - IMC scheme configuration commands file</p>"},{"location":"man/bpv6/imcrc/#description","title":"DESCRIPTION","text":"<p>IMC scheme configuration commands are passed to imcadmin either in a file of text lines or interactively at imcadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.</p> <p>IMC scheme configuration commands simply establish which nodes are the local node's parents and children within a single IMC multicast tree.  This single spanning tree, an overlay on a single BP-based network, is used to convey all multicast group membership assertions and cancellations in the network, for all groups.  Each node privately tracks which of its immediate \"relatives\" in the tree are members of which multicast groups and on this basis selectively forwards -- directly, to all (and only) interested relatives -- the bundles destined for the members of each group.</p> <p>Note that all of a node's immediate relatives in the multicast tree must be among its immediate neighbors in the underlying network.  This is because multicast bundles can only be correctly forwarded within the tree if each forwarding node knows the identity of the relative that passed the bundle to it, so that the bundle is not passed back to that relative creating a routing loop.  The identity of that prior forwarding node can only be known if the forwarding node was a neighbor, because no prior forwarding node (aside from the source) other than the immediate proximate (neighboring) sender of a received bundle is ever known.</p> <p>IMC group IDs are unsigned integers, just as IPN node IDs are unsigned integers.  The members of a group are nodes identified by node number, and the multicast tree parent and children of a node are neighboring nodes identified by node number.</p> <p>The formats and effects of the IMC scheme configuration commands are described below.</p>"},{"location":"man/bpv6/imcrc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ipnadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv6/imcrc/#kinship-commands","title":"KINSHIP COMMANDS","text":"<ul> <li> <p>a node_nbr { 1 | 0 }</p> <p>The add kin command.  This command adds the neighboring node identified by node_nbr as an immediate relative of the local node.  The Boolean value that follows the node number indicates whether or not this node is the local node's parent within the tree.</p> </li> <li> <p>c node_nbr { 1 | 0 }</p> <p>The change kin command.  This command changes the parentage status of the indicated relative according to Boolean value that follows the node number, as noted for the add kin command.</p> </li> <li> <p>d node_nbr</p> <p>The delete kin command.  This command deletes the immediate multicast tree relative identified by node_nbr.  That node still exists but it is no longer a parent or child of the local node.</p> </li> <li> <p>i node_nbr</p> <p>This command will print information (the parentage switch) for the multicast tree relative identified by node_nbr.</p> </li> <li> <p>l</p> <p>This command lists all of the local node's multicast tree relatives, indicating which one is its parent in the tree.</p> </li> </ul>"},{"location":"man/bpv6/imcrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a 983 1</p> <p>Declares that 983 is the local node's parent in the network's multicast tree.</p> </li> </ul>"},{"location":"man/bpv6/imcrc/#see-also","title":"SEE ALSO","text":"<p>imcadmin(1)</p>"},{"location":"man/bpv6/ipnadmin/","title":"NAME","text":"<p>ipnadmin - Interplanetary Internet (IPN) scheme administration interface</p>"},{"location":"man/bpv6/ipnadmin/#synopsis","title":"SYNOPSIS","text":"<p>ipnadmin [ commands_filename ]</p>"},{"location":"man/bpv6/ipnadmin/#description","title":"DESCRIPTION","text":"<p>ipnadmin configures the local ION node's routing of bundles to endpoints whose IDs conform to the ipn endpoint ID scheme.  ipn is a CBHE-conformant scheme; that is, every endpoint ID in the ipn scheme is a string of the form \"ipn:node_number.service_number\" where node_number is a CBHE \"node number\" and service_number identifies a specific application processing point.</p> <p>ipnadmin operates in response to IPN scheme configuration commands found in the file commands_filename, if provided; if not, ipnadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from ipnadmin with the 'h' or '?' commands at the prompt.  The commands are documented in ipnrc(5).</p>"},{"location":"man/bpv6/ipnadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of IPN scheme administration.</li> <li>\"1\" Unsuccessful completion of IPN scheme administration, due to inability to attach to the Bundle Protocol system or to initialize the IPN scheme.</li> </ul>"},{"location":"man/bpv6/ipnadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>ipnadmin</p> <p>Enter interactive IPN scheme configuration command entry mode.</p> </li> <li> <p>ipnadmin host1.ipnrc</p> <p>Execute all configuration commands in host1.ipnrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv6/ipnadmin/#files","title":"FILES","text":"<p>See ipnrc(5) for details of the IPN scheme configuration commands.</p>"},{"location":"man/bpv6/ipnadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/ipnadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ipnrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to ipnadmin.  Otherwise ipnadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>ipnadmin can't attach to BP.</p> <p>Bundle Protocol has not been initialized on this computer.  You need to run bpadmin(1) first.</p> </li> <li> <p>ipnadmin can't initialize routing database.</p> <p>There is no SDR data store for ipnadmin to use.  Please run ionadmin(1) to start the local ION node.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause ipnadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see ipnrc(5) for details.</p>"},{"location":"man/bpv6/ipnadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/ipnadmin/#see-also","title":"SEE ALSO","text":"<p>ipnrc(5)</p>"},{"location":"man/bpv6/ipnadminep/","title":"NAME","text":"<p>ipnadminep - administrative endpoint task for the IPN scheme</p>"},{"location":"man/bpv6/ipnadminep/#synopsis","title":"SYNOPSIS","text":"<p>ipnadminep</p>"},{"location":"man/bpv6/ipnadminep/#description","title":"DESCRIPTION","text":"<p>ipnadminep is a background \"daemon\" task that receives and processes administrative bundles (all custody signals and, nominally, all bundle status reports) that are sent to the IPN-scheme administrative endpoint on the local ION node, if and only if such an endpoint was established by bpadmin.  It is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  ipnadminep can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IPN scheme.</p> <p>ipnadminep responds to custody signals as specified in the Bundle Protocol specification, RFC 5050.  It responds to bundle status reports by logging ASCII text messages describing the reported activity.</p>"},{"location":"man/bpv6/ipnadminep/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ipnadminep terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart ipnadminep.</p> </li> <li> <p>\"1\"</p> <p>ipnadminep was unable to attach to Bundle Protocol operations or was unable to load the IPN scheme database, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv6/ipnadminep/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/ipnadminep/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/ipnadminep/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ipnadminep can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>ipnadminep can't load routing database.</p> <p>ipnadmin has not yet initialized the IPN scheme.</p> </li> <li> <p>ipnadminep crashed.</p> <p>An unrecoverable database error was encountered.  ipnadminep terminates.</p> </li> </ul>"},{"location":"man/bpv6/ipnadminep/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/ipnadminep/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), ipnadmin(1), bprc(5).</p>"},{"location":"man/bpv6/ipnd/","title":"NAME","text":"<p>ipnd - ION IPND module</p>"},{"location":"man/bpv6/ipnd/#description","title":"DESCRIPTION","text":"<p>The ipnd daemon is the ION implementation of DTN IP Neighbor Discovery. This module allows the node to send and receive beacon messages using  unicast, multicast or broadcast IP addresses. Beacons are used for the discovery of neighbors and may be used to advertise services that are  present and available on nodes, such as routing algorithms or CLAs.</p> <p>ION IPND module is configured using a *.rc configuration file.  The name of the configuration file must be passed as the sole command-line argument to ipnd when the daemon is started.  Commands are interpreted line by line, with exactly one command per line.  The formats and effects of the ION ipnd management commands are described below.</p>"},{"location":"man/bpv6/ipnd/#usage","title":"USAGE","text":"<p>ipnd config_file_name</p>"},{"location":"man/bpv6/ipnd/#commands","title":"COMMANDS","text":"<ul> <li> <p>1 </p> <p>The initialize command.  This must be the first command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ipnd to be logged into ion.log.  Setting echo to 0 disables this behavior. Default is 1.</p> </li> <li> <p>m eid eid</p> <p>Local eid. This command sets the advertised BP endpoint ID by which the node will identify itself in beacon messages.</p> </li> <li> <p>m announce period { 1 | 0 }</p> <p>Announce period control. Setting to 1 causes all beacons messages sent to contain beacon period. Setting to 0 disables this behavior. Default is 1.</p> </li> <li> <p>m announce eid { 1 | 0 }</p> <p>Announce eid control. Setting to 1 causes all beacons messages sent to contain source eid. Setting to 0 disables this behavior. This should be  always set to 1. Default is 1.</p> </li> <li> <p>m interval unicast interval</p> <p>Unicast interval. This command sets the beacon messages period on unicast  transmissions. Time interval is expressed in seconds. Default is 5.</p> </li> <li> <p>m interval multicast interval</p> <p>Multicast interval. This command sets the beacon messages period on multicast  transmissions. Time interval is expressed in seconds. Default is 7.</p> </li> <li> <p>m interval broadcast interval</p> <p>Broadcastcast interval. This command sets the beacon messages period on broadcast transmissions. Time interval is expressed in seconds. Default is 11.</p> </li> <li> <p>m multicast ttl ttl</p> <p>Multicast ttl. This command sets the multicast outgoing beacon messages' time to live, in seconds. Default is 255.</p> </li> <li> <p>m svcdef id name child_name:child_type ...</p> <p>Service definition. This command specifies definitions of \"services\", which are dynamically defined beacon message data structures indicating the capabilities of the beacon message sender.  id is a service-identifying number in the range 128-255. name is the name of the service type that is being defined. The definition of the structure of the service is a sequence of elements, each of which is a name:type pair.  Each child_type must be the name of a standard or previously defined service type.  Infinite recursion is supported.</p> </li> <li> <p>a svcadv name child_name:child_value ...</p> <p>Service advertising command. This command defines which services will  be advertised and with which values. All types of formats for values  are supported (e.g. 999, 0345 (octal), 0x999 (hex), -1e-9, 0.32, etc.). For a service that contains only a single element, it is not necessary to provide that element's name.  E.g. it is enough to write Booleans:true instead of Booleans:BooleanValues:B:true, as BooleanValues is the only child of Booleans and B is the only child of BooleanValues.</p> </li> <li> <p>a listen IP_address</p> <p>Listen socket specification command. This command asserts, in the form IP_address, the IP address of the socket at which the IPND daemon is to listen for incoming beacons; a default port number is used. The address can be an unicast, a multicast or a broadcast address. If a multicast address is provided all the configured unicast addresses will listen for multicast packets  in that group. If a broadcast address is provided all the unicast  addresses will listen for broadcasted packets.</p> </li> <li> <p>a destination destination_socket_spec</p> <p>Destination socket specification command. This command asserts the specification for a socket to which the IPND daemon is to send beacons. It can be an unicast, a multicast or a broadcast address.</p> </li> <li> <p>s</p> <p>The start command.  This command starts the IPND daemon for the local ION node.</p> </li> </ul>"},{"location":"man/bpv6/ipnd/#examples","title":"EXAMPLES","text":"<p>m scvdef 128 FooRouter Seed:SeedVal BaseWeight:WeightVal RootHash:bytes</p> <p>Defines a new service called FooRouter comprising 3 elements. SeedVal  and WeightVal are user defined services that must be already defined.</p> <p>m svcdef 129 SeedVal   Value:fixed16</p> <p>m svcdef 130 WeightVal Value:fixed16</p> <p>m svcdef 128 FooRouter Seed:SeedVal BaseWeight:WeightVal RootHash:bytes</p> <p>m svcdef 150 FixedValuesList F16:fixed16 F32:fixed32 F64:fixed64</p> <p>m svcdef 131 VariableValuesList U64:uint64 S64:sint64</p> <p>m svcdef 132 BooleanValues B:boolean</p> <p>m svcdef 133 FloatValuesList F:float D:double</p> <p>m svcdef 135 IntegersList FixedValues:FixedValuesList VariableValues:VariableValuesList</p> <p>m svcdef 136 NumbersList Integers:IntegersList Floats:FloatValuesList</p> <p>m svcdef 140 HugeService CLAv4:CLA-TCP-v4 Booleans:BooleanValues Numbers:NumbersList FR:FooRouter</p> <p>a svcadv HugeService CLAv4:IP:10.1.0.10 CLAv4:Port:4444 Booleans:true FR:Seed:0x5432 FR:BaseWeight:13 FR:RootHash:BEEF Numbers:Integers:FixedValues:F16:0x16 Numbers:Integers:FixedValues:F32:0x32 Numbers:Integers:FixedValues:F64:0x1234567890ABCDEF Numbers:Floats:F:0.32 Numbers:Floats:D:-1e-6 Numbers:Integers:VariableValues:U64:18446744073704783380 Numbers:Integers:VariableValues:S64:-4611686018422619668</p> <p>This shows how to define multiple nested services and how to advertise them.</p>"},{"location":"man/bpv6/ipnd/#see-also","title":"SEE ALSO","text":"<p>ion(3)</p>"},{"location":"man/bpv6/ipnfw/","title":"NAME","text":"<p>ipnfw - bundle route computation task for the IPN scheme</p>"},{"location":"man/bpv6/ipnfw/#synopsis","title":"SYNOPSIS","text":"<p>ipnfw</p>"},{"location":"man/bpv6/ipnfw/#description","title":"DESCRIPTION","text":"<p>ipnfw is a background \"daemon\" task that pops bundles from the queue of bundle destined for IPN-scheme endpoints, computes proximate destinations for those bundles, and appends those bundles to the appropriate queues of bundles pending transmission to those computed proximate destinations.</p> <p>For each possible proximate destination (that is, neighboring node) there is a separate queue for each possible level of bundle priority: 0, 1, 2.  Each outbound bundle is appended to the queue matching the bundle's designated priority.</p> <p>Proximate destination computation is affected by static and default routes as configured by ipnadmin(1) and by contact graphs as managed by ionadmin(1) and rfxclock(1).</p> <p>ipnfw is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  ipnfw can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IPN scheme.</p>"},{"location":"man/bpv6/ipnfw/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ipnfw terminated, for reasons noted in the ion.log log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart ipnfw.</p> </li> <li> <p>\"1\"</p> <p>ipnfw could not commence operations, for reasons noted in the ion.log log file.  Investigate and solve the problem identified in the log file, then use bpadmin to restart ipnfw.</p> </li> </ul>"},{"location":"man/bpv6/ipnfw/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/ipnfw/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/ipnfw/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ipnfw can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>ipnfw can't load routing database.</p> <p>ipnadmin has not yet initialized the IPN scheme.</p> </li> <li> <p>Can't create lists for route computation.</p> <p>An unrecoverable database error was encountered.  ipnfw terminates.</p> </li> <li> <p>'ipn' scheme is unknown.</p> <p>The IPN scheme was not added when bpadmin initialized BP operations.  Use bpadmin to add and start the scheme.</p> </li> <li> <p>Can't take forwarder semaphore.</p> <p>ION system error.  ipnfw terminates.</p> </li> <li> <p>Can't exclude sender from routes.</p> <p>An unrecoverable database error was encountered.  ipnfw terminates.</p> </li> <li> <p>Can't enqueue bundle.</p> <p>An unrecoverable database error was encountered.  ipnfw terminates.</p> </li> </ul>"},{"location":"man/bpv6/ipnfw/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/ipnfw/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), ipnadmin(1), bprc(5), ipnrc(5)</p>"},{"location":"man/bpv6/ipnrc/","title":"NAME","text":"<p>ipnrc - IPN scheme configuration commands file</p>"},{"location":"man/bpv6/ipnrc/#description","title":"DESCRIPTION","text":"<p>IPN scheme configuration commands are passed to ipnadmin either in a file of text lines or interactively at ipnadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.</p> <p>IPN scheme configuration commands (a) establish egress plans for direct transmission to neighboring nodes that are members of endpoints identified in the \"ipn\" URI scheme and (b) establish static default routing rules for forwarding bundles to specified destination nodes.</p> <p>The egress plan established for a given node associates a duct expression with that node.  Each duct expression is a string of the form \"protocol_name/outduct_name\" signifying that the bundle is to be queued for transmission via the indicated convergence layer protocol outduct.</p> <p>Note that egress plans must be established for all neighboring nodes, regardless of whether or not contact graph routing is used for computing dynamic routes to distant nodes.  This is by definition: if there isn't an egress plan to a node, it can't be considered a neighbor.</p> <p>Static default routes are declared as exits in the ipn-scheme routing database.  An exit is a range of node numbers identifying a set of nodes for which defined default routing behavior is established.  Whenever a bundle is to be forwarded to a node whose number is in the exit's node number range and it has not been possible to compute a dynamic route to that node from the contact schedules that have been provided to the local node and that node is not a neighbor to which the bundle can be directly transmitted, BP will forward the bundle to the gateway node associated with this exit.  The gateway node for any exit is identified by an endpoint ID, which might or might not be an ipn-scheme EID; regardless, directing a bundle to the gateway for an exit causes the bundle to be re-forwarded to that intermediate destination endpoint.  Multiple exits may encompass the same node number, in which case the gateway associated with the most restrictive exit (the one with the smallest range) is always selected.</p> <p>Note that \"exits\" were termed \"groups\" in earlier versions of ION.  The term \"exit\" has been adopted instead, to minimize any possible confusion with multicast groups.  To protect backward compatibility, the keyword \"group\" continues to be accepted by ipnadmin as an alias for the new keyword \"exit\", but the older terminology is deprecated.</p> <p>The formats and effects of the IPN scheme configuration commands are described below.</p>"},{"location":"man/bpv6/ipnrc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ipnadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv6/ipnrc/#plan-commands","title":"PLAN COMMANDS","text":"<ul> <li> <p>a plan node_nbr duct_expression [nominal_data_rate]</p> <p>The add plan command.  This command establishes an egress plan for the bundles that must be transmitted to the neighboring node identified by node_nbr.  The nominal_data_rate is the assumed rate of transmission to this node in the absence of contact plan information. A nominal_data_rate of zero (the default) in the absence of contact plan information completely disables rate control.</p> <p>Note that the plan commands consumed by ipnadmin are a simplified shortcut for submitting plan commands as consumed by bpadmin (see bprc(5)). The syntax of these commands is DIFFERENT from that of the more general and more powerful bpadmin commands.</p> </li> <li> <p>c plan node_nbr nominal_data_rate</p> <p>The change plan command.  This command changes the nominal data rate for the indicated plan.</p> </li> <li> <p>d plan node_nbr</p> <p>The delete plan command.  This command deletes the egress plan for the node identified by node_nbr.</p> </li> <li> <p>i plan node_nbr</p> <p>This command will print information about the egress plan for the node identified by node_nbr.</p> </li> <li> <p>l plan</p> <p>This command lists all egress plans established in the IPN database for the local node.</p> </li> </ul>"},{"location":"man/bpv6/ipnrc/#exit-commands","title":"EXIT COMMANDS","text":"<ul> <li> <p>a exit first_node_nbr last_node_nbr gateway_endpoint_ID</p> <p>The add exit command.  This command establishes an \"exit\" for static  default routing as described above.</p> </li> <li> <p>c exit first_node_nbr last_node_nbr gateway_endpoint_ID</p> <p>The change exit command.  This command changes the gateway node number for the exit identified by first_node_nbr and last_node_nbr .</p> </li> <li> <p>d exit first_node_nbr last_node_nbr</p> <p>The delete exit command.  This command deletes the exit identified by first_node_nbr and last_node_nbr.</p> </li> <li> <p>i exit first_node_nbr last_node_nbr</p> <p>This command will print information (the gateway endpoint ID) about the exit identified by first_node_nbr and last_node_nbr.</p> </li> <li> <p>l exit</p> <p>This command lists all exits defined in the IPN database for the local node.</p> </li> </ul>"},{"location":"man/bpv6/ipnrc/#override-commands","title":"OVERRIDE COMMANDS","text":"<ul> <li> <p>a rtovrd data_label dest_node_nbr source_node_nbr neighbor</p> <p>The add rtovrd command.  This command cause bundles characterized by data_label, dest_node_nbr (\"all other destinations\" if this node number is zero) and source_node_nbr (\"all other sources\" if this node number is zero) to be forwarded to neighbor.  If neighbor is zero, the override will be \"learned\" by ION: the neighbor selected for this bundle, by whatever means, becomes the override for all subsequent matching bundles.</p> </li> <li> <p>c rtovrd data_label dest_node_nbr source_node_nbr neighbor</p> <p>The change rtovrd command.  This command changes the override neighbor for the override identified by data_label, dest_node_nbr, and source_node_nbr.  To cause ION to forget the override, use -1 as neighbor.</p> </li> <li> <p>a cosovrd data_label dest_node_nbr source_node_nbr priority ordinal</p> <p>The add cosovrd command.  This command cause bundles characterized by data_label, dest_node_nbr (\"all other destinations\" if this node number is zero) and source_node_nbr (\"all other sources\" if this node number is zero) to have their effective class of service (priority and ordinal) changed as noted.</p> </li> <li> <p>c cosovrd data_label dest_node_nbr source_node_nbr priority ordinal</p> <p>The change cosovrd command.  This command changes the override priority and ordinal for the override identified by data_label, dest_node_nbr, and source_node_nbr.  To cause ION to forget the override, use -1 as priority.</p> </li> <li> <p>d ovrd data_label dest_node_nbr source_node_nbr</p> <p>The delete override command.  This command deletes all overrides identified by data_label, dest_node_nbr, and source_node_nbr.</p> </li> <li> <p>i ovrd data_label dest_node_nbr source_node_nbr</p> <p>This command will print information for all overrides identified by data_label, dest_node_nbr, and source_node_nbr.</p> </li> <li> <p>l ovrd</p> <p>This command lists all overrides defined in the IPN database for the local node.</p> </li> </ul>"},{"location":"man/bpv6/ipnrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a plan 18 ltp/18</p> <p>Declares the egress plan to use for transmission from the local node to neighboring node 18.  By default, any bundle for which the computed \"next hop\" node is node 18 will be queued for transmission on LTP outduct 18.</p> </li> <li> <p>a exit 1 999 dtn://stargate</p> <p>Declares a default route for bundles destined for all nodes whose numbers are in the range 1 through 999 inclusive: absent any other routing decision, such bundles are to be forwarded to \"dtn://stargate\".</p> </li> </ul>"},{"location":"man/bpv6/ipnrc/#see-also","title":"SEE ALSO","text":"<p>ipnadmin(1)</p>"},{"location":"man/bpv6/lgagent/","title":"NAME","text":"<p>lgagent - ION Load/Go remote agent program</p>"},{"location":"man/bpv6/lgagent/#synopsis","title":"SYNOPSIS","text":"<p>lgagent own_endpoint_ID</p>"},{"location":"man/bpv6/lgagent/#description","title":"DESCRIPTION","text":"<p>ION Load/Go is a system for management of an ION-based network, enabling the execution of ION administrative programs at remote nodes.  The system comprises two programs, lgsend and lgagent.</p> <p>The lgagent task on a given node opens the indicated ION endpoint for bundle reception, receives the extracted payloads of Load/Go bundles sent to it by lgsend as run on one or more remote nodes, and processes those payloads, which are the text of Load/Go source files.</p> <p>Load/Go source file content is limited to newline-terminated lines of ASCII characters.  More specifically, the text of any Load/Go source file is a sequence of line sets of two types: file capsules and directives. Any Load/Go source file may contain any number of file capsules and any number of directives, freely intermingled in any order, but the typical structure of a Load/Go source file is simply a single file capsule followed by a single directive.</p> <p>When lgagent identifies a file capsule, it copies all of the capsule's text lines to a new file that it creates in the current working directory. When lgagent identifies a directive, it executes the directive by passing the text of the directive to the pseudoshell() function (see platform(3)).  lgagent processes the line sets of a Load/Go source file in the order in which they appear in the file, so the text of a directive may reference a file that was created as the result of processing a prior file capsule in the same source file.</p>"},{"location":"man/bpv6/lgagent/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Load/Go remote agent processing has terminated.</p> </li> </ul>"},{"location":"man/bpv6/lgagent/#files","title":"FILES","text":"<p>lgfile contains the Load/Go file capsules and directives that are to be processed.</p>"},{"location":"man/bpv6/lgagent/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/lgagent/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>lgagent: can't attach to BP.</p> <p>Bundle Protocol is not running on this computer.  Run bpadmin(1) to start BP.</p> </li> <li> <p>lgagent: can't open own endpoint.</p> <p>own_endpoint_ID is not a declared endpoint on the local ION node.  Run bpadmin(1) to add it.</p> </li> <li> <p>lgagent: bundle reception failed.</p> <p>ION system problem.  Investigate and correct before restarting.</p> </li> <li> <p>lgagent cannot continue.</p> <p>lgagent processing problem.  See earlier diagnostic messages for details. Investigate and correct before restarting.</p> </li> <li> <p>lgagent: no space for bundle content.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgagent: can't receive bundle content.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgagent: can't handle bundle delivery.</p> <p>ION system problem.  Investigate and correct before restarting.</p> </li> <li> <p>lgagent: pseudoshell failed.</p> <p>Error in directive line, usually an attempt to execute a non-existent administration program (e.g., a misspelled program name).  Terminates processing of source file content.</p> </li> </ul> <p>A variety of other diagnostics noting source file parsing problems may also be reported.  These errors are non-fatal but they terminate the processing of the source file content from the most recently received bundle.</p>"},{"location":"man/bpv6/lgagent/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/lgagent/#see-also","title":"SEE ALSO","text":"<p>lgsend(1), lgfile(5)</p>"},{"location":"man/bpv6/lgfile/","title":"NAME","text":"<p>lgfile - ION Load/Go source file</p>"},{"location":"man/bpv6/lgfile/#description","title":"DESCRIPTION","text":"<p>The ION Load/Go system enables the execution of ION administrative programs at remote nodes:</p> <p>The lgsend program reads a Load/Go source file from a local file system, encapsulates the text of that source file in a bundle, and sends the bundle to a designated DTN endpoint on the remote node.</p> <p>An lgagent task running on the remote node, which has opened that DTN endpoint for bundle reception, receives the extracted payload of the bundle -- the text of the Load/Go source file -- and processes it.</p> <p>Load/Go source file content is limited to newline-terminated lines of ASCII characters.  More specifically, the text of any Load/Go source file is a sequence of line sets of two types: file capsules and directives. Any Load/Go source file may contain any number of file capsules and any number of directives, freely intermingled in any order, but the typical structure of a Load/Go source file is simply a single file capsule followed by a single directive.</p> <p>Each file capsule is structured as a single start-of-capsule line, followed by zero or more capsule text lines, followed by a single end-of-capsule line.  Each start-of-capsule line is of this form:</p> <p>[file_name</p> <p>Each capsule text line can be any line of ASCII text that does not begin with an opening ([) or closing (]) bracket character.</p> <p>A text line that begins with a closing bracket character (]) is interpreted as an end-of-capsule line.</p> <p>A directive is any line of text that is not one of the lines of a file capsule and that is of this form:</p> <p>!directive_text</p> <p>When lgagent identifies a file capsule, it copies all of the capsule's text lines to a new file named file_name that it creates in the current working directory.  When lgagent identifies a directive, it executes the directive by passing directive_text to the pseudoshell() function (see platform(3)).  lgagent processes the line sets of a Load/Go source file in the order in which they appear in the file, so the directive_text of a directive may reference a file that was created as the result of processing a prior file capsule line set in the same source file.</p> <p>Note that lgfile directives are passed to pseudoshell(), which on a VxWorks platform will always spawn a new task; the first argument in directive_text must be a symbol that VxWorks can resolve to a function, not a shell command.  Also note that the arguments in directive_text will be actual task arguments, not shell command-line arguments, so they should never be enclosed in double-quote characters (\").  However, any argument that contains embedded whitespace must be enclosed in single-quote characters (') so that pseudoshell() can parse it correctly.</p>"},{"location":"man/bpv6/lgfile/#examples","title":"EXAMPLES","text":"<p>Presenting the following lines of source file text to lgsend:</p> <p>[cmd33.bprc</p> <p>x protocol ltp</p> <p>]</p> <p>!bpadmin cmd33.bprc</p> <p>should cause the receiving node to halt the operation of the LTP convergence-layer protocol.</p>"},{"location":"man/bpv6/lgfile/#see-also","title":"SEE ALSO","text":"<p>lgsend(1), lgagent(1), platform(3)</p>"},{"location":"man/bpv6/lgsend/","title":"NAME","text":"<p>lgsend - ION Load/Go command program</p>"},{"location":"man/bpv6/lgsend/#synopsis","title":"SYNOPSIS","text":"<p>lgsend command_file_name own_endpoint_ID destination_endpoint_ID</p>"},{"location":"man/bpv6/lgsend/#description","title":"DESCRIPTION","text":"<p>ION Load/Go is a system for management of an ION-based network, enabling the execution of ION administrative programs at remote nodes.  The system comprises two programs, lgsend and lgagent.</p> <p>The lgsend program reads a Load/Go source file from a local file system, encapsulates the text of that source file in a bundle, and sends the bundle to an lgagent task that is waiting for data at a designated DTN endpoint on the remote node.</p> <p>To do so, it first reads all lines of the Load/Go source file identified by command_file_name into a temporary buffer in ION's SDR data store, concatenating the lines of the file and retaining all newline characters. Then it invokes the bp_send() function to create and send a bundle whose payload is this temporary buffer, whose destination is destination_endpoint_ID, and whose source endpoint ID is own_endpoint_ID.  Then it terminates.</p>"},{"location":"man/bpv6/lgsend/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Load/Go file transmission succeeded.</p> </li> <li> <p>\"1\"</p> <p>Load/Go file transmission failed.  Examine ion.log to determine the cause of the failure, then re-run.</p> </li> </ul>"},{"location":"man/bpv6/lgsend/#files","title":"FILES","text":"<p>lgfile contains the Load/Go file capsules and directive that are to be sent to the remote node.</p>"},{"location":"man/bpv6/lgsend/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/lgsend/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>lgsend: can't attach to BP.</p> <p>Bundle Protocol is not running on this computer.  Run bpadmin(1) to start BP.</p> </li> <li> <p>lgsend: can't open own endpoint.</p> <p>own_endpoint_ID is not a declared endpoint on the local ION node. Run bpadmin(1) to add it.</p> </li> <li> <p>lgsend: can't open file of LG commands: error description</p> <p>command_file_name doesn't identify a file that can be opened.  Correct spelling of file name or file's access permissions.</p> </li> <li> <p>lgsend: can't get size of LG command file: error description</p> <p>Operating system problem.  Investigate and correct before rerunning.</p> </li> <li> <p>lgsend: LG cmd file size &gt; 64000.</p> <p>Load/Go command file is too large.  Split it into multiple files if possible.</p> </li> <li> <p>lgsend: no space for application data unit.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgsend: fgets failed: error description</p> <p>Operating system problem.  Investigate and correct before rerunning.</p> </li> <li> <p>lgsend: can't create application data unit.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgsend: can't send bundle.</p> <p>ION system problem.  Investigate and correct before rerunning.</p> </li> </ul>"},{"location":"man/bpv6/lgsend/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/lgsend/#see-also","title":"SEE ALSO","text":"<p>lgagent(1), lgfile(5)</p>"},{"location":"man/bpv6/ltpcli/","title":"NAME","text":"<p>ltpcli - LTP-based BP convergence layer input task</p>"},{"location":"man/bpv6/ltpcli/#synopsis","title":"SYNOPSIS","text":"<p>ltpcli local_node_nbr</p>"},{"location":"man/bpv6/ltpcli/#description","title":"DESCRIPTION","text":"<p>ltpcli is a background \"daemon\" task that receives LTP data transmission blocks, extracts bundles from the received blocks, and passes them to the bundle protocol agent on the local ION node.</p> <p>ltpcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"ltp\" convergence layer protocol is added to the BP database. The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  ltpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the LTP convergence layer protocol.</p>"},{"location":"man/bpv6/ltpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart ltpcli.</p> </li> <li> <p>\"1\"</p> <p>ltpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart ltpcli.</p> </li> </ul>"},{"location":"man/bpv6/ltpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/ltpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/ltpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ltpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such ltp duct.</p> <p>No LTP induct matching local_node_nbr has been added to the BP database.  Use bpadmin to stop the LTP convergence-layer protocol, add the induct, and then restart the LTP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of ltpcli.</p> </li> <li> <p>ltpcli can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP operations.</p> </li> <li> <p>ltpcli can't open client access.</p> <p>Another task has already opened the client service for BP over LTP.</p> </li> <li> <p>ltpcli can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart LTP.</p> </li> </ul>"},{"location":"man/bpv6/ltpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/ltpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), ltpadmin(1), ltprc(5), ltpclo(1)</p>"},{"location":"man/bpv6/ltpclo/","title":"NAME","text":"<p>ltpclo - LTP-based BP convergence layer adapter output task</p>"},{"location":"man/bpv6/ltpclo/#synopsis","title":"SYNOPSIS","text":"<p>ltpclo remote_node_nbr</p>"},{"location":"man/bpv6/ltpclo/#description","title":"DESCRIPTION","text":"<p>ltpclo is a background \"daemon\" task that extracts bundles from the queues of segments ready for transmission via LTP to the remote bundle protocol agent identified by remote_node_nbr and passes them to the local LTP engine for aggregation, segmentation, and transmission to the remote node.</p> <p>ltpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  ltpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the LTP convergence layer protocol.</p>"},{"location":"man/bpv6/ltpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the BRSC protocol.</p> </li> <li> <p>\"1\"</p> <p>ltpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the BRSC protocol.</p> </li> </ul>"},{"location":"man/bpv6/ltpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/ltpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/ltpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ltpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such ltp duct.</p> <p>No LTP outduct with duct name matching remote_node_nbr has been added to the BP database.  Use bpadmin to stop the LTP convergence-layer protocol, add the outduct, and then restart the LTP protocol.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of ltpclo.</p> </li> <li> <p>ltpclo can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP operations.</p> </li> </ul>"},{"location":"man/bpv6/ltpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/ltpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), ltpadmin(1), ltprc(5), ltpcli(1)</p>"},{"location":"man/bpv6/stcpcli/","title":"NAME","text":"<p>sstcpcli - DTN simple TCP convergence layer input task</p>"},{"location":"man/bpv6/stcpcli/#synopsis","title":"SYNOPSIS","text":"<p>stcpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv6/stcpcli/#description","title":"DESCRIPTION","text":"<p>stcpcli is a background \"daemon\" task comprising 1 + N threads: one that handles TCP connections from remote stcpclo tasks, spawning sockets for data reception from those tasks, plus one input thread for each spawned socket to handle data reception over that socket.</p> <p>The connection thread simply accepts connections on a TCP socket bound to local_hostname and local_port_nbr and spawns reception threads.  The default value for local_port_nbr, if omitted, is 4556.</p> <p>Each reception thread receives bundles over the associated connected socket. Each bundle received on the connection is preceded by a 32-bit unsigned integer in network byte order indicating the length of the bundle.  The received bundles are passed to the bundle protocol agent on the local ION node.</p> <p>stcpcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"stcp\" convergence layer protocol is added to the BP database. The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  stcpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the STCP convergence layer protocol.</p>"},{"location":"man/bpv6/stcpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>stcpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart stcpcli.</p> </li> <li> <p>\"1\"</p> <p>stcpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart stcpcli.</p> </li> </ul>"},{"location":"man/bpv6/stcpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/stcpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/stcpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>stcpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such stcp duct.</p> <p>No STCP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the STCP convergence-layer protocol, add the induct, and then restart the STCP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of stcpcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> <li> <p>Can't open TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> <li> <p>Can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> <li> <p>stcpcli can't create access thread</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> </ul>"},{"location":"man/bpv6/stcpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/stcpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), stcpclo(1)</p>"},{"location":"man/bpv6/stcpclo/","title":"NAME","text":"<p>stcpclo - DTN simple TCP convergence layer adapter output task</p>"},{"location":"man/bpv6/stcpclo/#synopsis","title":"SYNOPSIS","text":"<p>stcpclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv6/stcpclo/#description","title":"DESCRIPTION","text":"<p>stcpclo is a background \"daemon\" task that connects to a remote node's TCP socket at remote_hostname and remote_port_nbr.  It then begins extracting bundles from the queues of bundles ready for transmission via TCP to this remote bundle protocol agent and transmitting those bundles over the connected socket to that node.  Each transmitted bundle is preceded by a 32-bit integer in network byte order indicating the length of the bundle.</p> <p>If not specified, remote_port_nbr defaults to 4556.</p> <p>stcpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  stcpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the STCP convergence layer protocol.</p>"},{"location":"man/bpv6/stcpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>stcpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the STCP protocol.</p> </li> <li> <p>\"1\"</p> <p>stcpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the STCP protocol.</p> </li> </ul>"},{"location":"man/bpv6/stcpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/stcpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/stcpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>stcpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such stcp duct.</p> <p>No STCP outduct with duct name matching remote_hostname and remote_port_nbr has been added to the BP database.  Use bpadmin to stop the STCP convergence-layer protocol, add the outduct, and then restart the STCP protocol.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of stcpclo.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> </ul>"},{"location":"man/bpv6/stcpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/stcpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), stcpcli(1)</p>"},{"location":"man/bpv6/tcpcli/","title":"NAME","text":"<p>tcpcli - DTN TCPCL-compliant convergence layer input task</p>"},{"location":"man/bpv6/tcpcli/#synopsis","title":"SYNOPSIS","text":"<p>tcpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv6/tcpcli/#description","title":"DESCRIPTION","text":"<p>tcpcli is a background \"daemon\" task comprising 3 + 2*N threads: an executive thread; a clock thread that periodically attempts to connect to remote TCPCL entities as identified by the tcp outducts enumerated in the bprc(5) file (each of which must specify the hostname[:port_nbr] to connect to); a thread that handles TCP connections from remote TCPCL entities, spawning sockets for data reception from those tasks; plus one input thread and one output thread for each connection, to handle data reception and transmission over that socket.</p> <p>The connection thread simply accepts connections on a TCP socket bound to local_hostname and local_port_nbr and spawns reception threads.  The default value for local_port_nbr, if omitted, is 4556.</p> <p>Each time a connection is established, the entities will first exchange contact headers, because connection parameters need to be negotiated. tcpcli records the acknowledgement flags, reactive fragmentation flag, and negative acknowledgements flag in the contact header it receives from its peer TCPCL entity.</p> <p>Each reception thread receives bundles over the associated connected socket. Each bundle received on the connection is preceded by message type, fragmentation flags, and size represented as an SDNV.  The received bundles are passed to the bundle protocol agent on the local ION node.</p> <p>Similarly, each transmission thread obtains outbound bundles from the local ION node, encapsulates them as noted above, and transmits them over the associated connected socket.</p> <p>tcpcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"tcp\" convergence layer protocol is added to the BP database. The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  tcpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the TCP convergence layer protocol.</p>"},{"location":"man/bpv6/tcpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart tcpcli.</p> </li> <li> <p>\"1\"</p> <p>tcpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart tcpcli.</p> </li> </ul>"},{"location":"man/bpv6/tcpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/tcpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/tcpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such tcp duct.</p> <p>No TCP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the TCP convergence-layer protocol, add the induct, and then restart the TCP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of tcpcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> <li> <p>Can't open TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> <li> <p>Can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> <li> <p>tcpcli can't create access thread</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> </ul>"},{"location":"man/bpv6/tcpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/tcpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv6/tcpclo/","title":"NAME","text":"<p>tcpclo - DTN TCPCL-compliant convergence layer adapter output task</p>"},{"location":"man/bpv6/tcpclo/#synopsis","title":"SYNOPSIS","text":"<p>tcpclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv6/tcpclo/#description","title":"DESCRIPTION","text":"<p>tcpclo is a background \"daemon\" task that connects to a remote node's TCP socket at remote_hostname and remote_port_nbr.  It sends a contact header, and it records the acknowledgement flag, reactive fragmentation flag and negative acknowledgements flag in the contact header it receives from its peer tcpcli task.  It then begins extracting bundles from the queues of bundles ready for transmission via TCP to this remote bundle protocol agent and transmitting those bundles over the connected socket to that node.  Each transmitted bundle is preceded by message type, segmentation flags, and an SDNV indicating the size of the bundle (in bytes).</p> <p>If not specified, remote_port_nbr defaults to 4556.</p> <p>tcpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  tcpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the TCP convergence layer protocol.</p>"},{"location":"man/bpv6/tcpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the TCPCL protocol.</p> </li> <li> <p>\"1\"</p> <p>tcpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the TCPCL protocol.</p> </li> </ul>"},{"location":"man/bpv6/tcpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/tcpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/tcpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such tcp duct.</p> <p>No TCP outduct with duct name matching remote_hostname and remote_port_nbr has been added to the BP database.  Use bpadmin to stop the TCP convergence-layer protocol, add the outduct, and then restart the TCP protocol.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of tcpclo.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> </ul>"},{"location":"man/bpv6/tcpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/tcpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), tcpcli(1)</p>"},{"location":"man/bpv6/udpcli/","title":"NAME","text":"<p>udpcli - UDP-based BP convergence layer input task</p>"},{"location":"man/bpv6/udpcli/#synopsis","title":"SYNOPSIS","text":"<p>udpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv6/udpcli/#description","title":"DESCRIPTION","text":"<p>udpcli is a background \"daemon\" task that receives UDP datagrams via a UDP socket bound to local_hostname and local_port_nbr, extracts bundles from those datagrams, and passes them to the bundle protocol agent on the local ION node.</p> <p>If not specified, port number defaults to 4556.</p> <p>The convergence layer input task is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"udp\" convergence layer protocol is added to the BP database.  The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  udpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the UDP convergence layer protocol.</p>"},{"location":"man/bpv6/udpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart udpcli.</p> </li> <li> <p>\"1\"</p> <p>udpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart udpcli.</p> </li> </ul>"},{"location":"man/bpv6/udpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/udpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/udpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such udp duct.</p> <p>No UDP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the UDP convergence-layer protocol, add the induct, and then restart the UDP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of udpcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>Can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>Can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>udpcli can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> </ul>"},{"location":"man/bpv6/udpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/udpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), udpclo(1)</p>"},{"location":"man/bpv6/udpclo/","title":"NAME","text":"<p>udpclo - UDP-based BP convergence layer output task</p>"},{"location":"man/bpv6/udpclo/#synopsis","title":"SYNOPSIS","text":"<p>udpclo round_trip_time remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv6/udpclo/#description","title":"DESCRIPTION","text":"<p>udpclo is a background \"daemon\" task that extracts bundles from the queues of bundles ready for transmission via UDP to a remote node's UDP socket at remote_hostname and remote_port_nbr, encapsulates those bundles in UDP datagrams, and sends those datagrams to that remote UDP socket.</p> <p>Because UDP is not itself a \"reliable\" transmission protocol (i.e., it performs no retransmission of lost data), it may be used in conjunction with BP custodial retransmission.  BP custodial retransmission is triggered only by expiration of a timer whose interval is nominally the round-trip time between the sending BP node and the next node in the bundle's end-to-end path that is expected to take custody of the bundle; notionally, if no custody signal citing the transmitted bundle has been received before the end of this interval it can be assumed that either the bundle or the custody signal was lost in transmission and therefore the bundle should be retransmitted.  The value of the custodial retransmission timer interval (the expected round-trip time between the sending node and the anticipated next custodian) must be provided as a run-time argument to udpclo.  If the value of this parameter is zero, custodial retransmission is disabled.</p> <p>udpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  udpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the UDP convergence layer protocol.</p>"},{"location":"man/bpv6/udpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart udpclo.</p> </li> <li> <p>\"1\"</p> <p>udpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart udpclo.</p> </li> </ul>"},{"location":"man/bpv6/udpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv6/udpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv6/udpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No memory for UDP buffer in udpclo.</p> <p>ION system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>No such udp duct.</p> <p>No UDP outduct with duct name remote_hostname[:&lt;remote_port_nbr&gt;] has been added to the BP database.  Use bpadmin to stop the UDP convergence-layer protocol, add the outduct, and then restart the UDP protocol.</p> </li> <li> <p>CLO task is already started for this engine.</p> <p>Redundant initiation of udpclo.</p> </li> <li> <p>CLO can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpclo.</p> </li> <li> <p>CLO write() error on socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpclo.</p> </li> <li> <p>Bundle is too big for UDP CLA.</p> <p>Configuration error: bundles that are too large for UDP transmission (i.e., larger than 65535 bytes) are being enqueued for udpclo.  Change routing.</p> </li> </ul>"},{"location":"man/bpv6/udpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv6/udpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), udpcli(1)</p>"},{"location":"man/bpv7/","title":"Index of Man Pages","text":"<ul> <li>bibeadmin</li> <li>bibeclo</li> <li>biberc</li> <li>bp</li> <li>bpadmin</li> <li>bpcancel</li> <li>bpchat</li> <li>bpclm</li> <li>bpclock</li> <li>bpcounter</li> <li>bpdriver</li> <li>bpecho</li> <li>bpextensions</li> <li>bping</li> <li>bplist</li> <li>bpnmtest</li> <li>bprc</li> <li>bprecvfile</li> <li>bprecvfile2</li> <li>bpsecadmin</li> <li>bpsecrc</li> <li>bpsendfile</li> <li>bpsink</li> <li>bpsource</li> <li>bpstats</li> <li>bpstats2</li> <li>bptrace</li> <li>bptransit</li> <li>brsccla</li> <li>brsscla</li> <li>cgrfetch</li> <li>dccpcli</li> <li>dccpclo</li> <li>dgrcli</li> <li>dgrclo</li> <li>dtn2admin</li> <li>dtn2adminep</li> <li>dtn2fw</li> <li>dtn2rc</li> <li>hmackeys</li> <li>imcadminep</li> <li>imcfw</li> <li>ipnadmin</li> <li>ipnadminep</li> <li>ipnd</li> <li>ipnfw</li> <li>ipnrc</li> <li>lgagent</li> <li>lgfile</li> <li>lgsend</li> <li>ltpcli</li> <li>ltpclo</li> <li>stcpcli</li> <li>stcpclo</li> <li>tcpcli</li> <li>tcpclo</li> <li>udpcli</li> <li>udpclo</li> </ul>"},{"location":"man/bpv7/bibeadmin/","title":"NAME","text":"<p>bibeadmin - bundle-in-bundle encapsulation database administration interface</p>"},{"location":"man/bpv7/bibeadmin/#synopsis","title":"SYNOPSIS","text":"<p>bibeadmin [ commands_filename ]</p>"},{"location":"man/bpv7/bibeadmin/#description","title":"DESCRIPTION","text":"<p>bibeadmin configures the local ION node's database of parameters governing the forwarding of BIBE PDUs to specified remote nodes.</p> <p>bibeadmin operates in response to BIBE configuration commands found in the file commands_filename, if provided; if not, bibeadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from bibeadmin with the 'h' or '?' commands at the prompt.  The commands are documented in biberc(5).</p>"},{"location":"man/bpv7/bibeadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of BIBE administration.</li> <li>\"1\" Unsuccessful completion of BIBE administration, due to inability to attach to the Bundle Protocol system or to initialize the BIBE database.</li> </ul>"},{"location":"man/bpv7/bibeadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>bibeadmin</p> <p>Enter interactive BIBE configuration command entry mode.</p> </li> <li> <p>bibeadmin host1.biberc</p> <p>Execute all configuration commands in host1.biberc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv7/bibeadmin/#files","title":"FILES","text":"<p>See biberc(5) for details of the BIBE configuration commands.</p>"},{"location":"man/bpv7/bibeadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bibeadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the biberc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to bibeadmin.  Otherwise bibeadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>bibeadmin can't attach to BP.</p> <p>Bundle Protocol has not been initialized on this computer.  You need to run bpadmin(1) first.</p> </li> <li> <p>bibeadmin can't initialize routing database.</p> <p>There is no SDR data store for bibeadmin to use.  Please run ionadmin(1) to start the local ION node.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause bibeadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see biberc(5) for details.</p>"},{"location":"man/bpv7/bibeadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bibeadmin/#see-also","title":"SEE ALSO","text":"<p>bibeclo(1), biberc(5)</p>"},{"location":"man/bpv7/bibeclo/","title":"NAME","text":"<p>bibeclo - BP convergence layer output task using bundle-in-bundle encapsulation</p>"},{"location":"man/bpv7/bibeclo/#synopsis","title":"SYNOPSIS","text":"<p>bibeclo peer_EID destination_EID</p>"},{"location":"man/bpv7/bibeclo/#description","title":"DESCRIPTION","text":"<p>bibeclo is a background \"daemon\" task that extracts bundles from the queues of bundles destined for destination_EID that are ready for transmission via bundle-in-bundle encapsulation (BIBE) to peer_EID, encapsulates them in BP administrative records of (non-standard) record type 7 (BP_BIBE_PDU), and sends those administrative records in encapsulating bundles destined for peer_EID.  The forwarding of encapsulated bundles for which custodial acknowledgment is requested causes bibeclo to post custodial re-forwarding timers to the node's timeline.  Parameters governing the forwarding of BIBE PDUs to peer_EID are stipulated in the corresponding BIBE convergence-layer adapter (bcla) structure residing in the BIBE database, as managed by bibeadmin.</p> <p>The receiving node is expected to process received BIBE PDUs by simply dispatching the encapsulated bundles - whose destination is the node identified by destination_EID - as if they had been received from neighboring nodes in the normal course of operations; BIBE PDUs for which custodial acknowledgment was requested cause the received bundles to be noted in custody signals that are being aggregated by the receiving node.</p> <p>bibeclo additionally sends aggregated custody signals in BP administrative records of (non-standard) record type 8 (BP_BIBE_SIGNAL) as the deadlines for custody signal transmission arrive.</p> <p>Note that the reception and processing of both encapsulated bundles and custody signals is performed by the scheme-specific administration endpoint daemon(s) at the receiving nodes.  Reception of a custody signal terminates the custodial re-forwarding timers for all bundles acknowledged in that signal; the re-forwarding of bundles upon custodial re-forwarding timer expiration is initiated by the bpclock daemon.</p> <p>bibeclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  bibeclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the BIBE convergence layer protocol.</p>"},{"location":"man/bpv7/bibeclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bibeclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart bibeclo.</p> </li> <li> <p>\"1\"</p> <p>bibeclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart bibeclo.</p> </li> </ul>"},{"location":"man/bpv7/bibeclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bibeclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bibeclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bibeclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such bibe outduct.</p> <p>No BIBE outduct with duct name destination_EID exists.  Use bpadmin to stop the BIBE convergence-layer protocol, add the outduct, and then restart the BIBE protocol.</p> </li> <li> <p>No such bcla.</p> <p>No bcla structure for the node identified by peer_EID has been added to the BP database.  Use bpadmin to stop the BIBE convergence-layer protocol, use bibeadmin to add the bcla, and then use bpadmin to restart the BIBE protocol.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of bibeclo.</p> </li> <li> <p>Can't dequeue bundle.</p> <p>BIBE outduct closed deleted or other system error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>[i] bibeclo outduct closed.</p> <p>Nominal shutdown message.</p> </li> <li> <p>Can't prepend header; CLO stopping.</p> <p>System error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>Can't destroy old ZCO; CLO stopping.</p> <p>System error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>Can't get outbound space for BPDU.</p> <p>System error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>Can't send encapsulated bundle.</p> <p>System error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>Can't track bundle.</p> <p>System error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>[!] Encapsulated bundle not sent.</p> <p>Malformed bundle issuance request, which might be a software error.  Contact technical support.</p> </li> <li> <p>Can't release ZCO; CLO stopping.</p> <p>System error.  Check ION log; correct the problem and restart BIBE.</p> </li> <li> <p>[i] bibeclo duct has ended.</p> <p>Nominal shutdown message.</p> </li> </ul>"},{"location":"man/bpv7/bibeclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bibeclo/#see-also","title":"SEE ALSO","text":"<p>biberc(5), bibeadmin(1)</p>"},{"location":"man/bpv7/biberc/","title":"NAME","text":"<p>biberc - BIBE configuration commands file</p>"},{"location":"man/bpv7/biberc/#description","title":"DESCRIPTION","text":"<p>BIBE configuration commands are passed to bibeadmin either in a file of text lines or interactively at bibeadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.</p> <p>BIBE configuration commands establish the parameters governing transmission of BIBE PDUs to specified peer nodes: anticipated delivery latency in the forward direction, anticipated delivery latency in the return direction, TTL for BIBE PDUs, priority for BIBE PDUs, ordinal priority for BIBE PDUs in the event that priority is Expedited, and (optionally) data label for BIBE PDUs.  As such, they configure BIBE convergence-layer adapter (bcla) structures.</p> <p>The formats and effects of the BIBE configuration commands are described below.</p> <p>NOTE: in order to cause bundles to be transmitted via BIBE:</p> <ul> <li> <p>Plan</p> <p>Remember that BIBE is a convergence-layer protocol; as such, it operates between two nodes that are topologically adjacent in a BP network (but in this case the BP network within which the nodes are topologically adjacent is an overlay on top of the real BP network).  Since the sending and receiving nodes are topologically adjacent they are neighbors: the sending node MUST have an egress plan for transmission to the receiving (that is, peer) node, and there MUST be a BIBE outduct attached to that plan.</p> </li> <li> <p>Routing</p> <p>In order to compel bundles bound for some destination node to be forwarded via the BIBE peer node rather than over some other route computed by CGR, you have to override CGR routing for that bundle.  The way to do this is to (a) tag the bundle with data label X (in ancillary data) and (b) use ipnadmin to establish at the sending node a routing override that coerces all bundles with data label X to be sent directly to the peer node.</p> <p>If the peer node happens to be a true BP neighbor as well - that is, there is also a non-BIBE outduct attached to the egress plan for transmission to that node - then you additionally need to tell the egress plan management daemon (bpclm) for that node which bundles need to be forwarded using the BIBE outduct rather than the non-BIBE outduct.  The way to do this is to use ipnadmin to establish at the sending node a class-of-service override that locally and temporarily OR's the BP_BIBE_REQUESTED flag (32) to the quality-of-service flags of any bundle tagged with data label X.</p> </li> <li> <p>Quality of Service</p> <p>If you want custody transfer to be invoked for each BIBE transmission of a bundle from the sending node to the peer node, you must additionally use ipnadmin to establish at the sending node a class-of-service override that locally and temporarily OR's the BP_CT_REQUESTED flag (64) to the quality-of-service flags of any bundle tagged with data label X.</p> <p>If you need to establish a class-of-service override to set the BP_BIBE_REQUESTED flag (as described above) as well, then use the OR of BP_BIBE_REQUESTED and BP_CT_REQUESTED - that is, 96 - as the quality-of-service flags argument for that override.</p> <p>NOTE that an alternative method of setting both the BP_BIBE_REQUESTED and BP_CT_REQUESTED flags for a given bundle is simply to request custody transfer when the bundle is sourced; this will OR that bundle's own quality-of-service flags (in ancillary data) with 96.  But be careful: in this case the bundle will be permanently tagged with these flag values, meaning that it will be forwarded via BIBE with custody transfer over every \"hop\" of the end-to-end path to its destination, and if BIBE is unavailable at any forwarding node on the path then the bundle can never reach the destination node.</p> </li> </ul>"},{"location":"man/bpv7/biberc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by bibeadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>w { 0 | 1 | activity_spec }</p> <p>The watch command.  This command enables and disables production of a continuous stream of user-selected Bundle-in-Bundle Encapsulation custody transfer activity indication characters.  A watch parameter of \"1\" selects all BIBE-CT activity indication characters; \"0\" de-selects all BIBE-CT activity indication characters; any other activity_spec such as \"mw\" selects all activity indicators in the string, de-selecting all others.  BIBE will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>w   custody of bundle is accepted</p> <p>m   custody acceptance is received for one bundle</p> <p>x   custody of bundle is refused</p> <p>&amp;   custody refusal is received for one bundle</p> <p>$   bundle retransmitted due to expired custodial retransmission interval</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv7/biberc/#bcla-commands","title":"BCLA COMMANDS","text":"<ul> <li> <p>a bcla peer_EID fwd_latency rtn_latency time_to_live priority ordinal [data label]</p> <p>The add bcla command.  This command adds the neighboring node identified by peer_EID as a BIBE destination of the local node.</p> </li> <li> <p>c bcla peer_EID fwd_latency rtn_latency time_to_live priority ordinal [data label]</p> <p>The change bcla command.  This command changes the transmission parameters governing BIBE PDU transmission to the indicated peer node.</p> </li> <li> <p>d bcla peer_EID</p> <p>The delete bcla command.  This command deletes the bcla identified by peer_EID.</p> </li> <li> <p>i bcla peer_EID</p> <p>This command will print information (the transmission parameters) for the BIBE peer node identified by peer_EID.</p> </li> <li> <p>l</p> <p>This command lists all of the local node's BIBE peers.</p> </li> </ul>"},{"location":"man/bpv7/biberc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a bcla ipn:3.2 10 10 60 1 0 16</p> <p>Declares that ipn:3.2 is a BIBE destination and that BIBE PDUs destined for this node are to be sent with TTL 60 seconds, priority 1 (standard), and data label 16; it is expected that BIBE PDUs sent to this node will arrive within 10 seconds and that BIBE PDUs sent from this node will arrive within 10 seconds.</p> </li> </ul>"},{"location":"man/bpv7/biberc/#see-also","title":"SEE ALSO","text":"<p>bibeadmin(1), bibeclo(1)</p>"},{"location":"man/bpv7/bp/","title":"NAME","text":"<p>bp - Bundle Protocol communications library</p>"},{"location":"man/bpv7/bp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"bp.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/bpv7/bp/#description","title":"DESCRIPTION","text":"<p>The bp library provides functions enabling application software to use Bundle Protocol to send and receive information over a delay-tolerant network.  It conforms to the Bundle Protocol specification as documented in Internet RFC 5050.</p> <ul> <li> <p>int bp_attach( )</p> <p>Attaches the application to BP functionality on the local computer.  Returns 0 on success, -1 on any error.</p> <p>Note that all ION libraries and applications draw memory dynamically, as needed, from a shared pool of ION working memory.  The size of the pool is established when ION node functionality is initialized by ionadmin(1).  This is a precondition for initializing BP functionality by running bpadmin(1), which in turn is required in order for bp_attach() to succeed.</p> </li> <li> <p>Sdr bp_get_sdr( )</p> <p>Returns handle for the SDR data store used for BP, to enable creation and interrogation of bundle payloads (application data units).</p> </li> <li> <p>void bp_detach( )</p> <p>Terminates all access to BP functionality on the local computer.</p> </li> <li> <p>int bp_open(char *eid, BpSAP *ionsapPtr)</p> <p>Opens the application's access to the BP endpoint identified by eid, so that the application can take delivery of bundles destined for the indicated endpoint.  This SAP can also be used for sending bundles whose source is the indicated endpoint; all bundles sent via this SAP will be subject to immediate destruction upon transmission, i.e., no bundle addresses will be returned by bp_send() for use in tracking, suspending/resuming, or cancelling transmission of these bundles.  On success, places a value in *ionsapPtr that can be supplied to future bp function invocations and returns 0.  Returns -1 on any error.</p> </li> <li> <p>int bp_open_source(char *eid, BpSAP *ionsapPtr, detain)</p> <p>Opens the application's access to the BP endpoint identified by eid, so that the application can send bundles whose source is the indicated endpoint.  If and only if the value of detain is non-zero, citing this SAP in an invocation of bp_send() will cause the address of the newly issued bundle to be returned for use in tracking, suspending/resuming, or cancelling transmission of this bundle.  USE THIS FEATURE WITH GREAT CARE: such a bundle will continue to occupy storage resources until it is explicitly released by an invocation of bp_release() or until its time to live expires, so bundle detention increases the risk of resource exhaustion. (If the value of detain is zero, all bundles sent via this SAP will be subject to immediate destruction upon transmission.)  On success, places a value in *ionsapPtr that can be supplied to future bp function invocations and returns 0.  Returns -1 on any error.</p> </li> <li> <p>int bp_send(BpSAP sap, char *destEid, char *reportToEid, int lifespan, int classOfService, BpCustodySwitch custodySwitch, unsigned char srrFlags, int ackRequested, BpAncillaryData *ancillaryData, Object adu, Object *newBundle)</p> <p>Sends a bundle to the endpoint identified by destEid, from the source endpoint as provided to the bp_open() call that returned sap. When sap is NULL, the transmitted bundle is anonymous, i.e., the source of the bundle is not identified.  This is legal, but anonymous bundles cannot be uniquely identified; status reporting therefore cannot be requested for an anonymous bundle.</p> <p>reportToEid identifies the endpoint to which any status reports pertaining to this bundle will be sent; if NULL, defaults to the source endpoint.</p> <p>lifespan is the maximum number of seconds that the bundle can remain in-transit (undelivered) in the network prior to automatic deletion.</p> <p>classOfService is simply priority for now: BP_BULK_PRIORITY, BP_STD_PRIORITY, or BP_EXPEDITED_PRIORITY.  If class-of-service flags are defined in a future version of Bundle Protocol, those flags would be OR'd with priority.</p> <p>custodySwitch indicates whether or not custody transfer is requested for this bundle and, if so, whether or not the source node itself is required to be the initial custodian.  The valid values are SourceCustodyRequired, SourceCustodyOptional, NoCustodyRequired.  Note that custody transfer can take effect only for segments of the end-to-end path that are traversed using the Bundle-in-Bundle Encapsulation protocol at the \"convergence layer\"; however, requesting custody transfer is interpreted by ION as a request to use \"reliable\" convergence-layer protocols over all segments of the end-to-end path, whether implemented by custody transfer or not.</p> <p>srrFlags, if non-zero, is the logical OR of the status reporting behaviors requested for this bundle: BP_RECEIVED_RPT, BP_FORWARDED_RPT, BP_DELIVERED_RPT, BP_DELETED_RPT.</p> <p>ackRequested is a Boolean parameter indicating whether or not the recipient application should be notified that the source application requests some sort of application-specific end-to-end acknowledgment upon receipt of the bundle.</p> <p>ancillaryData, if not NULL, is used to populate the Extended Class Of Service block for this bundle.  The block's ordinal value is used to provide fine-grained ordering within \"expedited\" traffic: ordinal values from 0 (the default) to 254 (used to designate the most urgent traffic) are valid, with 255 reserved for custody signals.  Note that the insertion of application-specific extension blocks into the bundle, in addition to the canonical extension blocks inserted automatically per the bpextensions.c file, may be requested by listing those blocks in the extensions variable of the ancillaryData block.  The value of the block's flags is the logical OR of the applicable extended class-of-service flags:</p> <pre><code>BP\\_MINIMUM\\_LATENCY designates the bundle as \"critical\" for the\npurposes of Contact Graph Routing.\n\nBP\\_BEST\\_EFFORT signifies that non-reliable convergence-layer protocols, as\navailable, may be used to transmit the bundle.  Notably, the bundle may be\nsent as \"green\" data rather than \"red\" data when issued via LTP.\n\nBP\\_DATA\\_LABEL\\_PRESENT signifies whether or not the value of _dataLabel_\nin _ancillaryData_ must be encoded into the ECOS block when the bundle is\ntransmitted.\n</code></pre> <p>adu is the \"application data unit\" that will be conveyed as the payload of the new bundle.  adu must be a \"zero-copy object\" (ZCO).  To ensure orderly access to transmission buffer space for all applications, adu must be created by invoking ionCreateZco(), which may be configured either to block so long as insufficient ZCO storage space is available for creation of the requested ZCO or to fail immediately if insufficient ZCO storage space is available.</p> <p>The function returns 1 on success, 0 on user error, -1 on any system error.  If 0 is returned, then an invalid argument value was passed to bp_send(); a message to this effect will have been written to the log file. If 1 is returned, then either the destination of the bundle was \"dtn:none\" (the bit bucket) or the ADU has been accepted and queued for transmission in a bundle.  In the latter case, if and only if sap was a reference to a BpSAP returned by an invocation of bp_open_source() that had a non-zero value in the detain parameter, then newBundle must be non-NULL and the address of the newly created bundle within the ION database is placed in newBundle.  This address can be used to track, suspend/resume, or cancel transmission of the bundle.</p> </li> <li> <p>int bp_track(Object bundle, Object trackingElt)</p> <p>Adds trackingElt to the list of \"tracking\" references in bundle. trackingElt must be the address of an SDR list element -- whose data is the address of this same bundle -- within some list of bundles that is privately managed by the application.  Upon destruction of the bundle this list element will automatically be deleted, thus removing the bundle from the application's privately managed list of bundles.  This enables the application to keep track of bundles that it is operating on without risk of inadvertently de-referencing the address of a nonexistent bundle. </p> </li> <li> <p>void bp_untrack(Object bundle, Object trackingElt)</p> <p>Removes trackingElt from the list of \"tracking\" references in bundle, if it is in that list.  Does not delete trackingElt itself.</p> </li> <li> <p>int bp_suspend(Object bundle)</p> <p>Suspends transmission of bundle.  Has no effect if bundle is \"critical\" (i.e., has got extended class of service BP_MINIMUM_LATENCY flag set) or if the bundle is already suspended.  Otherwise, reverses the enqueuing of the bundle to its selected transmission outduct and places it in the \"limbo\" queue until the suspension is lifted by calling bp_resume.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_resume(Object bundle)</p> <p>Terminates suspension of transmission of bundle.  Has no effect if bundle is \"critical\" (i.e., has got extended class of service BP_MINIMUM_LATENCY flag set) or is not suspended.  Otherwise, removes the bundle from the \"limbo\" queue and queues it for route re-computation and re-queuing.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_cancel(Object bundle)</p> <p>Cancels transmission of bundle.  If the indicated bundle is currently queued for forwarding, transmission, or retransmission, it is removed from the relevant queue and destroyed exactly as if its Time To Live had expired.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_release(Object bundle)</p> <p>Releases a detained bundle for destruction when all retention constraints have been removed.  After a detained bundle has been released, the application can no longer track, suspend/resume, or cancel its transmission.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int bp_receive(BpSAP sap, BpDelivery *dlvBuffer, int timeoutSeconds)</p> <p>Receives a bundle, or reports on some failure of bundle reception activity.</p> <p>The \"result\" field of the dlvBuffer structure will be used to indicate the outcome of the data reception activity.</p> <p>If at least one bundle destined for the endpoint for which this SAP is opened has not yet been delivered to the SAP, then the payload of the oldest such bundle will be returned in dlvBuffer-&gt;adu and dlvBuffer-&gt;result will be set to BpPayloadPresent.  If there is no such bundle, bp_receive() blocks for up to timeoutSeconds while waiting for one to arrive.</p> <p>If timeoutSeconds is BP_POLL (i.e., zero) and no bundle is awaiting delivery, or if timeoutSeconds is greater than zero but no bundle arrives before timeoutSeconds have elapsed, then dlvBuffer-&gt;result will be set to BpReceptionTimedOut.  If timeoutSeconds is BP_BLOCKING (i.e., -1) then bp_receive() blocks until either a bundle arrives or the function is interrupted by an invocation of bp_interrupt().</p> <p>dlvBuffer-&gt;result will be set to BpReceptionInterrupted in the event that the calling process received and handled some signal other than SIGALRM while waiting for a bundle.</p> <p>dlvBuffer-&gt;result will be set to BpEndpointStopped in the event that the operation of the indicated endpoint has been terminated.</p> <p>The application data unit delivered in the data delivery structure, if any, will be a \"zero-copy object\" reference.  Use zco reception functions (see zco(3)) to read the content of the application data unit.</p> <p>Be sure to call bp_release_delivery() after every successful invocation of bp_receive().</p> <p>The function returns 0 on success, -1 on any error.</p> </li> <li> <p>void bp_interrupt(BpSAP sap)</p> <p>Interrupts a bp_receive() invocation that is currently blocked.  This function is designed to be called from a signal handler; for this purpose, sap may need to be obtained from a static variable.</p> </li> <li> <p>void bp_release_delivery(BpDelivery *dlvBuffer, int releaseAdu)</p> <p>Releases resources allocated to the indicated delivery.  releaseAdu is a Boolean parameter: if non-zero, the ADU ZCO reference in dlvBuffer (if any) is destroyed, causing the ZCO itself to be destroyed if no other references to it remain.</p> </li> <li> <p>void bp_close(BpSAP sap)</p> <p>Terminates the application's access to the BP endpoint identified by the eid cited by the indicated service access point.  The application relinquishes its ability to take delivery of bundles destined for the indicated endpoint and to send bundles whose source is the indicated endpoint.</p> </li> </ul>"},{"location":"man/bpv7/bp/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), lgsend(1), lgagent(1), bpextensions(3), bprc(5), lgfile(5)</p>"},{"location":"man/bpv7/bpadmin/","title":"NAME","text":"<p>bpadmin - ION Bundle Protocol (BP) administration interface</p>"},{"location":"man/bpv7/bpadmin/#synopsis","title":"SYNOPSIS","text":"<p>bpadmin [ commands_filename | . | ! ]</p>"},{"location":"man/bpv7/bpadmin/#description","title":"DESCRIPTION","text":"<p>bpadmin configures, starts, manages, and stops bundle protocol operations for the local ION node.</p> <p>It operates in response to BP configuration commands found in the file commands_filename, if provided; if not, bpadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to bpadmin -- that is, the ION node's bpclock task,  forwarder tasks, and convergence layer adapter tasks are stopped. If commands_filename is an exclamation point (!), that effect is reversed: the ION node's bpclock task, forwarder tasks, and convergence layer adapter tasks are restarted.</p> <p>The format of commands for commands_filename can be queried from bpadmin with the 'h' or '?' commands at the prompt.  The commands are documented in bprc(5).</p>"},{"location":"man/bpv7/bpadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of BP administration.</li> </ul>"},{"location":"man/bpv7/bpadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>bpadmin</p> <p>Enter interactive BP configuration command entry mode.</p> </li> <li> <p>bpadmin host1.bp</p> <p>Execute all configuration commands in host1.bp, then terminate immediately.</p> </li> <li> <p>bpadmin .</p> <p>Stop all bundle protocol operations on the local node.</p> </li> </ul>"},{"location":"man/bpv7/bpadmin/#files","title":"FILES","text":"<p>See bprc(5) for details of the BP configuration commands.</p>"},{"location":"man/bpv7/bpadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the bprc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to bpadmin.  Otherwise bpadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>ION can't set custodian EID information.</p> <p>The custodial_endpoint_id specified in the BP initialization ('1') command is malformed.  Remember that the format for this argument is  ipn:element_number.0 and that the final 0 is required, as  custodial/administration service is always service 0.  Additional detail for this error is provided if one of the following other errors is present:</p> <pre><code>Malformed EID.\n\nMalformed custodian EID.\n</code></pre> </li> <li> <p>bpadmin can't attach to ION.</p> <p>There is no SDR data store for bpadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause bpadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see bprc(5) for details.</p>"},{"location":"man/bpv7/bpadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpadmin/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1), bprc(5), ipnadmin(1), ipnrc(5), dtnadmin(1), dtnrc(5)</p>"},{"location":"man/bpv7/bpcancel/","title":"NAME","text":"<p>bpcancel - Bundle Protocol (BP) bundle cancellation utility</p>"},{"location":"man/bpv7/bpcancel/#synopsis","title":"SYNOPSIS","text":"<p>bpcancel source_EID creation_seconds [creation_count [fragment_offset [fragment_length]]]</p>"},{"location":"man/bpv7/bpcancel/#description","title":"DESCRIPTION","text":"<p>bpcancel attempts to locate the bundle identified by the command-line parameter values and cancel transmission of this bundle.  Bundles for which multiple copies have been queued for transmission can't be canceled, because one or more of those copies might already have been transmitted.  Transmission of a bundle that has never been cloned and that is still in local bundle storage is cancelled by simulation of an immediate time-to-live expiration.</p>"},{"location":"man/bpv7/bpcancel/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpcancel has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bpcancel/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpcancel/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpcancel/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>bpcancel failed finding bundle.</p> <p>The attempt to locate the subject bundle failed due to some serious system error.  It will probably be necessary to terminate and re-initialize the local ION node.</p> </li> <li> <p>bpcancel failed destroying bundle.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bpcancel failed.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> </ul>"},{"location":"man/bpv7/bpcancel/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpcancel/#see-also","title":"SEE ALSO","text":"<p>bplist(1)</p>"},{"location":"man/bpv7/bpchat/","title":"NAME","text":"<p>bpchat - Bundle Protocol chat test program</p>"},{"location":"man/bpv7/bpchat/#synopsis","title":"SYNOPSIS","text":"<p>bpchat sourceEID destEID [ct]</p>"},{"location":"man/bpv7/bpchat/#description","title":"DESCRIPTION","text":"<p>bpchat uses Bundle Protocol to send input text in bundles, and display the payload of received bundles as output.  It is similar to the talk utility, but operates over the Bundle Protocol.  It operates like a combination of the bpsource and bpsink utilities in one program (unlike bpsource,  bpchat emits bundles with a sourceEID).</p> <p>If the sourceEID and destEID are both bpchat applications, then two users can chat with each other over the Bundle Protocol: lines that one user types on the keyboard will be transported over the network in bundles and displayed on the screen of the other user (and the reverse).</p> <p>bpchat terminates upon receiving the SIGQUIT signal, i.e., ^C from the keyboard.</p>"},{"location":"man/bpv7/bpchat/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpchat has terminated normally.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>bpchat has terminated due to a BP transmit or reception failure.  Details should be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bpchat/#options","title":"OPTIONS","text":"<ul> <li> \\[ct\\] <p>If the string \"ct\" is appended as the last argument, then bundles will be sent with custody transfer requested.</p> </li> </ul>"},{"location":"man/bpv7/bpchat/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpchat/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpchat/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpchat are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpchat bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpchat can't send echo bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bpchat/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpchat/#see-also","title":"SEE ALSO","text":"<p>bpecho(1), bpsource(1), bpsink(1), bp(3)</p>"},{"location":"man/bpv7/bpclm/","title":"NAME","text":"<p>bpclm - DTN bundle protocol convergence layer management daemon</p>"},{"location":"man/bpv7/bpclm/#synopsis","title":"SYNOPSIS","text":"<p>bpclm neighboring_node_ID</p>"},{"location":"man/bpv7/bpclm/#description","title":"DESCRIPTION","text":"<p>bpclm is a background \"daemon\" task that manages the transmission of bundles to a single designated neighboring node (as constrained by an \"egress plan\" data structure for that node) by one or more convergence-layer (CL) adapter output daemons (via buffer structures called \"outducts\").</p> <p>bpclm is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  bpclm can also be spawned and terminated in response to commands that START and STOP the corresponding node's egress plan.</p>"},{"location":"man/bpv7/bpclm/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpclm terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the egress plan for this node.</p> </li> <li> <p>\"1\"</p> <p>bpclm terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the egress plan for this node.</p> </li> </ul>"},{"location":"man/bpv7/bpclm/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpclm/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpclm/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpclm can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No egress plan for this node</p> <p>No egress plan for the node identified by neighboring_node_ID has been added to the BP database.  Use bpadmin to add and start the plan.</p> </li> <li> <p>bpclm task is already started for this node</p> <p>Redundant initiation of bpclm.</p> </li> </ul>"},{"location":"man/bpv7/bpclm/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpclm/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv7/bpclock/","title":"NAME","text":"<p>bpclock - Bundle Protocol (BP) daemon task for managing scheduled events</p>"},{"location":"man/bpv7/bpclock/#synopsis","title":"SYNOPSIS","text":"<p>bpclock</p>"},{"location":"man/bpv7/bpclock/#description","title":"DESCRIPTION","text":"<p>bpclock is a background \"daemon\" task that periodically performs scheduled Bundle Protocol activities.  It is spawned automatically by bpadmin in response to the 's' command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.</p> <p>Once per second, bpclock takes the following action:</p> <p>First it (a) destroys all bundles whose TTLs have expired, (b) enqueues for re-forwarding all bundles that were expected to have been transmitted (by convergence-layer output tasks) by now but are still stuck in their assigned transmission queues, and (c) enqueues for re-forwarding all bundles for which custody has not yet been taken that were expected to have been received and acknowledged by now (as noted by invocation of the bpMemo() function by some convergence-layer adapter that had CL-specific insight into the appropriate interval to wait for custody acceptance).</p> <p>Then bpclock adjusts the transmission and reception \"throttles\" that control rates of LTP transmission to and reception from neighboring nodes, in response to data rate changes as noted in the RFX database by rfxclock.</p> <p>bpclock then checks for bundle origination activity that has been blocked due to insufficient allocated space for BP traffic in the ION data store: if space for bundle origination is now available, bpclock gives the bundle production throttle semaphore to unblock that activity.</p> <p>Finally, bpclock applies rate control to all convergence-layer protocol inducts and outducts:</p> <p>For each induct, bpclock increases the current capacity of the duct by the applicable nominal data reception rate.  If the revised current capacity is greater than zero, bpclock gives the throttle's semaphore to unblock data acquisition (which correspondingly reduces the current capacity of the duct) by the associated convergence layer input task.</p> <p>For each outduct, bpclock increases the current capacity of the duct by the applicable nominal data transmission rate.  If the revised current capacity is greater than zero, bpclock gives the throttle's semaphore to unblock data transmission (which correspondingly reduces the current capacity of the duct) by the associated convergence layer output task.</p>"},{"location":"man/bpv7/bpclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart bpclock.</p> </li> <li> <p>\"1\"</p> <p>bpclock was unable to attach to Bundle Protocol operations, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv7/bpclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpclock can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't dispatch events.</p> <p>An unrecoverable database error was encountered.  bpclock terminates.</p> </li> <li> <p>Can't adjust throttles.</p> <p>An unrecoverable database error was encountered.  bpclock terminates.</p> </li> </ul>"},{"location":"man/bpv7/bpclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpclock/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), rfxclock(1)</p>"},{"location":"man/bpv7/bpcounter/","title":"NAME","text":"<p>bpcounter - Bundle Protocol reception test program</p>"},{"location":"man/bpv7/bpcounter/#synopsis","title":"SYNOPSIS","text":"<p>bpcounter ownEndpointId [maxCount]</p>"},{"location":"man/bpv7/bpcounter/#description","title":"DESCRIPTION","text":"<p>bpcounter uses Bundle Protocol to receive application data units from a remote bpdriver application task.  When the total number of application data units it has received exceeds maxCount, it terminates and prints its reception count.  If maxCount is omitted, the default limit is 2 billion application data units.</p>"},{"location":"man/bpv7/bpcounter/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpcounter has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bpcounter/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpcounter/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpcounter/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpcounter are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpcounter bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bpcounter/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpcounter/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpdriver(1), bpecho(1), bp(3)</p>"},{"location":"man/bpv7/bpdriver/","title":"NAME","text":"<p>bpdriver - Bundle Protocol transmission test program</p>"},{"location":"man/bpv7/bpdriver/#synopsis","title":"SYNOPSIS","text":"<p>bpdriver nbrOfCycles ownEndpointId destinationEndpointId [length] [t_TTL_] [i_Injection Rate_]</p>"},{"location":"man/bpv7/bpdriver/#description","title":"DESCRIPTION","text":"<p>bpdriver uses Bundle Protocol to send nbrOfCycles application data units of length indicated by length, to a counterpart application task that has opened the BP endpoint identified by destinationEndpointId.</p> <p>If omitted, length defaults to 60000.  </p> <p>TTL indicates the number of seconds the bundles may remain in the network, undelivered, before they are automatically destroyed. If omitted, TTL defaults to 300 seconds.</p> <p>bpdriver normally runs in \"echo\" mode: after sending each bundle it waits for an acknowledgment bundle before sending the next one.  For this purpose, the counterpart application task should be bpecho.</p> <p>Alternatively bpdriver can run in \"streaming\" mode, i.e., without expecting or receiving acknowledgments.  Streaming mode is enabled when length is specified as a negative number, in which case the additive inverse of length is used as the effective value of length.  For this purpose, the counterpart application task should be bpcounter.</p> <p>If the effective value of length is 1, the sizes of the transmitted service data units will be randomly selected multiples of 1024 in the range 1024 to 62464.</p> <p>Injection Rate specifies in bits-per-second the equivalent, average  rate at which bpdriver will send bundles into the network. A negative  or 0 rate value will turn off injection rate control. By default,  bpdriver will inject bundle as fast as it can be handled by ION unless a positive value for injection rate is provided.</p> <p>bpdriver normally runs with custody transfer disabled.  To request custody transfer for all bundles sent by bpdriver, specify nbrOfCycles as a negative number; the additive inverse of nbrOfCycles will be used as its effective value in this case.</p> <p>When all copies of the file have been sent, bpdriver prints a performance report.</p>"},{"location":"man/bpv7/bpdriver/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpdriver has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bpdriver/#files","title":"FILES","text":"<p>The service data units transmitted by bpdriver are sequences of text obtained from a file in the current working directory named \"bpdriverAduFile\", which bpdriver creates automatically.</p>"},{"location":"man/bpv7/bpdriver/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpdriver/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpdriver are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>Can't create ADU file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Error writing to ADU file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>bpdriver can't create file ref.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpdriver can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpdriver can't send message</p> <p>Bundle Protocol service to the remote endpoint has been stopped.</p> </li> <li> <p>bpdriver reception failed</p> <p>bpdriver is in \"echo\" mode, and Bundle Protocol delivery service has been stopped.</p> </li> </ul>"},{"location":"man/bpv7/bpdriver/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpdriver/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpcounter(1), bpecho(1), bp(3)</p>"},{"location":"man/bpv7/bpecho/","title":"NAME","text":"<p>bpecho - Bundle Protocol reception test program</p>"},{"location":"man/bpv7/bpecho/#synopsis","title":"SYNOPSIS","text":"<p>bpecho ownEndpointId</p>"},{"location":"man/bpv7/bpecho/#description","title":"DESCRIPTION","text":"<p>bpecho uses Bundle Protocol to receive application data units from a remote bpdriver application task.  In response to each received application data unit it sends back an \"echo\" application data unit of length 2, the NULL-terminated string \"x\".</p> <p>bpecho terminates upon receiving the SIGQUIT signal, i.e., ^C from the keyboard.</p>"},{"location":"man/bpv7/bpecho/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpecho has terminated normally.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>bpecho has terminated due to a BP reception failure.  Details should be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bpecho/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpecho/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpecho/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpecho are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpecho bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpecho can't send echo bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bpecho/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpecho/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpdriver(1), bpcounter(1), bp(3)</p>"},{"location":"man/bpv7/bpextensions/","title":"NAME","text":"<p>bpextensions - interface for adding extensions to Bundle Protocol</p>"},{"location":"man/bpv7/bpextensions/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"bpextensions.c\"\n</code></pre>"},{"location":"man/bpv7/bpextensions/#description","title":"DESCRIPTION","text":"<p>ION's interface for extending the Bundle Protocol enables the definition of external functions that insert extension blocks into outbound bundles (either before or after the payload block), parse and record extension blocks in inbound bundles, and modify extension blocks at key points in bundle processing.  All extension-block handling is statically linked into ION at build time, but the addition of an extension never requires that any standard ION source code be modified.</p> <p>Standard structures for recording extension blocks -- both in transient storage [memory] during bundle acquisition (AcqExtBlock) and in persistent storage [the ION database] during subsequent bundle processing (ExtensionBlock) -- are defined in the bei.h header file.  In each case, the extension block structure comprises a block type code, block processing flags, possibly a list of EID references, an array of bytes (the serialized form of the block, for transmission), the length of that array, optionally an extension-specific opaque object whose structure is designed to characterize the block in a manner that's convenient for the extension processing functions, and the size of that object.</p> <p>The definition of each extension is asserted in an ExtensionDef structure, also as defined in the bei.h header file.  Each ExtensionDef must supply:</p> <p>The name of the extension.  (Used in some diagnostic messages.)</p> <p>The extension's block type code.</p> <p>A pointer to an offer function.</p> <p>A pointer to a function to be called when forwarding a bundle containing this sort of block.</p> <p>A pointer to a function to be called when taking custody of a bundle containing this sort of block.</p> <p>A pointer to a function to be called when enqueuing for transmission a bundle containing this sort of block.</p> <p>A pointer to a function to be called when a convergence-layer adapter dequeues a bundle containing this sort of block, before serializing it.</p> <p>A pointer to a function to be called immediately before a convergence-layer adapter transmits a bundle containing this sort of block, after the bundle has been serialized.</p> <p>A pointer to a release function.</p> <p>A pointer to a copy function.</p> <p>A pointer to an acquire function.</p> <p>A pointer to a review function.</p> <p>A pointer to a decrypt function.</p> <p>A pointer to a parse function.</p> <p>A pointer to a check function.</p> <p>A pointer to a record function.</p> <p>A pointer to a clear function.</p> <p>All extension definitions must be coded into an array of ExtensionDef structures named extensionDefs.</p> <p>An array of ExtensionSpec structures named extensionSpecs is also required.  Each ExtensionSpec provides the specification for producing an outbound extension block: block definition (identified by block type number), three discriminator tags whose semantics are block-type-specific, and CRC type indicating what type of CRC must be used to protect this extension block.  The order of appearance of extension specifications in the extensionSpecs array determines the order in which extension blocks will be inserted into locally sourced bundles.</p> <p>The standard extensionDefs array -- which is empty -- is in the noextensions.c prototype source file.  The procedure for extending the Bundle Protocol in ION is as follows:</p> <p>1.  Specify -DBP_EXTENDED in the Makefile's compiler command line when building the libbpP.c library module.</p> <p>2.  Create a copy of the prototype extensions file, named \"bpextensions.c\", in a directory that is made visible to the Makefile's libbpP.c compilation command line (by a -I parameter).</p> <p>3.  In the \"external function declarations\" area of \"bpextensions.c\", add \"extern\" function declarations identifying the functions that will implement your extension (or extensions).</p> <p>4.  Add one or more ExtensionDef structure initialization lines to the extensionDefs array, referencing those declared functions.</p> <p>5.  Add one or more ExtensionSpec structure initialization lines to the extensionSpecs array, referencing those extension definitions.</p> <p>6.  Develop the implementations of the extension implementation functions in one or more new source code files.</p> <p>7.  Add the object file or files for the new extension implementation source file (or files) to the Makefile's command line for linking libbpP.so.</p> <p>The function pointers supplied in each ExtensionDef must conform to the following specifications.  NOTE that any function that modifies the bytes member of an ExtensionBlock or AckExtBlock must set the corresponding length to the new length of the bytes array, if changed.</p> <ul> <li> <p>int (*BpExtBlkOfferFn)(ExtensionBlock *blk, Bundle *bundle)</p> <p>Populates all fields of the indicated ExtensionBlock structure for inclusion in the indicated outbound bundle.  This function is automatically called when a new bundle is locally sourced or upon acquisition of a remotely sourced bundle that does not contain an extension block of this type.  The values of the extension block are typically expected to be a function of the state of the bundle, but this is extension-specific.  If it is not appropriate to offer an extension block of this type as part of this bundle, then the size, length, object, and bytes members of blk must all be set to zero.  If it is appropriate to offer such a block but no internal object representing the state of the block is needed, the object and size members of blk must be set to zero.  The type, blkProcFlags, and dataLength members of blk must be populated by the implementation of the \"offer\" function, but the length and bytes members are typically populated by calling the BP library function serializeExtBlk(), which must be passed the block to be serialized (with type, blkProcFlags and dataLength already set), a Lyst of EID references (two list elements -- offsets -- per EID reference, if applicable; otherwise NULL), and a pointer to the extension-specific block data.  The block's bytes array and object (if present) must occupy space allocated from the ION database heap.  Return zero on success, -1 on any system failure.</p> </li> <li> <p>int (*BpExtBlkProcessFn)(ExtensionBlock *blk, Bundle *bundle, void *context)</p> <p>Performs some extension-specific transformation of the data encapsulated in blk based on the state of bundle.  The transformation to be performed will typically vary depending on whether the identified function is the one that is automatically invoked upon forwarding the bundle, upon taking custody of the bundle, upon enqueuing the bundle for transmission, upon removing the bundle from the transmission queue, or upon transmitting the serialized bundle.  The context argument may supply useful supplemental information; in particular, the context provided to the ON_DEQUEUE function will comprise the name of the protocol for the duct from which the bundle has been dequeued, together with the EID of the neighboring node endpoint to which the bundle will be directly transmitted when serialized.  The block-specific data in blk is located within bytes immediately after the header of the extension block; the length of the block's header is the difference between length and dataLength.  Whenever the block's blkProcFlags, EID extensions, and/or block-specific data are altered, the serializeExtBlk() function should be called again to recalculate the size of the extension block and rebuild the bytes array.  Return zero on success, -1 on any system failure.</p> </li> <li> <p>void (*BpExtBlkReleaseFn)(ExtensionBlock *blk)</p> <p>Releases all ION database space occupied by the object member of blk. This function is automatically called when a bundle is destroyed.  Note that incorrect implementation of this function may result in a database space leak.</p> </li> <li> <p>int (*BpExtBlkCopyFn)(ExtensionBlock *newblk, ExtensionBlock *oldblk)</p> <p>Copies the object member of oldblk to ION database heap space and places the address of that new non-volatile object in the object member of newblk, also sets size in newblk.  This function is automatically called when two copies of a bundle are needed, e.g., in the event that it must both be delivered to a local client and also fowarded to another node. Return zero on success, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkAcquireFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Populates the indicated AcqExtBlock structure with size and object for retention as part of the indicated inbound bundle.  (The type, blkProcFlags, EID references (if any), dataLength, length, and bytes values of the structure are pre-populated with data as extracted from the serialized bundle.)  This function is only to be provided for extension blocks that are never encrypted; a extension block that may be encrypted should have a BpAcqExtBlkParseFn callback instead.  The function is automatically called when an extension block of this type is encountered in the course of parsing and acquiring a bundle for local delivery and/or forwarding.  If no internal object representing the state of the block is needed, the object member of acqblk must be set to NULL and the size member must be set to zero.  If an object is needed for this block, it must occupy space that is allocated from ION working memory using MTAKE and its size must be indicated in blk.  Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if the block is successfully parsed, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkReviewFn)(AcqWorkArea *work)</p> <p>Reviews the extension blocks that have been acquired for this bundle, checking to make sure that all blocks of this type that are required by policy are present.  Returns 0 if any blocks are missing, 1 if all required blocks are present, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkDecryptFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Decrypts some other extension block that has been acquired but not yet parsed, nominally using encapsulated ciphersuite information.  Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if no error in decryption was encountered, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkParseFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Populates the indicated AcqExtBlock structure with size and object for retention as part of the indicated inbound bundle.  (The type, blkProcFlags, EID references (if any), dataLength, length, and bytes values of the structure are pre-populated with data as extracted from the serialized bundle.)  This function is provided for extension blocks that may be encrypted; a extension block that can never be encrypted should have a BpAcqExtBlkAcquireFn callback instead.  The function is automatically called when an extension block of this type is encountered in the course of parsing and acquiring a bundle for local delivery and/or forwarding.  If no internal object representing the state of the block is needed, the object member of acqblk must be set to NULL and the size member must be set to zero.  If an object is needed for this block, it must occupy space that is allocated from ION working memory using MTAKE and its size must be indicated in blk.  Return zero if the block is malformed (this will cause the bundle to be discarded), 1 if the block is successfully parsed, -1 on any system failure.</p> </li> <li> <p>int (*BpAcqExtBlkCheckFn)(AcqExtBlock *acqblk, AcqWorkArea *work)</p> <p>Examines the bundle in work to determine whether or not it is authentic, in the context of the indicated extension block.  Return 1 if the block is determined to be inauthentic (this will cause the bundle to be discarded), zero if no inauthenticity is detected, -1 on any system failure.</p> </li> <li> <p>int (*BpExtBlkRecordFn)(ExtensionBlock *blk, AcqExtBlock *acqblk)</p> <p>Copies the object member of acqblk to ION database heap space and places the address of that non-volatile object in the object member of blk; also sets size in blk.  This function is automatically called when an acquired bundle is accepted for forwarding and/or delivery.  Return zero on success, -1 on any system failure.</p> </li> <li> <p>void (*BpAcqExtBlkClearFn)(AcqExtBlock *acqblk)</p> <p>Uses MRELEASE to release all ION working memory occupied by the object member of acqblk.  This function is automatically called when acquisition of a bundle is completed, whether or not the bundle is accepted.  Note that incorrect implementation of this function may result in a working memory leak.</p> </li> </ul>"},{"location":"man/bpv7/bpextensions/#utility-functions-for-extension-processing","title":"UTILITY FUNCTIONS FOR EXTENSION PROCESSING","text":"<ul> <li> <p>void discardExtensionBlock(AcqExtBlock *blk)</p> <p>Deletes this block from the bundle acquisition work area prior to the recording of the bundle in the ION database.</p> </li> <li> <p>void scratchExtensionBlock(ExtensionBlock *blk)</p> <p>Deletes this block from the bundle after the bundle has been recorded in the ION database.</p> </li> <li> <p>Object findExtensionBlock(Bundle *bundle, unsigned int type, unsigned char tag1, unsigned char tag2, unsigned char tag3)</p> <p>On success, returns the address of the ExtensionBlock in bundle for the indicated type and tag values.  If no such extension block exists, returns zero.</p> </li> <li> <p>int serializeExtBlk(ExtensionBlock *blk, char *blockData)</p> <p>Constructs a BPv7-conformant serialized representation of this extension block in blk-&gt;bytes.  Returns 0 on success, -1 on an unrecoverable system error.</p> </li> <li> <p>void suppressExtensionBlock(ExtensionBlock *blk)</p> <p>Causes blk to be omitted when the bundle to which it is attached is serialized for transmission.  This suppression remains in effect until it is reversed by restoreExtensionBlock();</p> </li> <li> <p>void restoreExtensionBlock(ExtensionBlock *blk)</p> <p>Reverses the effect of suppressExtensionBlock(), enabling the block to be included when the bundle to which it is attached is serialized.</p> </li> </ul>"},{"location":"man/bpv7/bpextensions/#see-also","title":"SEE ALSO","text":"<p>bp(3)</p>"},{"location":"man/bpv7/bping/","title":"NAME","text":"<p>bping - Send and receive Bundle Protocol echo bundles.</p>"},{"location":"man/bpv7/bping/#synopsis","title":"SYNOPSIS","text":"<p>bping [-c count] [-i interval] [-p priority] [-q wait] [-r flags] [-t ttl] srcEID destEID [reporttoEID]</p>"},{"location":"man/bpv7/bping/#description","title":"DESCRIPTION","text":"<p>bping sends bundles from srcEID to destEID.  If the destEID echoes the bundles back (for instance, it is a bpecho endpoint), bping will print the round-trip time.  When complete, bping will print statistics before exiting.  It is very similar to ping, except it works with the bundle protocol.</p> <p>bping terminates when one of the following happens: it receives the SIGINT signal (Ctrl+C), it receives responses to all of the bundles it sent, or it has sent all count of its bundles and waited wait seconds.</p> <p>When bping is executed in a VxWorks or RTEMS environment, its runtime arguments are presented positionally rather than by keyword, in this order: count, interval, priority, wait, flags, TTL, verbosity (a Boolean, defaulting to zero), source EID, destination EID, report-to EID.</p> <p>Source EID and destination EID are always required.</p>"},{"location":"man/bpv7/bping/#exit-status","title":"EXIT STATUS","text":"<p>These exit statuses are taken from ping.</p> <ul> <li> <p>\"0\"</p> <p>bping has terminated normally, and received responses to all the packets it sent.</p> </li> <li> <p>\"1\"</p> <p>bping has terminated normally, but it did not receive responses to all the packets it sent.</p> </li> <li> <p>\"2\"</p> <p>bping has terminated due to an error.  Details should be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bping/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bping/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bping/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bping are written to the ION log file ion.log and printed to standard error.  Diagnostic messages that don't cause bping to terminate indicate a failure parsing an echo response bundle.  This means that destEID isn't an echo endpoint: it's responding with some other bundle message of an unexpected format.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bping bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bping can't send echo bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bping/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bping/#see-also","title":"SEE ALSO","text":"<p>bpecho(1), bptrace(1), bpadmin(1), bp(3), ping(8)</p>"},{"location":"man/bpv7/bplist/","title":"NAME","text":"<p>bplist - Bundle Protocol (BP) utility for listing queued bundles</p>"},{"location":"man/bpv7/bplist/#synopsis","title":"SYNOPSIS","text":"<p>bplist [{count | detail} [destination_EID[/priority]]]</p>"},{"location":"man/bpv7/bplist/#description","title":"DESCRIPTION","text":"<p>bplist is a utility program that reports on bundles that currently reside in the local node, as identified by entries in the local bundle agent's \"timeline\" list.</p> <p>Either a count of bundles or a detailed list of bundles (noting primary block information together with hex and ASCII dumps of the payload and all extension blocks, in expiration-time sequence) may be requested.</p> <p>Either all bundles or just a subset of bundles - restricted to bundles for a single destination endpoint, or to bundles of a given level of priority that are all destined for some specified endpoint - may be included in the report.</p> <p>By default, bplist prints a detailed list of all bundles residing in the local node.</p>"},{"location":"man/bpv7/bplist/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bplist terminated, for reasons noted in the ion.log file.</p> </li> <li> <p>\"1\"</p> <p>bplist was unable to attach to Bundle Protocol operations, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv7/bplist/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bplist/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bplist/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv7/bplist/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bplist/#see-also","title":"SEE ALSO","text":"<p>bpclock(1)</p>"},{"location":"man/bpv7/bpnmtest/","title":"NAME","text":"<p>bpnmtest - Bundle Protocol (BP) network management statistics test</p>"},{"location":"man/bpv7/bpnmtest/#synopsis","title":"SYNOPSIS","text":"<p>bpnmtest</p>"},{"location":"man/bpv7/bpnmtest/#description","title":"DESCRIPTION","text":"<p>bpnmtest simply prints to stdout messages containing the current values of all BP network management tallies, then terminates.</p>"},{"location":"man/bpv7/bpnmtest/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpnmtest has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bpnmtest/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpnmtest/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpnmtest/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv7/bpnmtest/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bprc/","title":"NAME","text":"<p>bprc - Bundle Protocol management commands file</p>"},{"location":"man/bpv7/bprc/#description","title":"DESCRIPTION","text":"<p>Bundle Protocol management commands are passed to bpadmin either in a file of text lines or interactively at bpadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the Bundle Protocol management commands are described below.</p>"},{"location":"man/bpv7/bprc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by bpadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed and the crypto suite BP was compiled with.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1</p> <p>The initialize command.  Until this command is executed, Bundle Protocol is not in operation on the local ION node and most bpadmin commands will fail.</p> </li> <li> <p>r 'command_text'</p> <p>The run command.  This command will execute command_text as if it had been typed at a console prompt.  It is used to, for example, run another administrative program.</p> </li> <li> <p>s</p> <p>The start command.  This command starts all schemes and all protocols on the local node.</p> </li> <li> <p>m heapmax max_database_heap_per_acquisition</p> <p>The manage heap for bundle acquisition command.  This command declares the maximum number of bytes of SDR heap space that will be occupied by any single bundle acquisition activity (nominally the acquisition of a single bundle, but this is at the discretion of the convergence-layer input task). All data acquired in excess of this limit will be written to a temporary file pending extraction and dispatching of the acquired bundle or bundles.  Default is the minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimum SDR heap space occupancy in the event that all acquisition is into a file.</p> </li> <li> <p>m maxcount max_value_of_bundle_ID_sequence_nbr</p> <p>The manage maximum bundle ID sequence number command.  This command sets the maximum value that will be assigned as the sequence number in a bundle ID for any bundle sourced at a node that lacks a synchronized clock (such that the creation time in the ID of every locally sourced bundle is always zero). The default value is -1, i.e., unlimited.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops all schemes and all protocols on the local node.</p> </li> <li> <p>w { 0 | 1 | activity_spec }</p> <p>The BP watch command.  This command enables and disables production of a continuous stream of user-selected Bundle Protocol activity indication characters.  A watch parameter of \"1\" selects all BP activity indication characters; \"0\" de-selects all BP activity indication characters; any other activity_spec such as \"acz~\" selects all activity indication characters in the string, de-selecting all others.  BP will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>a   new bundle is queued for forwarding</p> <p>b   bundle is queued for transmission</p> <p>c   bundle is popped from its transmission queue</p> <p>y   bundle is accepted upon arrival</p> <p>z   bundle is queued for delivery to an application</p> <p>~   bundle is abandoned (discarded) on attempt to forward it</p> <p>!   bundle is destroyed due to TTL expiration</p> <p>#   bundle is queued for re-forwarding due to CL protocol failure</p> <p>j   bundle is placed in \"limbo\" for possible future re-forwarding</p> <p>k   bundle is removed from \"limbo\" and queued for re-forwarding</p> <p>Note that a slightly amended interpretation should be applied to watch characters printed in the course of multicast transmission.  The '~' character, meaning Abandoned (node did not forward this bundle), is printed by a node that is a leaf of the multicast tree, i.e., a node with no children; it cannot forward the bundle because it's got nobody to forward it to.  The '!' character, meaning Destroyed (node destroyed a physical copy of a bundle), is printed by a node that has forwarded copies of the bundle to all of its children and no longer needs to retain the original - so it does an immediate permanent bundle destruction just as if the bundle's time to live had expired. Neither condition is anomalous.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#scheme-commands","title":"SCHEME COMMANDS","text":"<ul> <li> <p>a scheme scheme_name 'forwarder_command' 'admin_app_command'</p> <p>The add scheme command.  This command declares an endpoint naming \"scheme\" for use in endpoint IDs, which are structured as URIs: scheme_name:scheme-specific_part.  forwarder_command will be executed when the scheme is started on this node, to initiate operation of a forwarding daemon for this scheme.  admin_app_command will also be executed when the scheme is started on this node, to initiate operation of a daemon that opens a custodian endpoint identified within this scheme so that it can receive and process custody signals and bundle status reports.</p> </li> <li> <p>c scheme scheme_name 'forwarder_command' 'admin_app_command'</p> <p>The change scheme command.  This command sets the indicated scheme's  forwarder_command and admin_app_command to the strings provided as arguments.</p> </li> <li> <p>d scheme scheme_name</p> <p>The delete scheme command.  This command deletes the scheme identified by scheme_name.  The command will fail if any bundles identified in this scheme are pending forwarding, transmission, or delivery.</p> </li> <li> <p>i scheme scheme_name</p> <p>This command will print information (number and commands) about the endpoint naming scheme identified by scheme_name.</p> </li> <li> <p>l scheme</p> <p>This command lists all declared endpoint naming schemes.</p> </li> <li> <p>s scheme scheme_name</p> <p>The start scheme command.  This command starts the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.</p> </li> <li> <p>x scheme scheme_name</p> <p>The stop scheme command.  This command stops the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#endpoint-commands","title":"ENDPOINT COMMANDS","text":"<ul> <li> <p>a endpoint endpoint_ID { q | x } ['recv_script']</p> <p>The add endpoint command.  This command establishes a DTN endpoint named endpoint_ID on the local node.  The remaining parameters indicate what is to be done when bundles destined for this endpoint arrive at a time when no application has got the endpoint open for bundle reception.  If 'x', then such bundles are to be discarded silently and immediately.  If 'q', then such bundles are to be enqueued for later delivery and, if recv_script is provided, recv_script is to be executed.</p> </li> <li> <p>c endpoint endpoint_ID { q | x } ['recv_script']</p> <p>The change endpoint command.  This command changes the action that is to be taken when bundles destined for this endpoint arrive at a time when no application has got the endpoint open for bundle reception, as described above.</p> </li> <li> <p>d endpoint endpoint_ID</p> <p>The delete endpoint command.  This command deletes the endpoint identified by endpoint_ID.  The command will fail if any bundles are currently pending delivery to this endpoint.</p> </li> <li> <p>i endpoint endpoint_ID</p> <p>This command will print information (disposition and script) about the endpoint identified by endpoint_ID.</p> </li> <li> <p>l endpoint</p> <p>This command lists all local endpoints, regardless of scheme name.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#protocol-commands","title":"PROTOCOL COMMANDS","text":"<ul> <li> <p>a protocol protocol_name [protocol_class]</p> <p>The add protocol command.  This command establishes access to the named convergence layer protocol at the local node.</p> <p>The optional protocol_class argument indicates the reliability of the protocol.  The value 1 indicates that the protocol natively supports bundle streaming; currently the only protocol in class 1 is BSSP.  The value 2 indicates that the protocol performs no retransmission; an example is UDP. The value 8 (which is the default) indicates that the protocol detects data loss and automatically retransmits data accordingly; an example is TCP. Protocol class need not be specified when protocol_name is bssp, udp, tcp, stcp, brss, brsc, or ltp, as the protocol classes for these well-known protocols are hard-coded in ION.</p> <p>In earlier versions of ION this command took two additional arguments, payload_bytes_per_frame and overhead_bytes_per_frame.  These arguments are deprecated.  BP configuration files that include a protocol commands in the old format will be processed correctly; the deprecated arguments will simply be ignored.</p> </li> <li> <p>d protocol protocol_name</p> <p>The delete protocol command.  This command deletes the convergence layer protocol identified by protocol_name.  The command will fail if any ducts are still locally declared for this protocol.</p> </li> <li> <p>i protocol protocol_name</p> <p>This command will print information about the convergence layer protocol identified by protocol_name.</p> </li> <li> <p>l protocol</p> <p>This command lists all convergence layer protocols that can currently be utilized at the local node.</p> </li> <li> <p>s protocol protocol_name</p> <p>The start protocol command.  This command starts all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.</p> </li> <li> <p>x protocol protocol_name</p> <p>The stop protocol command.  This command stops all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#induct-commands","title":"INDUCT COMMANDS","text":"<ul> <li> <p>a induct protocol_name duct_name 'CLI_command'</p> <p>The add induct command.  This command establishes a \"duct\" for reception of bundles via the indicated CL protocol.  The duct's data acquisition structure is used and populated by the \"induct\" task whose operation is initiated by CLI_command at the time the duct is started.</p> </li> <li> <p>c induct protocol_name duct_name 'CLI_command'</p> <p>The change induct command.  This command changes the command that is used to initiate operation of the induct task for the indicated duct.</p> </li> <li> <p>d induct protocol_name duct_name</p> <p>The delete induct command.  This command deletes the induct identified by protocol_name and duct_name.  The command will fail if any bundles are currently pending acquisition via this induct.</p> </li> <li> <p>i induct protocol_name duct_name</p> <p>This command will print information (the CLI command) about the induct identified by protocol_name and duct_name.</p> </li> <li> <p>l induct [protocol_name]</p> <p>If protocol_name is specified, this command lists all inducts established locally for the indicated CL protocol.  Otherwise it lists all locally established inducts, regardless of protocol.</p> </li> <li> <p>s induct protocol_name duct_name</p> <p>The start induct command.  This command starts the indicated induct  task as defined for the indicated CL protocol on the local node.</p> </li> <li> <p>x induct protocol_name duct_name</p> <p>The stop induct command.  This command stops the indicated induct  task as defined for the indicated CL protocol on the local node.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#outduct-commands","title":"OUTDUCT COMMANDS","text":"<ul> <li> <p>a outduct protocol_name duct_name 'CLO_command' [max_payload_length]</p> <p>The add outduct command.  This command establishes a \"duct\" for transmission of bundles via the indicated CL protocol.  The duct's data transmission structure is serviced by the \"outduct\" task whose operation is initiated by CLO_command at the time the duct is started.  A value of zero for max_payload_length indicates that bundles of any size can be accommodated; this is the default.</p> </li> <li> <p>c outduct protocol_name duct_name 'CLO_command' [max_payload_length]</p> <p>The change outduct command.  This command sets new values for the indicated duct's payload size limit and the command that is used to initiate operation of the outduct task for this duct.</p> </li> <li> <p>d outduct protocol_name duct_name</p> <p>The delete outduct command.  This command deletes the outduct identified by protocol_name and duct_name.  The command will fail if any bundles are currently pending transmission via this outduct.</p> </li> <li> <p>i outduct protocol_name duct_name</p> <p>This command will print information (the CLO command) about the outduct identified by protocol_name and duct_name.</p> </li> <li> <p>l outduct [protocol_name]</p> <p>If protocol_name is specified, this command lists all outducts established locally for the indicated CL protocol.  Otherwise it lists all locally established outducts, regardless of protocol.</p> </li> <li> <p>s outduct protocol_name duct_name</p> <p>The start outduct command.  This command starts the indicated outduct  task as defined for the indicated CL protocol on the local node.</p> </li> <li> <p>x outduct protocol_name duct_name</p> <p>The stop outduct command.  This command stops the indicated outduct  task as defined for the indicated CL protocol on the local node.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#egress-plan-commands","title":"EGRESS PLAN COMMANDS","text":"<ul> <li> <p>a plan endpoint_name [transmission_rate]</p> <p>The add plan command.  This command establishes an egress plan governing transmission to the neighboring node[s] identified by endpoint_name.  The plan is functionally enacted by a bpclm(1) daemon dedicated to managing bundles queued for transmission to the indicated neighboring node[s].</p> <p>NOTE that these \"plan\" commands supersede and generalize the egress plan commands documented in the ipnrc(5) and dtn2rc(5) man pages, which are retained for backward compatibility.  The syntax of the egress plan commands consumed by bpadmin is DIFFERENT from that of the commands consumed by ipnadmin and dtn2admin.  The endpoint_name identifying an egress plan is normally the node ID for a single node but may instead be \"wild-carded\".  That is, when the last character of an endpoint name ID is either '*' or '~' (these two wild-card characters are equivalent for this purpose), the plan applies to all nodes whose IDs are identical to the wild-carded node name up to the wild-card character.  For example, a bundle whose destination EID name is \"dtn://foghorn\" would be routed by plans citing the following node IDs: \"dtn://foghorn\", \"dtn://fogh*\", \"dtn://fog~\", \"//*\".  When multiple plans are all applicable to the same destination EID, the one citing the longest (i.e., most narrowly targeted) node ID will be applied.</p> <p>An egress plan may direct that bundles queued for transmission to the node[s] matching endpoint_name be transmitted using one of the convergence-layer protocol \"outducts\" that have been attached to the plan, or instead that those bundles be routed to some other \"gateway\" endpoint (resulting in transmission according to some other egress plan).  In the event that both a gateway endpoint and one or more outducts have been declared for a given plan, the gateway declaration prevails.</p> <p>A transmission_rate may be asserted for an egress plan; this rate is used as the basis for transmission rate control in the absence of applicable contacts (in the node's contact plan, as per ionrc(5)).  A transmission rate of zero (absent applicable contacts) disables rate control completely; this is the default.</p> </li> <li> <p>c plan endpoint_name [transmission_rate]</p> <p>The change plan command.  This command sets a new value for the indicated plan's transmission rate.</p> </li> <li> <p>d plan endpoint_name</p> <p>The delete plan command.  This command deletes the plan identified by endpoint_name.  The command will fail if any bundles are currently pending transmission per this plan.</p> </li> <li> <p>i plan endpoint_name</p> <p>This command will print information (the transmission rate) about the plan identified by endpoint_name.</p> </li> <li> <p>l plan</p> <p>This command lists all locally established egress plans.</p> </li> <li> <p>s plan endpoint_name</p> <p>The start plan command.  This command starts the bpclm(1) task for the indicated egress plan.</p> </li> <li> <p>x plan endpoint_name</p> <p>The stop plan command.  This command stops the bpclm(1) task for the indicated egress plan. </p> </li> <li> <p>b plan endpoint_name</p> <p>The block plan command.  This command disables transmission of bundles queued for transmission to the indicated node and reforwards all non-critical bundles currently queued for transmission to this node.  This may result in some or all of these bundles being enqueued for transmission (actually just retention) to the pseudo-node \"limbo\".</p> </li> <li> <p>u plan endpoint_name</p> <p>The unblock plan command.  This command re-enables transmission of bundles to the indicated node and reforwards all bundles in \"limbo\" in the hope that the unblocking of this egress plan will enable some of them to be transmitted.</p> </li> <li> <p>g plan endpoint_name gateway_endpoint_name</p> <p>The declare gateway command.  This command declares the name of the endpoint to which bundles queued for transmission to the node[s] identified by endpoint_name must be re-routed.  Declaring gateway_endpoint_name to be the zero-length string \"''\" disables re-routing: bundles will instead be transmitted using the plan's attached convergence-layer protocol outduct[s].</p> </li> <li> <p>a planduct endpoint_name protocol_name duct_name</p> <p>The attach outduct command.  This command declares that the indicated convergence-layer protocol outduct is now a viable device for transmitting bundles to the node[s] identified by endpoint_name.</p> </li> <li> <p>d planduct protocol_name duct_name</p> <p>The detach outduct command.  This command declares that the indicated convergence-layer protocol outduct is no longer a viable device for transmitting bundles to the node[s] to which it is currently assigned.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a scheme ipn 'ipnfw' 'ipnadminep'</p> <p>Declares the \"ipn\" scheme on the local node.</p> </li> <li> <p>a protocol udp 1400 100 16384</p> <p>Establishes access to the \"udp\" convergence layer protocol on the local node, estimating the number of payload bytes per ultimate (lowest-layer) frame to be 1400 with 100 bytes of total overhead (BP, UDP, IP, AOS) per lowest-layer frame, and setting the default nominal data rate to be 16384 bytes per second.</p> </li> <li> <p>r 'ipnadmin flyby.ipnrc'</p> <p>Runs the administrative program ipnadmin from within bpadmin.</p> </li> </ul>"},{"location":"man/bpv7/bprc/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), ipnadmin(1), dtn2admin(1)</p>"},{"location":"man/bpv7/bprecvfile/","title":"NAME","text":"<p>bprecvfile - Bundle Protocol (BP) file reception utility</p>"},{"location":"man/bpv7/bprecvfile/#synopsis","title":"SYNOPSIS","text":"<p>bprecvfile own_endpoint_ID [max_files]</p>"},{"location":"man/bpv7/bprecvfile/#description","title":"DESCRIPTION","text":"<p>bprecvfile is intended to serve as the counterpart to bpsendfile.  It uses bp_receive() to receive bundles containing file content.  The content of each bundle is simply written to a file named \"testfileN\" where N is the total number of bundles received since the program began running.</p> <p>If a max_files value of N (where N &gt; 0) is provided, the program will terminate automatically upon completing its Nth file reception.  Otherwise it will run indefinitely; use ^C to terminate the program.</p>"},{"location":"man/bpv7/bprecvfile/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bprecvfile has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bprecvfile/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bprecvfile/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bprecvfile/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>bprecvfile bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't open test file</p> <p>File system error.  bprecvfile terminates.</p> </li> <li> <p>bprecvfile: can't receive bundle content.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't write to test file</p> <p>File system error.  bprecvfile terminates.</p> </li> <li> <p>bprecvfile cannot continue.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't handle bundle delivery.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bprecvfile/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bprecvfile/#see-also","title":"SEE ALSO","text":"<p>bpsendfile(1), bp(3)</p>"},{"location":"man/bpv7/bprecvfile2/","title":"NAME","text":"<p>bprecvfile2 - Bundle Protocol (BP) file reception utility</p>"},{"location":"man/bpv7/bprecvfile2/#synopsis","title":"SYNOPSIS","text":"<p>bprecvfile own_endpoint_ID [filename]</p>"},{"location":"man/bpv7/bprecvfile2/#description","title":"DESCRIPTION","text":"<p>This is an updated version of the original bprecvfile utility</p> <p>bprecvfile is intended to serve as the counterpart to bpsendfile.  It uses bp_receive() to receive bundles containing file content.  The content of each bundle is simply written to a file named \"filename\". If the filename is not provided on the command line bundles are written to stdout. Use of UNIX pipes is allowed. Note: If filename exists data will be appended to that file. If filename does not exist it will be created. Use ^C to terminate the program.</p>"},{"location":"man/bpv7/bprecvfile2/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bprecvfile has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bprecvfile2/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bprecvfile2/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bprecvfile2/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>bprecvfile bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't open test file</p> <p>File system error.  bprecvfile terminates.</p> </li> <li> <p>bprecvfile: can't receive bundle content.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't write to test file</p> <p>File system error.  bprecvfile terminates.</p> </li> <li> <p>bprecvfile cannot continue.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bprecvfile: can't handle bundle delivery.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bprecvfile2/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bprecvfile2/#see-also","title":"SEE ALSO","text":"<p>bpsendfile(1), bp(3)</p>"},{"location":"man/bpv7/bpsecadmin/","title":"NAME","text":"<p>bpsecadmin - BP security policy administration interface</p>"},{"location":"man/bpv7/bpsecadmin/#synopsis","title":"SYNOPSIS","text":"<p>bpsecadmin [ commands_filename ]</p>"},{"location":"man/bpv7/bpsecadmin/#description","title":"DESCRIPTION","text":"<p>bpsecadmin configures and manages BP security policy on the local computer.</p> <p>It configures and manages BP security policy on the local computer in response to BP configuration commands found in commands_filename, if provided; if not, bpsecadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from bpsecadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in bpsecrc(5).</p>"},{"location":"man/bpv7/bpsecadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of BP security policy administration.</p> </li> </ul>"},{"location":"man/bpv7/bpsecadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>bpsecadmin</p> <p>Enter interactive ION security policy administration command entry mode.</p> </li> <li> <p>bpsecadmin host1.bpsecrc</p> <p>Execute all configuration commands in host1.bpsecrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv7/bpsecadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from bpsecadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which bpsecadmin was run.  The log file is typically named ion.log.</p> <p>See also bpsecrc(5).</p>"},{"location":"man/bpv7/bpsecadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpsecadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ionrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to bpsecadmin.  Otherwise bpsecadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause bpsecadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see bpsecrc(5) for details.</p>"},{"location":"man/bpv7/bpsecadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpsecadmin/#see-also","title":"SEE ALSO","text":"<p>bpsecrc(5)</p>"},{"location":"man/bpv7/bpsecrc/","title":"NAME","text":"<p>bpsecrc - BP security policy management commands file</p>"},{"location":"man/bpv7/bpsecrc/#description","title":"DESCRIPTION","text":"<p>BP security policy management commands are passed to bpsecadmin either in a file of text lines or interactively at bpsecadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  JSON commands may span multiple lines when provided as part of a config file. The formats and effects of the BP security policy management commands  are described below.</p> <p>A parameter identifed as an eid_expr is an \"endpoint ID expression.\"  For all commands, whenever the last character of an endpoint ID expression is the wild-card character '*', an applicable endpoint ID \"matches\" this EID expression if all characters of the endpoint ID expression prior to the last one are equal to the corresponding characters of that endpoint ID.  Otherwise an applicable endpoint ID \"matches\" the EID expression only when all characters of the EID and EID expression are identical.</p> <p>At present, ION supports a subset of the proposed \"BPSec\" security protocol specification currently under consideration by the Internet Engineering Steering Group.  Since BPSec is not yet a published standard, ION's Bundle Protocol security mechanisms will not necessarily interoperate with those of other BP implementations.  This is unfortunate but (we hope) temporary, as BPSec represents a major improvement in bundle security. Future releases of ION will implement the entire BPSec specification.</p>"},{"location":"man/bpv7/bpsecrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by bpsecadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>a { event_set : { name : event set name, desc : (opt) description } }</p> <p>The add event_set command. This command will add a named security operation event set to the local security policy database.</p> </li> <li> <p>i { event_set : { name : event set name } }</p> <p>The info event_set command for event sets displays the information the system maintains for a named event set. The security operation events and configured,  optional processing actions associated with that event set are shown.</p> </li> <li> <p>d { event_set : { name : event set name } }</p> <p>The delete event_set command deletes a named event set from the system.  A named event set cannot be deleted if it is referenced by a security policy  rule. All security policy rules associated with the named event set must be deleted  before the event set itself may be deleted.</p> </li> <li> <p>l {event_set}</p> <p>The list event_set command lists the names of all event sets defined in the  system.</p> </li> <li> <p>a { event : {      es_ref   : event set name,     event_id : security operation event ID,     actions  : [ {id: processing action, (opt.) action parm key, (opt.) parm value}, ... ,                     {id: processing action, (opt.) action parm key, (opt.) parm value} ] } }</p> <p>The add event command adds security operation event and associated optional  processing action(s) to an event set. Multiple processing actions can be specified  for a single security operation event.</p> </li> <li> <p>d { event : {      es_ref : event set name,     event_id : security operation event ID } }</p> <p>The delete event command is used to delete optional processing actions from a named event set. This command currently deletes all of the optional processing actions associated with the security operation event provided.</p> </li> <li> <p>a { policyrule : {     desc : (opt.) description,     filter :     {         rule_id : Security policy rule id,         role : Security policy role,         src : Bundle source,         dest : Bundle destination         sec_src : Security source         tgt : Security target block type,         sc_id : Security context ID,      },     spec :      {         svc : Security service,         sc_id : Security context ID,         sc_parms : [ {SC parm ID, SC parm value }, ... ,                         {SC parm ID, SC parm value } ]      },     es_ref : Event set name } }</p> <p>The add policyrule command adds a policy rule to the system, describing a  required security operation and the security policy role of the BPA applying  the policy statement. The above command adds a policy rule referencing a  named event set to the system.</p> </li> <li> <p>d { policyrule : { rule_id : Security policy rule ID } }</p> <p>The delete policyrule command deletes the policy rule identified by its rule ID.</p> </li> <li> <p>i {policyrule : { rule_id : Security policy rule ID } }</p> <p>The info policyrule command displays the information for the policy rule matching the provided ID.</p> </li> <li> <p>f {policyrule :      {type : all | best,      src : Bundle source,     dest : Bundle destination,      sec_src : Security source,      sc_id : Security context ID,     role : Security policy role } }</p> <p>The find policyrule command finds all policy rules matching the provided criteria  when type all is selected, and finds the single policy rule that is determined to be  the best match when type best is selected. </p> </li> <li> <p>l {policyrule}</p> <p>The list policyrule command lists all policy rules currently  defined in the system.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv7/bpsecrc/#see-also","title":"SEE ALSO","text":"<p>bpsecadmin(1)</p>"},{"location":"man/bpv7/bpsendfile/","title":"NAME","text":"<p>bpsendfile - Bundle Protocol (BP) file transmission utility</p>"},{"location":"man/bpv7/bpsendfile/#synopsis","title":"SYNOPSIS","text":"<p>bpsendfile own_endpoint_ID destination_endpoint_ID file_name [class_of_service [time_to_live (seconds) ]]</p>"},{"location":"man/bpv7/bpsendfile/#description","title":"DESCRIPTION","text":"<p>bpsendfile uses bp_send() to issue a single bundle to a designated destination endpoint, containing the contents of the file identified by file_name, then terminates.  The bundle is sent with no custody transfer requested.  When class_of_service is omitted, the bundle is sent at standard priority; for details of the class_of_service parameter, see bptrace(1).  time_to_live, if not specified, defaults to 300 seconds (5 minutes).  NOTE that time_to_live is specified AFTER class_of_service, rather than before it as in bptrace(1).</p>"},{"location":"man/bpv7/bpsendfile/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpsendfile has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bpsendfile/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpsendfile/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpsendfile/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>Can't stat the file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>bpsendfile can't create file ref.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bpsendfile can't create ZCO.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bpsendfile can't send file in bundle.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bpsendfile/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpsendfile/#see-also","title":"SEE ALSO","text":"<p>bprecvfile(1), bp(3)</p>"},{"location":"man/bpv7/bpsink/","title":"NAME","text":"<p>bpsink - Bundle Protocol reception test program</p>"},{"location":"man/bpv7/bpsink/#synopsis","title":"SYNOPSIS","text":"<p>bpsink ownEndpointId</p>"},{"location":"man/bpv7/bpsink/#description","title":"DESCRIPTION","text":"<p>bpsink uses Bundle Protocol to receive application data units from a remote bpsource application task.  For each application data unit it receives, it prints the ADU's length and -- if length is less than 80 -- its text.</p> <p>bpsink terminates upon receiving the SIGQUIT signal, i.e., ^C from the keyboard.</p>"},{"location":"man/bpv7/bpsink/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpsink has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bpsink/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpsink/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpsink/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpsink are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>Can't open own endpoint.</p> <p>Another application has already opened ownEndpointId.  Terminate that application and rerun.</p> </li> <li> <p>bpsink bundle reception failed.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't receive payload.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't handle delivery.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bpsink/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpsink/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpsource(1), bp(3)</p>"},{"location":"man/bpv7/bpsource/","title":"NAME","text":"<p>bpsource - Bundle Protocol transmission test shell</p>"},{"location":"man/bpv7/bpsource/#synopsis","title":"SYNOPSIS","text":"<p>bpsource destinationEndpointId [\"text\"] [-t_TTL_]</p>"},{"location":"man/bpv7/bpsource/#description","title":"DESCRIPTION","text":"<p>When text is supplied, bpsource simply uses Bundle Protocol to send text to a counterpart bpsink application task that has opened the BP endpoint identified by destinationEndpointId, then terminates.</p> <p>Otherwise, bpsource offers the user an interactive \"shell\" for testing Bundle Protocol data transmission.  bpsource prints a prompt string (\": \") to stdout, accepts a string of text from stdin, uses Bundle Protocol to send the string to a counterpart bpsink application task that has opened the BP endpoint identified by destinationEndpointId, then prints another prompt string and so on.  To terminate the program, enter a string consisting of a single exclamation point (!) character.</p> <p>TTL indicates the number of seconds the bundles may remain in the network, undelivered, before they are automatically destroyed. If omitted, TTL defaults to 300 seconds.</p> <p>The source endpoint ID for each bundle sent by bpsource is the null endpoint ID, i.e., the bundles are anonymous.  All bundles are sent standard priority with no custody transfer and no status reports requested.</p>"},{"location":"man/bpv7/bpsource/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpsource has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/bpv7/bpsource/#files","title":"FILES","text":"<p>The service data units transmitted by bpsource are sequences of text obtained from a file in the current working directory named \"bpsourceAduFile\", which bpsource creates automatically.</p>"},{"location":"man/bpv7/bpsource/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpsource/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by bpsource are written to the ION log file ion.log.</p> <ul> <li> <p>Can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>bpsource fgets failed</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpsource can't send ADU</p> <p>Bundle Protocol service to the remote endpoint has been stopped.</p> </li> </ul>"},{"location":"man/bpv7/bpsource/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpsource/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bpsink(1), bp(3)</p>"},{"location":"man/bpv7/bpstats/","title":"NAME","text":"<p>bpstats - Bundle Protocol (BP) processing statistics query utility</p>"},{"location":"man/bpv7/bpstats/#synopsis","title":"SYNOPSIS","text":"<p>bpstats</p>"},{"location":"man/bpv7/bpstats/#description","title":"DESCRIPTION","text":"<p>bpstats simply logs messages containing the current values of all BP processing statistics accumulators, then terminates.</p>"},{"location":"man/bpv7/bpstats/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpstats has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bpstats/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpstats/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpstats/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpstats can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv7/bpstats/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpstats/#see-also","title":"SEE ALSO","text":"<p>ion(3)</p>"},{"location":"man/bpv7/bpstats2/","title":"NAME","text":"<p>bpstats2 - Bundle Protocol (BP) processing statistics query utility via bundles</p>"},{"location":"man/bpv7/bpstats2/#synopsis","title":"SYNOPSIS","text":"<p>bpstats2 sourceEID [default destEID] [ct]</p>"},{"location":"man/bpv7/bpstats2/#description","title":"DESCRIPTION","text":"<p>bpstats2 creates bundles containing the current values of all BP processing statistics accumulators.  It creates these bundles when:</p> <ul> <li>an interrogation bundle is delivered to sourceEID: the contents of the bundle are discarded, a new statistics bundle is generated and sent to the source of the interrogation bundle.  The format of the interrogation bundle is irrelevant.</li> <li>a SIGUSR1 signal is delivered to the bpstats2 application: a new statistics bundle is generated and sent to default destEID.</li> </ul>"},{"location":"man/bpv7/bpstats2/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpstats2 has terminated. Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>bpstats2 failed to start up or receive bundles.  Diagnose the issue  reported in the ion.log file and try again.</p> </li> </ul>"},{"location":"man/bpv7/bpstats2/#options","title":"OPTIONS","text":"<ul> <li> \\[ct\\] <p>If the string \"ct\" is appended as the last argument, then statistics bundles will be sent with custody transfer requested.</p> </li> </ul>"},{"location":"man/bpv7/bpstats2/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bpstats2/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bpstats2/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bpstats2 can't bp_attach().</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>bpstats2 can't open own endpoint.</p> <p>Another BP application has opened that endpoint; close it and try again.</p> </li> <li> <p>No space for ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create ZCO extent.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>bpstats2 can't send stats bundle.</p> <p>Bundle Protocol service to the remote endpoint has been stopped.</p> </li> <li> <p>Can't send stats: bad dest EID (dest EID)</p> <p>The destination EID printed is an invalid destination EID.  The destination EID may be specified in default destEID or the source EID of the interrogation bundle.  Ensure that default destEID is an EID that  is valid for ION, and that the interrogator is a source EID that is also a valid destination EID.  Note that \"dtn:none\" is not a valid destination EID, but is a valid source EID.</p> </li> </ul>"},{"location":"man/bpv7/bpstats2/#notes","title":"NOTES","text":"<p>A very simple interrogator is bpchat which can repeatedly interrogate bpstats2 by just striking the enter key.</p>"},{"location":"man/bpv7/bpstats2/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bpstats2/#see-also","title":"SEE ALSO","text":"<p>bpstats(1), bpchat(1)</p>"},{"location":"man/bpv7/bptrace/","title":"NAME","text":"<p>bptrace - Bundle Protocol (BP) network trace utility</p>"},{"location":"man/bpv7/bptrace/#synopsis","title":"SYNOPSIS","text":"<p>bptrace own_endpoint_ID destination_endpoint_ID report-to_endpoint_ID TTL class_of_service \"trace_text\" [status_report_flags]</p>"},{"location":"man/bpv7/bptrace/#description","title":"DESCRIPTION","text":"<p>bptrace uses bp_send() to issue a single bundle to a designated destination endpoint, with status reporting options enabled as selected by the user, then terminates.  The status reports returned as the bundle makes its way through the network provide a view of the operation of the network as currently configured.</p> <p>TTL indicates the number of seconds the trace bundle may remain in the network, undelivered, before it is automatically destroyed.</p> <p>class_of_service is custody-requested.priority[.ordinal[.unreliable.critical[.data-label]]], where custody-requested must be 0 or 1 (Boolean), priority must be 0 (bulk) or 1 (standard) or 2 (expedited), ordinal must be 0-254, unreliable must be 0 or 1 (Boolean), critical must also be 0 or 1 (Boolean), and data-label may be any unsigned integer.  custody-requested is passed in with the bundle transmission request, but if set to 1 it serves only to request the use of reliable convergence-layer protocols; this will have the effect of enabling custody transfer whenever the applicable convergence-layer protocol is bundle-in-bundle encapsulation (BIBE). ordinal is ignored if priority is not 2.  Setting class_of_service to \"0.2.254\" or \"1.2.254\" gives a bundle the highest possible priority.  Setting unreliable to 1 causes BP to forego convergence-layer retransmission in the event of data loss.  Setting critical to 1 causes contact graph routing to forward the bundle on all plausible routes rather than just the \"best\" route it computes; this may result in multiple copies of the bundle arriving at the destination endpoint, but when used in conjunction with priority 2.254 it ensures that the bundle will be delivered as soon as physically possible.</p> <p>trace_text can be any string of ASCII text; alternatively, if we want to send a file, it can be \"@\" followed by the name of the file.</p> <p>status_report_flags must be a sequence of status report flags, separated by commas, with no embedded whitespace.  Each status report flag must be one of the following: rcv, fwd, dlv, del.</p>"},{"location":"man/bpv7/bptrace/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bptrace has terminated.</p> </li> </ul>"},{"location":"man/bpv7/bptrace/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bptrace/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bptrace/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bptrace can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>bptrace can't open own endpoint.</p> <p>Another BP application task currently has own_endpoint_ID open for bundle origination and reception.  Try again after that task has terminated. If no such task exists, it may have crashed while still holding the endpoint open; the easiest workaround is to select a different source endpoint.</p> </li> <li> <p>No space for bptrace text.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bptrace can't create ZCO.</p> <p>Probably an unrecoverable database error, in which case the local ION node must be terminated and re-initialized.</p> </li> <li> <p>bptrace can't send message.</p> <p>BP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/bpv7/bptrace/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bptrace/#see-also","title":"SEE ALSO","text":"<p>bp(3)</p>"},{"location":"man/bpv7/bptransit/","title":"NAME","text":"<p>bptransit - Bundle Protocol (BP) daemon task for forwarding received bundles</p>"},{"location":"man/bpv7/bptransit/#synopsis","title":"SYNOPSIS","text":"<p>bptransit</p>"},{"location":"man/bpv7/bptransit/#description","title":"DESCRIPTION","text":"<p>bptransit is a background \"daemon\" task that is responsible for presenting to ION's forwarding daemons any bundles that were received from other nodes (i.e., bundles whose payloads reside in Inbound ZCO space) and are destined for yet other nodes.  In doing so, it migrates these bundles from Inbound buffer space to Outbound buffer space on the same prioritized basis as the insertion of locally sourced outbound bundles.</p> <p>Management of the bptransit daemon is automatic.  It is spawned automatically by bpadmin in response to the 's' command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.</p> <p>Whenever a received bundle is determined to have a destination other than the local node, a pointer to that bundle is appended to one of two queues of  \"in-transit\" bundles, one for bundles whose forwarding is provisional (depending on the availability of Outbound ZCO buffer space; bundles in this queue are potentially subject to congestion loss) and one for bundles whose forwarding is confirmed.  Bundles received via convergence-layer adapters that can sustain flow control, such as STCP, are appended to the \"confirmed\" queue, while those from CLAs that cannot sustain flow control (such as LTP) are appended to the \"provisional\" queue.</p> <p>bptransit comprises two threads, one for each in-transit queue.  The confirmed in-transit thread dequeues bundles from the \"confirmed\" queue and moves them from Inbound to Outbound ZCO buffer space, blocking (if necessary) until space becomes available.  The provisional in-transit queue dequeues bundles from the \"provisional\" queue and moves them from Inbound to Outbound ZCO buffer space if Outbound space is available, discarding (\"abandoning\") them if it is not.</p>"},{"location":"man/bpv7/bptransit/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bptransit terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart bptransit.</p> </li> <li> <p>\"1\"</p> <p>bptransit was unable to attach to Bundle Protocol operations, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv7/bptransit/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/bptransit/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/bptransit/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bptransit can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> </ul>"},{"location":"man/bpv7/bptransit/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/bptransit/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1)</p>"},{"location":"man/bpv7/brsccla/","title":"NAME","text":"<p>brsccla - BRSC-based BP convergence layer adapter (input and output) task</p>"},{"location":"man/bpv7/brsccla/#synopsis","title":"SYNOPSIS","text":"<p>brsccla server_hostname[:server_port_nbr]_own_node_nbr</p>"},{"location":"man/bpv7/brsccla/#description","title":"DESCRIPTION","text":"<p>BRSC is the \"client\" side of the Bundle Relay Service (BRS) convergence layer protocol for BP.  It is complemented by BRSS, the \"server\" side of the BRS convergence layer protocol for BP.  BRS clients send bundles directly only to the server, regardless of their final destinations, and the server forwards them to other clients as necessary.</p> <p>brsccla is a background \"daemon\" task comprising three threads: one that connects to the BRS server, spawns the other threads, and then handles BRSC protocol output by transmitting bundles over the connected socket to the BRS server; one that simply sends periodic \"keepalive\" messages over the connected socket to the server (to assure that local inactivity doesn't cause the connection to be lost); and one that handles BRSC protocol input from the connected server.</p> <p>The output thread connects to the server's TCP socket at server_hostname and server_port_nbr, sends over the connected socket the client's own_node_nbr (in SDNV representation) followed by a 32-bit time tag and a 160-bit HMAC-SHA1 digest of that time tag, to authenticate itself; checks the authenticity of the 160-bit countersign returned by the server; spawns the keepalive and receiver threads; and then begins extracting bundles from the queues of bundles ready for transmission via BRSC and transmitting those bundles over the connected socket to the server.  Each transmitted bundle is preceded by its length, a 32-bit unsigned integer in network byte order.  The default value for server_port_nbr, if omitted, is 80.</p> <p>The reception thread receives bundles over the connected socket and passes them to the bundle protocol agent on the local ION node.  Each bundle received on the connection is preceded by its length, a 32-bit unsigned integer in network byte order.</p> <p>The keepalive thread simply sends a \"bundle length\" value of zero (a 32-bit unsigned integer in network byte order) to the server once every 15 seconds.</p> <p>brsccla is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  brsccla can also be spawned and terminated in response to START and STOP commands that pertain specifically to the BRSC convergence layer protocol.</p>"},{"location":"man/bpv7/brsccla/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>brsccla terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the BRSC protocol.</p> </li> <li> <p>\"1\"</p> <p>brsccla terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the BRSC protocol.</p> </li> </ul>"},{"location":"man/bpv7/brsccla/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/brsccla/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/brsccla/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>brsccla can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such brsc induct.</p> <p>No BRSC induct with duct name matching server_hostname, own_node_nbr, and server_port_nbr has been added to the BP database.  Use bpadmin to stop the BRSC convergence-layer protocol, add the induct, and then restart the BRSC protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of brsccla.</p> </li> <li> <p>No such brsc outduct.</p> <p>No BRSC outduct with duct name matching server_hostname, own_node_nbr, and server_port_nbr has been added to the BP database.  Use bpadmin to stop the BRSC convergence-layer protocol, add the outduct, and then restart the BRSC protocol.</p> </li> <li> <p>Can't connect to server.</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSC.</p> </li> <li> <p>Can't register with server.</p> <p>Configuration error.  Authentication has failed, probably because (a) the client and server are using different HMAC/SHA1 keys or (b) the clocks of the client and server differ by more than 5 seconds.  Update security policy database(s), as necessary, and assure that the clocks are synchronized.</p> </li> <li> <p>brsccla can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSC.</p> </li> <li> <p>brsccla can't create keepalive thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSC.</p> </li> </ul>"},{"location":"man/bpv7/brsccla/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/brsccla/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), brsscla(1)</p>"},{"location":"man/bpv7/brsscla/","title":"NAME","text":"<p>brsscla - BRSS-based BP convergence layer adapter (input and output) task</p>"},{"location":"man/bpv7/brsscla/#synopsis","title":"SYNOPSIS","text":"<p>brsscla local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv7/brsscla/#description","title":"DESCRIPTION","text":"<p>BRSS is the \"server\" side of the Bundle Relay Service (BRS) convergence layer protocol for BP.  It is complemented by BRSC, the \"client\" side of the BRS convergence layer protocol for BP.</p> <p>brsscla is a background \"daemon\" task that spawns 2*N threads: one that handles BRSS client connections and spawns sockets for continued data interchange with connected clients; one that handles BRSS protocol output by transmitting over those spawned sockets to the associated clients; and two thread for each spawned socket, an input thread to handle BRSS protocol input from the associated connected client and an output thread to forward BRSS protocol output to the associated connected client.</p> <p>The connection thread simply accepts connections on a TCP socket bound to local_hostname and local_port_nbr and spawns reception threads.  The default value for local_port_nbr, if omitted, is 80.</p> <p>Each reception thread receives over the socket connection the node number of the connecting client (in SDNV representation), followed by a 32-bit time tag and a 160-bit HMAC-SHA1 digest of that time tag.  The receiving thread checks the time tag, requiring that it differ from the current time by no more than BRSTERM (default value 5) seconds.  It then recomputes the digest value using the HMAC-SHA1 key named \"node_number.brs\" as recorded in the ION security database (see ionsecrc(5)), requiring that the supplied and computed digests be identical.  If all registration conditions are met, the receiving thread sends the client a countersign -- a similarly computed HMAC-SHA1 digest, for the time tag that is 1 second later than the provided time tag -- to assure the client of its own authenticity, then commences receiving bundles over the connected socket.  Each bundle received on the connection is preceded by its length, a 32-bit unsigned integer in network byte order.  The received bundles are passed to the bundle protocol agent on the local ION node.</p> <p>Each output thread extracts bundles from the queues of bundles ready for transmission via BRSS to the corresponding connected client and transmits the bundles over the socket to that client.  Each transmitted bundle is preceded by its length, a 32-bit unsigned integer in network byte order.</p> <p>brsscla is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  brsscla can also be spawned and terminated in response to START and STOP commands that pertain specifically to the BRSS convergence layer protocol.</p>"},{"location":"man/bpv7/brsscla/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>brsscla terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the BRSS protocol.</p> </li> <li> <p>\"1\"</p> <p>brsscla terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the BRSS protocol.</p> </li> </ul>"},{"location":"man/bpv7/brsscla/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/brsscla/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/brsscla/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>brsscla can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such brss induct.</p> <p>No BRSS induct with duct name matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the BRSS convergence-layer protocol, add the induct, and then restart the BRSS protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of brsscla.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>Can't open TCP socket</p> <p>Operating system error -- unable to open TCP socket for accepting connections. Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>Can't initialize socket (note: must be root for port 80)</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>brsscla can't create sender thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> <li> <p>brsscla can't create access thread</p> <p>Operating system error.  Check errtext, correct problem, and restart BRSS.</p> </li> </ul>"},{"location":"man/bpv7/brsscla/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/brsscla/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), brsccla(1)</p>"},{"location":"man/bpv7/cgrfetch/","title":"NAME","text":"<p>cgrfetch - Visualize CGR simulations</p>"},{"location":"man/bpv7/cgrfetch/#synopsis","title":"SYNOPSIS","text":"<p>cgrfetch [OPTIONS] DEST-NODE</p>"},{"location":"man/bpv7/cgrfetch/#description","title":"DESCRIPTION","text":"<p>cgrfetch uses CGR to simulate sending a bundle from the local node to DEST-NODE. It traces the execution of CGR to generate graphs of the routes that were considered and the routes that were ultimately chosen to forward along. No bundle is sent during the simulation.</p> <p>A JSON representation of the simulation is output to OUTPUT-FILE. The representation includes parameters of the simulation and a structure for each considered route, which in turn includes calculated parameters for the route and an image of the contact graph.</p> <p>The dot(1) tool from the Graphviz package is used to generate the contact graph images and is required for cgrfetch(1). The base64(1) tool from coreutils is used to embed the images in the JSON and is also required.</p> <p>Note that a trace of the route computation logic performed by CGR is printed to stderr; there is currently no cgrfetch option for redirecting this output to a file.</p>"},{"location":"man/bpv7/cgrfetch/#options","title":"OPTIONS","text":"<ul> <li> <p>DEST-NODE</p> <p>The final destination to route to. To be useful, it should be a node that exists in the contact plan.</p> </li> <li> <p>-q</p> <p>Disable trace message output.</p> </li> <li> <p>-j</p> <p>Disable JSON output.</p> </li> <li> <p>-m</p> <p>Use a minimum-latency extended COS for the bundle. This ends up sending the bundle to all proximate nodes.</p> </li> <li> <p>-t DISPATCH-OFFSET</p> <p>Request a dispatch time of DISPATCH-OFFSET seconds from the time the command is run (default: 0).</p> </li> <li> <p>-e EXPIRATION-OFFSET</p> <p>Set the bundle expiration time to EXPIRATION-OFFSET seconds from the time the command is run (default: 3600).</p> </li> <li> <p>-s BUNDLE-SIZE</p> <p>Set the bundle payload size to BUNDLE-SIZE bytes (default: 0).</p> </li> <li> <p>-o OUTPUT-FILE</p> <p>Send JSON to OUTPUT-FILE (default: stdout).</p> </li> <li> <p>-d PROTO:NAME</p> <p>Use PROTO as the outduct protocol and NAME as the outduct name (default: udp:*). Use list to list all available outducts.</p> </li> </ul>"},{"location":"man/bpv7/cgrfetch/#examples","title":"EXAMPLES","text":"<ul> <li> <p>cgrfetch 8</p> <p>Simulate CGR with destination node 8 and dispatch time equal to the current time.</p> </li> <li> <p>cgrfetch 8 -t 60</p> <p>Do the same with a dispatch time 60 seconds in the future.</p> </li> <li> <p>cgrfetch -d list</p> <p>List all available outducts.</p> </li> </ul>"},{"location":"man/bpv7/cgrfetch/#see-also","title":"SEE ALSO","text":"<p>dot(1), base64(1)</p>"},{"location":"man/bpv7/dccpcli/","title":"NAME","text":"<p>dccpcli - DCCP-based BP convergence layer input task</p>"},{"location":"man/bpv7/dccpcli/#synopsis","title":"SYNOPSIS","text":"<p>dccpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv7/dccpcli/#description","title":"DESCRIPTION","text":"<p>dccpcli is a background \"daemon\" task that receives DCCP datagrams via a DCCP socket bound to local_hostname and local_port_nbr, extracts bundles from those datagrams, and passes them to the bundle protocol agent on the local ION node.</p> <p>If not specified, port number defaults to 4556.</p> <p>Note that dccpcli has no fragmentation support at all. Therefore, the largest bundle that can be sent via this convergence layer is limited to just under the link's MTU (typically 1500 bytes).</p> <p>The convergence layer input task is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"dccp\" convergence layer protocol is added to the BP database.  The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  dccpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DCCP convergence layer protocol.</p>"},{"location":"man/bpv7/dccpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dccpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dccpcli.</p> </li> <li> <p>\"1\"</p> <p>dccpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dccpcli.</p> </li> </ul>"},{"location":"man/bpv7/dccpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/dccpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dccpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dccpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such dccp duct.</p> <p>No DCCP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the DCCP convergence-layer protocol, add the induct, and then restart the DCCP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of dccpcli.</p> </li> <li> <p>dccpcli can't get IP address for host.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> <li> <p>CLI can't open DCCP socket. This probably means DCCP is not supported on your system.</p> <p>Operating system error. This probably means that you are not using an operating system that supports DCCP. Make sure that you are using a current Linux kernel and that the DCCP modules are being compiled. Check errtext,  correct problem, and restart dccpcli.</p> </li> <li> <p>CLI can't initialize socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> <li> <p>dccpcli can't get acquisition work area.</p> <p>ION system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> <li> <p>dccpcli can't create new thread.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpcli.</p> </li> </ul>"},{"location":"man/bpv7/dccpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dccpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), dccpclo(1)</p>"},{"location":"man/bpv7/dccpclo/","title":"NAME","text":"<p>dccpclo - DCCP-based BP convergence layer output task</p>"},{"location":"man/bpv7/dccpclo/#synopsis","title":"SYNOPSIS","text":"<p>dccpclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv7/dccpclo/#description","title":"DESCRIPTION","text":"<p>dccpclo is a background \"daemon\" task that connects to a remote node's DCCP socket at remote_hostname and remote_port_nbr. It then begins extracting bundles from the queues of bundles ready for transmission via DCCP to this remote bundle protocol agent and transmitting those bundles as DCCP datagrams to the remote host.</p> <p>If not specified, remote_port_nbr defaults to 4556.</p> <p>Note that dccpclo has no fragmentation support at all. Therefore, the largest bundle that can be sent via this convergence layer is limited to just under the link's MTU (typically 1500 bytes).</p> <p>dccpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dccpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DCCP convergence layer protocol.</p>"},{"location":"man/bpv7/dccpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dccpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dccpclo.</p> </li> <li> <p>\"1\"</p> <p>dccpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dccpclo.</p> </li> </ul>"},{"location":"man/bpv7/dccpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/dccpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dccpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dccpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No memory for DCCP buffer in dccpclo.</p> <p>ION system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>No such dccp duct.</p> <p>No DCCP outduct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the DCCP convergence-layer protocol, add the outduct, and then restart dccpclo.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of dccpclo.</p> </li> <li> <p>dccpclo can't get IP address for host.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>dccpclo can't create thread.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>CLO can't open DCCP socket. This probably means DCCP is not supported on your system.</p> <p>Operating system error. This probably means that you are not using an operating system that supports DCCP. Make sure that you are using a current Linux kernel and that the DCCP modules are being compiled. Check errtext,  correct problem, and restart dccpclo.</p> </li> <li> <p>CLO can't initialize socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>CLO send() error on socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccpclo.</p> </li> <li> <p>Bundle is too big for DCCP CLO.</p> <p>Configuration error: bundles that are too large for DCCP transmission (i.e., larger than the MTU of the link or 65535 bytes--whichever is smaller) are being enqueued for dccpclo.  Change routing or use smaller bundles.</p> </li> </ul>"},{"location":"man/bpv7/dccpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dccpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), dccpcli(1)</p>"},{"location":"man/bpv7/dgrcli/","title":"NAME","text":"<p>dgrcli - DGR-based BP convergence layer reception task</p>"},{"location":"man/bpv7/dgrcli/#synopsis","title":"SYNOPSIS","text":"<p>dgrcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv7/dgrcli/#description","title":"DESCRIPTION","text":"<p>dgrcli is a background \"daemon\" task that handles DGR convergence layer protocol input.</p> <p>The daemon receives DGR messages via a UDP socket bound to local_hostname and local_port_nbr, extracts bundles from those messages, and passes them to the bundle protocol agent on the local ION node. (local_port_nbr defaults to 1113 if not specified.)</p> <p>dgrcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dgrcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DGR convergence layer protocol.</p>"},{"location":"man/bpv7/dgrcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dgrcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dgrcli.</p> </li> <li> <p>\"1\"</p> <p>dgrcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dgrcli.</p> </li> </ul>"},{"location":"man/bpv7/dgrcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/dgrcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dgrcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dgrcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such dgr induct.</p> <p>No DGR induct with duct name matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the DGR convergence-layer protocol, add the induct, and then restart the DGR protocol.</p> </li> <li> <p>CLI task is already started for this engine.</p> <p>Redundant initiation of dgrcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> <li> <p>dgrcli can't open DGR service access point.</p> <p>DGR system error.  Check prior messages in ion.log log file, correct problem, and then stop and restart the DGR protocol.</p> </li> <li> <p>dgrcli can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> </ul>"},{"location":"man/bpv7/dgrcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dgrcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv7/dgrclo/","title":"NAME","text":"<p>dgrclo - DGR-based BP convergence layer transmission task</p>"},{"location":"man/bpv7/dgrclo/#synopsis","title":"SYNOPSIS","text":"<p>dgrclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv7/dgrclo/#description","title":"DESCRIPTION","text":"<p>dgrclo is a background \"daemon\" task that spawns two threads, one that handles DGR convergence layer protocol input (positive and negative acknowledgments) and a second that handles DGR convergence layer protocol output.</p> <p>The output thread extracts bundles from the queues of bundles ready for transmission via DGR to a remote bundle protocol agent, encapsulates them in DGR messages, and uses a randomly configured local UDP socket to send those messages to the remote UDP socket bound to remote_hostname and remote_port_nbr.  (local_port_nbr defaults to 1113 if not specified.)</p> <p>The input thread receives DGR messages via the same local UDP socket and uses them to manage DGR retransmission of transmitted datagrams.</p> <p>dgrclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dgrclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the DGR convergence layer protocol.</p>"},{"location":"man/bpv7/dgrclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dgrclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dgrclo.</p> </li> <li> <p>\"1\"</p> <p>dgrclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart dgrclo.</p> </li> </ul>"},{"location":"man/bpv7/dgrclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/dgrclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dgrclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dgrclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>CLI task is already started for this engine.</p> <p>Redundant initiation of dgrclo.</p> </li> <li> <p>No such dgr outduct.</p> <p>No DGR outduct with duct name matching remote_hostname and remote_port_nbr has been added to the BP database.  Use bpadmin to stop the DGR convergence-layer protocol, add the outduct, and then restart the DGR protocol.</p> </li> <li> <p>dgrclo can't open DGR service access point.</p> <p>DGR system error.  Check prior messages in ion.log log file, correct problem, and then stop and restart the DGR protocol.</p> </li> <li> <p>dgrclo can't create sender thread</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> <li> <p>dgrclo can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart DGR.</p> </li> </ul>"},{"location":"man/bpv7/dgrclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dgrclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv7/dtn2admin/","title":"NAME","text":"<p>dtn2admin - baseline \"dtn\" scheme administration interface</p>"},{"location":"man/bpv7/dtn2admin/#synopsis","title":"SYNOPSIS","text":"<p>dtn2admin [ commands_filename ]</p>"},{"location":"man/bpv7/dtn2admin/#description","title":"DESCRIPTION","text":"<p>dtn2admin configures the local ION node's routing of bundles to endpoints whose IDs conform to the dtn endpoint ID scheme.  Endpoint IDs in the dtn scheme are strings of the form \"dtn://node_name/[[~]demux_token]\", where node_name identifies a BP node (often this is the DNS name of the computer on which the node resides) and demux_token normally identifies a specific application processing point.  When and only when the terminating demux string (everything after the final '/') does NOT begin with '~', the endpoint ID identifies a singleton endpoint; when the terminating demux string is omitted, the endpoint ID constitutes a node ID.  Although the dtn endpoint ID scheme imposes more transmission overhead than the ipn scheme, ION provides support for dtn endpoint IDs to enable interoperation with other implementations of Bundle Protocol.</p> <p>dtn2admin operates in response to \"dtn\" scheme configuration commands found in the file commands_filename, if provided; if not, dtn2admin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from dtn2admin with the 'h' or '?' commands at the prompt.  The commands are documented in dtn2rc(5).</p>"},{"location":"man/bpv7/dtn2admin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of \"dtn\" scheme administration.</li> <li>\"1\" Unsuccessful completion of \"dtn\" scheme administration, due to inability to attach to the Bundle Protocol system or to initialize the \"dtn\" scheme.</li> </ul>"},{"location":"man/bpv7/dtn2admin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>dtn2admin</p> <p>Enter interactive \"dtn\" scheme configuration command entry mode.</p> </li> <li> <p>dtn2admin host1.dtn2rc</p> <p>Execute all configuration commands in host1.dtn2rc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv7/dtn2admin/#files","title":"FILES","text":"<p>See dtn2rc(5) for details of the DTN scheme configuration commands.</p>"},{"location":"man/bpv7/dtn2admin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dtn2admin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the dtn2rc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to dtn2admin.  Otherwise dtn2admin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>dtn2admin can't attach to BP.</p> <p>Bundle Protocol has not been initialized on this computer.  You need to run bpadmin(1) first.</p> </li> <li> <p>dtn2admin can't initialize routing database.</p> <p>There is no SDR data store for dtn2admin to use.  Please run ionadmin(1) to start the local ION node.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause dtn2admin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see dtn2rc(5) for details.</p>"},{"location":"man/bpv7/dtn2admin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dtn2admin/#see-also","title":"SEE ALSO","text":"<p>dtn2rc(5)</p>"},{"location":"man/bpv7/dtn2adminep/","title":"NAME","text":"<p>dtn2adminep - administrative endpoint task for the \"dtn\" scheme</p>"},{"location":"man/bpv7/dtn2adminep/#synopsis","title":"SYNOPSIS","text":"<p>dtn2adminep</p>"},{"location":"man/bpv7/dtn2adminep/#description","title":"DESCRIPTION","text":"<p>dtn2adminep is a background \"daemon\" task that receives and processes administrative bundles (minimally, all bundle status reports) that are sent to the \"dtn\"-scheme administrative endpoint on the local ION node, if and only if such an endpoint was established by bpadmin.  It is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dtn2adminep can also be spawned and terminated in response to START and STOP commands that pertain specifically to the \"dtn\" scheme.</p> <p>dtn2adminep responds to bundle status reports by logging ASCII text messages describing the reported activity.</p>"},{"location":"man/bpv7/dtn2adminep/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dtn2adminep terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dtn2adminep.</p> </li> <li> <p>\"1\"</p> <p>dtn2adminep was unable to attach to Bundle Protocol operations or was unable to load the \"dtn\" scheme database, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv7/dtn2adminep/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/dtn2adminep/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dtn2adminep/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dtn2adminep can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>dtn2adminep can't load routing database.</p> <p>dtn2admin has not yet initialized the \"dtn\" scheme.</p> </li> <li> <p>dtn2adminep can't get admin EID.</p> <p>dtn2admin has not yet initialized the \"dtn\" scheme.</p> </li> <li> <p>dtn2adminep crashed.</p> <p>An unrecoverable database error was encountered.  dtn2adminep terminates.</p> </li> </ul>"},{"location":"man/bpv7/dtn2adminep/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dtn2adminep/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), dtn2admin(1).</p>"},{"location":"man/bpv7/dtn2fw/","title":"NAME","text":"<p>dtn2fw - bundle route computation task for the \"dtn\" scheme</p>"},{"location":"man/bpv7/dtn2fw/#synopsis","title":"SYNOPSIS","text":"<p>dtn2fw</p>"},{"location":"man/bpv7/dtn2fw/#description","title":"DESCRIPTION","text":"<p>dtn2fw is a background \"daemon\" task that pops bundles from the queue of bundle destined for \"dtn\"-scheme endpoints, computes proximate destinations for those bundles, and appends those bundles to the appropriate queues of bundles pending transmission to those computed proximate destinations.</p> <p>For each possible proximate destination (that is, neighboring node) there is a separate queue for each possible level of bundle priority: 0, 1, 2.  Each outbound bundle is appended to the queue matching the bundle's designated priority.</p> <p>Proximate destination computation is affected by static routes as configured by dtn2admin(1).</p> <p>dtn2fw is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  dtn2fw can also be spawned and terminated in response to START and STOP commands that pertain specifically to the \"dtn\" scheme.</p>"},{"location":"man/bpv7/dtn2fw/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dtn2fw terminated, for reasons noted in the ion.log log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart dtn2fw.</p> </li> <li> <p>\"1\"</p> <p>dtn2fw could not commence operations, for reasons noted in the ion.log log file.  Investigate and solve the problem identified in the log file, then use bpadmin to restart dtn2fw.</p> </li> </ul>"},{"location":"man/bpv7/dtn2fw/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/dtn2fw/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/dtn2fw/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dtn2fw can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>dtn2fw can't load routing database.</p> <p>dtn2admin has not yet initialized the \"dtn\" scheme.</p> </li> <li> <p>Can't create lists for route computation.</p> <p>An unrecoverable database error was encountered.  dtn2fw terminates.</p> </li> <li> <p>'dtn' scheme is unknown.</p> <p>The \"dtn\" scheme was not added when bpadmin initialized BP operations.  Use bpadmin to add and start the scheme.</p> </li> <li> <p>Can't take forwarder semaphore.</p> <p>ION system error.  dtn2fw terminates.</p> </li> <li> <p>Can't enqueue bundle.</p> <p>An unrecoverable database error was encountered.  dtn2fw terminates.</p> </li> </ul>"},{"location":"man/bpv7/dtn2fw/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/dtn2fw/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), dtn2admin(1), bprc(5), dtn2rc(5).</p>"},{"location":"man/bpv7/dtn2rc/","title":"NAME","text":"<p>dtn2rc - \"dtn\" scheme configuration commands file</p>"},{"location":"man/bpv7/dtn2rc/#description","title":"DESCRIPTION","text":"<p>\"dtn\" scheme configuration commands are passed to dtn2admin either in a file of text lines or interactively at dtn2admin's command prompt (:). Commands are interpreted line-by line, with exactly one command per line.</p> <p>\"dtn\" scheme configuration commands establish static routing rules for forwarding bundles to nodes identified by \"dtn\"-scheme destination endpoints.</p> <p>Static routes are expressed as plans in the \"dtn\"-scheme routing database. A plan that is established for a given node name associates a routing directive with the named node.  Each directive is a string of one of two possible forms:</p> <p>f endpoint_ID</p> <p>...or...</p> <p>x protocol_name/outduct_name</p> <p>The former form signifies that the bundle is to be forwarded to the indicated endpoint, requiring that it be re-queued for processing by the forwarder for that endpoint (which might, but need not, be identified by another \"dtn\"-scheme endpoint ID).  The latter form signifies that the bundle is to be queued for transmission via the indicated convergence layer protocol outduct.</p> <p>The node names cited in dtn2rc plans may be \"wild-carded\".  That is, when the last character of a plan's node name is either '*' or '~' (these two wild-card characters are equivalent for this purpose), the plan applies to all nodes whose names are identical to the wild-carded node name up to the wild-card character.  For example, a bundle whose destination EID is \"dtn://foghorn/x\" would be routed by plans citing the following node names: \"foghorn\", \"fogh*\", \"fog~\", \"*\".  When multiple plans are all applicable to the same destination EID, the one citing the longest (i.e., most narrowly targeted) node name will be applied.</p> <p>The formats and effects of the DTN scheme configuration commands are described below.</p>"},{"location":"man/bpv7/dtn2rc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by dtn2admin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv7/dtn2rc/#plan-commands","title":"PLAN COMMANDS","text":"<ul> <li> <p>a plan node_name directive [nominal_xmit_rate]</p> <p>The add plan command.  This command establishes a static route for the bundles destined for the node(s) identified by node_nameID.  The nominal_xmit_rate is the assumed rate of transmission to this node in the absence of contact plan information.  A nominal_data_rate of zero (the default) in the absence of contact plan information completely disables rate control.</p> <p>Note that the plan commands consumed by dtn2admin are a simplified shortcut for submitting plan commands as consumed by bpadmin (see bprc(5)). The syntax of these commands is DIFFERENT from that of the more general and more powerful bpadmin commands.</p> </li> <li> <p>c plan node_nameID [f endpoint_ID] [nominal_xmit_rate]</p> <p>The change plan command.  This command revises the \"via node\" and/or nominal_data_rate of the static route for the node(s) identified by node_nameID.  To detach an outduct from the plan, use the \"planduct\" deletion command processed by bpadmin.</p> </li> <li> <p>d plan node_nameID</p> <p>The delete plan command.  This command deletes the static route for the node(s) identified by node_nameID.</p> </li> <li> <p>i plan node_nameID</p> <p>This command will print information about the static route for the node(s) identified by node_nameID.</p> </li> <li> <p>l plan</p> <p>This command lists all static routes established in the DTN database for the local node.</p> </li> </ul>"},{"location":"man/bpv7/dtn2rc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a plan bbn2 f ipn:8.41</p> <p>Declares a static route from the local node to node \"bbn2\".  Any bundle destined for any endpoint whose node name is \"bbn2\" will be forwarded to endpoint \"ipn:8.41\".</p> </li> <li> <p>a plan mitre* x ltp/6</p> <p>Declares a static route from the local node to any node whose node name begins with \"mitre\".  Any bundle destined for any endpoint whose node name begins with \"mitre1\" will be queued for transmission on LTP outduct 6.</p> </li> </ul>"},{"location":"man/bpv7/dtn2rc/#see-also","title":"SEE ALSO","text":"<p>dtn2admin(1)</p>"},{"location":"man/bpv7/hmackeys/","title":"NAME","text":"<p>hmackeys - utility program for generating good HMAC-SHA1 keys</p>"},{"location":"man/bpv7/hmackeys/#synopsis","title":"SYNOPSIS","text":"<p>hmackeys [ keynames_filename ]</p>"},{"location":"man/bpv7/hmackeys/#description","title":"DESCRIPTION","text":"<p>hmackeys writes files containing randomized 160-bit key values suitable for use by HMAC-SHA1 in support of Bundle Authentication Block processing, Bundle Relay Service connections, or other functions for which symmetric hash computation is applicable.  One file is written for each key name presented to hmackeys; the content of each file is 20 consecutive randomly selected 8-bit integer values, and the name given to each file is simply \"keyname.hmk\".</p> <p>hmackeys operates in response to the key names found in the file keynames_filename, one name per file text line, if provided; if not, hmackeys prints a simple prompt (:) so that the user may type key names directly into standard input.</p> <p>When the program is run in interactive mode, either enter 'q' or press ^C to terminate.</p>"},{"location":"man/bpv7/hmackeys/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Completion of key generation.</li> </ul>"},{"location":"man/bpv7/hmackeys/#examples","title":"EXAMPLES","text":"<ul> <li> <p>hmackeys</p> <p>Enter interactive HMAC/SHA1 key generation mode.</p> </li> <li> <p>hmackeys host1.keynames</p> <p>Create a key file for each key name in host1.keynames, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv7/hmackeys/#files","title":"FILES","text":"<p>No other files are used in the operation of hmackeys.</p>"},{"location":"man/bpv7/hmackeys/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/hmackeys/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>Can't open keynames file...</p> <p>The keynames_filename specified in the command line doesn't exist.</p> </li> </ul>"},{"location":"man/bpv7/hmackeys/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/hmackeys/#see-also","title":"SEE ALSO","text":"<p>brsscla(1), ionsecadmin(1)</p>"},{"location":"man/bpv7/imcadminep/","title":"NAME","text":"<p>imcadminep - administrative endpoint task for the IMC (multicast) scheme</p>"},{"location":"man/bpv7/imcadminep/#synopsis","title":"SYNOPSIS","text":"<p>imcadminep</p>"},{"location":"man/bpv7/imcadminep/#description","title":"DESCRIPTION","text":"<p>imcadminep is a background \"daemon\" task that receives and processes administrative bundles (multicast group petitions) that are sent to the IMC-scheme administrative endpoint on the local ION node, if and only if such an endpoint was established by bpadmin.  It is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command. imcadminep can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IMC scheme.</p> <p>imcadminep responds to multicast group \"join\" and \"leave\" petitions by managing entries in the node's database of multicast groups and their members.</p>"},{"location":"man/bpv7/imcadminep/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>imcadminep terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart imcadminep.</p> </li> <li> <p>\"1\"</p> <p>imcadminep was unable to attach to Bundle Protocol operations or was unable to load the IMC scheme database, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv7/imcadminep/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/imcadminep/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/imcadminep/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>imcadminep can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>imcadminep can't load routing database.</p> <p>imcadmin has not yet initialized the IMC scheme.</p> </li> <li> <p>imcadminep crashed.</p> <p>An unrecoverable database error was encountered.  imcadminep terminates.</p> </li> </ul>"},{"location":"man/bpv7/imcadminep/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/imcadminep/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv7/imcfw/","title":"NAME","text":"<p>imcfw - bundle route computation task for the IMC scheme</p>"},{"location":"man/bpv7/imcfw/#synopsis","title":"SYNOPSIS","text":"<p>imcfw</p>"},{"location":"man/bpv7/imcfw/#description","title":"DESCRIPTION","text":"<p>imcfw is a background \"daemon\" task that pops bundles from the queue of bundle destined for IMC-scheme (Interplanetary Multicast) endpoints, determines which \"relatives\" on the IMC multicast tree to forward the bundles to, and appends those bundles to the appropriate queues of bundles pending transmission to those proximate destinations.</p> <p>For each possible proximate destination (that is, neighboring node) there is a separate queue for each possible level of bundle priority: 0, 1, 2.  Each outbound bundle is appended to the queue matching the bundle's designated priority.</p> <p>Proximate destination computation is determined by multicast group membership as resulting from nodes' registration in multicast endpoints (accomplished simply by adding the appropriate endpoint as discussed in bprc(5).</p> <p>imcfw is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  imcfw can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IMC scheme.</p>"},{"location":"man/bpv7/imcfw/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>imcfw terminated, for reasons noted in the ion.log log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart imcfw.</p> </li> <li> <p>\"1\"</p> <p>imcfw could not commence operations, for reasons noted in the ion.log log file.  Investigate and solve the problem identified in the log file, then use bpadmin to restart imcfw.</p> </li> </ul>"},{"location":"man/bpv7/imcfw/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/imcfw/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/imcfw/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>imcfw can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>imcfw can't load routing database.</p> <p>ipnadmin has not yet initialized the IPN scheme.</p> </li> <li> <p>Can't create lists for route computation.</p> <p>An unrecoverable database error was encountered.  imcfw terminates.</p> </li> <li> <p>'imc' scheme is unknown.</p> <p>The IMC scheme was not added when bpadmin initialized BP operations.  Use bpadmin to add and start the scheme.</p> </li> <li> <p>Can't take forwarder semaphore.</p> <p>ION system error.  imcfw terminates.</p> </li> <li> <p>Can't exclude sender from routes.</p> <p>An unrecoverable database error was encountered.  imcfw terminates.</p> </li> <li> <p>Can't enqueue bundle.</p> <p>An unrecoverable database error was encountered.  imcfw terminates.</p> </li> </ul>"},{"location":"man/bpv7/imcfw/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/imcfw/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv7/ipnadmin/","title":"NAME","text":"<p>ipnadmin - Interplanetary Internet (IPN) scheme administration interface</p>"},{"location":"man/bpv7/ipnadmin/#synopsis","title":"SYNOPSIS","text":"<p>ipnadmin [ commands_filename ]</p>"},{"location":"man/bpv7/ipnadmin/#description","title":"DESCRIPTION","text":"<p>ipnadmin configures the local ION node's routing of bundles to endpoints whose IDs conform to the ipn endpoint ID scheme.  Every endpoint ID in the ipn scheme is a string of the form \"ipn:node_number.service_number\" where node_number is a CBHE \"node number\" and service_number identifies a specific application processing point.  When service_number is zero, the endpoint ID constitutes a node ID.  All endpoint IDs formed in the ipn scheme identify singleton endpoints.</p> <p>ipnadmin operates in response to IPN scheme configuration commands found in the file commands_filename, if provided; if not, ipnadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from ipnadmin with the 'h' or '?' commands at the prompt.  The commands are documented in ipnrc(5).</p>"},{"location":"man/bpv7/ipnadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of IPN scheme administration.</li> <li>\"1\" Unsuccessful completion of IPN scheme administration, due to inability to attach to the Bundle Protocol system or to initialize the IPN scheme.</li> </ul>"},{"location":"man/bpv7/ipnadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>ipnadmin</p> <p>Enter interactive IPN scheme configuration command entry mode.</p> </li> <li> <p>ipnadmin host1.ipnrc</p> <p>Execute all configuration commands in host1.ipnrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/bpv7/ipnadmin/#files","title":"FILES","text":"<p>See ipnrc(5) for details of the IPN scheme configuration commands.</p>"},{"location":"man/bpv7/ipnadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/ipnadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ipnrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to ipnadmin.  Otherwise ipnadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>ipnadmin can't attach to BP.</p> <p>Bundle Protocol has not been initialized on this computer.  You need to run bpadmin(1) first.</p> </li> <li> <p>ipnadmin can't initialize routing database.</p> <p>There is no SDR data store for ipnadmin to use.  Please run ionadmin(1) to start the local ION node.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause ipnadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see ipnrc(5) for details.</p>"},{"location":"man/bpv7/ipnadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/ipnadmin/#see-also","title":"SEE ALSO","text":"<p>ipnrc(5)</p>"},{"location":"man/bpv7/ipnadminep/","title":"NAME","text":"<p>ipnadminep - administrative endpoint task for the IPN scheme</p>"},{"location":"man/bpv7/ipnadminep/#synopsis","title":"SYNOPSIS","text":"<p>ipnadminep</p>"},{"location":"man/bpv7/ipnadminep/#description","title":"DESCRIPTION","text":"<p>ipnadminep is a background \"daemon\" task that receives and processes administrative bundles (nominally, all bundle status reports) that are sent to the IPN-scheme administrative endpoint on the local ION node, if and only if such an endpoint was established by bpadmin.  It is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  ipnadminep can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IPN scheme.</p> <p>ipnadminep responds to bundle status reports by logging ASCII text messages describing the reported activity.</p>"},{"location":"man/bpv7/ipnadminep/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ipnadminep terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart ipnadminep.</p> </li> <li> <p>\"1\"</p> <p>ipnadminep was unable to attach to Bundle Protocol operations or was unable to load the IPN scheme database, probably because bpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bpv7/ipnadminep/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/ipnadminep/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/ipnadminep/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ipnadminep can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>ipnadminep can't load routing database.</p> <p>ipnadmin has not yet initialized the IPN scheme.</p> </li> <li> <p>ipnadminep crashed.</p> <p>An unrecoverable database error was encountered.  ipnadminep terminates.</p> </li> </ul>"},{"location":"man/bpv7/ipnadminep/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/ipnadminep/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), ipnadmin(1), bprc(5)</p>"},{"location":"man/bpv7/ipnd/","title":"NAME","text":"<p>ipnd - ION IPND module</p>"},{"location":"man/bpv7/ipnd/#description","title":"DESCRIPTION","text":"<p>The ipnd daemon is the ION implementation of DTN IP Neighbor Discovery. This module allows the node to send and receive beacon messages using  unicast, multicast or broadcast IP addresses. Beacons are used for the discovery of neighbors and may be used to advertise services that are  present and available on nodes, such as routing algorithms or CLAs.</p> <p>ION IPND module is configured using a *.rc configuration file.  The name of the configuration file must be passed as the sole command-line argument to ipnd when the daemon is started.  Commands are interpreted line by line, with exactly one command per line.  The formats and effects of the ION ipnd management commands are described below.</p>"},{"location":"man/bpv7/ipnd/#usage","title":"USAGE","text":"<p>ipnd config_file_name</p>"},{"location":"man/bpv7/ipnd/#commands","title":"COMMANDS","text":"<ul> <li> <p>1 </p> <p>The initialize command.  This must be the first command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ipnd to be logged into ion.log.  Setting echo to 0 disables this behavior. Default is 1.</p> </li> <li> <p>m eid eid</p> <p>Local eid. This command sets the advertised BP endpoint ID by which the node will identify itself in beacon messages.</p> </li> <li> <p>m announce period { 1 | 0 }</p> <p>Announce period control. Setting to 1 causes all beacons messages sent to contain beacon period. Setting to 0 disables this behavior. Default is 1.</p> </li> <li> <p>m announce eid { 1 | 0 }</p> <p>Announce eid control. Setting to 1 causes all beacons messages sent to contain source eid. Setting to 0 disables this behavior. This should be  always set to 1. Default is 1.</p> </li> <li> <p>m interval unicast interval</p> <p>Unicast interval. This command sets the beacon messages period on unicast  transmissions. Time interval is expressed in seconds. Default is 5.</p> </li> <li> <p>m interval multicast interval</p> <p>Multicast interval. This command sets the beacon messages period on multicast  transmissions. Time interval is expressed in seconds. Default is 7.</p> </li> <li> <p>m interval broadcast interval</p> <p>Broadcastcast interval. This command sets the beacon messages period on broadcast transmissions. Time interval is expressed in seconds. Default is 11.</p> </li> <li> <p>m multicast ttl ttl</p> <p>Multicast ttl. This command sets the multicast outgoing beacon messages' time to live, in seconds. Default is 255.</p> </li> <li> <p>m svcdef id name child_name:child_type ...</p> <p>Service definition. This command specifies definitions of \"services\", which are dynamically defined beacon message data structures indicating the capabilities of the beacon message sender.  id is a service-identifying number in the range 128-255. name is the name of the service type that is being defined. The definition of the structure of the service is a sequence of elements, each of which is a name:type pair.  Each child_type must be the name of a standard or previously defined service type.  Infinite recursion is supported.</p> </li> <li> <p>a svcadv name child_name:child_value ...</p> <p>Service advertising command. This command defines which services will  be advertised and with which values. All types of formats for values  are supported (e.g. 999, 0345 (octal), 0x999 (hex), -1e-9, 0.32, etc.). For a service that contains only a single element, it is not necessary to provide that element's name.  E.g. it is enough to write Booleans:true instead of Booleans:BooleanValues:B:true, as BooleanValues is the only child of Booleans and B is the only child of BooleanValues.</p> </li> <li> <p>a listen IP_address</p> <p>Listen socket specification command. This command asserts, in the form IP_address, the IP address of the socket at which the IPND daemon is to listen for incoming beacons; a default port number is used. The address can be an unicast, a multicast or a broadcast address. If a multicast address is provided all the configured unicast addresses will listen for multicast packets  in that group. If a broadcast address is provided all the unicast  addresses will listen for broadcasted packets.</p> </li> <li> <p>a destination destination_socket_spec</p> <p>Destination socket specification command. This command asserts the specification for a socket to which the IPND daemon is to send beacons. It can be an unicast, a multicast or a broadcast address.</p> </li> <li> <p>s</p> <p>The start command.  This command starts the IPND daemon for the local ION node.</p> </li> </ul>"},{"location":"man/bpv7/ipnd/#examples","title":"EXAMPLES","text":"<p>m scvdef 128 FooRouter Seed:SeedVal BaseWeight:WeightVal RootHash:bytes</p> <p>Defines a new service called FooRouter comprising 3 elements. SeedVal  and WeightVal are user defined services that must be already defined.</p> <p>m svcdef 129 SeedVal   Value:fixed16</p> <p>m svcdef 130 WeightVal Value:fixed16</p> <p>m svcdef 128 FooRouter Seed:SeedVal BaseWeight:WeightVal RootHash:bytes</p> <p>m svcdef 150 FixedValuesList F16:fixed16 F32:fixed32 F64:fixed64</p> <p>m svcdef 131 VariableValuesList U64:uint64 S64:sint64</p> <p>m svcdef 132 BooleanValues B:boolean</p> <p>m svcdef 133 FloatValuesList F:float D:double</p> <p>m svcdef 135 IntegersList FixedValues:FixedValuesList VariableValues:VariableValuesList</p> <p>m svcdef 136 NumbersList Integers:IntegersList Floats:FloatValuesList</p> <p>m svcdef 140 HugeService CLAv4:CLA-TCP-v4 Booleans:BooleanValues Numbers:NumbersList FR:FooRouter</p> <p>a svcadv HugeService CLAv4:IP:10.1.0.10 CLAv4:Port:4444 Booleans:true FR:Seed:0x5432 FR:BaseWeight:13 FR:RootHash:BEEF Numbers:Integers:FixedValues:F16:0x16 Numbers:Integers:FixedValues:F32:0x32 Numbers:Integers:FixedValues:F64:0x1234567890ABCDEF Numbers:Floats:F:0.32 Numbers:Floats:D:-1e-6 Numbers:Integers:VariableValues:U64:18446744073704783380 Numbers:Integers:VariableValues:S64:-4611686018422619668</p> <p>This shows how to define multiple nested services and how to advertise them.</p>"},{"location":"man/bpv7/ipnd/#see-also","title":"SEE ALSO","text":"<p>ion(3)</p>"},{"location":"man/bpv7/ipnfw/","title":"NAME","text":"<p>ipnfw - bundle route computation task for the IPN scheme</p>"},{"location":"man/bpv7/ipnfw/#synopsis","title":"SYNOPSIS","text":"<p>ipnfw</p>"},{"location":"man/bpv7/ipnfw/#description","title":"DESCRIPTION","text":"<p>ipnfw is a background \"daemon\" task that pops bundles from the queue of bundle destined for IPN-scheme endpoints, computes proximate destinations for those bundles, and appends those bundles to the appropriate queues of bundles pending transmission to those computed proximate destinations.</p> <p>For each possible proximate destination (that is, neighboring node) there is a separate queue for each possible level of bundle priority: 0, 1, 2.  Each outbound bundle is appended to the queue matching the bundle's designated priority.</p> <p>Proximate destination computation is affected by static and default routes as configured by ipnadmin(1) and by contact graphs as managed by ionadmin(1) and rfxclock(1).</p> <p>ipnfw is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of Bundle Protocol on the local ION node, and it is terminated by bpadmin in response to an 'x' (STOP) command.  ipnfw can also be spawned and terminated in response to START and STOP commands that pertain specifically to the IPN scheme.</p>"},{"location":"man/bpv7/ipnfw/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ipnfw terminated, for reasons noted in the ion.log log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart ipnfw.</p> </li> <li> <p>\"1\"</p> <p>ipnfw could not commence operations, for reasons noted in the ion.log log file.  Investigate and solve the problem identified in the log file, then use bpadmin to restart ipnfw.</p> </li> </ul>"},{"location":"man/bpv7/ipnfw/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/ipnfw/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/ipnfw/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ipnfw can't attach to BP.</p> <p>bpadmin has not yet initialized BP operations.</p> </li> <li> <p>ipnfw can't load routing database.</p> <p>ipnadmin has not yet initialized the IPN scheme.</p> </li> <li> <p>Can't create lists for route computation.</p> <p>An unrecoverable database error was encountered.  ipnfw terminates.</p> </li> <li> <p>'ipn' scheme is unknown.</p> <p>The IPN scheme was not added when bpadmin initialized BP operations.  Use bpadmin to add and start the scheme.</p> </li> <li> <p>Can't take forwarder semaphore.</p> <p>ION system error.  ipnfw terminates.</p> </li> <li> <p>Can't exclude sender from routes.</p> <p>An unrecoverable database error was encountered.  ipnfw terminates.</p> </li> <li> <p>Can't enqueue bundle.</p> <p>An unrecoverable database error was encountered.  ipnfw terminates.</p> </li> </ul>"},{"location":"man/bpv7/ipnfw/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/ipnfw/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), ipnadmin(1), bprc(5), ipnrc(5)</p>"},{"location":"man/bpv7/ipnrc/","title":"NAME","text":"<p>ipnrc - IPN scheme configuration commands file</p>"},{"location":"man/bpv7/ipnrc/#description","title":"DESCRIPTION","text":"<p>IPN scheme configuration commands are passed to ipnadmin either in a file of text lines or interactively at ipnadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.</p> <p>IPN scheme configuration commands (a) establish egress plans for direct transmission to neighboring nodes that are members of endpoints identified in the \"ipn\" URI scheme and (b) establish static default routing rules for forwarding bundles to specified destination nodes.</p> <p>The egress plan established for a given node associates a duct expression with that node.  Each duct expression is a string of the form \"protocol_name/outduct_name\" signifying that the bundle is to be queued for transmission via the indicated convergence layer protocol outduct.</p> <p>Note that egress plans must be established for all neighboring nodes, regardless of whether or not contact graph routing is used for computing dynamic routes to distant nodes.  This is by definition: if there isn't an egress plan to a node, it can't be considered a neighbor.</p> <p>Static default routes are declared as exits in the ipn-scheme routing database.  An exit is a range of node numbers identifying a set of nodes for which defined default routing behavior is established.  Whenever a bundle is to be forwarded to a node whose number is in the exit's node number range and it has not been possible to compute a dynamic route to that node from the contact schedules that have been provided to the local node and that node is not a neighbor to which the bundle can be directly transmitted, BP will forward the bundle to the gateway node associated with this exit.  The gateway node for any exit is identified by an endpoint ID, which might or might not be an ipn-scheme EID; regardless, directing a bundle to the gateway for an exit causes the bundle to be re-forwarded to that intermediate destination endpoint.  Multiple exits may encompass the same node number, in which case the gateway associated with the most restrictive exit (the one with the smallest range) is always selected.</p> <p>Note that \"exits\" were termed \"groups\" in earlier versions of ION.  The term \"exit\" has been adopted instead, to minimize any possible confusion with multicast groups.  To protect backward compatibility, the keyword \"group\" continues to be accepted by ipnadmin as an alias for the new keyword \"exit\", but the older terminology is deprecated.</p> <p>Routing and class-of-service overrides may also be managed:</p> <p>A routing override declares a neighboring node to which all bundles must be forwarded that meet specified criteria.  This override is strictly local, affecting only forwarding from the local node, and it is applied before any route computed by CGR or IRR is considered.</p> <p>A class-of-service override declares the class of service (priority and ordinal and [optionally] quality-of-service flags) that will condition - in terms of order and outduct selection - the forwarding of all bundles that meet specified criteria.  Again this override is strictly local, affecting only forwarding from the local node.</p> <p>The formats and effects of the IPN scheme configuration commands are described below.</p>"},{"location":"man/bpv7/ipnrc/#general-commands","title":"GENERAL COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ipnadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bpv7/ipnrc/#plan-commands","title":"PLAN COMMANDS","text":"<ul> <li> <p>a plan node_nbr duct_expression [nominal_data_rate]</p> <p>The add plan command.  This command establishes an egress plan for the bundles that must be transmitted to the neighboring node identified by node_nbr.  The nominal_data_rate is the assumed rate of transmission to this node in the absence of contact plan information. A nominal_data_rate of zero (the default) in the absence of contact plan information completely disables rate control.</p> <p>Note that the plan commands consumed by ipnadmin are a simplified shortcut for submitting plan commands as consumed by bpadmin (see bprc(5)). The syntax of these commands is DIFFERENT from that of the more general and more powerful bpadmin commands.</p> </li> <li> <p>c plan node_nbr nominal_data_rate</p> <p>The change plan command.  This command changes the nominal data rate for the indicated plan.</p> </li> <li> <p>d plan node_nbr</p> <p>The delete plan command.  This command deletes the egress plan for the node identified by node_nbr.</p> </li> <li> <p>i plan node_nbr</p> <p>This command will print information about the egress plan for the node identified by node_nbr.</p> </li> <li> <p>l plan</p> <p>This command lists all egress plans established in the IPN database for the local node.</p> </li> </ul>"},{"location":"man/bpv7/ipnrc/#exit-commands","title":"EXIT COMMANDS","text":"<ul> <li> <p>a exit first_node_nbr last_node_nbr gateway_endpoint_ID</p> <p>The add exit command.  This command establishes an \"exit\" for static  default routing as described above.</p> </li> <li> <p>c exit first_node_nbr last_node_nbr gateway_endpoint_ID</p> <p>The change exit command.  This command changes the gateway node number for the exit identified by first_node_nbr and last_node_nbr .</p> </li> <li> <p>d exit first_node_nbr last_node_nbr</p> <p>The delete exit command.  This command deletes the exit identified by first_node_nbr and last_node_nbr.</p> </li> <li> <p>i exit first_node_nbr last_node_nbr</p> <p>This command will print information (the gateway endpoint ID) about the exit identified by first_node_nbr and last_node_nbr.</p> </li> <li> <p>l exit</p> <p>This command lists all exits defined in the IPN database for the local node.</p> </li> </ul>"},{"location":"man/bpv7/ipnrc/#override-commands","title":"OVERRIDE COMMANDS","text":"<ul> <li> <p>a rtovrd data_label dest_node_nbr source_node_nbr neighbor</p> <p>The add rtovrd command.  This command cause bundles characterized by data_label, dest_node_nbr (\"all other destinations\" if this node number is zero) and source_node_nbr (\"all other sources\" if this node number is zero) to be forwarded to neighbor.  If neighbor is zero, the override will be \"learned\" by ION: the neighbor selected for this bundle, by whatever means, becomes the override for all subsequent matching bundles.</p> </li> <li> <p>c rtovrd data_label dest_node_nbr source_node_nbr neighbor</p> <p>The change rtovrd command.  This command changes the override neighbor for the override identified by data_label, dest_node_nbr, and source_node_nbr.  To cause ION to forget the override, use -1 as neighbor.</p> </li> <li> <p>a cosovrd data_label dest_node_nbr source_node_nbr priority ordinal [qos_flags]</p> <p>The add cosovrd command.  This command cause bundles characterized by data_label, dest_node_nbr (\"all other destinations\" if this node number is zero) and source_node_nbr (\"all other sources\" if this node number is zero) to have their effective class of service (priority and ordinal and, optionally, additional quality-of-service flags) changed as noted.</p> </li> <li> <p>c cosovrd data_label dest_node_nbr source_node_nbr priority ordinal [qos_flags]</p> <p>The change cosovrd command.  This command changes the effective class of service (priority and ordinal and, optionally, additional quality-of-service flags) for the override identified by data_label, dest_node_nbr, and source_node_nbr.  To cause ION to forget the override, use -1 as priority.</p> </li> <li> <p>d ovrd data_label dest_node_nbr source_node_nbr</p> <p>The delete override command.  This command deletes all overrides identified by data_label, dest_node_nbr, and source_node_nbr.</p> </li> <li> <p>i ovrd data_label dest_node_nbr source_node_nbr</p> <p>This command will print information for all overrides identified by data_label, dest_node_nbr, and source_node_nbr.</p> </li> <li> <p>l ovrd</p> <p>This command lists all overrides defined in the IPN database for the local node.</p> </li> </ul>"},{"location":"man/bpv7/ipnrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a plan 18 ltp/18</p> <p>Declares the egress plan to use for transmission from the local node to neighboring node 18.  By default, any bundle for which the computed \"next hop\" node is node 18 will be queued for transmission on LTP outduct 18.</p> </li> <li> <p>a exit 1 999 dtn://stargate</p> <p>Declares a default route for bundles destined for all nodes whose numbers are in the range 1 through 999 inclusive: absent any other routing decision, such bundles are to be forwarded to \"dtn://stargate\".</p> </li> </ul>"},{"location":"man/bpv7/ipnrc/#see-also","title":"SEE ALSO","text":"<p>ipnadmin(1)</p>"},{"location":"man/bpv7/lgagent/","title":"NAME","text":"<p>lgagent - ION Load/Go remote agent program</p>"},{"location":"man/bpv7/lgagent/#synopsis","title":"SYNOPSIS","text":"<p>lgagent own_endpoint_ID</p>"},{"location":"man/bpv7/lgagent/#description","title":"DESCRIPTION","text":"<p>ION Load/Go is a system for management of an ION-based network, enabling the execution of ION administrative programs at remote nodes.  The system comprises two programs, lgsend and lgagent.</p> <p>The lgagent task on a given node opens the indicated ION endpoint for bundle reception, receives the extracted payloads of Load/Go bundles sent to it by lgsend as run on one or more remote nodes, and processes those payloads, which are the text of Load/Go source files.</p> <p>Load/Go source file content is limited to newline-terminated lines of ASCII characters.  More specifically, the text of any Load/Go source file is a sequence of line sets of two types: file capsules and directives. Any Load/Go source file may contain any number of file capsules and any number of directives, freely intermingled in any order, but the typical structure of a Load/Go source file is simply a single file capsule followed by a single directive.</p> <p>When lgagent identifies a file capsule, it copies all of the capsule's text lines to a new file that it creates in the current working directory. When lgagent identifies a directive, it executes the directive by passing the text of the directive to the pseudoshell() function (see platform(3)).  lgagent processes the line sets of a Load/Go source file in the order in which they appear in the file, so the text of a directive may reference a file that was created as the result of processing a prior file capsule in the same source file.</p>"},{"location":"man/bpv7/lgagent/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Load/Go remote agent processing has terminated.</p> </li> </ul>"},{"location":"man/bpv7/lgagent/#files","title":"FILES","text":"<p>lgfile contains the Load/Go file capsules and directives that are to be processed.</p>"},{"location":"man/bpv7/lgagent/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/lgagent/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>lgagent: can't attach to BP.</p> <p>Bundle Protocol is not running on this computer.  Run bpadmin(1) to start BP.</p> </li> <li> <p>lgagent: can't open own endpoint.</p> <p>own_endpoint_ID is not a declared endpoint on the local ION node.  Run bpadmin(1) to add it.</p> </li> <li> <p>lgagent: bundle reception failed.</p> <p>ION system problem.  Investigate and correct before restarting.</p> </li> <li> <p>lgagent cannot continue.</p> <p>lgagent processing problem.  See earlier diagnostic messages for details. Investigate and correct before restarting.</p> </li> <li> <p>lgagent: no space for bundle content.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgagent: can't receive bundle content.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgagent: can't handle bundle delivery.</p> <p>ION system problem.  Investigate and correct before restarting.</p> </li> <li> <p>lgagent: pseudoshell failed.</p> <p>Error in directive line, usually an attempt to execute a non-existent administration program (e.g., a misspelled program name).  Terminates processing of source file content.</p> </li> </ul> <p>A variety of other diagnostics noting source file parsing problems may also be reported.  These errors are non-fatal but they terminate the processing of the source file content from the most recently received bundle.</p>"},{"location":"man/bpv7/lgagent/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/lgagent/#see-also","title":"SEE ALSO","text":"<p>lgsend(1), lgfile(5)</p>"},{"location":"man/bpv7/lgfile/","title":"NAME","text":"<p>lgfile - ION Load/Go source file</p>"},{"location":"man/bpv7/lgfile/#description","title":"DESCRIPTION","text":"<p>The ION Load/Go system enables the execution of ION administrative programs at remote nodes:</p> <p>The lgsend program reads a Load/Go source file from a local file system, encapsulates the text of that source file in a bundle, and sends the bundle to a designated DTN endpoint on the remote node.</p> <p>An lgagent task running on the remote node, which has opened that DTN endpoint for bundle reception, receives the extracted payload of the bundle -- the text of the Load/Go source file -- and processes it.</p> <p>Load/Go source file content is limited to newline-terminated lines of ASCII characters.  More specifically, the text of any Load/Go source file is a sequence of line sets of two types: file capsules and directives. Any Load/Go source file may contain any number of file capsules and any number of directives, freely intermingled in any order, but the typical structure of a Load/Go source file is simply a single file capsule followed by a single directive.</p> <p>Each file capsule is structured as a single start-of-capsule line, followed by zero or more capsule text lines, followed by a single end-of-capsule line.  Each start-of-capsule line is of this form:</p> <p>[file_name</p> <p>Each capsule text line can be any line of ASCII text that does not begin with an opening ([) or closing (]) bracket character.</p> <p>A text line that begins with a closing bracket character (]) is interpreted as an end-of-capsule line.</p> <p>A directive is any line of text that is not one of the lines of a file capsule and that is of this form:</p> <p>!directive_text</p> <p>When lgagent identifies a file capsule, it copies all of the capsule's text lines to a new file named file_name that it creates in the current working directory.  When lgagent identifies a directive, it executes the directive by passing directive_text to the pseudoshell() function (see platform(3)).  lgagent processes the line sets of a Load/Go source file in the order in which they appear in the file, so the directive_text of a directive may reference a file that was created as the result of processing a prior file capsule line set in the same source file.</p> <p>Note that lgfile directives are passed to pseudoshell(), which on a VxWorks platform will always spawn a new task; the first argument in directive_text must be a symbol that VxWorks can resolve to a function, not a shell command.  Also note that the arguments in directive_text will be actual task arguments, not shell command-line arguments, so they should never be enclosed in double-quote characters (\").  However, any argument that contains embedded whitespace must be enclosed in single-quote characters (') so that pseudoshell() can parse it correctly.</p>"},{"location":"man/bpv7/lgfile/#examples","title":"EXAMPLES","text":"<p>Presenting the following lines of source file text to lgsend:</p> <p>[cmd33.bprc</p> <p>x protocol ltp</p> <p>]</p> <p>!bpadmin cmd33.bprc</p> <p>should cause the receiving node to halt the operation of the LTP convergence-layer protocol.</p>"},{"location":"man/bpv7/lgfile/#see-also","title":"SEE ALSO","text":"<p>lgsend(1), lgagent(1), platform(3)</p>"},{"location":"man/bpv7/lgsend/","title":"NAME","text":"<p>lgsend - ION Load/Go command program</p>"},{"location":"man/bpv7/lgsend/#synopsis","title":"SYNOPSIS","text":"<p>lgsend command_file_name own_endpoint_ID destination_endpoint_ID</p>"},{"location":"man/bpv7/lgsend/#description","title":"DESCRIPTION","text":"<p>ION Load/Go is a system for management of an ION-based network, enabling the execution of ION administrative programs at remote nodes.  The system comprises two programs, lgsend and lgagent.</p> <p>The lgsend program reads a Load/Go source file from a local file system, encapsulates the text of that source file in a bundle, and sends the bundle to an lgagent task that is waiting for data at a designated DTN endpoint on the remote node.</p> <p>To do so, it first reads all lines of the Load/Go source file identified by command_file_name into a temporary buffer in ION's SDR data store, concatenating the lines of the file and retaining all newline characters. Then it invokes the bp_send() function to create and send a bundle whose payload is this temporary buffer, whose destination is destination_endpoint_ID, and whose source endpoint ID is own_endpoint_ID.  Then it terminates.</p>"},{"location":"man/bpv7/lgsend/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Load/Go file transmission succeeded.</p> </li> <li> <p>\"1\"</p> <p>Load/Go file transmission failed.  Examine ion.log to determine the cause of the failure, then re-run.</p> </li> </ul>"},{"location":"man/bpv7/lgsend/#files","title":"FILES","text":"<p>lgfile contains the Load/Go file capsules and directive that are to be sent to the remote node.</p>"},{"location":"man/bpv7/lgsend/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/lgsend/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>lgsend: can't attach to BP.</p> <p>Bundle Protocol is not running on this computer.  Run bpadmin(1) to start BP.</p> </li> <li> <p>lgsend: can't open own endpoint.</p> <p>own_endpoint_ID is not a declared endpoint on the local ION node. Run bpadmin(1) to add it.</p> </li> <li> <p>lgsend: can't open file of LG commands: error description</p> <p>command_file_name doesn't identify a file that can be opened.  Correct spelling of file name or file's access permissions.</p> </li> <li> <p>lgsend: can't get size of LG command file: error description</p> <p>Operating system problem.  Investigate and correct before rerunning.</p> </li> <li> <p>lgsend: LG cmd file size &gt; 64000.</p> <p>Load/Go command file is too large.  Split it into multiple files if possible.</p> </li> <li> <p>lgsend: no space for application data unit.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgsend: fgets failed: error description</p> <p>Operating system problem.  Investigate and correct before rerunning.</p> </li> <li> <p>lgsend: can't create application data unit.</p> <p>ION system problem: have exhausted available SDR data store reserves.</p> </li> <li> <p>lgsend: can't send bundle.</p> <p>ION system problem.  Investigate and correct before rerunning.</p> </li> </ul>"},{"location":"man/bpv7/lgsend/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/lgsend/#see-also","title":"SEE ALSO","text":"<p>lgagent(1), lgfile(5)</p>"},{"location":"man/bpv7/ltpcli/","title":"NAME","text":"<p>ltpcli - LTP-based BP convergence layer input task</p>"},{"location":"man/bpv7/ltpcli/#synopsis","title":"SYNOPSIS","text":"<p>ltpcli local_node_nbr</p>"},{"location":"man/bpv7/ltpcli/#description","title":"DESCRIPTION","text":"<p>ltpcli is a background \"daemon\" task that receives LTP data transmission blocks, extracts bundles from the received blocks, and passes them to the bundle protocol agent on the local ION node.</p> <p>ltpcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"ltp\" convergence layer protocol is added to the BP database. The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  ltpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the LTP convergence layer protocol.</p>"},{"location":"man/bpv7/ltpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart ltpcli.</p> </li> <li> <p>\"1\"</p> <p>ltpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart ltpcli.</p> </li> </ul>"},{"location":"man/bpv7/ltpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/ltpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/ltpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ltpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such ltp duct.</p> <p>No LTP induct matching local_node_nbr has been added to the BP database.  Use bpadmin to stop the LTP convergence-layer protocol, add the induct, and then restart the LTP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of ltpcli.</p> </li> <li> <p>ltpcli can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP operations.</p> </li> <li> <p>ltpcli can't open client access.</p> <p>Another task has already opened the client service for BP over LTP.</p> </li> <li> <p>ltpcli can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart LTP.</p> </li> </ul>"},{"location":"man/bpv7/ltpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/ltpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), ltpadmin(1), ltprc(5), ltpclo(1)</p>"},{"location":"man/bpv7/ltpclo/","title":"NAME","text":"<p>ltpclo - LTP-based BP convergence layer adapter output task</p>"},{"location":"man/bpv7/ltpclo/#synopsis","title":"SYNOPSIS","text":"<p>ltpclo remote_node_nbr</p>"},{"location":"man/bpv7/ltpclo/#description","title":"DESCRIPTION","text":"<p>ltpclo is a background \"daemon\" task that extracts bundles from the queues of segments ready for transmission via LTP to the remote bundle protocol agent identified by remote_node_nbr and passes them to the local LTP engine for aggregation, segmentation, and transmission to the remote node.</p> <p>ltpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  ltpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the LTP convergence layer protocol.</p>"},{"location":"man/bpv7/ltpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the BRSC protocol.</p> </li> <li> <p>\"1\"</p> <p>ltpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the BRSC protocol.</p> </li> </ul>"},{"location":"man/bpv7/ltpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/ltpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/ltpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ltpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such ltp duct.</p> <p>No LTP outduct with duct name matching remote_node_nbr has been added to the BP database.  Use bpadmin to stop the LTP convergence-layer protocol, add the outduct, and then restart the LTP protocol.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of ltpclo.</p> </li> <li> <p>ltpclo can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP operations.</p> </li> </ul>"},{"location":"man/bpv7/ltpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/ltpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), ltpadmin(1), ltprc(5), ltpcli(1)</p>"},{"location":"man/bpv7/stcpcli/","title":"NAME","text":"<p>sstcpcli - DTN simple TCP convergence layer input task</p>"},{"location":"man/bpv7/stcpcli/#synopsis","title":"SYNOPSIS","text":"<p>stcpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv7/stcpcli/#description","title":"DESCRIPTION","text":"<p>stcpcli is a background \"daemon\" task comprising 1 + N threads: one that handles TCP connections from remote stcpclo tasks, spawning sockets for data reception from those tasks, plus one input thread for each spawned socket to handle data reception over that socket.</p> <p>The connection thread simply accepts connections on a TCP socket bound to local_hostname and local_port_nbr and spawns reception threads.  The default value for local_port_nbr, if omitted, is 4556.</p> <p>Each reception thread receives bundles over the associated connected socket. Each bundle received on the connection is preceded by a 32-bit unsigned integer in network byte order indicating the length of the bundle.  The received bundles are passed to the bundle protocol agent on the local ION node.</p> <p>stcpcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"stcp\" convergence layer protocol is added to the BP database. The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  stcpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the STCP convergence layer protocol.</p>"},{"location":"man/bpv7/stcpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>stcpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart stcpcli.</p> </li> <li> <p>\"1\"</p> <p>stcpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart stcpcli.</p> </li> </ul>"},{"location":"man/bpv7/stcpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/stcpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/stcpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>stcpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such stcp duct.</p> <p>No STCP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the STCP convergence-layer protocol, add the induct, and then restart the STCP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of stcpcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> <li> <p>Can't open TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> <li> <p>Can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> <li> <p>stcpcli can't create access thread</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> </ul>"},{"location":"man/bpv7/stcpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/stcpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), stcpclo(1)</p>"},{"location":"man/bpv7/stcpclo/","title":"NAME","text":"<p>stcpclo - DTN simple TCP convergence layer adapter output task</p>"},{"location":"man/bpv7/stcpclo/#synopsis","title":"SYNOPSIS","text":"<p>stcpclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv7/stcpclo/#description","title":"DESCRIPTION","text":"<p>stcpclo is a background \"daemon\" task that connects to a remote node's TCP socket at remote_hostname and remote_port_nbr.  It then begins extracting bundles from the queues of bundles ready for transmission via TCP to this remote bundle protocol agent and transmitting those bundles over the connected socket to that node.  Each transmitted bundle is preceded by a 32-bit integer in network byte order indicating the length of the bundle.</p> <p>If not specified, remote_port_nbr defaults to 4556.</p> <p>stcpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  stcpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the STCP convergence layer protocol.</p>"},{"location":"man/bpv7/stcpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>stcpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart the STCP protocol.</p> </li> <li> <p>\"1\"</p> <p>stcpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart the STCP protocol.</p> </li> </ul>"},{"location":"man/bpv7/stcpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/stcpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/stcpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>stcpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such stcp duct.</p> <p>No STCP outduct with duct name matching remote_hostname and remote_port_nbr has been added to the BP database.  Use bpadmin to stop the STCP convergence-layer protocol, add the outduct, and then restart the STCP protocol.</p> </li> <li> <p>CLO task is already started for this duct.</p> <p>Redundant initiation of stcpclo.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart STCP.</p> </li> </ul>"},{"location":"man/bpv7/stcpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/stcpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), stcpcli(1)</p>"},{"location":"man/bpv7/tcpcli/","title":"NAME","text":"<p>tcpcli - DTN TCPCL-compliant convergence layer input task</p>"},{"location":"man/bpv7/tcpcli/#synopsis","title":"SYNOPSIS","text":"<p>tcpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv7/tcpcli/#description","title":"DESCRIPTION","text":"<p>tcpcli is a background \"daemon\" task comprising 3 + 2*N threads: an executive thread; a clock thread that periodically attempts to connect to remote TCPCL entities as identified by the tcp outducts enumerated in the bprc(5) file (each of which must specify the hostname[:port_nbr] to connect to); a thread that handles TCP connections from remote TCPCL entities, spawning sockets for data reception from those tasks; plus one input thread and one output thread for each connection, to handle data reception and transmission over that socket.</p> <p>The connection thread simply accepts connections on a TCP socket bound to local_hostname and local_port_nbr and spawns reception threads.  The default value for local_port_nbr, if omitted, is 4556.</p> <p>Each time a connection is established, the entities will first exchange contact headers, because connection parameters need to be negotiated. tcpcli records the acknowledgement flags, reactive fragmentation flag, and negative acknowledgements flag in the contact header it receives from its peer TCPCL entity.</p> <p>Each reception thread receives bundles over the associated connected socket. Each bundle received on the connection is preceded by message type, fragmentation flags, and size represented as an SDNV.  The received bundles are passed to the bundle protocol agent on the local ION node.</p> <p>Similarly, each transmission thread obtains outbound bundles from the local ION node, encapsulates them as noted above, and transmits them over the associated connected socket.</p> <p>tcpcli is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"tcp\" convergence layer protocol is added to the BP database. The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  tcpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the TCP convergence layer protocol.</p>"},{"location":"man/bpv7/tcpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart tcpcli.</p> </li> <li> <p>\"1\"</p> <p>tcpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart tcpcli.</p> </li> </ul>"},{"location":"man/bpv7/tcpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/tcpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/tcpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such tcp duct.</p> <p>No TCP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the TCP convergence-layer protocol, add the induct, and then restart the TCP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of tcpcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> <li> <p>Can't open TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> <li> <p>Can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> <li> <p>tcpcli can't create access thread</p> <p>Operating system error.  Check errtext, correct problem, and restart TCP.</p> </li> </ul>"},{"location":"man/bpv7/tcpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/tcpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5)</p>"},{"location":"man/bpv7/tcpclo/","title":"NAME","text":"<p>tcpclo - TCPCL-compliant convergence layer adapter output task [DEPRECATED]</p>"},{"location":"man/bpv7/tcpclo/#synopsis","title":"SYNOPSIS","text":"<p>tcpclo</p>"},{"location":"man/bpv7/tcpclo/#description","title":"DESCRIPTION","text":"<p>tcpclo is deprecated.  The outducts for the \"tcp\" convergence-layer adapter are now drained by threads managed within tcpcli.</p>"},{"location":"man/bpv7/tcpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcpclo terminated normally.</p> </li> </ul>"},{"location":"man/bpv7/tcpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/tcpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/tcpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>No diagnostics apply.</p>"},{"location":"man/bpv7/tcpclo/#see-also","title":"SEE ALSO","text":"<p>tcpcli(1)</p>"},{"location":"man/bpv7/udpcli/","title":"NAME","text":"<p>udpcli - UDP-based BP convergence layer input task</p>"},{"location":"man/bpv7/udpcli/#synopsis","title":"SYNOPSIS","text":"<p>udpcli local_hostname[:local_port_nbr]</p>"},{"location":"man/bpv7/udpcli/#description","title":"DESCRIPTION","text":"<p>udpcli is a background \"daemon\" task that receives UDP datagrams via a UDP socket bound to local_hostname and local_port_nbr, extracts bundles from those datagrams, and passes them to the bundle protocol agent on the local ION node.</p> <p>If not specified, port number defaults to 4556.</p> <p>The convergence layer input task is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol; the text of the command that is used to spawn the task must be provided at the time the \"udp\" convergence layer protocol is added to the BP database.  The convergence layer input task is terminated by bpadmin in response to an 'x' (STOP) command.  udpcli can also be spawned and terminated in response to START and STOP commands that pertain specifically to the UDP convergence layer protocol.</p>"},{"location":"man/bpv7/udpcli/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udpcli terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart udpcli.</p> </li> <li> <p>\"1\"</p> <p>udpcli terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart udpcli.</p> </li> </ul>"},{"location":"man/bpv7/udpcli/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/udpcli/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/udpcli/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udpcli can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No such udp duct.</p> <p>No UDP induct matching local_hostname and local_port_nbr has been added to the BP database.  Use bpadmin to stop the UDP convergence-layer protocol, add the induct, and then restart the UDP protocol.</p> </li> <li> <p>CLI task is already started for this duct.</p> <p>Redundant initiation of udpcli.</p> </li> <li> <p>Can't get IP address for host</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>Can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>Can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>udpcli can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart UDP.</p> </li> </ul>"},{"location":"man/bpv7/udpcli/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/udpcli/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), udpclo(1)</p>"},{"location":"man/bpv7/udpclo/","title":"NAME","text":"<p>udpclo - UDP-based BP convergence layer output task</p>"},{"location":"man/bpv7/udpclo/#synopsis","title":"SYNOPSIS","text":"<p>udpclo remote_hostname[:remote_port_nbr]</p>"},{"location":"man/bpv7/udpclo/#description","title":"DESCRIPTION","text":"<p>udpclo is a background \"daemon\" task that extracts bundles from the queues of bundles ready for transmission via UDP to a remote node's UDP socket at remote_hostname and remote_port_nbr, encapsulates those bundles in UDP datagrams, and sends those datagrams to that remote UDP socket.</p> <p>udpclo is spawned automatically by bpadmin in response to the 's' (START) command that starts operation of the Bundle Protocol, and it is terminated by bpadmin in response to an 'x' (STOP) command.  udpclo can also be spawned and terminated in response to START and STOP commands that pertain specifically to the UDP convergence layer protocol.</p>"},{"location":"man/bpv7/udpclo/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udpclo terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bpadmin to restart udpclo.</p> </li> <li> <p>\"1\"</p> <p>udpclo terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bpadmin to restart udpclo.</p> </li> </ul>"},{"location":"man/bpv7/udpclo/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bpv7/udpclo/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bpv7/udpclo/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udpclo can't attach to BP.</p> <p>bpadmin has not yet initialized Bundle Protocol operations.</p> </li> <li> <p>No memory for UDP buffer in udpclo.</p> <p>ION system error.  Check errtext, correct problem, and restart UDP.</p> </li> <li> <p>No such udp duct.</p> <p>No UDP outduct with duct name remote_hostname[:&lt;remote_port_nbr&gt;] has been added to the BP database.  Use bpadmin to stop the UDP convergence-layer protocol, add the outduct, and then restart the UDP protocol.</p> </li> <li> <p>CLO task is already started for this engine.</p> <p>Redundant initiation of udpclo.</p> </li> <li> <p>CLO can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpclo.</p> </li> <li> <p>CLO write() error on socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpclo.</p> </li> <li> <p>Bundle is too big for UDP CLA.</p> <p>Configuration error: bundles that are too large for UDP transmission (i.e., larger than 65535 bytes) are being enqueued for udpclo.  Change routing.</p> </li> </ul>"},{"location":"man/bpv7/udpclo/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bpv7/udpclo/#see-also","title":"SEE ALSO","text":"<p>bpadmin(1), bprc(5), udpcli(1)</p>"},{"location":"man/bss/","title":"Index of Man Pages","text":"<ul> <li>bss</li> <li>bssStreamingApp</li> <li>bssrecv</li> </ul>"},{"location":"man/bss/bss/","title":"NAME","text":"<p>bss - Bundle Streaming Service library</p>"},{"location":"man/bss/bss/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"bss.h\"\n\ntypedef int (*RTBHandler)(time_t time, unsigned long count, char *buffer, int bufLength);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/bss/bss/#description","title":"DESCRIPTION","text":"<p>The BSS library supports the streaming of data over delay-tolerant networking (DTN) bundles.  The intent of the library is to enable applications that pass streaming data received in transmission time order (i.e., without time regressions) to an application-specific \"display\" function -- notionally for immediate real-time display -- but to store all received data (including out-of-order data) in a private database for playback under user control.  The reception and real-time display of in-order data is performed by a background thread, leaving the application's main (foreground) thread free to respond to user commands controlling playback or other application-specific functions.</p> <p>The application-specific \"display\" function invoked by the background thread must conform to the RTBHandler type definition.  It must return 0 on success, -1 on any error that should terminate the background thread.  Only on return from this function will the background thread proceed to acquire the next BSS payload.</p> <p>All data acquired by the BSS background thread is written to a BSS database comprising three files: table, list, and data.  The name of the database is the root name that is common to the three files, e.g., db3.tbl, db3.lst, db3.dat would be the three files making up the db3 BSS database.  All three files of the selected BSS database must reside in the same directory of the file system.</p> <p>Several replay navigation functions in the BSS library require that the application provide a navigation state structure of type bssNav as defined in the bss.h header file.  The application is not reponsible for populating this structure; it's strictly for the private use of the BSS library.</p> <ul> <li> <p>int bssOpen(char *bssName, char *path, char *eid)</p> <p>Opens access to a BSS database, to enable data playback.  bssName identifies the specific BSS database that is to be opened.  path identifies the directory in which the database resides.  eid is ignored.  On any failure, returns -1.  On success, returns zero.</p> </li> <li> <p>int bssStart(char *bssName, char *path, char *eid, char *buffer, int bufLen, RTBHandler handler)</p> <p>Starts a BSS data acquisition background thread.  bssName identifies the BSS database into which data will be acquired.  path identifies the directory in which that database resides.  eid is used to open the BP endpoint at which the delivered BSS bundle payload contents will be acquired.  buffer identifies a data acquisition buffer, which must be provided by the application, and bufLen indicates the length of that buffer; received bundle payloads in excess of this length will be discarded.</p> <p>handler identifies the display function to which each in-order bundle payload will be passed.  The time and count parameters passed to this function identify the received bundle, indicating the bundle's creation timestamp time (in seconds) and counter value.  The buffer and bufLength parameters indicate the location into which the bundle's payload was acquired and the length of the acquired payload.  handler must return -1 on any unrecoverable system error, 0 otherwise.  A return value of -1 from handler will terminate the BSS data acquisition background thread.</p> <p>On any failure, returns -1.  On success, returns zero.</p> </li> <li> <p>int bssRun(char *bssName, char *path, char *eid, char *buffer, int bufLen, RTBHandler handler)</p> <p>A convenience function that performs both bssOpen() and bssStart().  On any failure, returns -1.  On success, returns zero.</p> </li> <li> <p>void bssClose()</p> <p>Terminates data playback access to the most recently opened BSS database.</p> </li> <li> <p>void bssStop()</p> <p>Terminates the most recently initiated BSS data acquisition background thread.</p> </li> <li> <p>void bssExit()</p> <p>A convenience function that performs both bssClose() and bssStop().</p> </li> <li> <p>long bssRead(bssNav nav, char *data, int dataLen)</p> <p>Copies the data at the current playback position in the database, as indicated by nav, into data; if the length of the data is in excess of dataLen then an error condition is asserted (i.e., -1 is returned).  Note that bssRead() cannot be successfully called until nav has been populated, nominally by a preceding call to bssSeek(), bssNext(), or bssPrev().  Returns the length of data read, or -1 on any error.</p> </li> <li> <p>long bssSeek(bssNav *nav, time_t time, time_t *curTime, unsigned long *count)</p> <p>Sets the current playback position in the database, in nav, to the data received in the bundle with the earliest creation time that was greater than or equal to time.  Populates nav and also returns the creation time and bundle ID count of that bundle in curTime and count.  Returns the length of data at this location, or -1 on any error.</p> </li> <li> <p>long bssSeek_read(bssNav *nav, time_t time, time_t *curTime, unsigned long *count, char *data, int dataLen)</p> <p>A convenience function that performs bssSeek() followed by an immediate bssRead() to return the data at the new playback position.  Returns the length of data read, or -1 on any error.</p> </li> <li> <p>long bssNext(bssNav *nav, time_t *curTime, unsigned long *count)</p> <p>Sets the playback position in the database, in nav, to the data received in the bundle with the earliest creation time and ID count greater than that of the bundle at the current playback position.  Populates nav and also returns the creation time and bundle ID count of that bundle in curTime and count.  Returns the length of data at this location (if any), -2 on reaching end of list, or -1 on any error.</p> </li> <li> <p>long bssNext_read(bssNav *nav, time_t *curTime, unsigned long *count, char *data, int dataLen)</p> <p>A convenience function that performs bssNext() followed by an immediate bssRead() to return the data at the new playback position.  Returns the length of data read, -2 on reaching end of list, or -1 on any error.</p> </li> <li> <p>long bssPrev(bssNav *nav, time_t *curTime, unsigned long *count)</p> <p>Sets the playback position in the database, in nav, to the data received in the bundle with the latest creation time and ID count earlier than that of the bundle at the current playback position.  Populates nav and also returns the creation time and bundle ID count of that bundle in curTime and count.  Returns the length of data at this location (if any), -2 on reaching end of list, or -1 on any error.</p> </li> <li> <p>long bssPrev_read(bssNav *nav, time_t *curTime, unsigned long *count, char *data, int dataLen)</p> <p>A convenience function that performs bssPrev() followed by an immediate bssRead() to return the data at the new playback position.  Returns the length of data read, -2 on reaching end of list, or -1 on any error.</p> </li> </ul>"},{"location":"man/bss/bss/#see-also","title":"SEE ALSO","text":"<p>bp(3)</p>"},{"location":"man/bss/bssStreamingApp/","title":"NAME","text":"<p>bssStreamingApp - Bundle Streaming Service transmission test program</p>"},{"location":"man/bss/bssStreamingApp/#synopsis","title":"SYNOPSIS","text":"<p>bssStreamingApp own_endpoint_ID destination_endpoint_ID [class_of_service]</p>"},{"location":"man/bss/bssStreamingApp/#description","title":"DESCRIPTION","text":"<p>bssStreamingApp uses BSS to send streaming data over BP from own_endpoint_ID to bssrecv listening at destination_endpoint_ID. class_of_service is as specified for bptrace(1); if omitted, bundles are sent at BP's standard priority (1).</p> <p>The bundles issued by bssStreamingApp all have 65000-byte payloads, where the ASCII representation of a positive integer (increasing monotonically from 0, by 1, throughout the operation of the program) appears at the start of each payload.  All bundles are sent with custody transfer requested, with time-to-live set to 1 day.  The application meters output by sleeping for 12800 microseconds after issuing each bundle.</p> <p>Use CTRL-C to terminate the program.</p>"},{"location":"man/bss/bssStreamingApp/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bss/bssStreamingApp/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bss/bssStreamingApp/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bss/bssStreamingApp/#see-also","title":"SEE ALSO","text":"<p>bssrecv(1), bss(3)</p>"},{"location":"man/bss/bssrecv/","title":"NAME","text":"<p>bssrecv - Bundle Streaming Service reception test program</p>"},{"location":"man/bss/bssrecv/#synopsis","title":"SYNOPSIS","text":"<p>bssrecv</p>"},{"location":"man/bss/bssrecv/#description","title":"DESCRIPTION","text":"<p>bssrecv uses BSS to acquire streaming data from bssStreamingApp.</p> <p>bssrecv is a menu-driven interactive test program, run from the operating system shell prompt.  The program enables the user to begin and end a session of BSS data acquisition from bssStreamingApp, displaying the data as it arrives in real time; to replay data acquired during the current session; and to replay data acquired during a prior session.</p> <p>The user must provide values for three parameters in order to initiate the acquisition or replay of data from bssStreamingApp:</p> <ul> <li> <p>BSS database name</p> <p>All data acquired by the BSS session thread will be written to a BSS \"database\" comprising three files: table, list, and data.  The name of the database is the root name that is common to the three files, e.g., db3.tbl, db3.lst, db3.dat would be the three files making up the db3 BSS database.</p> </li> <li> <p>path name</p> <p>All three files of the selected BSS database must reside in the same directory of the file system; the path name of that directory is required.</p> </li> <li> <p>endpoint ID</p> <p>In order to acquire streaming data issued by bssStreamingApp, the bssrecv session thread must open the BP endpoint to which that data is directed.  For this purpose, the ID of that endpoint is needed.</p> </li> </ul> <p>bssrecv offers the following menu options:</p> <ul> <li> <ol> <li>Open BSS Receiver in playback mode</li> </ol> <p>bssrecv prompts the user for the three parameter values noted above, then opens the indicated BSS database for replay of the data in that database.</p> </li> <li> <ol> <li>Start BSS receiving thread</li> </ol> <p>bssrecv prompts the user for the three parameter values noted above, then starts a background session thread to acquire data into the indicated database. Each bundle that is acquired is passed to a display function that prints a single line consisting of N consecutive '*' characters, where N is computed as the data number at the start of the bundle's payload data, modulo 150. Note that the database is not open for replay at this time.</p> </li> <li> <ol> <li>Run BSS receiver thread</li> </ol> <p>bssrecv prompts the user for the three parameter values noted above, then starts a background session thread to acquire data into the indicated database (displaying the data as described for option 2 above) and also opens the database for replay.</p> </li> <li> <ol> <li>Close current playback session</li> </ol> <p>bssrecv closes the indicated BSS database, terminating replay access.</p> </li> <li> <ol> <li>Stop BSS receiving thread</li> </ol> <p>bssrecv terminates the current background session thread.  Replay access to the BSS database, if currently open, is not terminated.</p> </li> <li> <ol> <li>Stop BSS Receiver</li> </ol> <p>bssrecv terminates the current background session thread.  Replay access to the BSS database, if currently open, is also terminated.</p> </li> <li> <ol> <li>Replay session</li> </ol> <p>bssrecv prompts the user for the start and end times bounding the reception interval that is to be replayed, then displays all data within that interval in both forward and reverse time order.  The display function performed for this purpose is the same one that is exercised during real-time acquisition of streaming data.</p> </li> <li> <ol> <li>Exit</li> </ol> <p>bssrecv terminates.</p> </li> </ul>"},{"location":"man/bss/bssrecv/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bssrecv has terminated.</p> </li> </ul>"},{"location":"man/bss/bssrecv/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bss/bssrecv/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bss/bssrecv/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bss/bssrecv/#see-also","title":"SEE ALSO","text":"<p>bssStreamingApp(1), bss(3)</p>"},{"location":"man/bssp/","title":"Index of Man Pages","text":"<ul> <li>bssp</li> <li>bsspadmin</li> <li>bsspclock</li> <li>bssprc</li> <li>tcpbsi</li> <li>tcpbso</li> <li>udpbsi</li> <li>udpbso</li> </ul>"},{"location":"man/bssp/bssp/","title":"NAME","text":"<p>bssp - Bundle Streaming Service Protocol (BSSP) communications library</p>"},{"location":"man/bssp/bssp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"bssp.h\"\n\ntypedef enum\n{\n    BsspNoNotice = 0,\n    BsspXmitSuccess,\n    BsspXmitFailure,\n    BsspRecvSuccess\n} BsspNoticeType;\n\n[see description for available functions]\n</code></pre>"},{"location":"man/bssp/bssp/#description","title":"DESCRIPTION","text":"<p>The bssp library provides functions enabling application software to use BSSP to send and receive streaming data in bundles.</p> <p>BSSP is designed to forward streaming data in original transmission order wherever possible but to retransmit data as necessary to ensure that the entire stream is available for playback eventually.  To this end, BSSP uses not one but two underlying \"link service\" channels: (a) an unreliable \"best efforts\" channel, for data items that are successfully received upon initial transmission over every extent of the end-to-end path, and (b) a \"reliable\" channel, for data items that were lost at some point, had to be retransmitted, and therefore are now out of order.  The BSS library at the destination node supports immediate \"real-time\" display of all data received on the \"best efforts\" channel in transmission order, together with database retention of all data eventually received on the \"reliable\" channel.</p> <p>The BSSP notion of engine ID corresponds closely to the Internet notion of a host, and in ION engine IDs are normally indistinguishable from node numbers including the node numbers in Bundle Protocol endpoint IDs conforming to the \"ipn\" scheme.</p> <p>The BSSP notion of client ID corresponds closely to the Internet notion of \"protocol number\" as used in the Internet Protocol.  It enables data from multiple applications -- clients -- to be multiplexed over a single reliable link.  However, for ION operations we normally use BSSP exclusively for the transmission of Bundle Protocol data, identified by client ID = 1.</p> <ul> <li> <p>int bssp_attach()</p> <p>Attaches the application to BSSP functionality on the lcoal computer.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void bssp_detach()</p> <p>Terminates all access to BSSP functionality on the local computer.</p> </li> <li> <p>int bssp_engine_is_started()</p> <p>Returns 1 if the local BSSP engine has been started and not yet stopped, 0 otherwise.</p> </li> <li> <p>int bssp_send(uvast destinationEngineId, unsigned int clientId, Object clientServiceData, int inOrder, BsspSessionId *sessionId)</p> <p>Sends a client service data unit to the application that is waiting for data tagged with the indicated clientId as received at the remote BSSP engine identified by destinationEngineId.</p> <p>clientServiceData must be a \"zero-copy object\" reference as returned by ionCreateZco().  Note that BSSP will privately make and destroy its own reference to the client service data object; the application is free to destroy its reference at any time.</p> <p>inOrder is a Boolean value indicating whether or not the service data item that is being sent is \"in order\", i.e., was originally transmitted after all items that have previously been sent to this destination by this local BSSP engine: 0 if no (meaning that the item must be transmitted using the \"reliable\" channel), 1 if yes (meaning that the item must be transmitted using the \"best-efforts\" channel.</p> <p>On success, the function populates *sessionId with the source engine ID and the \"session number\" assigned to transmission of this client service data unit and returns zero.  The session number may be used to link future BSSP processing events to the affected client service data.  bssp_send() returns -1 on any error.</p> </li> <li> <p>int bssp_open(unsigned int clientId)</p> <p>Establishes the application's exclusive access to received service data units tagged with the indicated BSSP client service data ID.  At any time, only a single application task is permitted to receive service data units for any single client service data ID.</p> <p>Returns 0 on success, -1 on any error (e.g., the indicated client service is already being held open by some other application task).</p> </li> <li> <p>int bssp_get_notice(unsigned int clientId, BsspNoticeType *type, BsspSessionId *sessionId, unsigned char *reasonCode, unsigned int *dataLength, Object *data)</p> <p>Receives notices of BSSP processing events pertaining to the flow of service data units tagged with the indicated client service ID.  The nature of each event is indicated by *type.  Additional parameters characterizing the event are returned in *sessionId, *reasonCode, *dataLength, and *data as relevant.</p> <p>The value returned in *data is always a zero-copy object; use the zco_* functions defined in \"zco.h\" to retrieve the content of that object.</p> <p>When the notice is an BsspRecvSuccess, the ZCO returned in *data contains the content of a single BSSP block.</p> <p>The cancellation of an export session results in delivery of a  BsspXmitFailure notice.  In this case, the ZCO returned in *data is a service data unit ZCO that had previously been passed to bssp_send().</p> <p>bssp_get_notice() always blocks indefinitely until an BSSP processing event is delivered.</p> <p>Returns zero on success, -1 on any error.</p> </li> <li> <p>void bssp_interrupt(unsigned int clientId)</p> <p>Interrupts an bssp_get_notice() invocation.  This function is designed to be called from a signal handler; for this purpose, clientId may need to be obtained from a static variable.</p> </li> <li> <p>void bssp_release_data(Object data)</p> <p>Releases the resources allocated to hold data, which must be a received client service data unit ZCO.</p> </li> <li> <p>void bssp_close(unsigned int clientId)</p> <p>Terminates the application's exclusive access to received service data units tagged with the indicated client service data ID.</p> </li> </ul>"},{"location":"man/bssp/bssp/#see-also","title":"SEE ALSO","text":"<p>bsspadmin(1), bssprc(5), zco(3)</p>"},{"location":"man/bssp/bsspadmin/","title":"NAME","text":"<p>bsspadmin - Bundle Streaming Service Protocol (BSSP) administration interface</p>"},{"location":"man/bssp/bsspadmin/#synopsis","title":"SYNOPSIS","text":"<p>bsspadmin [ commands_filename | . ]</p>"},{"location":"man/bssp/bsspadmin/#description","title":"DESCRIPTION","text":"<p>bsspadmin configures, starts, manages, and stops BSSP operations for the local ION node.</p> <p>It operates in response to BSSP configuration commands found in the file commands_filename, if provided; if not, bsspadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to bsspadmin -- that is, the ION node's bsspclock task and link service adapter tasks are stopped.</p> <p>The format of commands for commands_filename can be queried from bsspadmin with the 'h' or '?' commands at the prompt.  The commands are documented in bssprc(5).</p>"},{"location":"man/bssp/bsspadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p><code>0</code></p> <p>Successful completion of BSSP administration.</p> </li> </ul>"},{"location":"man/bssp/bsspadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>bsspadmin</p> <p>Enter interactive BSSP configuration command entry mode.</p> </li> <li> <p>bsspadmin host1.bssp</p> <p>Execute all configuration commands in host1.bssp, then terminate immediately.</p> </li> <li> <p>bsspadmin .</p> <p>Stop all BSSP operations on the local node.</p> </li> </ul>"},{"location":"man/bssp/bsspadmin/#files","title":"FILES","text":"<p>See bssprc(5) for details of the BSSP configuration commands.</p>"},{"location":"man/bssp/bsspadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bssp/bsspadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the bssprc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to bsspadmin.  Otherwise bsspadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>bsspadmin can't attach to ION.</p> <p>There is no SDR data store for bsspadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause bsspadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see bssprc(5) for details.</p>"},{"location":"man/bssp/bsspadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bssp/bsspadmin/#see-also","title":"SEE ALSO","text":"<p>bssprc(5)</p>"},{"location":"man/bssp/bsspclock/","title":"NAME","text":"<p>bsspclock - BSSP daemon task for managing scheduled events</p>"},{"location":"man/bssp/bsspclock/#synopsis","title":"SYNOPSIS","text":"<p>bsspclock</p>"},{"location":"man/bssp/bsspclock/#description","title":"DESCRIPTION","text":"<p>bsspclock is a background \"daemon\" task that periodically performs scheduled BSSP activities.  It is spawned automatically by bsspadmin in response to the 's' command that starts operation of the BSSP protocol, and it is terminated by bsspadmin in response to an 'x' (STOP) command.</p> <p>Once per second, bsspclock takes the following action:</p> <p>First it manages the current state of all links (\"spans\").  Specifically, it infers link state changes (\"link cues\") from data rate changes as noted in the RFX database by rfxclock:</p> <p>If the rate of transmission to a neighbor was zero but is now non-zero, then transmission to that neighbor resumes.  The applicable \"buffer empty\" semaphore is given (enabling start of a new transmission session) and the best-efforts and/or reliable \"PDUs ready\" semaphores are given if the corresponding outbound PDU queues are non-empty (enabling transmission of PDUs by the link service output task).</p> <p>If the rate of transmission to a neighbor was non-zero but is now zero, then transmission to that neighbor is suspended -- i.e., the semaphores triggering transmission will no longer be given.</p> <p>If the imputed rate of transmission from a neighbor was non-zero but is now zero, then all best-efforts transmission acknowledgment timers affecting transmission to that neighbor are suspended.  This has the effect of extending the interval of each affected timer by the length of time that the timers remain suspended.</p> <p>If the imputed rate of transmission from a neighbor was zero but is now non-zero, then all best-efforts transmission acknowledgment timers affecting transmission to that neighbor are resumed.</p> <p>Then bsspclock enqueues for reliable transmission all blocks for which the best-efforts transmission acknowledgment timeout interval has now expired but no acknowledgment has yet been received.</p>"},{"location":"man/bssp/bsspclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bsspclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bsspadmin to restart bsspclock.</p> </li> <li> <p>\"1\"</p> <p>bsspclock was unable to attach to BSSP protocol operations, probably because bsspadmin has not yet been run.</p> </li> </ul>"},{"location":"man/bssp/bsspclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bssp/bsspclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bssp/bsspclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>bsspclock can't initialize BSSP.</p> <p>bsspadmin has not yet initialized BSSP protocol operations.</p> </li> <li> <p>Can't dispatch events.</p> <p>An unrecoverable database error was encountered.  bsspclock terminates.</p> </li> <li> <p>Can't manage links.</p> <p>An unrecoverable database error was encountered.  bsspclock terminates.</p> </li> </ul>"},{"location":"man/bssp/bsspclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bssp/bsspclock/#see-also","title":"SEE ALSO","text":"<p>bsspadmin(1), rfxclock(1)</p>"},{"location":"man/bssp/bssprc/","title":"NAME","text":"<p>bssprc - Bundle Streaming Service Protocol management commands file</p>"},{"location":"man/bssp/bssprc/#description","title":"DESCRIPTION","text":"<p>BSSP management commands are passed to bsspadmin either in a file of text lines or interactively at bsspadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the BSSP management commands are described below.</p>"},{"location":"man/bssp/bssprc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by bsspadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1 est_max_nbr_of_sessions</p> <p>The initialize command.  Until this command is executed, BSSP is not in operation on the local ION node and most bsspadmin commands will fail.</p> <p>The command uses est_max_nbr_of_sessions to configure the hashtable it will use to manage access to transmission sessions that are currently in progress.  For optimum performance, est_max_nbr_of_sessions should normally equal or exceed the summation of max_nbr_of_sessions over all spans as discussed below.</p> </li> <li> <p>a span peer_engine_nbr max_nbr_of_sessions max_block_size 'BE-BSO_command' 'RL-BSO_command [queuing_latency]</p> <p>The add span command.  This command declares that a span of potential BSSP data interchange exists between the local BSSP engine and the indicated (neighboring) BSSP engine.</p> <p>The max_block_size is expressed as a number of bytes of data. max_block_size is used to configure transmission buffer sizes; as such, it limits client data item size. When exceeded, it causes bssp_send() to fail, and bssp_clo() to shutdown. To restart bssp_clo() without rebooting ION immediately, say, due to on-going data transfer over other convergence layers, one can try to first  stop bpadmin with 'x', then stop bsspadmin with 'x', then run ionrestart to repair any issue in the volatile database, then relaunch bssp daemon and then bp daemon using corresponding configuration files. This procedure could temporarily  enable resumption of operation until it is safe to reboot ION.</p> <p>max_nbr_of__sessions constitutes, in effect, the local BSSP engine's retransmission \"window\" for this span.  The retransmission windows of the spans impose flow control on BSSP transmission, reducing the chance ofx allocation of all available space in the ION node's data store to BSSP transmission sessions.</p> <p>BE-BSO_command is script text that will be executed when BSSP is started on this node, to initiate operation of the best-efforts transmission channel task for this span.  Note that \" peer_engine_nbr\" will automatically be appended to BE-BSO_command by bsspadmin before the command is executed, so only the link-service-specific portion of the command should be provided in the LSO_command string itself.</p> <p>RL-BSO_command is script text that will be executed when BSSP is started on this node, to initiate operation of the reliable transmission channel task for this span.  Note that \" peer_engine_nbr\" will automatically be appended to RL-BSO_command by bsspadmin before the command is executed, so only the link-service-specific portion of the command should be provided in the LSO_command string itself.</p> <p>queuing_latency is the estimated number of seconds that we expect to lapse between reception of a block at this node and transmission of an acknowledging PDU, due to processing delay in the node.  (See the 'm ownqtime' command below.)  The default value is 1.</p> <p>If queuing latency a negative number, the absolute value of this number is used as the actual queuing latency and session purging is enabled; otherwise session purging is disabled.  If session purging is enabled for a span then at the end of any period of transmission over this span all of the span's export sessions that are currently in progress are automatically canceled.  Notionally this forces re-forwarding of the DTN bundles in each session's block, to avoid having to wait for the restart of transmission on this span before those bundles can be successfully transmitted.</p> </li> <li> <p>a seat 'BE-BSI_command' 'RL-BSI_command'</p> <p>The add seat command.  This command declares that the local BSSP engine can receive BSSP PDUs via the link service input daemons that begin running when 'BE-BSI_command' and 'RL-BSI_command' are executed.</p> </li> <li> <p>c span peer_engine_nbr max_nbr_of_sessions max_block_size 'BE-BSO_command' 'RL-BSO_command [queuing_latency]</p> <p>The change span command.  This command sets the indicated span's  configuration parameters to the values provided as arguments.</p> </li> <li> <p>d span peer_engine_nbr</p> <p>The delete span command.  This command deletes the span identified by peer_engine_nbr.  The command will fail if any outbound blocks for this span are pending transmission.</p> </li> <li> <p>d seat 'BE-BSI_command' 'RL-BSI_command'</p> <p>The delete span command.  This command deletes the seat identified by 'BE-BSI_command' and 'RL-BSI_command'.</p> </li> <li> <p>i span peer_engine_nbr</p> <p>This command will print information (all configuration parameters) about the span identified by peer_engine_nbr.</p> </li> <li> <p>i seat 'BE-BSI_command' 'RL-BSI_command'</p> <p>This command will print all information (i.e., process ID numbers) about the seat identified by 'BE-BSO_command' and 'RL-BSO_command'.</p> </li> <li> <p>l span</p> <p>This command lists all declared BSSP data interchange spans.</p> </li> <li> <p>l seat</p> <p>This command lists all declared BSSP data acquisition seats.</p> </li> <li> <p>s ['BE-BSI_command' 'RL-BSI_command']</p> <p>The start command.  This command starts reliable and best-efforts link service output tasks for all BSSP spans (to remote engines) from the local BSSP engine, and it starts the reliable and best-efforts link service input tasks for the local engine.  'BE-BSI_command' and 'RL-BSI_command' are deprecated but are supported for backward compatibility; if provided, the effect is the same as entering the command  \"a seat 'BE-BSI_command' 'RL-BSI_command'\" prior to starting all daemon tasks.</p> </li> <li> <p>m ownqtime own_queuing_latency</p> <p>The manage own queuing time command.  This command sets the number of seconds of predicted additional latency attributable to processing delay within the local engine itself that should be included whenever BSSP computes the nominal round-trip time for an exchange of data with any remote engine. The default value is 1.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops all link service input and output tasks for the local BSSP engine.</p> </li> <li> <p>w { 0 | 1 | &lt;activity_spec&gt; }</p> <p>The BSSP watch command.  This command enables and disables production of a continuous stream of user-selected BSSP activity indication characters.  A watch parameter of \"1\" selects all BSSP activity indication characters; \"0\" de-selects all BSSP activity indication characters; any other activity_spec such as \"DF-\" selects the activity indication characters in the string, de-selecting all others.  BSSP will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>D   bssp send completed</p> <p>E   bssp block constructed for issuance</p> <p>F   bssp block issued</p> <p>G   bssp block popped from best-efforts transmission queue</p> <p>H   positive ACK received for bssp block, session ended</p> <p>S   bssp block received</p> <p>T   bssp block popped from reliable transmission queue</p> <p>-   unacknowledged best-efforts block requeued for reliable transmission</p> <p>*  session canceled locally by sender</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/bssp/bssprc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a span 19 20 4096 'udpbso node19.ohio.edu:5001' 'tcpbso node19.ohio.edu:5001'</p> <p>Declares a data interchange span between the local BSSP engine and the remote engine (ION node) numbered 19.  There can be at most 20 concurrent sessions of BSSP transmission activity to this node.  Maximum block size for this span is set to 4096 bytes, and the best-efforts and reliable link service output tasks that are initiated when BSSP is started on the local ION node will execute the udpbso and tcpbso programs as indicated.</p> </li> <li> <p>m ownqtime 2</p> <p>Sets local queuing delay allowance to 2 seconds.</p> </li> </ul>"},{"location":"man/bssp/bssprc/#see-also","title":"SEE ALSO","text":"<p>bsspadmin(1), udpbsi(1), udpbso(1), tcpbsi(1), tcpbso(1)</p>"},{"location":"man/bssp/tcpbsi/","title":"NAME","text":"<p>tcpbsi - TCP-based reliable link service input task for BSSP</p>"},{"location":"man/bssp/tcpbsi/#synopsis","title":"SYNOPSIS","text":"<p>tcpbsi {local_hostname | @}[:local_port_nbr]</p>"},{"location":"man/bssp/tcpbsi/#description","title":"DESCRIPTION","text":"<p>tcpbsi is a background \"daemon\" task that receives TCP stream data via a TCP socket bound to local_hostname and local_port_nbr, extracts BSSP blocks from that stream, and passes them to the local BSSP engine. Host name \"@\" signifies that the host name returned by hostname(1) is to be used as the socket's host name.  If not specified, port number defaults to 4556.</p> <p>The link service input task is spawned automatically by bsspadmin in response to the 's' command that starts operation of the BSSP protocol; the text of the command that is used to spawn the task must be provided as a parameter to the 's' command.  The link service input task is terminated by bsspadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/bssp/tcpbsi/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcpbsi terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bsspadmin to restart tcpbsi.</p> </li> <li> <p>\"1\"</p> <p>tcpbsi terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bsspadmin to restart tcpbsi.</p> </li> </ul>"},{"location":"man/bssp/tcpbsi/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bssp/tcpbsi/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bssp/tcpbsi/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcpbsi can't initialize BSSP.</p> <p>bsspadmin has not yet initialized BSSP protocol operations.</p> </li> <li> <p>RL-BSI task is already started.</p> <p>Redundant initiation of tcpbsi.</p> </li> <li> <p>RL-BSI can't open TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart tcpbsi.</p> </li> <li> <p>RL-BSI can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart tcpbsi.</p> </li> <li> <p>tcpbsi can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart tcpbsi.</p> </li> </ul>"},{"location":"man/bssp/tcpbsi/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bssp/tcpbsi/#see-also","title":"SEE ALSO","text":"<p>bsspadmin(1), tcpbso(1), udpbsi(1)</p>"},{"location":"man/bssp/tcpbso/","title":"NAME","text":"<p>tcpbso - TCP-based reliable link service output task for BSSP</p>"},{"location":"man/bssp/tcpbso/#synopsis","title":"SYNOPSIS","text":"<p>tcpbso {remote_engine_hostname | @}[:remote_port_nbr] remote_engine_nbr</p>"},{"location":"man/bssp/tcpbso/#description","title":"DESCRIPTION","text":"<p>tcpbso is a background \"daemon\" task that extracts BSSP blocks from the queue of blocks bound for the indicated remote BSSP engine and uses a TCP socket to send them to the indicated TCP port on the indicated host.  If not specified, port number defaults to 4556.</p> <p>Each \"span\" of BSSP data interchange between the local BSSP engine and a neighboring BSSP engine requires its own best-effort and reliable link service output tasks. All link service output tasks are spawned automatically by bsspadmin in response to the 's' command that starts operation of the BSSP protocol, and they are all terminated by bsspadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/bssp/tcpbso/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcpbso terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bsspadmin to restart tcpbso.</p> </li> <li> <p>\"1\"</p> <p>tcpbso terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bsspadmin to restart tcpbso.</p> </li> </ul>"},{"location":"man/bssp/tcpbso/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bssp/tcpbso/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bssp/tcpbso/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcpbso can't initialize BSSP.</p> <p>bsspadmin has not yet initialized BSSP protocol operations.</p> </li> <li> <p>No such engine in database.</p> <p>remote_engine_nbr is invalid, or the applicable span has not yet been added to the BSSP database by bsspadmin.</p> </li> <li> <p>RL-BSO task is already started for this engine.</p> <p>Redundant initiation of tcpbso.</p> </li> <li> <p>RL-BSO can't open TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart tcpbso.</p> </li> <li> <p>RL-BSO can't bind TCP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart tcpbso.</p> </li> </ul>"},{"location":"man/bssp/tcpbso/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bssp/tcpbso/#see-abso","title":"SEE ABSO","text":"<p>bsspadmin(1), tcpbsi(1), udpbso(1)</p>"},{"location":"man/bssp/udpbsi/","title":"NAME","text":"<p>udpbsi - UDP-based best-effort link service input task for BSSP</p>"},{"location":"man/bssp/udpbsi/#synopsis","title":"SYNOPSIS","text":"<p>udpbsi {local_hostname | @}[:local_port_nbr]</p>"},{"location":"man/bssp/udpbsi/#description","title":"DESCRIPTION","text":"<p>udpbsi is a background \"daemon\" task that receives UDP datagrams via a UDP socket bound to local_hostname and local_port_nbr, extracts BSSP PDUs from those datagrams, and passes them to the local BSSP engine. Host name \"@\" signifies that the host name returned by hostname(1) is to be used as the socket's host name.  If not specified, port number defaults to 6001.</p> <p>The link service input task is spawned automatically by bsspadmin in response to the 's' command that starts operation of the BSSP protocol; the text of the command that is used to spawn the task must be provided as a parameter to the 's' command.  The link service input task is terminated by bsspadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/bssp/udpbsi/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udpbsi terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bsspadmin to restart udpbsi.</p> </li> <li> <p>\"1\"</p> <p>udpbsi terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bsspadmin to restart udpbsi.</p> </li> </ul>"},{"location":"man/bssp/udpbsi/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bssp/udpbsi/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bssp/udpbsi/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udpbsi can't initialize BSSP.</p> <p>bsspadmin has not yet initialized BSSP protocol operations.</p> </li> <li> <p>BE-BSI task is already started.</p> <p>Redundant initiation of udpbsi.</p> </li> <li> <p>BE-BSI can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpbsi.</p> </li> <li> <p>BE-BSI can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpbsi.</p> </li> <li> <p>udpbsi can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart udpbsi.</p> </li> </ul>"},{"location":"man/bssp/udpbsi/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bssp/udpbsi/#see-also","title":"SEE ALSO","text":"<p>bsspadmin(1), tcpbsi(1), udpbso(1)</p>"},{"location":"man/bssp/udpbso/","title":"NAME","text":"<p>udpbso - UDP-based best-effort link service output task for BSSP</p>"},{"location":"man/bssp/udpbso/#synopsis","title":"SYNOPSIS","text":"<p>udpbso {remote_engine_hostname | @}[:remote_port_nbr] txbps remote_engine_nbr</p>"},{"location":"man/bssp/udpbso/#description","title":"DESCRIPTION","text":"<p>udpbso is a background \"daemon\" task that extracts BSSP PDUs from the queue of PDUs bound for the indicated remote BSSP engine, encapsulates them in UDP datagrams, and sends those datagrams to the indicated UDP port on the indicated host.  If not specified, port number defaults to 6001.</p> <p>The parameter txbps is optional and kept only for backward compatibility  with older configuration files. If it is included, it's value is ignored. For context, txbps (transmission rate in bits per second) was used for congestion control but  udpbso now derive its data rate from contact graph.</p> <p>When invoking udpbso through bsspadmin using the start or add seat command, the remote_engine_nbr and txbps should be omitted. BSSP admin daemon will automatically provide the remote_engine_nbr.</p> <p>Each \"span\" of BSSP data interchange between the local BSSP engine and a neighboring BSSP engine requires its own best-effort and reliable link service output tasks. All link service output tasks are spawned automatically by bsspadmin in response to the 's' command that starts operation of the BSSP protocol, and they are all terminated by bsspadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/bssp/udpbso/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udpbso terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use bsspadmin to restart udpbso.</p> </li> <li> <p>\"1\"</p> <p>udpbso terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use bsspadmin to restart udpbso.</p> </li> </ul>"},{"location":"man/bssp/udpbso/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/bssp/udpbso/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/bssp/udpbso/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udpbso can't initialize BSSP.</p> <p>bsspadmin has not yet initialized BSSP protocol operations.</p> </li> <li> <p>No such engine in database.</p> <p>remote_engine_nbr is invalid, or the applicable span has not yet been added to the BSSP database by bsspadmin.</p> </li> <li> <p>BE-BSO task is already started for this engine.</p> <p>Redundant initiation of udpbso.</p> </li> <li> <p>BE-BSO can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpbso.</p> </li> <li> <p>BE-BSO can't bind UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udpbso.</p> </li> <li> <p>Segment is too big for UDP BSO.</p> <p>Configuration error: PDUs that are too large for UDP transmission (i.e., larger than 65535 bytes) are being enqueued for udpbso.  Use bsspadmin to change maximum block size for this span.</p> </li> </ul>"},{"location":"man/bssp/udpbso/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/bssp/udpbso/#see-abso","title":"SEE ABSO","text":"<p>bsspadmin(1), tcpbso(1), udpbsi(1)</p>"},{"location":"man/cfdp/","title":"Index of Man Pages","text":"<ul> <li>bpcp</li> <li>bpcpd</li> <li>bputa</li> <li>cfdp</li> <li>cfdpadmin</li> <li>cfdpclock</li> <li>cfdprc</li> <li>cfdptest</li> <li>tcputa</li> </ul>"},{"location":"man/cfdp/bpcp/","title":"NAME","text":"<p>bpcp - A remote copy utility for delay tolerant networks utilizing NASA JPL's Interplanetary Overlay Network (ION)</p>"},{"location":"man/cfdp/bpcp/#synopsis","title":"SYNOPSIS","text":"<p>bpcp [-dqr | -v] [-L bundle_lifetime] [-C custody_on/off]  [-S class_of_service] [host1:]file1 ... [host2:]file2 </p>"},{"location":"man/cfdp/bpcp/#description","title":"DESCRIPTION","text":"<p>bpcp copies files between hosts utilizing NASA JPL's Interplanetary Overlay Network (ION) to provide a delay tolerant network. File copies from local to remote, remote to local, or remote to remote are permitted. bpcp depends on ION to do any authentication or encryption of file transfers. All covergence layers over which bpcp runs MUST be reliable.</p> <p>The options are permitted as follows:</p> <ul> <li>** -d**   Debug output. Repeat for increased verbosity.</li> <li>** -q**   Quiet. Do not output status messages.</li> <li>** -r**   Recursive.</li> <li>** -v**   Display version information.</li> <li> <p>** -L** bundle_lifetime</p> <p>Bundle lifetime in seconds. Default is 86400 seconds (1 day).</p> </li> <li> <p>** -C** BP_custody</p> <p>Acceptable values are ON/OFF,YES/NO,1/0. Default is OFF.</p> </li> <li> <p>** -S** class_of_service</p> <p>Bundle Protocol Class of Service for this transfer. Available options are:</p> <ul> <li>0 Bulk Priority</li> <li>1 Standard Priority</li> <li>2 Expedited Priority</li> </ul> <p>Default is Standard Priority.</p> </li> </ul> <p>bpcp utilizes CFDP to preform the actual file transfers. This has several important implications. First, ION's CFDP implementation requires that reliable convergence layers be used to transfer the data. Second, file permissions are not transferred. Files will be made executable on copy. Third, symbolic links are ignored for local to remote transfers and their target is copied for remote transfers. Fourth, all hosts must be specified using ION's IPN naming scheme.</p> <p>In order to preform remote to local transfers or remote to remote transfers, bpcpd must be running on the remote hosts. However, bpcp should NOT be run simultaneously with bpcpd or cfdptest.</p>"},{"location":"man/cfdp/bpcp/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpcp terminated normally.</p> </li> <li> <p>\"1\"</p> <p>bpcp terminated abnormally. Check console and the ion.log file for error messages.</p> </li> </ul>"},{"location":"man/cfdp/bpcp/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/cfdp/bpcp/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/bpcp/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/bpcp/#see-also","title":"SEE ALSO","text":"<p>bpcpd(1), ion(3), cfdptest(1)</p>"},{"location":"man/cfdp/bpcpd/","title":"NAME","text":"<p>bpcpd - ION Delay Tolerant Networking remote file copy daemon</p>"},{"location":"man/cfdp/bpcpd/#synopsis","title":"SYNOPSIS","text":"<p>bpcpd [-d | -v]</p>"},{"location":"man/cfdp/bpcpd/#description","title":"DESCRIPTION","text":"<p>bpcpd is the daemon for bpcp. Together these programs copy files between hosts utilizing NASA JPL's Interplanetary Overlay Network (ION) to provide a delay tolerant network.</p> <p>The options are permitted as follows:</p> <p>** -d**   Debug output. Repeat for increased verbosity.</p> <p>** -v**   Display version information.</p> <p>bpcpd must be running in order to copy files from this host to another host (i.e. remote to local). Copies in the other direction (local to remote) do not require bpcpd. Further, bpcpd should NOT be run simultaneously with bpcp or cfdptest.</p>"},{"location":"man/cfdp/bpcpd/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bpcpd terminated normally.</p> </li> <li> <p>\"1\"</p> <p>bpcpd terminated abnormally. Check console and the ion.log file for error messages.</p> </li> </ul>"},{"location":"man/cfdp/bpcpd/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/cfdp/bpcpd/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/bpcpd/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/bpcpd/#see-also","title":"SEE ALSO","text":"<p>bpcp(1), ion(3), cfdptest(1)</p>"},{"location":"man/cfdp/bputa/","title":"NAME","text":"<p>bputa - BP-based CFDP UT-layer adapter</p>"},{"location":"man/cfdp/bputa/#synopsis","title":"SYNOPSIS","text":"<p>bputa</p>"},{"location":"man/cfdp/bputa/#description","title":"DESCRIPTION","text":"<p>bputa is a background \"daemon\" task that sends and receives CFDP PDUs encapsulated in DTN bundles.</p> <p>The task is spawned automatically by cfdpadmin in response to the 's' command that starts operation of the CFDP protocol; the text of the command that is used to spawn the task must be provided as a parameter to the 's' command.  The UT-layer daemon is terminated by cfdpadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/cfdp/bputa/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>bputa terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use cfdpadmin to restart bputa.</p> </li> <li> <p>\"1\"</p> <p>bputa terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use cfdpadmin to restart bputa.</p> </li> </ul>"},{"location":"man/cfdp/bputa/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/cfdp/bputa/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/bputa/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>CFDP can't attach to BP.</p> <p>bpadmin has not yet initialized BP protocol operations.</p> </li> <li> <p>CFDP can't open own endpoint.</p> <p>Most likely another bputa task is already running.  Use cfdpadmin to stop CFDP and restart.</p> </li> <li> <p>CFDP can't get Bundle Protocol SAP.</p> <p>Most likely a BP configuration problem.  Use bpadmin to stop BP and restart.</p> </li> <li> <p>bputa can't attach to CFDP.</p> <p>cfdpadmin has not yet initialized CFDP protocol operations.</p> </li> <li> <p>bputa can't dequeue outbound CFDP PDU; terminating.</p> <p>Possible system error.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>bputa can't send PDU in bundle; terminating.</p> <p>Possible system error.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>bputa can't track PDU; terminating.</p> <p>Possible system error.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>bputa bundle reception failed.</p> <p>Possible system error; reception thread terminates.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>bputa can't receive bundle ADU.</p> <p>Possible system error; reception thread terminates.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>bputa can't handle bundle delivery.</p> <p>Possible system error; reception thread terminates.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>bputa can't handle inbound PDU.</p> <p>Possible system error; reception thread terminates.  Check ion.log for additional diagnostic messages.</p> </li> </ul>"},{"location":"man/cfdp/bputa/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/bputa/#see-also","title":"SEE ALSO","text":"<p>cfdpadmin(1), bpadmin(1)</p>"},{"location":"man/cfdp/cfdp/","title":"NAME","text":"<p>cfdp - CCSDS File Delivery Protocol (CFDP) communications library</p>"},{"location":"man/cfdp/cfdp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"cfdp.h\"\n\ntypedef enum\n{\n    CksumTypeUnknown = -1,\n    ModularChecksum = 0,\n    CRC32CChecksum = 2,\n    NullChecksum = 15\n} CfdpCksumType;\n\ntypedef int (*CfdpReaderFn)(int fd, unsigned int *checksum, CfdpCksumType ckType);\n\ntypedef int (*CfdpMetadataFn)(uvast fileOffset, unsigned int recordOffset, unsigned int length, int sourceFileFD, char *buffer);\n\ntypedef enum\n{\n    CfdpCreateFile = 0,\n    CfdpDeleteFile,\n    CfdpRenameFile,\n    CfdpAppendFile,\n    CfdpReplaceFile,\n    CfdpCreateDirectory,\n    CfdpRemoveDirectory,\n    CfdpDenyFile,\n    CfdpDenyDirectory\n} CfdpAction;\n\ntypedef enum\n{\n    CfdpNoEvent = 0,\n    CfdpTransactionInd,\n    CfdpEofSentInd,\n    CfdpTransactionFinishedInd,\n    CfdpMetadataRecvInd,\n    CfdpFileSegmentRecvInd,\n    CfdpEofRecvInd,\n    CfdpSuspendedInd,\n    CfdpResumedInd,\n    CfdpReportInd,\n    CfdpFaultInd,\n    CfdpAbandonedInd\n} CfdpEventType;\n\ntypedef struct\n{\n    char            *sourceFileName;\n    char            *destFileName;\n    MetadataList    messagesToUser;\n    MetadataList    filestoreRequests;\n    CfdpHandler     *faultHandlers;\n    int             unacknowledged;\n    unsigned int    flowLabelLength;\n    unsigned char   *flowLabel;\n    int             recordBoundsRespected;\n    int             closureRequested;\n} CfdpProxyTask;\n\ntypedef struct\n{\n    char            *directoryName;\n    char            *destFileName;\n} CfdpDirListTask;\n\n[see description for available functions]\n</code></pre>"},{"location":"man/cfdp/cfdp/#description","title":"DESCRIPTION","text":"<p>The cfdp library provides functions enabling application software to use CFDP to send and receive files.  It conforms to the Class 1 (Unacknowledged) service class defined in the CFDP Blue Book and includes implementations of several standard CFDP user operations.</p> <p>In the ION implementation of CFDP, the CFDP notion of entity ID is taken to be identical to the BP (CBHE) notion of DTN node number.</p> <p>CFDP entity and transaction numbers may be up to 64 bits in length.  For portability to 32-bit machines, these numbers are stored in the CFDP state machine as structures of type CfdpNumber.</p> <p>To simplify the interface between CFDP the user application without risking storage leaks, the CFDP-ION API uses MetadataList objects.  A MetadataList is a specially formatted SDR list of user messages, filestore requests, or filestore responses.  During the time that a MetadataList is pending processing via the CFDP API, but is not yet (or is no longer) reachable from any FDU object, a pointer to the list is appended to one of the lists of MetadataList objects in the CFDP non-volatile database.  This assures that any unplanned termination of the CFDP daemons won't leave any SDR lists unreachable -- and therefore un-recyclable -- due to the absence of references to those lists.  Restarting CFDP automatically purges any unused MetadataLists from the CFDP database.  The \"user data\" variable of the MetadataList itself is used to implement this feature: while the list is reachable only from the database root, its user data variable points to the database root list from which it is referenced; while the list is attached to a File Delivery Unit, its user data is null. </p> <p>By default, CFDP transmits the data in a source file in segments of fixed size. The user application can override this behavior at the time transmission of a file is requested, by supplying a file reader callback function that reads the file -- one byte at a time -- until it detects the end of a \"record\" that has application significance.  Each time CFDP calls the reader function, the function must return the length of one such record (which must be no greater than 65535).</p> <p>When CFDP is used to transmit a file, a 32-bit checksum must be provided in the \"EOF\" PDU to enable the receiver of the file to assure that it was not corrupted in transit.  When an application-specific file reader function is supplied, that function is responsible for updating the computed checksum as it reads each byte of the file; a CFDP library function is provided for this purpose.  Two types of file checksums are supported: a simple modular checksum or a 32-bit CRC.  The checksum type must be passed through to the CFDP checksum computation function, so it must be provided by (and thus to) the file reader function.</p> <p>Per-segment metadata may be provided by the user application.  To enable this, upon formation of each file data segment, CFDP will invoke the user-provided per-segment metadata composition callback function (if any), a function conforming to the CfdpMetadataFn type definition.  The callback will be passed the offset of the segment within the file, the segment's offset within the current record (as applicable), the length of the segment, an open file descriptor for the source file (in case the data must be read in order to construct the metadata), and a 63-byte buffer in which to place the new metadata.  The callback function must return the length of metadata to attach to the file data segment PDU (may be zero) or -1 in the event of a general system failure.</p> <p>The return value for each CFDP \"request\" function (put, cancel, suspend, resume, report) is a reference number that enables \"events\" obtained by calling cfdp_get_event() to be matched to the requests that caused them. Events with reference number set to zero are events that were caused by autonomous CFDP activity, e.g., the reception of a file data segment.</p> <ul> <li> <p>int cfdp_attach()</p> <p>Attaches the application to CFDP functionality on the local computer.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int cfdp_entity_is_started()</p> <p>Returns 1 if the local CFDP entity has been started and not yet stopped, 0 otherwise.</p> </li> <li> <p>void cfdp_detach()</p> <p>Terminates all access to CFDP functionality on the local computer.</p> </li> <li> <p>void cfdp_compress_number(CfdpNumber *toNbr, uvast from)</p> <p>Converts an unsigned vast number into a CfdpNumber structure, e.g., for use when invoking the cfdp_put() function.</p> </li> <li> <p>void cfdp_decompress_number(uvast toNbr, CfdpNumber *from)</p> <p>Converts a numeric value in a CfdpNumber structure to an unsigned vast integer.</p> </li> <li> <p>void cfdp_update_checksum(unsigned char octet, uvast *offset, unsigned int *checksum, CfdpCksumType ckType)</p> <p>For use by an application-specific file reader callback function, which must pass to cfdp_update_checksum() the value of each byte (octet) it reads. offset must be octet's displacement in bytes from the start of the file.  The checksum pointer is provided to the reader function by CFDP.</p> </li> <li> <p>MetadataList cfdp_create_usrmsg_list()</p> <p>Creates a non-volatile linked list, suitable for containing messages-to-user that are to be presented to cfdp_put().</p> </li> <li> <p>int cfdp_add_usrmsg(MetadataList list, unsigned char *text, int length)</p> <p>Appends the indicated message-to-user to list.</p> </li> <li> <p>int cfdp_get_usrmsg(MetadataList list, unsigned char *textBuf, int *length)</p> <p>Removes from list the first of the remaining messages-to-user contained in the list and delivers its text and length.  When the last message in the list is delivered, destroys the list.</p> </li> <li> <p>void cfdp_destroy_usrmsg_list(MetadataList *list)</p> <p>Removes and destroys all messages-to-user in list and destroys the list.</p> </li> <li> <p>MetadataList cfdp_create_fsreq_list()</p> <p>Creates a non-volatile linked list, suitable for containing filestore requests that are to be presented to cfdp_put().</p> </li> <li> <p>int cfdp_add_fsreq(MetadataList list, CfdpAction action, char *firstFileName, char *seconfdFIleName)</p> <p>Appends the indicated filestore request to list.</p> </li> <li> <p>int cfdp_get_fsreq(MetadataList list, CfdpAction *action, char *firstFileNameBuf, char *secondFileNameBuf)</p> <p>Removes from list the first of the remaining filestore requests contained in the list and delivers its action code and file names.  When the last request in the list is delivered, destroys the list.</p> </li> <li> <p>void cfdp_destroy_fsreq_list(MetadataList *list)</p> <p>Removes and destroys all filestore requests in list and destroys the list.</p> </li> <li> <p>int cfdp_get_fsresp(MetadataList list, CfdpAction *action, int *status, char *firstFileNameBuf, char *secondFileNameBuf, char *messageBuf)</p> <p>Removes from list the first of the remaining filestore responses contained in the list and delivers its action code, status, file names, and message. When the last response in the list is delivered, destroys the list.</p> </li> <li> <p>void cfdp_destroy_fsresp_list(MetadataList *list)</p> <p>Removes and destroys all filestore responses in list and destroys the list.</p> </li> <li> <p>int cfdp_read_space_packets(int fd, unsigned int *checksum)</p> <p>This is a standard \"reader\" function that segments the source file on CCSDS space packet boundaries.  Multiple small packets may be aggregated into a single file data segment.</p> </li> <li> <p>int cfdp_read_text_lines(int fd, unsigned int *checksum)</p> <p>This is a standard \"reader\" function that segments a source file of text lines on line boundaries.</p> </li> <li> <p>int cfdp_put(CfdpNumber *destinationEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpMetadataFn metadataFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpTransactionId *transactionId)</p> <p>Sends the file identified by sourceFileName to the CFDP entity identified by destinationEntityNbr.  destinationFileName is used to indicate the name by which the file will be catalogued upon arrival at its final destination; if NULL, the destination file name defaults to sourceFileName.  If  sourceFileName is NULL, it is assumed that the application is requesting transmission of metadata only (as discussed below) and destinationFileName is ignored.  Note that both sourceFileName and destinationFileName are interpreted as path names, i.e., directory paths may be indicated in either or both.  The syntax of path names is opaque to CFDP; the syntax of sourceFileName must conform to the path naming syntax of the source entity's file system and the syntax of destinationFileName must conform to the path naming syntax of the destination entity's file system.</p> <p>The byte array identified by utParms, if non-NULL, is interpreted as transmission control information that is to be passed on to the UT layer.  The nominal UT layer for ION's CFDP being Bundle Protocol, the utParms array is normally a pointer to a structure of type BpUtParms; see the bp man page for a discussion of the parameters in that structure. </p> <p>closureLatency is the length of time following transmission of the EOF PDU within which a responding Transaction Finish PDU is expected.  If no Finish PDU is requested, this parameter value should be zero.</p> <p>messagesToUser and filestoreRequests, where non-zero, must be the addresses of non-volatile linked lists (that is, linked lists in ION's SDR database) of CfdpMsgToUser and CfdpFilestoreRequest objects identifying metadata that are intended to accompany the transmitted file.  Note that this metadata may accompany a file of zero length (as when sourceFileName is NULL as noted above) -- a transmission of metadata only.</p> <p>On success, the function populates *transactionID with the source entity ID and the transaction number assigned to this transmission and returns the request number identifying this \"put\" request.  The transaction ID may be used to suspend, resume, cancel, or request a report on the progress of this transmission.  cfdp_put() returns -1 on any error.</p> </li> <li> <p>int cfdp_cancel(CfdpTransactionId *transactionId)</p> <p>Cancels transmission or reception of the indicated transaction.  Note that, since the ION implementation of CFDP is Unacknowledged, cancellation of a file transmission may have little effect.  Returns request number on success, -1 on any error.</p> </li> <li> <p>int cfdp_suspend(CfdpTransactionId *transactionId)</p> <p>Suspends transmission of the indicated transaction.  Note that, since the ION implementation of CFDP is Unacknowledged, suspension of a file transmission may have little effect.  Returns request number on success, -1 on any error.</p> </li> <li> <p>int cfdp_resume(CfdpTransactionId *transactionId)</p> <p>Resumes transmission of the indicated transaction.  Note that, since the ION implementation of CFDP is Unacknowledged, resumption of a file transmission may have little effect.  Returns request number on success, -1 on any error.</p> </li> <li> <p>int cfdp_report(CfdpTransactionId *transactionId)</p> <p>Requests issuance of a report on the transmission or reception progress of the indicated transaction.  The report takes the form of a character string that is returned in a CfdpEvent structure; use cfdp_get_event() to receive the event (which may be matched to the request by request number).  Returns request number on success, 0 if transaction is unknown, -1 on any error.</p> </li> <li> <p>int cfdp_get_event(CfdpEventType *type, time_t *time, int *reqNbr, CfdpTransactionId *transactionId, char *sourceFileNameBuf, char *destFileNameBuf, uvast *fileSize, MetadataList *messagesToUser, uvast *offset, unsigned int *length, CfdpCondition *condition, uvast *progress, CfdpFileStatus *fileStatus, CfdpDeliveryCode *deliveryCode, CfdpTransactionId *originatingTransactionId, char *statusReportBuf, MetadataList *filestoreResponses);</p> <p>Populates return value fields with data from the oldest CFDP event not yet delivered to the application.  </p> <p>cfdp_get_event() always blocks indefinitely until an CFDP processing event is delivered or the function is interrupted by an invocation of cfdp_interrupt().</p> <p>On application error, returns zero but sets errno to EINVAL.  Returns -1 on system failure, zero otherwise.</p> </li> <li> <p>void cfdp_interrupt()</p> <p>Interrupts an cfdp_get_event() invocation.  This function is designed to be called from a signal handler.</p> </li> <li> <p>int cfdp_rput(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpNumber *beneficiaryEntityNbr, CfdpProxyTask *proxyTask, CfdpTransactionId *transactionId)</p> <p>Sends to the indicated respondent entity a \"proxy\" request to perform a file transmission.  The transmission is to be subject to the configuration values in proxyTask and the destination of the file is to be the entity identified by beneficiaryEntityNbr.</p> </li> <li> <p>int cfdp_rput_cancel(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpTransactionId *rputTransactionId, CfdpTransactionId *transactionId)</p> <p>Sends to the indicated respondent entity a request to cancel a prior \"proxy\" file transmission request as identified by rputTransactionId, which is the value of transactionId that was returned by that earlier proxy transmission request.</p> </li> <li> <p>int cfdp_get(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpProxyTask *proxyTask, CfdpTransactionId *transactionId)</p> <p>Same as cfdp_rput except that beneficiaryEntityNbr is omitted; the local entity is the implicit beneficiary of the request.</p> </li> <li> <p>int cfdp_rls(CfdpNumber *respondentEntityNbr, unsigned int utParmsLength, unsigned char *utParms, char *sourceFileName, char *destFileName, CfdpReaderFn readerFn, CfdpHandler *faultHandlers, unsigned int flowLabelLength, unsigned char *flowLabel, unsigned int closureLatency, MetadataList messagesToUser, MetadataList filestoreRequests, CfdpDirListTask *dirListTask, CfdpTransactionId *transactionId)</p> <p>Sends to the indicated respondent entity a request to prepare a directory listing, save that listing in a file, and send it to the local entity.  The request is subject to the configuration values in dirListTask. </p> </li> <li> <p>int cfdp_preview(CfdpTransactionId *transactionId, uvast offset, unsigned int length, char *buffer);</p> <p>This function is provided to enable the application to get an advance look at the content of a file that CFDP has not yet fully received.  Reads length bytes starting at offset bytes from the start of the file that is the destination file of the transaction identified by transactionID, into buffer.  On user error (transaction is nonexistent or is outbound, or offset is beyond the end of file) returns 0.  On system failure, returns -1. Otherwise returns number of bytes read.</p> </li> <li> <p>int cfdp_map(CfdpTransactionId *transactionId, unsigned int *extentCount, CfdpExtent *extentsArray);</p> <p>This function is provided to enable the application to report on the portions of a partially-received file that have been received and written.  Lists the received continuous data extents in the destination file of the transaction identified by transactionID.  The extents (offset and length) are returned in the elements of extentsArray; the number of extents returned in the array is the total number of continuous extents received so far, or extentCount, whichever is less.  The total number of extents received so far is returned as the new value of extentCount.  On system failure, returns -1.  Otherwise returns 0.</p> </li> </ul>"},{"location":"man/cfdp/cfdp/#see-also","title":"SEE ALSO","text":"<p>cfdpadmin(1), cfdprc(5)</p>"},{"location":"man/cfdp/cfdpadmin/","title":"NAME","text":"<p>cfdpadmin - ION's CCSDS File Delivery Protocol (CFDP) administration interface</p>"},{"location":"man/cfdp/cfdpadmin/#synopsis","title":"SYNOPSIS","text":"<p>cfdpadmin [ commands_filename | . | ! ]</p>"},{"location":"man/cfdp/cfdpadmin/#description","title":"DESCRIPTION","text":"<p>cfdpadmin configures, starts, manages, and stops CFDP operations for the local ION node.</p> <p>It operates in response to CFDP configuration commands found in the file commands_filename, if provided; if not, cfdpadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to cfdpadmin -- that is, the ION node's cfdpclock task  and UT layer service task (nominally bputa) are stopped. If commands_filename is an exclamation point (!), that effect is reversed: the ION node's cfdpclock task and UT layer service task (nominally bputa) are restarted.</p> <p>The format of commands for commands_filename can be queried from cfdpadmin with the 'h' or '?' commands at the prompt.  The commands are documented in cfdprc(5).</p>"},{"location":"man/cfdp/cfdpadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of CFDP administration.</p> </li> </ul>"},{"location":"man/cfdp/cfdpadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>cfdpadmin</p> <p>Enter interactive CFDP configuration command entry mode.</p> </li> <li> <p>cfdpadmin host1.cfdprc</p> <p>Execute all configuration commands in host1.cfdprc, then terminate immediately.</p> </li> <li> <p>cfdpadmin .</p> <p>Stop all CFDP operations on the local node.</p> </li> </ul>"},{"location":"man/cfdp/cfdpadmin/#files","title":"FILES","text":"<p>See cfdprc(5) for details of the CFDP configuration commands.</p>"},{"location":"man/cfdp/cfdpadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/cfdpadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the cfdprc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to cfdpadmin.  Otherwise cfdpadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>cfdpadmin can't attach to ION.</p> <p>There is no SDR data store for cfdpadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause cfdpadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see cfdprc(5) for details.</p>"},{"location":"man/cfdp/cfdpadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/cfdpadmin/#see-also","title":"SEE ALSO","text":"<p>cfdprc(5)</p>"},{"location":"man/cfdp/cfdpclock/","title":"NAME","text":"<p>cfdpclock - CFDP daemon task for managing scheduled events</p>"},{"location":"man/cfdp/cfdpclock/#synopsis","title":"SYNOPSIS","text":"<p>cfdpclock</p>"},{"location":"man/cfdp/cfdpclock/#description","title":"DESCRIPTION","text":"<p>cfdpclock is a background \"daemon\" task that periodically performs scheduled CFDP activities.  It is spawned automatically by cfdpadmin in response to the 's' command that starts operation of the CFDP protocol, and it is terminated by cfdpadmin in response to an 'x' (STOP) command.</p> <p>Once per second, cfdpclock takes the following action:</p> <p>First it scans all inbound file delivery units (FDUs).  For each one whose check timeout deadline has passed, it increments the check timeout count and resets the check timeout deadline.  For each one whose check timeout count exceeds the limit configured for this node, it invokes the Check Limit Reached fault handling procedure.</p> <p>Then it scans all outbound FDUs.  For each one that has been Canceled, it cancels all extant PDU bundles and sets transmission progress to the size of the file, simulating the completion of transmission.  It destroys each outbound FDU whose transmission is completed.</p>"},{"location":"man/cfdp/cfdpclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>cfdpclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use cfdpadmin to restart cfdpclock.</p> </li> <li> <p>\"1\"</p> <p>cfdpclock was unable to attach to CFDP protocol operations, probably because cfdpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/cfdp/cfdpclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/cfdp/cfdpclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/cfdpclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>cfdpclock can't initialize CFDP.</p> <p>cfdpadmin has not yet initialized CFDP protocol operations.</p> </li> <li> <p>Can't dispatch events.</p> <p>An unrecoverable database error was encountered.  cfdpclock terminates.</p> </li> <li> <p>Can't manage links.</p> <p>An unrecoverable database error was encountered.  cfdpclock terminates.</p> </li> </ul>"},{"location":"man/cfdp/cfdpclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/cfdpclock/#see-also","title":"SEE ALSO","text":"<p>cfdpadmin(1)</p>"},{"location":"man/cfdp/cfdprc/","title":"NAME","text":"<p>cfdprc - CCSDS File Delivery Protocol management commands file</p>"},{"location":"man/cfdp/cfdprc/#description","title":"DESCRIPTION","text":"<p>CFDP management commands are passed to cfdpadmin either in a file of text lines or interactively at cfdpadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the CFDP management commands are described below.</p>"},{"location":"man/cfdp/cfdprc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by cfdpadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1</p> <p>The initialize command.  Until this command is executed, CFDP is not in operation on the local ION node and most cfdpadmin commands will fail.</p> </li> <li> <p>a entity&gt; &lt;entity nbr&gt;   &lt;rtt&gt; &lt;incstype&gt; &lt;outcstype&gt; <p>The add entity command.  This command will add a new remote CFDP entity to the CFDP management information base.  Valid UT protocol names are bp and tcp.  Endpoint name is EID for bp, socket spec (IP address:port number) for tcp.  RTT is round-trip time, used to set acknowledgement timers. incstype is the type of checksum to use when validating data received from this entity; valid values are 0 (modular checksum), 2 (CRC32C), and 15 (the null checksum). outcstype is the type of checksum to use when computing the checksum for transmitting data to this entity.</p> <li> <p>c entity&gt; &lt;entity nbr&gt;   &lt;rtt&gt; &lt;incstype&gt; &lt;outcstype&gt; <p>The change entity command.  This command will change information associated with an existing entity in the CFDP management information base.</p> <li> <p>d entity&gt; &lt;entity nbr&gt;</p> <p>The delete entity command.  This command will delete an existing entity from the CFDP management information base.</p> </li> <li> <p>i [&lt;entity nbr&gt;]</p> <p>The info command.  When entity nbr is provided, this command will print information about the indicated entity.  Otherwise this command will print information about the current state of the local CFDP entity, including the current settings of all parameters that can be managed as described below.</p> </li> <li> <p>s 'UTS command'</p> <p>The start command.  This command starts the UT-layer service task for the local CFDP entity.</p> </li> <li> <p>m discard { 0 | 1 }</p> <p>The manage discard command.  This command enables or disables the discarding of partially received files upon cancellation of a file reception. The default value is 1;</p> </li> <li> <p>m requirecrc { 0 | 1 }</p> <p>The manage CRC data integrity command.  This command enables or disables the attachment of CRCs to all PDUs issued by the local CFDP entity.  The default value is 0;</p> </li> <li> <p>m fillchar file_fill_character</p> <p>The manage fill character command.  This command establishes the fill character to use for the portions of an incoming file that have not yet been received.  The fill character is normally expressed in hex, e.g.,  the default value is 0xaa.</p> </li> <li> <p>m ckperiod check_cycle_period</p> <p>The manage check interval command.  This command establishes the number of seconds following reception of the EOF PDU -- or following expiration of a prior check cycle -- after which the local CFDP will check for  completion of a file that is being received.  Default value is 86400 (i.e., one day).</p> </li> <li> <p>m maxtimeouts check_cycle_limit</p> <p>The manage check limit command.  This command establishes the number of check cycle expirations after which the local CFDP entity will invoke the check cycle expiration fault handler upon expiration of a check cycle. Default value is 7.</p> </li> <li> <p>m maxevents event_queue_limit</p> <p>The manage event queue limit command.  This command establishes the maximum number of unread service indications (CFDP \"events\") that may be queued up for delivery at any time.  When the events queue length exceeds this figure, events are simply deleted (in decreasing age order, oldest first) until the the limit is no longer exceeded.  Default value is 20.</p> </li> <li> <p>m maxtrnbr max_transaction_number</p> <p>The manage transaction numbers command.  This command establishes the largest possible transaction number used by the local CFDP entity for file transmission transactions.  After this number has been used, the  transaction number assigned to the next transaction will be 1.  The default value is 999999999.</p> </li> <li> <p>m segsize max_bytes_per_file_data_segment</p> <p>The manage segment size command.  This command establishes the number of bytes of file data in each file data PDU transmitted by the local CFDP entity in the absence of an application-supplied reader function.  The default value is 65000.</p> </li> <li> <p>m inactivity inactivity_period</p> <p>The manage inactivity period command. This command establishes the number of seconds that a CFDP file transfer is allowed to go idle before being canceled for inactivity. The default is one day.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops the UT-layer service task for the local CFDP engine.</p> </li> <li> <p>w { 0 | 1  | &lt;activity_spec&gt; }</p> <p>The CFDP watch command.  This command enables and disables production of a continuous stream of user-selected CFDP activity indication characters.  A watch parameter of \"1\" selects all CFDP activity indication characters; \"0\" de-selects all CFDP activity indication characters; any other activity_spec such as \"p\" selects all activity indication characters in the string, de-selecting all others.  CFDP will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>p   CFDP PDU transmitted</p> <p>q   CFDP PDU received</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li>"},{"location":"man/cfdp/cfdprc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>m requirecrc 1</p> <p>Initiates attachment of CRCs to all subsequently issued CFDP PDUs.</p> </li> </ul>"},{"location":"man/cfdp/cfdprc/#see-also","title":"SEE ALSO","text":"<p>cfdpadmin(1), bputa(1)</p>"},{"location":"man/cfdp/cfdptest/","title":"NAME","text":"<p>cfdptest - CFDP test shell for ION</p>"},{"location":"man/cfdp/cfdptest/#synopsis","title":"SYNOPSIS","text":"<p>cfdptest [ commands_filename ]</p>"},{"location":"man/cfdp/cfdptest/#description","title":"DESCRIPTION","text":"<p>cfdptest provides a mechanism for testing CFDP file transmission.  It can be used in either scripted or interactive mode.  All bundles containing CFDP PDUs are sent with custody transfer requested and with all bundle status reporting disabled.</p> <p>When scripted with commands_filename, cfdptest operates in response to CFDP management commands contained in the provided commands file.  Each line of text in the file is interpreted as a single command comprising several tokens: a one-character command code and, in most cases, one or more command arguments of one or more characters.  The commands configure and initiate CFDP file transmission operations.</p> <p>If no file is specified, cfdptest instead offers the user an interactive \"shell\" for command entry.  cfdptest prints a prompt string (\": \") to stdout, accepts strings of text from stdin, and interprets each string as a command.</p> <p>The supported cfdptest commands (whether interactive or scripted) are as follows:</p> <ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>h</p> <p>An alternate form of the help command.</p> </li> <li> <p>z [&lt;number of seconds to pause&gt;]</p> <p>The pause command.  When cfdptest is running in interactive mode, this command causes the console input processing thread to pause the indicated number of seconds (defaulting to 1) before processing the next command.  This is provided for use in test scripting.</p> </li> <li> <p>d &lt;destination CFDP entity ID number&gt;</p> <p>The destination command.  This command establishes the CFDP entity to which the next file transmission operation will be directed.  CFDP entity numbers in ION are, by convention, the same as BP node numbers.</p> </li> <li> <p>f &lt;source file path name&gt;</p> <p>The from command.  This command identifies the file that will be transmitted when the next file transmission operation is commanded.</p> </li> <li> <p>t &lt;destination file path name&gt;</p> <p>The to command.  This command provides the name for the file that will be created at the receiving entity when the next file transmission operation is commanded.</p> </li> <li> <p>l &lt;lifetime in seconds&gt;</p> <p>The time-to-live command.  This command establishes the time-to-live for all subsequently issued bundles containing CFDP PDUs.  If not specified, the default value 86400 (1 day) is used.</p> </li> <li> <p>p &lt;priority&gt;</p> <p>The priority command.  This command establishes the priority (class of service) for all subsequently issued bundles containing CFDP PDUs.  Valid values are 0, 1, and 2.  If not specified, priority is 1.</p> </li> <li> <p>o &lt;ordinal&gt;</p> <p>The ordinal command.  This command establishes the \"ordinal\" (sub-priority within priority 2) for all subsequently issued bundles containing CFDP PDUs. Valid values are 0-254.  If not specified, ordinal is 0.</p> </li> <li> <p>m &lt;mode&gt;</p> <p>The mode command.  This command establishes the transmission mode (\"best-effort\" or assured) for all subsequently issued bundles containing CFDP PDUs.  Valid values are 0 (assured, reliable, with reliability provided by a reliable DTN convergence layer protocol), 1 (best-effort, unreliable), and 2 (assured, reliable, but with reliability provided by BP custody transfer).  If not specified, transmission mode is 0.</p> </li> <li> <p>a &lt;latency in seconds&gt;</p> <p>The closure latency command.  This command establishes the transaction closure latency for all subsequent file transmission operations.  When it is set to zero, the file transmission is \"open loop\" and the CFDP transaction at the sending entity finishes when the EOF is sent.  Otherwise, the receiving CFDP entity is being asked to send a \"Finished\" PDU back to the sending CFDP entity when the transaction finishes at the receiving entity. Normally the transaction finishes at the sending entity only when that Finished PDU is received.  However, when closure latency seconds elapse following transmission of the EOF PDU prior to receipt of the Finished PDU, the transaction finishes immediately with a Check Timer fault.</p> </li> <li> <p>n { 0 | 1 }</p> <p>The segment metadata command.  This command controls the insertion of sample segment metadata -- a string representation of the current time -- in every file data segment PDU.  A value of 1 enables segment metadata insertion, while a value of 0 disables it.</p> </li> <li> <p>g &lt;srrflags&gt;</p> <p>The srrflags command.  This command establishes the BP status reporting that will be requested for all subsequently issued bundles containing CFDP PDUs.  srrflags must be a status reporting flags string as defined for bptrace(1): a sequence of status report flags, separated by commas, with no embedded whitespace.  Each status report flag must be one of the following: rcv, ct, fwd, dlv, del.</p> </li> <li> <p>c &lt;criticality&gt;</p> <p>The criticality command.  This command establishes the criticality for all subsequently issued bundles containing CFDP PDUs.  Valid values are 0 (not critical) and 1 (critical).  If not specified, criticality is 0.</p> </li> <li> <p>r &lt;action code nbr&gt; &lt;first path name&gt; &lt;second path name&gt;</p> <p>The filestore request command.  This command adds a filestore request to the metadata that will be issued when the next file transmission operation is commanded.  Action code numbers are:</p> <ul> <li>0 = create file</li> <li>1 = delete file</li> <li>2 = rename file</li> <li>3 = append file</li> <li>4 = replace file</li> <li>5 = create directory</li> <li>6 = remove directory</li> <li>7 = deny file</li> <li>8 = deny directory</li> </ul> </li> <li> <p>u '&lt;message text&gt;'</p> <p>The user message command.  This command adds a user message to the metadata that will be issued when the next file transmission operation is commanded.</p> </li> <li> <p>&amp;</p> <p>The send command.  This command initiates file transmission as configured by the most recent preceding d, f, t, and a commands.</p> </li> <li> <p>|</p> <p>The get command.  This command causes a request for file transmission to the local node, subject to the parameters provided by the most recent preceding f, t, and a commands, to be sent to the entity identified by the most recent preceding d command.</p> <p>NOTE that 'get' in CFDP is implemented very differently from 'send'.  The 'send' operation is a native element of the CFDP protocol. The 'get' operation is implemented by sending to the responding entity a standardized sequence of message-to-user messages in a Metadata PDU - the user application at the responding entity receives those messages and initiates a 'send' to accomplish transmission of the file.  This means that 'send' can succeed even if no user application is running at the remote node, but 'get' cannot.</p> </li> <li> <p>^</p> <p>The cancel command.  This command cancels the most recently initiated file transmission.</p> </li> <li> <p>%</p> <p>The suspend command.  This command suspends the most recently initiated file transmission.</p> </li> <li> <p>$</p> <p>The resume command.  This command resumes the most recently initiated file transmission.</p> </li> <li> <p>#</p> <p>The report command.  This command reports on the most recently initiated file transmission.</p> </li> <li> <p>q</p> <p>The quit command.  Terminates the cfdptest program.</p> </li> </ul> <p>cfdptest in interactive mode also spawns a CFDP event handling thread.  The event thread receives CFDP service indications and simply prints lines of text to stdout to announce them.</p> <p>NOTE that when cfdptest runs in scripted mode it does not spawn an event handling thread, which makes it possible for the CFDP events queue to grow indefinitely unless some other task consumes and reports on the events. One simple solution is to run an interactive cfdptest task in background, simply to keep the event queue cleared, while scripted non-interactive cfdptest tasks are run in the foreground.</p>"},{"location":"man/cfdp/cfdptest/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>cfdptest has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> </ul>"},{"location":"man/cfdp/cfdptest/#files","title":"FILES","text":"<p>See above for details on valid commands_filename commands.</p>"},{"location":"man/cfdp/cfdptest/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/cfdptest/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by cfdptest are written to the ION log file ion.log.</p> <ul> <li> <p>Can't open command file...</p> <p>The file identified by commands_filename doesn't exist.</p> </li> <li> <p>cfdptest can't initialize CFDP.</p> <p>cfdpadmin has not yet initialized CFDP operations.</p> </li> <li> <p>Can't put FDU.</p> <p>The attempt to initiate file transmission failed.  See the ION log for additional diagnostic messages from the CFDP library.</p> </li> <li> <p>Failed getting CFDP event.</p> <p>The attempt to retrieve a CFDP service indication failed.  See the ION log for additional diagnostic messages from the CFDP library.</p> </li> </ul>"},{"location":"man/cfdp/cfdptest/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/cfdptest/#see-also","title":"SEE ALSO","text":"<p>cfdpadmin(1), cfdp(3)</p>"},{"location":"man/cfdp/tcputa/","title":"NAME","text":"<p>tcputa - TCP/IP-based CFDP UT-layer adapter</p>"},{"location":"man/cfdp/tcputa/#synopsis","title":"SYNOPSIS","text":"<p>tcputa</p>"},{"location":"man/cfdp/tcputa/#description","title":"DESCRIPTION","text":"<p>tcputa is a background \"daemon\" task that sends and receives CFDP PDUs via a TCP/IP socket.</p> <p>The task is spawned automatically by cfdpadmin in response to the 's' command that starts operation of the CFDP protocol; the text of the command that is used to spawn the task must be provided as a parameter to the 's' command.  The UT-layer daemon is terminated by cfdpadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/cfdp/tcputa/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcputa terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use cfdpadmin to restart tcputa.</p> </li> <li> <p>\"1\"</p> <p>tcputa terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use cfdpadmin to restart tcputa.</p> </li> </ul>"},{"location":"man/cfdp/tcputa/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/cfdp/tcputa/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/cfdp/tcputa/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcputa can't attach to CFDP.</p> <p>cfdpadmin has not yet initialized CFDP protocol operations.</p> </li> <li> <p>tcputa can't dequeue outbound CFDP PDU; terminating.</p> <p>Possible system error.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>tcputa can't track PDU; terminating.</p> <p>Possible system error.  Check ion.log for additional diagnostic messages.</p> </li> <li> <p>tcputa can't handle inbound PDU.</p> <p>Possible system error; reception thread terminates.  Check ion.log for additional diagnostic messages.</p> </li> </ul>"},{"location":"man/cfdp/tcputa/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/cfdp/tcputa/#see-also","title":"SEE ALSO","text":"<p>cfdpadmin(1), bpadmin(1)</p>"},{"location":"man/dgr/","title":"Index of Man Pages","text":"<ul> <li>dgr</li> <li>dgr2file</li> <li>file2dgr</li> </ul>"},{"location":"man/dgr/dgr/","title":"NAME","text":"<p>dgr - Datagram Retransmission system library</p>"},{"location":"man/dgr/dgr/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"dgr.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/dgr/dgr/#description","title":"DESCRIPTION","text":"<p>The DGR library is an alternative implementation of a subset of LTP, intended for use over UDP/IP in the Internet; unlike ION's canonical LTP implementation it includes a congestion control mechanism that interprets LTP block transmission failure as an indication of network congestion (not data corruption) and reduces data transmission rate in response.</p> <p>As such, DGR differs from many reliable-UDP systems in two main ways:</p> <pre><code>    It uses adaptive timeout interval computation techniques\n    borrowed from TCP to try to avoid introducing congestion\n    into the network.\n\n    It borrows the concurrent-session model of transmission\n    from LTP (and ultimately from CFDP), rather than waiting\n    for one datagram to be acknowledged before sending the next,\n    to improve bandwidth utilization.\n</code></pre> <p>At this time DGR is interoperable with other implementations of LTP only when each block it receives is transmitted in a single LTP data segment encapsulated in a single UDP datagram.  More complex LTP behavior may be implemented in the future.</p> <ul> <li> <p>int dgr_open(uvast ownEngineId, unsigned int clientSvcId, unsigned short ownPortNbr, unsigned int ownIpAddress, char *memmgrName, Dgr *dgr, DgrRC *rc)</p> <p>Establishes the application's access to DGR communication service.</p> <p>ownEngineId is the sending LTP engine ID that will characterize segments issued by this DGR service access point.  In order to prevent erroneous system behavior, never assign the same LTP engine ID to any two interoperating DGR SAPs.</p> <p>clientSvcId identifies the LTP client service to which all LTP segments issued by this DGR service access point will be directed.</p> <p>ownPortNbr is the port number to use for DGR service.  If zero, a system-assigned UDP port number is used.</p> <p>ownIpAddress is the Internet address of the network interface to use for DGR service.  If zero, this argument defaults to the address of the interface identified by the local machine's host name.</p> <p>memmgrName is the name of the memory manager (see memmgr(3)) to use for dynamic memory management in DGR.  If NULL, defaults to the standard system malloc() and free() functions.</p> <p>dgr is the location in which to store the service access pointer that must be supplied on subsequent DGR function invocations.</p> <p>rc is the location in which to store the DGR return code resulting from the attempt to open this service access point (always DgrOpened).</p> <p>On any failure, returns -1.  On success, returns zero.</p> </li> <li> <p>void dgr_getsockname(Dgr dgr, unsigned short *portNbr, unsigned int *ipAddress)</p> <p>States the port number and IP address of the UDP socket used for this DGR service access point.</p> </li> <li> <p>void dgr_close(Dgr dgr)</p> <p>Reverses dgr_open(), releasing resources where possible.</p> </li> <li> <p>int dgr_send(Dgr dgr, unsigned short toPortNbr, unsigned int toIpAddress, int notificationFlags, char *content, int length, DgrRC *rc)</p> <p>Sends the indicated content, of length as indicated, to the remote DGR service access point identified by toPortNbr and toIpAddress.  The message will be retransmitted as necessary until either it is acknowledged or DGR determines that it cannot be delivered.</p> <p>notificationFlags, if non-zero, is the logical OR of the notification behaviors requested for this datagram.  Available behaviors are DGR_NOTE_FAILED (a notice of datagram delivery failure will issued if delivery of the datagram fails) and DGR_NOTE_ACKED (a notice of datagram delivery success will be issued if delivery of the datagram succeeds).  Notices are issued via dgr_receive() that is, the thread that calls dgr_receive() on this DGR service access point will receive these notices interspersed with inbound datagram contents.</p> <p>length of content must be greater than zero and may be as great as 65535, but lengths greater than 8192 may not be supported by the local underlying UDP implementation; to minimize the chance of data loss when transmitting over the internet, length should not exceed 512.</p> <p>rc is the location in which to store the DGR return code resulting from the attempt to send the content.</p> <p>On any failure, returns -1 and sets *rc to DgrFailed.  On success, returns zero.</p> </li> <li> <p>int dgr_receive(Dgr dgr, unsigned short *fromPortNbr, unsigned int *fromIpAddress, char *content, int *length, int *errnbr, int timeoutSeconds, DgrRC *rc)</p> <p>Delivers the oldest undelivered DGR event queued for delivery.</p> <p>DGR events are of two type: (a) messages received from a remote DGR service access point and (b) notices of previously sent messages that DGR has determined either have been or cannot be delivered, as requested in the notificationFlags parameters provided to the dgr_send() calls that sent those messages.</p> <p>In the former case, dgr_receive() will place the content of the inbound message in content, its length in length, and the IP address and port number of the sender in fromIpAddress and fromPortNbr, and it will set *rc to DgrDatagramReceived and return zero.</p> <p>In the latter case, dgr_receive() will place the content of the affected outbound message in content and its length in length and return zero.  If the event being reported is a delivery success, then DgrDatagramAcknowledged will be placed in *rc.  Otherwise, DgrDatagramNotAcknowledged will be placed in *rc and the relevant errno (if any) will be placed in *errnbr.</p> <p>The content buffer should be at least 65535 bytes in length to enable delivery of the content of the received or delivered/undeliverable message.</p> <p>timeoutSeconds controls blocking behavior.  If timeoutSeconds is DGR_BLOCKING (i.e., -1), dgr_receive() will not return until (a) there is either an inbound message to deliver or an outbound message delivery result to report, or (b) the function is interrupted by means of dgr_interrupt().  If timeoutSeconds is DGR_POLL (i.e., zero), dgr_receive() returns immediately; if there is currently no inbound message to deliver and no outbound message delivery result to report, the function sets *rc to DgrTimedOut and returns zero. For any other positive value of timeoutSeconds, dgr_receive() returns after the indicated number of seconds have lapsed (in which case the returned value of *rc is DgrTimedOut), or when there is a message to deliver or a delivery result to report, or when the function is interrupted by means of dgr_interrupt(), whichever occurs first.  When the function returns due to interruption by dgr_interrupt(), the value placed in *rc is DgrInterrupted instead of DgrDatagramReceived.</p> <p>rc is the location in which to store the DGR return code resulting from the attempt to receive content.</p> <p>On any I/O error or other unrecoverable system error, returns -1.  Otherwise always returns zero, placing DgrFailed in *rc and writing a failure message in the event of an operating error.</p> </li> <li> <p>void dgr_interrupt(Dgr dgr)</p> <p>Interrupts a dgr_receive() invocation that is currently blocked.  Designed  to be called from a signal handler; for this purpose, dgr may need to be obtained from a static variable.</p> </li> </ul>"},{"location":"man/dgr/dgr/#see-also","title":"SEE ALSO","text":"<p>ltp(3), file2dgr(1), dgr2file(1)</p>"},{"location":"man/dgr/dgr2file/","title":"NAME","text":"<p>dgr2file - DGR reception test program</p>"},{"location":"man/dgr/dgr2file/#synopsis","title":"SYNOPSIS","text":"<p>dgr2file</p>"},{"location":"man/dgr/dgr2file/#description","title":"DESCRIPTION","text":"<p>dgr2file uses DGR to receive multiple copies of the text of a file transmitted by file2dgr, writing each copy of the file to the current working directory.  The name of each file written by dgr2file is file_copy_cycleNbr, where cycleNbr is initially zero and is increased by 1 every time dgr2file closes the file it is currently writing and opens a new one.</p> <p>Upon receiving a DGR datagram from file2dgr, dgr2file extracts the content of the datagram (either a line of text from the file that is being transmitted by file2dgr or else an EOF string indicating the end of that file).  It appends each extracted line of text to the local copy of that file that dgr2file is currently writing.  When the extracted datagram content is an EOF string (the ASCII text \"*** End of the file ***\"), dgr2file closes the file it is writing, increments cycleNbr, opens a new copy of the file for writing, and prints the message \"working on cycle cycleNbr.\"</p> <p>dgr2file always receives datagrams at port 2101.</p>"},{"location":"man/dgr/dgr2file/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dgr2file has terminated.</p> </li> </ul>"},{"location":"man/dgr/dgr2file/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/dgr/dgr2file/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dgr/dgr2file/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>can't open dgr service</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>can't open output file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>dgr_receive failed</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>can't write to output file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> </ul>"},{"location":"man/dgr/dgr2file/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dgr/dgr2file/#see-also","title":"SEE ALSO","text":"<p>file2dgr(1), dgr(3)</p>"},{"location":"man/dgr/file2dgr/","title":"NAME","text":"<p>file2dgr - DGR transmission test program</p>"},{"location":"man/dgr/file2dgr/#synopsis","title":"SYNOPSIS","text":"<p>file2dgr remoteHostName fileName [nbrOfCycles]</p>"},{"location":"man/dgr/file2dgr/#description","title":"DESCRIPTION","text":"<p>file2dgr uses DGR to send nbrOfCycles copies of the text of the file named fileName to the dgr2file process running on the computer identified by remoteHostName.  If not specified (or if less than 1), nbrOfCycles defaults to 1.  After sending all lines of the file, file2dgr sends a datagram containing an EOF string (the ASCII text \"*** End of the file ***\") before reopening the file and starting transmission of the next copy.</p> <p>When all copies of the file have been sent, file2dgr prints a performance report:</p> <pre><code>    Bytes sent = I&lt;byteCount&gt;, usec elapsed = I&lt;elapsedTime&gt;.\n\n    Sending I&lt;dataRate&gt; bits per second.\n</code></pre>"},{"location":"man/dgr/file2dgr/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>file2dgr has terminated.</p> </li> </ul>"},{"location":"man/dgr/file2dgr/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/dgr/file2dgr/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dgr/file2dgr/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by file2dgr are written to the ION log file ion.log.</p> <ul> <li> <p>Can't open dgr service.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't open input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't acquire DGR working memory.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't reopen input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't read from input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>dgr_send failed.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/dgr/file2dgr/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dgr/file2dgr/#see-also","title":"SEE ALSO","text":"<p>file2dgr(1), dgr(3)</p>"},{"location":"man/dtpc/","title":"Index of Man Pages","text":"<ul> <li>dtpc</li> <li>dtpcadmin</li> <li>dtpcclock</li> <li>dtpcd</li> <li>dtpcrc</li> <li>dtpcreceive</li> <li>dtpcsend</li> </ul>"},{"location":"man/dtpc/dtpc/","title":"NAME","text":"<p>dtpc - Delay-Tolerant Payload Conditioning (DTPC) communications library</p>"},{"location":"man/dtpc/dtpc/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"dtpc.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/dtpc/dtpc/#description","title":"DESCRIPTION","text":"<p>The dtpc library provides functions enabling application software to use Delay-Tolerant Payload Conditioning (DTPC) when exchanging information over a delay-tolerant network.  DTPC is an application service protocol, running in a layer immediately above Bundle Protocol, that offers delay-tolerant support for several end-to-end services to applications that may require them.  These services include delivery of application data items in transmission (rather than reception) order; detection of reception gaps in the sequence of transmitted application data items, with end-to-end negative acknowledgment of the missing data; end-to-end positive acknowledgment of successfully received data; end-to-end retransmission of missing data, driven either by negative acknowledgment or timer expiration; suppression of duplicate application data items; aggregation of small application data items into large bundle payloads, to reduce bundle protocol overhead; and application-controlled elision of redundant data items in aggregated payloads, to improve link utiliization.</p> <ul> <li> <p>int dptc_attach( )</p> <p>Attaches the application to DTPC functionality on the local computer.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void dptc_detach( )</p> <p>Terminates all access to DTPC functionality on the local computer.</p> </li> <li> <p>int dtpc_entity_is_started( )</p> <p>Returns 1 if the local DTPC entity has been started and not yet stopped, 0 otherwise.</p> </li> <li> <p>int dtpc_open(unsigned int topicID, DtpcElisionFn elisionFn, DtpcSAP *dtpcsapPtr)</p> <p>Establishes the application as the sole authorized client for posting and receiving application data items on topic topicID within the local BP node.  On success, the service access point for posting and receiving such data items is placed in *dtpcsapPtr, the elision callback function elisionFn (if not NULL) is associated with this topic, and 0 is returned. Returns -1 on any error.</p> </li> <li> <p>int dtpc_send(unsigned int profileID, DtpcSAP sap, char *destEid, unsigned int maxRtx, unsigned int aggrSizeLimit, unsigned int aggrTimeLimit, int lifespan, BpAncillaryData *ancillaryData, unsigned char srrFlags, BpCustodySwitch custodySwitch, char *reportToEid, int classOfService, Object item, unsigned int length)</p> <p>Inserts an application data item into an outbound DTPC application data unit destined for destEid.</p> <p>Transmission of that outbound ADU will be subject to the profile identified by profileID, as asserted by dtpcadmin(1), if profileID is non-zero.  In that case, maxRtx, aggrSizeLimit, aggrTimeLimit, lifespan, ancillaryData, srrFlags, custodySwitch, reportToEid, and classOfService are ignored.</p> <p>If profileID is zero then the profile asserted by dtpcadmin(1) that matches maxRtx, aggrSizeLimit, aggrTimeLimit, lifespan, ancillaryData, srrFlags, custodySwitch, reportToEid, and classOfService will govern transmission of the ADU, unless no such profile has been asserted, in which case dtpc_send() returns 0 indicating user error.</p> <p>maxRtx is the maximum number of times any single DTPC ADU transmitted subject to the indicated profile may be retransmitted by the DTPC entity.  If maxRtx is zero, then the DTPC transport service features (in-order delivery, end-to-end acknowledgment, etc.) are disabled for this profile.</p> <p>aggrSizeLimit is the size threshold for concluding aggregation of an outbound ADU and requesting transmission of that ADU.  If aggrSizeLimit is zero, then the DTPC transmission optimization features (aggregation and elision) are disabled for this profile.</p> <p>aggrTimeLimit is the time threshold for concluding aggregation of an outbound ADU and requesting transmission of that ADU.  If aggrTimeLimit is zero, then the DTPC transmission optimization features (aggregation and elision) are disabled for this profile.</p> <p>lifespan, ancillaryData, srrFlags, custodySwitch, reportToEid, and classOfService are as defined for bp_send (see bp(3)).</p> <p>item must be an object allocated within ION's SDR \"heap\", and length must be the length of that object.  The item will be inserted into the outbound ADU's list of data items posted for the topic associated with sap, and the elision callback function declared for sap (if any, and if the applicable profile does not disable transmission optimization features) will be invoked immediately after insertion of the application data item but before DTPC makes any decision on whether or not to initiate transmission of the outbound ADU.</p> <p>The function returns 1 on success, 0 on any user application error, -1 on any system error.</p> </li> <li> <p>int dtpc_receive(DtpcSAP sap, DtpcDelivery *dlvBuffer, int timeoutSeconds)</p> <p>Receives a single DTPC application data item, or reports on some failure of DTPC reception activity.</p> <p>The \"result\" field of the dlvBuffer structure will be used to indicate the outcome of the data reception activity.</p> <p>If at least one application data item on the topic associated with sap has not yet been delivered to the SAP, then the payload of the oldest such item will be returned in dlvBuffer-&gt;item and dlvBuffer-&gt;result will be set to PayloadPresent.  If there is no such item, dtpc_receive() blocks for up to timeoutSeconds while waiting for one to arrive.</p> <p>If timeoutSeconds is DTPC_POLL (i.e., zero) and no application data item is awaiting delivery, or if timeoutSeconds is greater than zero but no item arrives before timeoutSeconds have elapsed, then dlvBuffer-&gt;result will be set to ReceptionTimedOut.  If timeoutSeconds is DTPC_BLOCKING (i.e., -1) then bp_receive() blocks until either an item arrives or the function is interrupted by an invocation of dtpc_interrupt().</p> <p>dlvBuffer-&gt;result will be set to ReceptionInterrupted in the event that the calling process received and handled some signal other than SIGALRM while waiting for a bundle.</p> <p>dlvBuffer-&gt;result will be set to DtpcServiceStopped in the event that DTPC service has been terminated on the local node.</p> <p>The application data item delivered in the DTPC delivery structure, if any, will be an object allocated within ION's SDR \"heap\"; the length of that object will likewise be provided in the DtpcDelivery structure.</p> <p>Be sure to call dtpc_release_delivery() after every successful invocation of dtpc_receive().</p> <p>The function returns 0 on success, -1 on any error.</p> </li> <li> <p>void dtpc_interrupt(DtpcSAP sap)</p> <p>Interrupts a dtpc_receive() invocation that is currently blocked.  This function is designed to be called from a signal handler; for this purpose, sap may need to be obtained from a static variable.</p> </li> <li> <p>void dtpc_release_delivery(DtpcDelivery *dlvBuffer)</p> <p>Releases resources allocated to the indicated DTPC delivery.</p> </li> <li> <p>void dtpc_close(DtpcSAP sap)</p> <p>Removes the application as the sole authorized client for posting and receiving application data items on the topic indicated in sap within the local BP node.  The application relinquishes its ability to send and receive application data items on the indicated topic.</p> </li> </ul>"},{"location":"man/dtpc/dtpc/#see-also","title":"SEE ALSO","text":"<p>dtpcadmin(1), dtpcrc(5), bp(3)</p>"},{"location":"man/dtpc/dtpcadmin/","title":"NAME","text":"<p>dtpcadmin - Delay-Tolerant Payload Conditioning (DTPC) administration interface</p>"},{"location":"man/dtpc/dtpcadmin/#synopsis","title":"SYNOPSIS","text":"<p>dtpcadmin [ commands_filename | . ]</p>"},{"location":"man/dtpc/dtpcadmin/#description","title":"DESCRIPTION","text":"<p>dtpcadmin configures, starts, manages, and stops DTPC operations for the local ION node.</p> <p>It operates in response to DTPC configuration commands found in the file commands_filename, if provided; if not, dtpcadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to dtpcadmin -- that is, the ION node's dtpcclock task and dtpcd task are stopped.</p> <p>The format of commands for commands_filename can be queried from dtpcadmin with the 'h' or '?' commands at the prompt.  The commands are documented in dtpcrc(5).</p>"},{"location":"man/dtpc/dtpcadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p><code>0</code></p> <p>Successful completion of DTPC administration.</p> </li> </ul>"},{"location":"man/dtpc/dtpcadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>dtpcadmin</p> <p>Enter interactive DTPC configuration command entry mode.</p> </li> <li> <p>dtpcadmin host1.dtpc</p> <p>Execute all configuration commands in host1.dtpc, then terminate immediately.</p> </li> <li> <p>dtpcadmin .</p> <p>Stop all DTPC operations on the local node.</p> </li> </ul>"},{"location":"man/dtpc/dtpcadmin/#files","title":"FILES","text":"<p>See dtpcrc(5) for details of the DTPC configuration commands.</p>"},{"location":"man/dtpc/dtpcadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dtpc/dtpcadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the dtpcrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to dtpcadmin.  Otherwise dtpcadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>dtpcadmin can't attach to ION.</p> <p>There is no SDR data store for dtpcadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause dtpcadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see dtpcrc(5) for details.</p>"},{"location":"man/dtpc/dtpcadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dtpc/dtpcadmin/#see-also","title":"SEE ALSO","text":"<p>dtpcrc(5)</p>"},{"location":"man/dtpc/dtpcclock/","title":"NAME","text":"<p>dtpcclock - DTPC daemon task for managing scheduled events</p>"},{"location":"man/dtpc/dtpcclock/#synopsis","title":"SYNOPSIS","text":"<p>dtpcclock</p>"},{"location":"man/dtpc/dtpcclock/#description","title":"DESCRIPTION","text":"<p>dtpcclock is a background \"daemon\" task that periodically performs scheduled DTPC activities.  It is spawned automatically by dtpcadmin in response to the 's' command that starts operation of the DTPC protocol, and it is terminated by dtpcadmin in response to an 'x' (STOP) command.</p> <p>Once per second, dtpcclock takes the following action:</p> <p>First it executes all DTPC events scheduled to occur at any time up to the current moment:</p> <p>DTPC ADUs for which an expected positive acknowledgment has not yet arrived are retransmitted.</p> <p>Received DTPC ADUs whose time to live has elapsed are deleted.</p> <p>Then dtpcclock increases the ages of all DTPC ADUs pending transmission and initiates transmission of each such ADU whose age now equals or exceeds its aggregation time limit.</p>"},{"location":"man/dtpc/dtpcclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p><code>0</code></p> <p>dtpcclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use dtpcadmin to restart dtpcclock.</p> </li> <li> <p><code>1</code></p> <p>dtpcclock was unable to attach to DTPC protocol operations, probably because dtpcadmin has not yet been run.</p> </li> </ul>"},{"location":"man/dtpc/dtpcclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/dtpc/dtpcclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dtpc/dtpcclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dtpcclock can't initialize DTPC.</p> <p>dtpcadmin has not yet initialized DTPC protocol operations.</p> </li> <li> <p>Can't send finished adu.</p> <p>An unrecoverable database error was encountered.  dtpcclock terminates.</p> </li> <li> <p>Can't stop aggregation for adu.</p> <p>An unrecoverable database error was encountered.  dtpcclock terminates.</p> </li> <li> <p>Could not scan outbound Adus</p> <p>An unrecoverable database error was encountered.  dtpcclock terminates.</p> </li> </ul>"},{"location":"man/dtpc/dtpcclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dtpc/dtpcclock/#see-also","title":"SEE ALSO","text":"<p>dtpcadmin(1)</p>"},{"location":"man/dtpc/dtpcd/","title":"NAME","text":"<p>dtpcd - DTPC daemon task for receiving and processing DTPC ADUs in bundles</p>"},{"location":"man/dtpc/dtpcd/#synopsis","title":"SYNOPSIS","text":"<p>dtpcd</p>"},{"location":"man/dtpc/dtpcd/#description","title":"DESCRIPTION","text":"<p>dtpcd is a background \"daemon\" task that manages the reception and processing of DTPC protocol data units.  It receives the payloads of bundles destined for the \"ipn\"-scheme endpoint whose node number is the number of the local node and whose service number is the DTPC_RECV_SVC_NBR (129 as of the time of this writeng).</p> <p>DTPC protocol data units are of two types: application data units (ADUs, i.e., aggregations of application data items) and acknowledgments.  Each acknowledgment is interpreted as authorization to release the buffer space occupied by the node's local copy of the acknowledged ADU.  Each ADU is parsed into its constituent application data items, which are then delivered to the applications awaiting them, and when required a DTPC end-to-end acknowledgment PDU is returned to the DTPC PDU sender.</p>"},{"location":"man/dtpc/dtpcd/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p><code>0</code></p> <p>dtpcd terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use dtpcadmin to restart dtpcd.</p> </li> <li> <p><code>1</code></p> <p>dtpcd terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use dtpcadmin to restart dtpcd.</p> </li> </ul>"},{"location":"man/dtpc/dtpcd/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/dtpc/dtpcd/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dtpc/dtpcd/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>DTPC can't open own 'send' endpoint. </p> <p>Bundle protocol agent has not been started.  See ion(3).</p> </li> <li> <p>dtpcd can't attach to DTPC. </p> <p>dtpcadmin has not yet initialized DTPC protocol operations.</p> </li> </ul>"},{"location":"man/dtpc/dtpcd/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dtpc/dtpcd/#see-also","title":"SEE ALSO","text":"<p>dtpcadmin(1), ion(3)</p>"},{"location":"man/dtpc/dtpcrc/","title":"NAME","text":"<p>dtpcrc - Delay-Tolerant Payload Conditioning management commands file</p>"},{"location":"man/dtpc/dtpcrc/#description","title":"DESCRIPTION","text":"<p>DTPC management commands are passed to dtpcadmin either in a file of text lines or interactively at dtpcadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the DTPC management commands are described below.</p>"},{"location":"man/dtpc/dtpcrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by dtpcadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1</p> <p>The initialize command.  Until this command is executed, DTPC is not in operation on the local ION node and most dtpcadmin commands will fail.</p> </li> <li> <p>a profile profileID maxRtx aggrSizeLimit aggrTimeLimit TTL class_of_service report_to_endpointID [statusReportFlags]</p> <p>The add profile command.  This command notes the definition of a single DPTC transmission profile.  A transmission profile asserts the BP and DTPC configuration parameter values that will be applied to all application data items (encapsulated in DTPC application data units and transmitted in bundles) that are issued subject to this profile.  Transmission profiles are globally defined; all transmission profiles must be provided, with identical parameter values, to all inter-communicating DTPC protocol entities.</p> <p>profileID must be the positive integer that uniquely defines the profile.</p> <p>maxRtx is the maximum number of times any single DTPC ADU transmitted subject to the indicated profile may be retransmitted by the DTPC entity.  If maxRtx is zero, then the DTPC transport service features (in-order delivery, end-to-end acknowledgment, etc.) are disabled for this profile.</p> <p>aggrSizeLimit is the size threshold for concluding aggregation of an outbound ADU and requesting transmission of that ADU.  If aggrSizeLimit is zero, then the DTPC transmission optimization features (aggregation and elision) are disabled for this profile.</p> <p>aggrTimeLimit is the time threshold for concluding aggregation of an outbound ADU and requesting transmission of that ADU.  If aggrTimeLimit is zero, then the DTPC transmission optimization features (aggregation and elision) are disabled for this profile.</p> <p>class_of_service is the class-of-service string as defined for bptrace(1).</p> <p>report_to_endpointID identifies the BP endpoint to which all status reports generated from bundles transmitted subject to this profile will be sent.</p> <p>statusReportFlags, if present, must be a sequence of status report flags, separated by commas, with no embedded whitespace.  Each status report flag must be one of the following: rcv, ct, fwd, dlv, del.</p> </li> <li> <p>d profile profileId</p> <p>The delete profile command.  This command erases the definition of the DTPC transmission profile identified by profileId.</p> </li> <li> <p>i profile profileId</p> <p>This command will print information (all configuration parameters) about the profile identified by profileId.</p> </li> <li> <p>l profile</p> <p>This command lists all known DTPC transmission profiles.</p> </li> <li> <p>s</p> <p>The start command.  This command starts the DTPC clock and daemon tasks for the local BP node.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops all DTPC tasks and notifies all DTPC applications that DTPC service has been stopped.</p> </li> <li> <p>w { 0 | 1 | &lt;activity_spec&gt; }</p> <p>The DTPC watch command.  This command enables and disables production of a continuous stream of user-selected DTPC activity indication characters.  A watch parameter of \"1\" selects all DTPC activity indication characters; \"0\" de-selects all DTPC activity indication characters; any other activity_spec such as \"o&lt;r&gt;\" selects all activity indication characters in the string, de-selecting all others.  DTPC will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>o   new aggregator created for profile and destination endpoint</p> <p>\\&lt; new ADU aggregation initiated</p> <p>r   application data item added to aggregation</p> <p>\\&gt; aggregation complete, outbound ADU created</p> <p>-   outbound ADU sent via BP</p> <p>l   ADU end-to-end acknowledgment sent</p> <p>m   ADU deleted due to TTL expiration</p> <p>n   ADU queued for retransmission</p> <p>i   inbound ADU collector created</p> <p>u   inbound ADU received</p> <p>v   ADU sequence gap detected</p> <p>?   inbound ADU discarded</p> <p>*  ADU sequence gap deleted due to impending ADU TTL expiration</p> <p>$   inbound ADU collector reset</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/dtpc/dtpcrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a profile 5 6 1000000 5 3600 0.1 dtn:none</p> <p>Notes the definition of DTPC transmission profile 5: transport services are enabled, with an end-to-end retransmission limit of 5; transmission optimization service is enabled, initiating bundle transmission whenever the aggregation of data items queued for transmission subject to this profile exceeds one million bytes or is more than five seconds old; the transmitted bundles will have one-hour lifetime, will not be subject to custody transfer, will be sent at \"standard\" priority, and will not be tracked by any bundle status report production.</p> </li> </ul>"},{"location":"man/dtpc/dtpcrc/#see-also","title":"SEE ALSO","text":"<p>dtpcadmin(1), bptrace(1)</p>"},{"location":"man/dtpc/dtpcreceive/","title":"NAME","text":"<p>dtpcreceive - Delay-Tolerant Payload Conditioning reception test program</p>"},{"location":"man/dtpc/dtpcreceive/#synopsis","title":"SYNOPSIS","text":"<p>dtpcreceive topic_ID</p>"},{"location":"man/dtpc/dtpcreceive/#description","title":"DESCRIPTION","text":"<p>dtpcreceive uses DTPC to acquire application data items on topic topic_ID sent by dtpcsend.  Upon termination it prints the total number of application data items received and the mean rate of application data transmission.</p> <p>Use CTRL-C to terminate the program.</p>"},{"location":"man/dtpc/dtpcreceive/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p><code>0</code></p> <p>dtpcreceive has terminated.</p> </li> </ul>"},{"location":"man/dtpc/dtpcreceive/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/dtpc/dtpcreceive/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dtpc/dtpcreceive/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dtpc/dtpcreceive/#see-also","title":"SEE ALSO","text":"<p>dtpcsend(1), dtpc(3)</p>"},{"location":"man/dtpc/dtpcsend/","title":"NAME","text":"<p>dtpcsend - Delay-Tolerant Payload Conditioning transmission test program</p>"},{"location":"man/dtpc/dtpcsend/#synopsis","title":"SYNOPSIS","text":"<p>dtpcsend nbr_of_cycles rate payload_size topic_ID profile_ID destination_endpoint</p>"},{"location":"man/dtpc/dtpcsend/#description","title":"DESCRIPTION","text":"<p>dtpcsend uses DTPC to send nbr_of_cycles application data items of  payload_size bytes each on topic topic_ID to destination_endpoint using transmission profile profile_ID at rate bits per second.</p> <p>rate must be between 1000 and 200 million bits per second.</p> <p>payload_size must be between 2 and 1 million bytes.  To use application data item sizes chosen at random from the range 1 to 65536, specify payload_size = 1.</p> <p>NOTE that dtpcsend invokes an elision function that removes from the outbound DTPC aggregate ADU all records that are of the same size as the first record in that aggregation.  This means that specifying any payload size other than 1 that is less than the configured DTPC aggregation size limit will cause DTPC to issue ADUs only when the aggregation time limit is exceeded, and each such ADU will always contain only a single record.</p> <p>Use CTRL-C to terminate the program.</p>"},{"location":"man/dtpc/dtpcsend/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/dtpc/dtpcsend/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/dtpc/dtpcsend/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/dtpc/dtpcsend/#see-also","title":"SEE ALSO","text":"<p>dtpcreceive(1), dtpc(3)</p>"},{"location":"man/ici/","title":"Index of Man Pages","text":"<ul> <li>file2sdr</li> <li>file2sm</li> <li>ion</li> <li>ionadmin</li> <li>ioncbor</li> <li>ionconfig</li> <li>ioncrc</li> <li>ionlog</li> <li>ionrc</li> <li>ionsecadmin</li> <li>ionsecrc</li> <li>ionunlock</li> <li>ionxnowner</li> <li>llcv</li> <li>lyst</li> <li>memmgr</li> <li>owltsim</li> <li>owlttb</li> <li>platform</li> <li>psm</li> <li>psmshell</li> <li>psmwatch</li> <li>rfxclock</li> <li>sdr</li> <li>sdr2file</li> <li>sdrhash</li> <li>sdrlist</li> <li>sdrmend</li> <li>sdrstring</li> <li>sdrtable</li> <li>sdrwatch</li> <li>sm2file</li> <li>smlist</li> <li>smlistsh</li> <li>smrbt</li> <li>smrbtsh</li> <li>zco</li> </ul>"},{"location":"man/ici/file2sdr/","title":"NAME","text":"<p>file2sdr - SDR data ingestion test program</p>"},{"location":"man/ici/file2sdr/#synopsis","title":"SYNOPSIS","text":"<p>file2sdr configFlags fileName</p>"},{"location":"man/ici/file2sdr/#description","title":"DESCRIPTION","text":"<p>file2sdr stress-tests SDR data ingestion by repeatedly writing all text lines of the file named fileName to one of a series of non-volatile linked lists created in a test SDR data store named \"testsdr_configFlags_\". By incorporating the data store configuration into the name (e.g., \"testsdr14\") we make it relatively easy to perform comparative testing on SDR data stores that are identical aside from their configuration settings.</p> <p>The operation of file2sdr is cyclical: a new linked list is created each time the program finishes copying the file's text lines and starts over again.  If you use ^C to terminate file2sdr and then restart it, the program resumes operation at the point where it left off.</p> <p>After writing each line to the current linked list, file2sdr gives a semaphore to indicate that the list is now non-empty.  This is mainly for the benefit of the complementary test program sdr2file(1).</p> <p>At the end of each cycle file2sdr appends a final EOF line to the current linked list, containing the text \"*** End of the file ***\", and prints a brief performance report:</p> <pre><code>    Processing I&lt;lineCount&gt; lines per second.\n</code></pre>"},{"location":"man/ici/file2sdr/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>file2sdr has terminated.</p> </li> </ul>"},{"location":"man/ici/file2sdr/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/file2sdr/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/file2sdr/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by file2sdr are written to the ION log file ion.log.</p> <ul> <li> <p>Can't use sdr.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create semaphore.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>SDR transaction failed.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't open input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't reopen input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't read from input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> </ul>"},{"location":"man/ici/file2sdr/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/file2sdr/#see-also","title":"SEE ALSO","text":"<p>sdr2file(1), sdr(3)</p>"},{"location":"man/ici/file2sm/","title":"NAME","text":"<p>file2sm - shared-memory linked list data ingestion test program</p>"},{"location":"man/ici/file2sm/#synopsis","title":"SYNOPSIS","text":"<p>file2sm fileName</p>"},{"location":"man/ici/file2sm/#description","title":"DESCRIPTION","text":"<p>file2sm stress-tests shared-memory linked list data ingestion by repeatedly writing all text lines of the file named fileName to a shared-memory linked list that is the root object of a PSM partition named \"file2sm\".</p> <p>After writing each line to the linked list, file2sm gives a semaphore to indicate that the list is now non-empty.  This is mainly for the benefit of the complementary test program sm2file(1).</p> <p>The operation of file2sm is cyclical.  After copying all text lines of the source file to the linked list, file2sm appends an EOF line to the linked list, containing the text \"*** End of the file ***\", and prints a brief performance report:</p> <pre><code>    Processing I&lt;lineCount&gt; lines per second.\n</code></pre> <p>Then it reopens the source file and starts appending the file's text lines to the linked list again.</p>"},{"location":"man/ici/file2sm/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>file2sm has terminated.</p> </li> </ul>"},{"location":"man/ici/file2sm/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/file2sm/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/file2sm/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>Can't attach to shared memory</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't manage shared memory.</p> <p>PSM error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create shared memory list.</p> <p>smlist error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create semaphore.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't open input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't reopen input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't read from input file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Ran out of memory.</p> <p>Nominal behavior.  sm2file is not extracting data from the linked list quickly enough to prevent it from growing to consume all memory allocated to the test partition.</p> </li> </ul>"},{"location":"man/ici/file2sm/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/file2sm/#see-also","title":"SEE ALSO","text":"<p>sm2file(1), smlist(3), psm(3)</p>"},{"location":"man/ici/ion/","title":"NAME","text":"<p>ion - Interplanetary Overlay Network common definitions and functions</p>"},{"location":"man/ici/ion/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"ion.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/ion/#description","title":"DESCRIPTION","text":"<p>The Interplanetary Overlay Network (ION) software distribution is an implementation of Delay-Tolerant Networking (DTN) architecture as described in Internet RFC 4838.  It is designed to enable inexpensive insertion of DTN functionality into embedded systems such as robotic spacecraft.  The intent of ION deployment in space flight mission systems is to reduce cost and risk in mission communications by simplifying the construction and operation of automated digital data communication networks spanning space links, planetary surface links, and terrestrial links.</p> <p>The ION distribution comprises the following software packages:</p> <p>ici (Interplanetary Communication Infrastructure), a set of general-purpose libraries providing common functionality to the other packages.</p> <p>ltp (Licklider Transmission Protocol), a core DTN protocol that provides transmission reliability based on delay-tolerant acknowledgments, timeouts, and retransmissions.</p> <p>dgr (Datagram Retransmission), a library that enables data to be transmitted via UDP with reliability comparable to that provided by TCP.  DGR is an alternative implementation of LTP, designed for use within an internet.</p> <p>bssp (Bundle Streaming Service Protocol), a protocol that supports delay-tolerant data streaming.  BSSP delivers data in transmission order with minimum latency but possibly with omissions, for immediate display, and at the same time it delivers the same data reliably in background so that the streamed data can be \"rewound\" for possibly improved presentation.</p> <p>bp (Bundle Protocol), a core DTN protocol that provides delay-tolerant forwarding of data through a network in which continuous end-to-end connectivity is never assured, including support for delay-tolerant dynamic routing.  The Bundle Protocol (BP) specification is defined in Internet RFC 5050.</p> <p>ams (Asynchronous Message Service), cfdp (CCSDS File Delivery Protocol), dtpc (Delay-Tolerant Payload Conditioning), and bss (Bundle Streaming Service), application-layer services that are not part of the DTN architecture but utilize underlying DTN protocols.</p> <p>Taken together, the packages included in the ION software distribution constitute a communication capability characterized by the following operational features:</p> <p>Reliable conveyance of data over a DTN, i.e., a network in which it might never be possible for any node to have reliable information about the detailed current state of any other node.</p> <p>Built on this capability, reliable distribution of short messages to multiple recipients (subscribers) residing in such a network.</p> <p>Management of traffic through such a network.</p> <p>Facilities for monitoring the performance of the network.</p> <p>Robustness against node failure.</p> <p>Portability across heterogeneous computing platforms.</p> <p>High speed with low overhead.</p> <p>Easy integration with heterogeneous underlying communication infrastructure, ranging from Internet to dedicated spacecraft communication links.</p> <p>While most of the ici package consists of libraries providing functionality that may be of general utility in any complex embedded software system, the functions and macros described below are specifically designed to support operations of ION's delay-tolerant networking protocol stack.</p> <ul> <li> <p>TIMESTAMPBUFSZ</p> <p>This macro returns the recommended size of a buffer that is intended to contain a timestamp in ION-standard format:</p> <pre><code>yyyy/mm/dd-hh:mm:ss\n</code></pre> </li> <li> <p>int ionAttach()</p> <p>Attaches the invoking task to ION infrastructure as previously established by running the ionadmin utility program.  Returns zero on success, -1 on any error.</p> </li> <li> <p>void ionDetach()</p> <p>Detaches the invoking task from ION infrastructure.  In particular, releases handle allocated for access to ION's non-volatile database.  NOTE, though, that ionDetach() has no effect when the invoking task is running in a non-memory-protected environment, such as VxWorks, where all ION resource access variables are shared by all tasks: no single task could detach without crashing all other ION tasks.</p> </li> <li> <p>void ionProd(uvast fromNode, uvast toNode, unsigned int xmitRate, unsigned int owlt)</p> <p>This function is designed to be called from an operating environment command or a fault protection routine, to enable operation of a node to resume when all of its scheduled contacts are in the past (making it impossible to use a DTN communication contact to assert additional future communication contacts).  The function asserts a single new unidirectional contact conforming to the arguments provided, including the applicable one-way light time, with start time equal to the current time (at the moment of execution of the function) and end time equal to the start time plus 2 hours.  The result of executing the function is written to the ION log using standard ION status message logging functions.</p> <p>NOTE that the ionProd() function must be invoked twice in order to establish bidirectional communication.</p> </li> <li> <p>void ionTerminate()</p> <p>Shuts down the entire ION node, terminating all daemons.  The state of  the node is retained in the node's SDR heap.</p> </li> <li> <p>int ionStartAttendant(ReqAttendant *attendant)</p> <p>Initializes the semaphore in attendant so that it can be used for blocking ZCO space requisitions by ionRequestZcoSpace().  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void ionPauseAttendant(ReqAttendant *attendant)</p> <p>\"Ends\" the semaphore in attendant so that the task that is blocked on taking it is interrupted and may respond to an error or shutdown condition.</p> </li> <li> <p>void ionResumeAttendant(ReqAttendant *attendant)</p> <p>Reinitializes the semaphore in attendant so that it can again be used for blocking ZCO space requisitions.</p> </li> <li> <p>void ionStopAttendant(ReqAttendant *attendant)</p> <p>Destroys the semaphore in attendant, preventing a potential resource leak.</p> </li> <li> <p>int ionRequestZcoSpace(ZcoAcct acct, vast fileSpaceNeeded, vast bulkSpaceNeeded, vast heapSpaceNeeded, unsigned char coarsePriority, unsigned char finePriority, ReqAttendant *attendant, ReqTicket *ticket)</p> <p>Lodges a request for ZCO space in the pool identified by acct.  If the requested space can be provided immediately, it is reserved for use by the calling task.  Otherwise, if attendant is non-NULL then the request is queued for service when space becomes available.  In any case, *ticket is set to the address of a \"ticket\" referencing this request.  The status of the request can be interrogated by calling ionSpaceAwarded().  If this function returns 1 (True) then ZCO space may be consumed immediately and the ticket must then be destroyed by a call to ionShred().  Otherwise, if an attendant was provided, then the calling task should pend on the semaphore in attendant and upon successfully taking the semaphore it must consume the requested ZCO space and then ionShred() the ticket.  Otherwise the request for ZCO space has been definitively denied and, as always, the ticket must by destroyed by an invocation of ionShred().  Returns 0 on success, -1 on any failure.</p> </li> <li> <p>int ionSpaceAwarded(ReqTicket *ticket)</p> <p>Returns 1 if ticket is for a ZCO space request that has been serviced (ZCO space has been reserved per this request), 0 otherwise.</p> </li> <li> <p>void ionShred(ReqTicket *ticket)</p> <p>Dismisses the reservation of ZCO space (if any) requested by the call to ionRequestZcoSpace() that returned ticket.  Calling ionShred() indicates either that the requested space was reserved (i.e., the request was \"serviced\") and has been claimed (consumed by the appending of a ZCO extent) or that the request has been canceled.  Note that failure to promptly (within 3 seconds of reception) ionShred() the ticket for a service request will be interpreted as refusal of the reserved ZCO space, resulting in that space being made available for use by other tasks.</p> </li> <li> <p>Object ionCreateZco(ZcoMedium source, Object location, vast offset, vast length, unsigned char coarsePriority, unsigned char finePriority, ZcoAcct acct, ReqAttendant *attendant)</p> <p>This function provides a \"blocking\" implementation of admission control in ION.  Like zco_create(), it constructs a zero-copy object (see zco(3)) that contains a single extent of source data residing at location in source, of which the first offset bytes are omitted and the next length bytes are included.  But unlike zco_create(), ionCreateZco() can be configured to block (rather than return an immediate error indication) so long as the total amount of space in source that is available for new ZCO formation is less than length.  ionCreateZco() operates by calling ionRequestZcoSpace(), then pending on the semaphore in attendant as necessary before creating the ZCO.  ionCreateZco() returns when either (a) space has become available and the ZCO has been created, in which case the location of the ZCO is returned, or (b) the function has failed (in which case ((Object) -1) is returned), or (c) either attendant was null and sufficient space for the first extent of the ZCO was not immediately available or else the function was interrupted by ionPauseAttendant() before space for the ZCO became available (in which case 0 is returned).</p> </li> <li> <p>vast ionAppendZcoExtent(Object zco, ZcoMedium source, Object location, vast offset, vast length, unsigned char coarsePriority, unsigned char finePriority, ReqAttendant *attendant)</p> <p>Similar to ionCreateZco() except that instead of creating a new ZCO it appends an additional extent to an existing ZCO.  Returns -1 on failure, 0 on interruption by ionPauseAttendant() or if attendant was NULL and sufficient space for the extent was not immediately available, length on success.</p> </li> <li> <p>char *getIonVersionNbr()</p> <p>Returns the name of the ION version installed on the local machine.</p> </li> <li> <p>Sdr getIonsdr()</p> <p>Returns a pointer to the SDR management object, previously acquired by calling ionAttach(), or zero on any error.</p> </li> <li> <p>PsmPartition getIonwm()</p> <p>Returns a pointer to the ION working memory partition, previously acquired by calling ionAttach(), or zero on any error.</p> </li> <li> <p>int getIonMemoryMgr()</p> <p>Returns the memory manager ID for operations on ION's working memory partition, previously acquired by calling ionAttach(), or -1 on any error.</p> </li> <li> <p>int ionLocked();</p> <p>Returns 1 if the calling task is the owner of the current SDR transaction. Assuring that ION is locked while related critical operations are performed is essential to the avoidance of race conditions.</p> </li> <li> <p>uvast getOwnNodeNbr()</p> <p>Returns the Bundle Protocol node number identifying this node, as declared when ION was initialized by ionadmin.</p> </li> <li> <p>time_t getCtime()</p> <p>Returns the current calendar (i.e., Unix epoch) time, as computed from local clock time and the computer's current offset from UTC (due to clock drift, not due to time zone difference; the utcdelta) as managed from ionadmin.</p> </li> <li> <p>int ionClockIsSynchronized()</p> <p>Returns 1 if the computer on which the local ION node is running has a synchronized clock , i.e., a clock that reports the current calendar (i.e., Unix epoch) time as a value that differs from the correct calendar time by an interval approximately equal to the currently asserted offset from UTC due to clock drift; returns zero otherwise.</p> <p>If the machine's clock is synchronized then its reported values (as returned by getCtime()) can safely be used as the creation times of new bundles and the expiration time of such a bundle can accurately be computed as the sum of the bundle's creation time and time to live.  If not, then the creation timestamp time of new bundles sourced at the local ION node must be zero and the creation timestamp sequence numbers must increase monotonically forever, never rolling over to zero.</p> </li> <li> <p>void writeTimestampLocal(time_t timestamp, char *timestampBuffer)</p> <p>Expresses the time value in timestamp as a local timestamp string in ION-standard format, as noted above, in timestampBuffer.</p> </li> <li> <p>void writeTimestampUTC(time_t timestamp, char *timestampBuffer)</p> <p>Expresses the time value in timestamp as a UTC timestamp string in ION-standard format, as noted above, in timestampBuffer.</p> </li> <li> <p>time_t readTimestampLocal(char *timestampBuffer, time_t referenceTime)</p> <p>Parses the local timestamp string in timestampBuffer and returns the corresponding calendar (i.e., Unix epoch) time value (as would be returned by time(2)), or zero if the timestamp string cannot be parsed successfully.  The timestamp string is normally expected to be an absolute expression of local time in ION-standard format as noted above.  However, a relative time expression variant is also supported: if the first character of timestampBuffer is '+' then the remainder of the string is interpreted as a count of seconds; the sum of this value and the time value in referenceTime is returned.</p> </li> <li> <p>time_t readTimestampUTC(char *timestampBuffer, time_t referenceTime)</p> <p>Same as readTimestampLocal() except that if timestampBuffer is not a relative time expression then it is interpreted as an absolute expression of UTC time in ION-standard format as noted above.</p> </li> </ul>"},{"location":"man/ici/ion/#status-messages","title":"STATUS MESSAGES","text":"<p>ION uses writeMemo(), putErrmsg(), and putSysErrmsg() to log several different types of standardized status messages.</p> <ul> <li> <p>Informational messages</p> <p>These messages are generated to inform the user of the occurrence of events that are nominal but significant, such as the controlled termination of a daemon or the production of a congestion forecast.  Each informational message has the following format:</p> <pre><code>{_yyyy/mm/dd hh:mm:ss_} \\[i\\] _text_\n</code></pre> </li> <li> <p>Warning messages</p> <p>These messages are generated to inform the user of the occurrence of events that are off-nominal but are likely caused by configuration or operational errors rather than software failure.  Each warning message has the following format:</p> <pre><code>{_yyyy/mm/dd hh:mm:ss_} \\[?\\] _text_\n</code></pre> </li> <li> <p>Diagnostic messages</p> <p>These messages are produced by calling putErrmsg() or putSysErrmsg().  They are generated to inform the user of the occurrence of events that are off-nominal and might be due to errors in software.  The location within the ION software at which the off-nominal condition was detected is indicated in the message:</p> <pre><code>{_yyyy/mm/dd hh:mm:ss_} at line _nnn_ of _sourcefilename_, _text_ (_argument_)\n</code></pre> <p>Note that the argument portion of the message (including its enclosing parentheses) will be provided only when an argument value seems potentially helpful in fault analysis.</p> </li> <li> <p>Bundle Status Report (BSR) messages</p> <p>A BSR message informs the user of the arrival of a BSR, a Bundle Protocol report on the status of some bundle.  BSRs are issued in the course of processing bundles for which one or more status report request flags are set, and they are also issued when bundles for which custody transfer is requested are destroyed prior to delivery to their destination endpoints.  A BSR message is generated by ipnadminep upon reception of a BSR.  The time and place (node) at which the BSR was issued are indicated in the message:</p> <pre><code>{_yyyy/mm/dd hh:mm:ss_} \\[s\\] (_sourceEID_)/_creationTimeSeconds_:_counter_/_fragmentOffset_ status _flagsByte_ at _time_ on _endpointID_, '_reasonString_'.\n</code></pre> </li> <li> <p>Communication statistics messages</p> <p>A network performance report is a set of eight communication statistics messages, one for each of eight different types of network activity.  A report is issued every time contact transmission or reception starts or stops, except when there is no activity of any kind on the local node since the prior report.  When a report is issued, statistic messages are generated to summarize all network activity detected since the prior report, after which all network activity counters and accumulators are reset to zero.</p> <p>NOTE also that the bpstats utility program can be invoked to issue an interim network performance report at any time.  Issuance of interim status reports does not cause network activity counters and accumulators to be reset to zero.</p> <p>Statistics messages have the following format:</p> <pre><code>{_yyyy/mm/dd hh:mm:ss_} \\[x\\] _xxx_ from _tttttttt_ to _TTTTTTTT_: (0) _aaaa_ _bbbbbbbbbb_ (1) _cccc_ _dddddddddd_ (2) _eeee_ _ffffffffff_ (+) _gggg_ _hhhhhhhhhh_\n</code></pre> <p>xxx indicates the type of network activity that the message is reporting on.  Statistics for eight different types of network activity are reported:</p> <ul> <li> <p>src</p> <p>This message reports on the bundles sourced at the local node during the indicated interval.</p> </li> <li> <p>fwd</p> <p>This message is about routing; it reports on the number of bundles queued for forwarding to neighboring nodes as selected by the routing procedure. When a bundle must be re-forwarded due to convergence-layer transmission failure it is counted a second time here.</p> </li> <li> <p>xmt</p> <p>This message reports on the bundles passed to the convergence layer protocol(s) for transmission from this node.  Again, a re-forwarded bundle that is then re-transmitted at the convergence layer is counted a second time here.</p> </li> <li> <p>rcv</p> <p>This message reports on the bundles from other nodes that were received at the local node.</p> </li> <li> <p>dlv</p> <p>This message reports on the bundles delivered to applications via endpoints on the local node.</p> </li> <li> <p>ctr</p> <p>This message reports on the custody refusal signals received at the local node.</p> </li> <li> <p>rfw</p> <p>This message reports on bundles for which convergence-layer transmission failed at this node, causing the bundles to be re-forwarded.</p> </li> <li> <p>exp</p> <p>This message reports on the bundles destroyed at this node due to TTL expiration.</p> </li> </ul> <p>tttttttt and TTTTTTTT indicate the start and end times of the interval for which statistics are being reported, expressed in yyyy/mm/dd-hh:mm:ss format.  TTTTTTTT is the current time and tttttttt is the time of the prior report.</p> <p>Each of the four value pairs following the colon (:) reports on the number of bundles counted for the indicated type of network activity, for the indicated traffic flow, followed by the sum of the sizes of the payloads of all those bundles.  The four traffic flows for which statistics are reported are \"(0)\" the priority-0 or \"bulk\" traffic, \"(1)\" the priority-1 \"standard\" traffic, \"(2)\" the priority-2 \"expedited\" traffic, and \"(+)\" the total for all classes of service.</p> </li> <li> <p>Free-form messages</p> <p>Other status messages are free-form, except that date and time are always noted just as for the documented status message types.</p> </li> </ul>"},{"location":"man/ici/ion/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1), rfxclock(1), bpstats(1), llcv(3), lyst(3), memmgr(3), platform(3), psm(3), sdr(3), zco(3), ltp(3), bp(3), cfdp(3), ams(3), bss(3)</p>"},{"location":"man/ici/ionadmin/","title":"NAME","text":"<p>ionadmin - ION node administration interface</p>"},{"location":"man/ici/ionadmin/#synopsis","title":"SYNOPSIS","text":"<p>ionadmin [ commands_filename | . | ! ]</p>"},{"location":"man/ici/ionadmin/#description","title":"DESCRIPTION","text":"<p>ionadmin configures, starts, manages, and stops the ION node on the local computer.</p> <p>It configures the node and sets (and reports on) global operational settings for the DTN protocol stack on the local computer in response to ION configuration commands found in commands_filename, if provided; if not, ionadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to ionadmin -- that is, the ION node's rfxclock task is stopped.  If commands_filename is an exclamation point (!), that effect is reversed: the ION node's rfxclock task is restarted.</p> <p>The format of commands for commands_filename can be queried from ionadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in ionrc(5).</p> <p>Note that ionadmin always computes a congestion forecast immediately before exiting.  The result of this forecast -- maximum projected occupancy of the DTN protocol traffic allocation in ION's SDR database -- is retained for application flow control purposes: if maximum projected occupancy is the entire protocol traffic allocation, then a message to this effect is logged and no new bundle origination by any application will be accepted until a subsequent forecast that predicts no congestion is computed.  (Congestion forecasts are constrained by horizon times, which can be established by commands issued to ionadmin.  One way to re-enable data origination temporarily while long-term traffic imbalances are being addressed is to declare a congestion forecast horizon in the near future, before congestion would occur if no adjustments were made.)</p>"},{"location":"man/ici/ionadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of ION node administration.</p> </li> </ul>"},{"location":"man/ici/ionadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>ionadmin</p> <p>Enter interactive ION configuration command entry mode.</p> </li> <li> <p>ionadmin host1.ion</p> <p>Execute all configuration commands in host1.ion, then terminate immediately.</p> </li> </ul>"},{"location":"man/ici/ionadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from ionadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which ionadmin was run.  The log file is typically named ion.log.</p> <p>See also ionconfig(5) and ionrc(5).</p>"},{"location":"man/ici/ionadmin/#environment","title":"ENVIRONMENT","text":"<p>Environment variables ION_NODE_LIST_DIR and ION_NODE_WDNAME can be used to enable the operation of multiple ION nodes on a single workstation computer. See section 2.1.3 of the ION Design and Operations Guide for details.</p>"},{"location":"man/ici/ionadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ionrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to ionadmin.  Otherwise ionadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> <li> <p>ionadmin SDR definition failed.</p> <p>A node initialization command was executed, but an SDR database already exists for the indicated node.  It is likely that an ION node is already running on this computer or that destruction of a previously started the previous ION node was incomplete.  For most ION installations, incomplete node destruction can be repaired by (a) killing all ION processes that are still running and then (b) using ipcrm to remove all SVr4 IPC objects owned by ION.</p> </li> <li> <p>ionadmin can't get SDR parms.</p> <p>A node initialization command was executed, but the ion_config_filename passed to that command contains improperly formatted commands.  Please see ionconfig(5) for further details.</p> </li> </ul> <p>Various errors that don't cause ionadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see ionrc(5) for details.</p>"},{"location":"man/ici/ionadmin/#bugs","title":"BUGS","text":"<p>If the ion_config_filename parameter passed to a node initialization command refers to a nonexistent filename, then ionadmin uses default values are used rather than reporting an error in the command line argument.</p> <p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/ionadmin/#see-also","title":"SEE ALSO","text":"<p>ionrc(5), ionconfig(5)</p>"},{"location":"man/ici/ioncbor/","title":"NAME","text":"<p>cbor - ION library for encoding and decoding CBOR data representations</p>"},{"location":"man/ici/ioncbor/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"cbor.h\"\n</code></pre>"},{"location":"man/ici/ioncbor/#description","title":"DESCRIPTION","text":"<p>ION's \"cbor\" library implements a subset of the Concise Binary Object Representation (CBOR) standard, RFC 7049; only those data types used in ION code are implemented.  Unlike other CBOR implementations, ION CBOR is specifically intended for compatibility with zero-copy objects, i.e., the data being decoded need not all be in a memory buffer.</p> <p>For all functions, *cursor is a pointer to the location in the CBOR coding buffer at which bytes are to be encoded or decoded.  This pointer is automatically advanced as the encoding or decoding operation is performed.</p> <p>Most of the ION CBOR decoding functions entail the decoding of unsigned integers.  The invoking code may require that an integer representation have a specific size by indicating the integer size \"class\" that is required.  Class -1 indicates that an integer of any size is acceptable; the other classes (0, 1, 2, 4, 8) indicate the number of bytes of integer data that MUST follow the integers initial byte.</p> <ul> <li> <p>int cbor_encode_integer(uvast value, unsigned char **cursor)</p> <p>Represent this value in an integer of the smallest possible integer class. Cursor is automatically advanced.  Returns number of bytes written.</p> </li> <li> <p>int cbor_encode_fixed_int(uvast value, int class, unsigned char **cursor)</p> <p>Represent this value in an integer of the indicated class.  Cursor is automatically advanced.  Returns number of bytes written, 0 on encoding error.</p> </li> <li> <p>int cbor_encode_byte_string(unsigned char *value, uvast size, unsigned char **cursor)</p> <p>size is the number of bytes to write.  If value is NULL, only the size of the byte string is written; otherwise the byte string itself is written as well.  Cursor is advanced by the number of bytes written in either case. Returns number of bytes written.</p> </li> <li> <p>int cbor_encode_text_string(char *value, uvast size, unsigned char **cursor)</p> <p>size is the number of bytes to write.  If value is NULL, only the size of the text string is written; otherwise the text string itself is written as well.  Cursor is advanced by the number of bytes written in either case. Returns number of bytes written.    </p> </li> <li> <p>int cbor_encode_array_open(uvast size, unsigned char **cursor)</p> <p>If size is ((uvast) -1), the array is of indefinite size; otherwise size indicates the number of items in the array.  Cursor is automatically advanced. Returns number of bytes written.</p> </li> <li> <p>int cbor_encode_break(unsigned char **cursor)</p> <p>Break code is written at the indicated location.  Cursor is automatically advanced.  Returns number of bytes written (always 1).</p> </li> <li> <p>int cbor_decode_initial_byte(unsigned char **cursor, unsigned int *bytesBuffered, int *majorType, int *additionalInfo)</p> <p>This function just extracts major type and additional info from the byte identified by cursor.  Cursor is automatically advanced.  Returns number of bytes decoded (always 1) or 0 on decoding error (e.g., no byte to decode).</p> </li> <li> <p>int cbor_decode_integer(    uvast *value, int class, unsigned char **cursor, unsigned int *bytesBuffered)</p> <p>If class is CborAny, any class of data item is accepted; otherwise only an integer data item of the indicated class is accepted.  Cursor is automatically advanced.  Returns number of bytes read, 0 on decoding error (e.g., integer is of the wrong class).</p> </li> <li> <p>int cbor_decode_byte_string(unsigned char *value, uvast *size, unsigned char **cursor, unsigned int *bytesBuffered)</p> <p>Initial value of size is the maximum allowable size of the decoded byte string; the actual number of bytes in the byte string (which, NOTE, is less than the number of bytes read) is returned in size.  If value is non-NULL, the decoded byte string is copied into value and cursor is automatically advanced to the end of the byte string; otherwise, cursor is advanced only to the beginning of the byte string.  Returns number of bytes read, 0 on decoding error (e.g., byte string exceeds maximum size).</p> </li> <li> <p>int cbor_decode_text_string(char *value, uvast *size, unsigned char **cursor, unsigned int *bytesBuffered)</p> <p>Initial value of size is the maximum allowable size of the decoded text string; the actual number of bytes in the text string (which, NOTE, is less than the number of bytes read) is returned in size.  If value is non-NULL, the decoded text string is copied into value and cursor is automatically advanced to the end of the text string; otherwise, cursor is advanced only to the beginning of the text string.  Returns number of bytes read, 0 on decoding error (e.g., text string exceeds maximum size).</p> </li> <li> <p>int cbor_decode_array_open(uvast *size, unsigned char **cursor, unsigned int *bytesBuffered)</p> <p>If size is zero, any array is accepted and the actual size of the decoded array is returned in size; ((uvast) -1) is returned in size if the array is of indefinite size.  If size is ((uvast) -1), only an array of indefinite length is accepted.  Otherwise, size indicates the required number of items in the array.  Cursor is automatically advanced.  Returns number of bytes read, 0 on decoding error (such as wrong number of items).</p> </li> <li> <p>int cbor_decode_break(unsigned char **cursor, unsigned int *bytesBuffered)</p> <p>Break code is read from the indicated location.  Cursor is automatically advanced.  Returns number of bytes read, 0 on decoding error (e.g., no break character at this location).</p> </li> </ul>"},{"location":"man/ici/ionconfig/","title":"NAME","text":"<p>ionconfig - ION node configuration parameters file</p>"},{"location":"man/ici/ionconfig/#description","title":"DESCRIPTION","text":"<p>ION node configuration parameters are passed to ionadmin in a file of parameter name/value pairs:</p> <p>parameter_name parameter_value</p> <p>Any line of the file that begins with a '#' character is considered a comment and is ignored.</p> <p>ionadmin supplies default values for any parameters for which no value is provided in the node configuration parameters file.</p> <p>The applicable parameters are as follows:</p> <ul> <li> <p>sdrName</p> <p>This is the character string by which this ION node's SDR database will be identified.  (Note that the SDR database infrastructure enables multiple databases to be constructed on a single host computer.)  The default value is \"ion\".</p> </li> <li> <p>sdrWmSize</p> <p>This is the size of the block of dynamic memory that will be reserved as private working memory for the SDR system itself.  A block of system memory of this size will be allocated (e.g., by malloc()) at the time the SDR system is initialized on the host computer.  The default value is 1000000 (1 million bytes).</p> </li> <li> <p>configFlags</p> <p>This is the bitwise \"OR\" (i.e., the sum) of the flag values that characterize the SDR database to use for this ION node.  The default value is 13 (that is, SDR_IN_DRAM | SDR_REVERSIBLE | SDR_BOUNDED).  The SDR configuration flags are documented in detail in sdr(3).  To recap:</p> <ul> <li> <p>SDR_IN_DRAM (1)</p> <p>The SDR is implemented in a region of shared memory.  [Possibly with write-through to a file, for fault tolerance.]</p> </li> <li> <p>SDR_IN_FILE (2)</p> <p>The SDR is implemented as a file.  [Possibly cached in a region of shared memory, for faster data retrieval.]</p> </li> <li> <p>SDR_REVERSIBLE (4)</p> <p>Transactions in the SDR are written ahead to a log, making them reversible.</p> </li> <li> <p>SDR_BOUNDED (8)</p> <p>SDR heap updates are not allowed to cross object boundaries.</p> </li> </ul> </li> <li> <p>heapKey</p> <p>This is the shared-memory key by which the pre-allocated block of shared dynamic memory to be used as heap space for this SDR can be located, if applicable.  The default value is -1, i.e., not specified and not applicable.</p> </li> <li> <p>pathName</p> <p>This is the fully qualified path name of the directory in which are located (a) the file to be used as heap space for this SDR (which will be created, if it doesn't already exist), in the event that the SDR is to be implemented in a file, and (b) the file to be used to log the database updates of each SDR transaction, in the event that transactions in this SDR are to be reversible.  The default value is /tmp.</p> </li> <li> <p>heapWords</p> <p>This is the number of words (of 32 bits each on a 32-bit machine, 64 bits each on a 64-bit machine) of nominally non-volatile storage to use for ION's SDR database.  If the SDR is to be implemented in shared memory and no heapKey is specified, a block of shared memory of this size will be allocated (e.g., by malloc()) at the time the node is created.  If the SDR is to be implemented in a file and no file named ion.sdr exists in the directory identified by pathName, then a file of this name and size will be created in this directory and initialized to all binary zeroes.  The default value is 250000 words (1 million bytes on a 32-bit computer).</p> </li> <li> <p>logSize</p> <p>This is the number of bytes of shared memory to use for ION's SDR transaction log.  If zero (the default), the transaction log is written to a file rather than to memory.  If the log is to be implemented in shared memory and no logKey is specified, a block of shared memory of this size will be allocated (e.g., by malloc()) at the time the node is created.</p> </li> <li> <p>logKey</p> <p>This is the shared-memory key by which the pre-allocated block of shared dynamic memory to be used for the transaction log for this SDR can be located, if applicable.  The default value is -1, i.e., not specified and not applicable.</p> </li> <li> <p>wmKey</p> <p>This is the shared-memory key by which this ION node's working memory will be identified.  The default value is 65281.</p> </li> <li> <p>wmAddress</p> <p>This is the address of the block of dynamic memory -- volatile storage, which is not expected to persist across a system reboot -- to use for this ION node's working memory.  If zero, the working memory block will be allocated from system memory (e.g., by malloc()) at the time the local ION node is created.  The default value is zero.</p> </li> <li> <p>wmSize</p> <p>This is the size of the block of dynamic memory that will be used for this ION node's working memory.  If wmAddress is zero, a block of system memory of this size will be allocated (e.g., by malloc()) at the time the node is created.  The default value is 5000000 (5 million bytes).</p> </li> </ul>"},{"location":"man/ici/ionconfig/#example","title":"EXAMPLE","text":"<p>configFlags 1</p> <p>heapWords 2500000</p> <p>heapKey -1</p> <p>pathName /usr/ion</p> <p>wmSize 5000000</p> <p>wmAddress 0</p>"},{"location":"man/ici/ionconfig/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1)</p>"},{"location":"man/ici/ioncrc/","title":"NAME","text":"<p>crc - ION library for computing several types of checksums.</p>"},{"location":"man/ici/ioncrc/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"crc.h\"\n</code></pre>"},{"location":"man/ici/ioncrc/#description","title":"DESCRIPTION","text":"<p>ION's \"crc\" library implements functions for computing four types of checksums: X.25 (16-bit), bzip2 (32-bit), CRC32 (32-bit), and CRC32C (32-bit).</p> <p>All checksum computation functions were provided by Antara Teknik, LLC.</p> <ul> <li> <p>uint16_t ion_CRC16_1021_X25(const char *data, uint32_t dLen, uint16_t crc)</p> <p>Computes the CRC16 value for poly 0x1021.  data points to the data block over which the checksum value is to be computed, len must be the length of that data block, and crc is the current value of the checksum that is being incrementally computed over a multi-block extent of data (zero for the first block of this extent, or if this block is the entire extent).</p> </li> <li> <p>uint32_t ion_CRC32_04C11DB7_bzip2(const char *data, uint32_t dLen, uint32_t crc)</p> <p>Computes the bzip2 CRC32 checksum value for poly 0x04c11db7.  data points to the data block over which the checksum value is to be computed, len must be the length of that data block, and crc is the current value of the checksum that is being incrementally computed over a multi-block extent of data (zero for the first block of this extent, or if this block is the entire extent).</p> </li> <li> <p>uint32_t ion_CRC32_04C11DB7(const char *data, uint32_t dLen, uint32_t crc)</p> <p>Computes the ISO-HDLC CRC32 value for poly 0x04c11db7.  data points to the data block over which the checksum value is to be computed, len must be the length of that data block, and crc is the current value of the checksum that is being incrementally computed over a multi-block extent of data (zero for the first block of this extent, or if this block is the entire extent).</p> </li> <li> <p>uint32_t ion_CRC32_1EDC6F41_C(const char *data, uint32_t dLen, uint32_t crc)</p> <p>Computes the CRC32C value for poly 0x1edc6f41.  data points to the data block over which the checksum value is to be computed, len must be the length of that data block, and crc is the current value of the checksum that is being incrementally computed over a multi-block extent of data (zero for the first block of this extent, or if this block is the entire extent).</p> </li> </ul>"},{"location":"man/ici/ionlog/","title":"NAME","text":"<p>ionlog - utility for redirecting stdin to the ION log file</p>"},{"location":"man/ici/ionlog/#synopsis","title":"SYNOPSIS","text":"<p>ionlog</p>"},{"location":"man/ici/ionlog/#description","title":"DESCRIPTION","text":"<p>The ionlog program simply reads lines of text from stdin and uses writeMemo to copy them into the ion.log file.  It terminates when it reaches EOF in stdin.</p>"},{"location":"man/ici/ionlog/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ionlog has terminated successfully.</p> </li> </ul>"},{"location":"man/ici/ionlog/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/ionlog/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/ionlog/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ionlog unable to attach to ION.</p> <p>Probable operations error: ION appears not to be initialized, in which case there is no point in running ionlog.</p> </li> </ul>"},{"location":"man/ici/ionlog/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/ionlog/#see-also","title":"SEE ALSO","text":"<p>amslogprt(1)</p>"},{"location":"man/ici/ionrc/","title":"NAME","text":"<p>ionrc - ION node management commands file</p>"},{"location":"man/ici/ionrc/#description","title":"DESCRIPTION","text":"<p>ION node management commands are passed to ionadmin either in a file of text lines or interactively at ionadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the ION node management commands are described below.</p>"},{"location":"man/ici/ionrc/#time-representation","title":"TIME REPRESENTATION","text":"<p>For many ION node management commands, time values must be passed as arguments.  Every time value may be represented in either of two formats. Absolute time is expressed as: </p> <p>yyyy/mm/dd-hh:mm:ss</p> <p>Relative time (a number of seconds following the current reference time, which defaults to the current time at the moment ionadmin began execution but which can be overridden by the at command described below) is expressed as:</p> <p>+ss</p>"},{"location":"man/ici/ionrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ionadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1 node_number [ { ion_config_filename | '.' | '' } ]</p> <p>The initialize command.  Until this command is executed, the local ION node does not exist and most ionadmin commands will fail.</p> <p>The command configures the local node to be identified by node_number, a CBHE node number which uniquely identifies the node in the delay-tolerant network.  It also configures ION's data space (SDR) and shared working-memory region.  For this purpose it uses a set of default settings if no argument follows node_number or if the argument following node_number is ''; otherwise it uses the configuration settings found in a configuration file.  If configuration file name '.' is provided, then the configuration file's name is implicitly \"hostname.ionconfig\"; otherwise, ion_config_filename is taken to be the explicit configuration file name. Please see ionconfig(5) for details of the configuration settings.</p> <p>For example:</p> <pre><code>    1 19 ''\n</code></pre> <p>would initialize ION on the local computer, assigning the local ION node the node number 19 and using default values to configure the data space and shared working-memory region.</p> </li> <li> <p>@ time</p> <p>The at command.  This is used to set the reference time that will be used for interpreting relative time values from now until the next revision of reference time.  Note that the new reference time can be a relative time, i.e., an offset beyond the current reference time.</p> </li> <li> <p>^ region_number</p> <p>The region command.  This is used to select the region to which all ensuing \"contact\" operations (until this execution of ionadmin terminates, or until the next region command is processed) pertain. A region is an arbitarily managed set of nodes that customarily are able to use contact graph routing to compute forwarding routes among themselves, and which consequently share a common contact plan.  As such, there is a one-to-one correspondence between regions and contact plans, so in effect the region command is used to switch between contact plans. Regions are notionally quite small sets (on the order of 16-32 nodes) because contact graph routing is computationally intensive.</p> <p>Information regarding up to two (2) regions may be managed at any single node.</p> <p>By default, region number 1 (the \"universal\" region) is selected.</p> </li> <li> <p>! [0 | 1]</p> <p>\"Announce\" control.  Setting the announce flag to 1 causes contact plan updates (contact add/change/delete, range add/delete) to be multicast to all other nodes in the region in addition to being processed at the local node.  Setting the announce flag to 0 disables this behavior.</p> </li> <li> <p>a contact start_time stop_time source_node dest_node xmit_data_rate [confidence]</p> <p>The add contact command.  This command schedules a period of data transmission from source_node to dest_node.  The period of transmission will begin at start_time and end at stop_time, and the rate of data transmission will be xmit_data_rate bytes/second. Our confidence in the contact defaults to 1.0, indicating that the contact is scheduled - not that non-occurrence of the contact is impossible, just that occurrence of the contact is planned and scheduled rather than merely imputed from past node behavior.  In the latter case, confidence indicates our estimation of the likelihood of this potential contact.</p> <p>The period of time between the start and stop times of a contact is termed the contact's \"interval\".  The intervals of scheduled contacts are not allowed to overlap.</p> <p>Commands pertaining to three different types of contact can be intermixed within an .ionrc file that defines a contact plan.</p> <ul> <li> <p>1  Registration</p> <p>When start_time is \"-1\", the contact signifies the \"registration\" of a node in the region corresponding to the contact plan of which this contact is a part.  In this case, source_node and dest_node must be identical and non-zero.  A registration contact simply affirms the source node's permanent membership in this region, persisting even during periods when the node is able neither to send nor to receive data.  When inserted into the contact plan, the contact's start and stop times are both automatically set to the maximum POSIX time, its data rate is set to zero, and its confidence value is set to 1.0.</p> </li> <li> <p>2  Hypothetical</p> <p>When stop_time is \"0\", the contact is \"hypothetical\".  A hypothetical contact is an anticipated opportunity for the local node to transmit data to, or receive data from, some potentially neighboring node in the same region.  The nature of that contact is completely unknown; if and when the contact occurs, the hypothetical contact will be transformed into a \"discovered\" contact for the duration of the opportunity, after which it will revert to being hypothetical.  source_node and dest_node must NOT be identical, and one or the other must identify the local node.  When inserted into the contact plan, the contact's start time is automatically set to zero, its stop time is set to the maximum POSIX time, its data rate is set to zero, and its confidence value is set to 0.0.</p> </li> <li> <p>3  Scheduled</p> <p>Otherwise, the contact is \"scheduled\".  A scheduled contact is a managed opportunity to transmit data between nodes, as inferred (for example) from a spacecraft or ground station operating plan.  start_time must be less than stop_time and data_rate and confidence must both be greater than zero.</p> </li> </ul> </li> <li> <p>c contact start_time source_node dest_node xmit_data_rate [confidence]</p> <p>The change contact command.  This command changes the data transmission rate and possibly our level of confidence in the scheduled period of data transmission from source_node to dest_node starting at start_time. Registration and hypothetical contacts cannot be changed.</p> </li> <li> <p>d contact start_time source_node dest_node</p> <p>The delete contact command.  This command deletes the contact from source_node to dest_node starting at start_time.  To delete all scheduled contacts between some pair of nodes, use '*' as start_time. To delete a registration contact, use \"-1\" as start_time.  To delete a hypothetical contact, use \"0\" as start_time.</p> </li> <li> <p>i contact start_time source_node dest_node</p> <p>This command will print information (stop time, data rate, confidence) about the scheduled period of transmission from source_node to dest_node that starts at start_time.</p> </li> <li> <p>l contact</p> <p>This command lists all contacts in the contact plan for the selected region.</p> </li> <li> <p>b contact</p> <p>The brief contacts command.  This command writes a file of commands that will recreate the current list of contacts, for the selected region, in the node's ION database.  The name of the file will be \"contacts.region_number.ionrc\".</p> </li> <li> <p>a range start_time stop_time one_node the_other_node distance</p> <p>The add range command.  This command predicts a period of time during which the distance from one_node to the_other_node will be constant to within one light second.  The period will begin at start_time and end at stop_time, and the distance between the nodes during that time will be distance light seconds.</p> <p>NOTE that the ranges declared by these commands are directional.  ION does not automatically assume that the distance from node A to node B is the same as the distance from node B to node A.  While this symmetry is certainly true of geographic distance, the range that concerns ION is the latency in propagating a signal from one node to the other; this latency may be different in different directions because (for example) the signal from B to A might need to be forwarded along a different convergence-layer network path from the one used for the signal from A to B.</p> <p>For this reason, the range identification syntax for this command is asymmetrical: ION interprets an add range command in which the node number of the first cited node is numerically less than that of the second cited node as implicitly declaring the same distance in the reverse direction (the normal case)  UNLESS a second range command is present that cites the same two nodes in the opposite order, which overrides the implicit declaration.  A range command in which the node number of the first cited node is numerically greater than that of the second cited node implies ABSOLUTELY NOTHING about the distance in the reverse direction.</p> </li> <li> <p>d range start_time one_node the_other_node</p> <p>The delete range command.  This command deletes the predicted period of constant distance between one_node and the_other_node starting at start_time.  To delete all ranges between some pair of nodes, use '*' as start_time.</p> <p>NOTE that the range identification syntax for this command is asymmetrical, much as described for the add range command described above.  ION interprets a delete range command in which the node number of the first cited node is numerically less than that of the second cited node as implicitly requesting deletion of the range in the opposite direction as well.  A delete range command in which the node number of the first cited node is numerically greater than that of the second cited node deletes only the range in that direction; the asserted range in the opposite direction is unaffected.</p> </li> <li> <p>i range start_time one_node the_other_node</p> <p>This command will print information (the stop time and range) about the predicted period of constant distance between one_node and the_other_node that starts at start_time.</p> </li> <li> <p>l range</p> <p>This command lists all predicted periods of constant distance.</p> </li> <li> <p>b range</p> <p>The brief ranges command.  This command writes a file of commands that will recreate the current list of ranges in the node's ION database.  The file's name will be \"ranges.ionrc\".</p> </li> <li> <p>m utcdelta local_time_sec_after_UTC</p> <p>This management command sets ION's understanding of the current difference between correct UTC time and the localtime equivalent of the current calendar (i.e., Unix epoch) time as reported by the clock for the local ION node's computer.  This delta is automatically applied to locally obtained time values whenever ION needs to know the current time.  For machines that are synchronized by NTP, the value of this delta should be 0, the default.</p> <p>Note that the purpose of the UTC delta is not to correct for time zone differences (which operating systems often do natively) but rather to compensate for error (drift) in clocks, particularly spacecraft clocks. The hardware clock on a spacecraft might gain or lose a few seconds every month, to the point at which its understanding of the current time - as reported out by the operating system and converted to UTC - might differ significantly from the actual value of UTC as reported by authoritative clocks on Earth.  To compensate for this difference without correcting the clock itself (which can be difficult and dangerous), ION simply adds the UTC delta to the calendar time reported by the operating system.</p> <p>Note that this means that setting the UTC delta is not a one-time node configuration activity but rather an ongoing node administration chore, because a drifting clock typically keeps on drifting.</p> </li> <li> <p>m clockerr known_maximum_clock_error</p> <p>This management command sets ION's understanding of the accuracy of the scheduled start and stop times of planned contacts, in seconds.  The default value is 1.  When revising local data transmission and reception rates, ionadmin will adjust contact start and stop times by this interval to be sure not to send bundles that arrive before the neighbor expects data arrival or to discard bundles that arrive slightly before they were expected.</p> </li> <li> <p>m clocksync [ { 1 | 0 } ]</p> <p>This management command reports whether or not the computer on which the local ION node is running has a synchronized clock, as discussed in the description of the ionClockIsSynchronized() function (ion(3)).</p> <p>If a Boolean argument is provided when the command is executed, the characterization of the machine's clock is revised to conform with the asserted value.  The default value is 1.</p> </li> <li> <p>m production planned_data_production_rate</p> <p>This management command sets ION's expectation of the mean rate of continuous data origination by local BP applications throughout the period of time over which congestion forecasts are computed, in bytes per second.  For nodes that function only as routers this variable will normally be zero.  A value of -1, which is the default, indicates that the rate of local data production is unknown; in that case local data production is not considered in the computation of congestion forecasts.</p> </li> <li> <p>m consumption planned_data_consumption_rate</p> <p>This management command sets ION's expectation of the mean rate of continuous data delivery to local BP applications throughout the period of time over which congestion forecasts are computed, in bytes per second.  For nodes that function only as routers this variable will normally be zero.  A value of -1, which is the default, indicates that the rate of local data consumption is unknown; in that case local data consumption is not considered in the computation of congestion forecasts.</p> </li> <li> <p>m inbound heap_occupancy_limit [file_system_occupancy_limit]</p> <p>This management command sets the maximum number of megabytes of storage space in ION's SDR non-volatile heap, and/or in the local file system, that can be used for the storage of inbound zero-copy objects.  A value of -1 for either limit signifies \"leave unchanged\".  The default heap limit is 30% of the SDR data space's total heap size.  The default file system limit is 1 Terabyte.</p> </li> <li> <p>m outbound heap_occupancy_limit [file_system_occupancy_limit]</p> <p>This management command sets the maximum number of megabytes of storage space in ION's SDR non-volatile heap, and/or in the local file system, that can be used for the storage of outbound zero-copy objects.  A value of -1 for either limit signifies \"leave unchanged\".  The default heap limit is 30% of the SDR data space's total heap size.  The default file system limit is 1 Terabyte.</p> </li> <li> <p>m search max_free_blocks_to_search_through</p> <p>This management command sets the limit on the number of free blocks the heap space allocation function will search through in the nominal free space bucket, looking for a sufficiently large free block, before giving up and switching to the next higher non-empty free space bucket. The default value is 0, which yields the highest memory management speed but may leave heap space under-utilized: data objects may be stored in unnecessarily large heap space blocks.  Increasing the value of the heap space search limit will manage space more efficiently - with less waste - but more slowly.</p> </li> <li> <p>m horizon { 0 | end_time_for_congestion_forecasts }</p> <p>This management command sets the end time for computed congestion forecasts.  Setting congestion forecast horizon to zero sets the congestion forecast end time to infinite time in the future: if there is any predicted net growth in bundle storage space occupancy at all, following the end of the last scheduled contact, then eventual congestion will be predicted.  The default value is zero, i.e., no end time.</p> </li> <li> <p>m alarm 'congestion_alarm_command'</p> <p>This management command establishes a command which will automatically be executed whenever ionadmin predicts that the node will become congested at some future time.  By default, there is no alarm command.</p> </li> <li> <p>m usage</p> <p>This management command simply prints ION's current data space occupancy (the number of megabytes of space in the SDR non-volatile heap and file system that are occupied by inbound and outbound zero-copy objects), the total zero-copy-object space occupancy ceiling, and the maximum level of occupancy predicted by the most recent ionadmin congestion forecast computation.</p> </li> <li> <p>r 'command_text'</p> <p>The run command.  This command will execute command_text as if it had been typed at a console prompt.  It is used to, for example, run another administrative program.</p> </li> <li> <p>s</p> <p>The start command.  This command starts the rfxclock task on the local ION node.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops the rfxclock task on the local ION node.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/ici/ionrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>@ 2008/10/05-11:30:00</p> <p>Sets the reference time to 1130 (UTC) on 5 October 2008.</p> </li> <li> <p>a range +1 2009/01/01-00:00:00 1 2 12</p> <p>Predicts that the distance between nodes 1 and 2 (endpoint IDs ipn:1.0 and ipn:2.0) will remain constant at 12 light seconds over the interval that begins 1 second after the reference time and ends at the end of calendar year 2009.</p> </li> <li> <p>a contact +60 +7260 1 2 10000</p> <p>Schedules a period of transmission at 10,000 bytes/second from node 1 to node 2, starting 60 seconds after the reference time and ending exactly two hours (7200 seconds) after it starts.</p> </li> </ul>"},{"location":"man/ici/ionrc/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1), rfxclock(1), ion(3)</p>"},{"location":"man/ici/ionsecadmin/","title":"NAME","text":"<p>ionsecadmin - ION global security database management interface</p>"},{"location":"man/ici/ionsecadmin/#synopsis","title":"SYNOPSIS","text":"<p>ionsecadmin [ commands_filename ]</p>"},{"location":"man/ici/ionsecadmin/#description","title":"DESCRIPTION","text":"<p>ionsecadmin configures and manages the ION security database on the local computer.</p> <p>It configures and manages the ION security database on the local computer in response to ION configuration commands found in commands_filename, if provided; if not, ionsecadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from ionsecadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in ionsecrc(5).</p>"},{"location":"man/ici/ionsecadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of ION security database administration.</p> </li> </ul>"},{"location":"man/ici/ionsecadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>ionsecadmin</p> <p>Enter interactive ION security policy administration command entry mode.</p> </li> <li> <p>ionsecadmin host1.ionsecrc</p> <p>Execute all configuration commands in host1.ionsecrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/ici/ionsecadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from ionsecadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which ionsecadmin was run.  The log file is typically named ion.log.</p> <p>See also ionsecrc(5).</p>"},{"location":"man/ici/ionsecadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/ionsecadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ionrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to ionsecadmin.  Otherwise ionsecadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause ionsecadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see ionsecrc(5) for details.</p>"},{"location":"man/ici/ionsecadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/ionsecadmin/#see-also","title":"SEE ALSO","text":"<p>ionsecrc(5)</p>"},{"location":"man/ici/ionsecrc/","title":"NAME","text":"<p>ionsecrc - ION security database management commands file</p>"},{"location":"man/ici/ionsecrc/#description","title":"DESCRIPTION","text":"<p>ION security database management commands are passed to ionsecadmin either in a file of text lines or interactively at ionsecadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the ION security database management commands are described below.</p>"},{"location":"man/ici/ionsecrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ionsecadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1</p> <p>The initialize command.  Until this command is executed, the local ION node has no security database and most ionsecadmin commands will fail.</p> </li> <li> <p>a key key_name file_name</p> <p>The add key command.  This command adds a named key value to the security database.  The content of file_name is taken as the value of the key.  Named keys can be referenced by other elements of the security database.</p> </li> <li> <p>c key key_name file_name</p> <p>The change key command.  This command changes the value of the named key, obtaining the new key value from the content of file_name.</p> </li> <li> <p>d key key_name</p> <p>The delete key command.  This command deletes the key identified by name.</p> </li> <li> <p>i key key_name</p> <p>This command will print information about the named key, i.e., the length of its current value.</p> </li> <li> <p>l key</p> <p>This command lists all keys in the security database.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/ici/ionsecrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a key BABKEY ./babkey.txt</p> <p>Adds a new key named \"BABKEY\" whose value is the content of the file \"./babkey.txt\".</p> </li> </ul>"},{"location":"man/ici/ionsecrc/#see-also","title":"SEE ALSO","text":"<p>ionsecadmin(1)</p>"},{"location":"man/ici/ionunlock/","title":"NAME","text":"<p>ionunlock - utility for unlocking a locked ION node</p>"},{"location":"man/ici/ionunlock/#synopsis","title":"SYNOPSIS","text":"<p>ionunlock [sdr_name]</p>"},{"location":"man/ici/ionunlock/#description","title":"DESCRIPTION","text":"<p>The ionunlock program is designed to be run when some ION thread has terminated while it is the owner of the node's system mutex, i.e., while in the midst of an SDR transaction.  IT MUST NEVER BE RUN AT ANY OTHER TIME as it will totally corrupt a node that is not locked up. The program simply declares itself to be the owner of the incomplete transaction and cancels it, enabling the rest of the system to resume operations.</p> <p>If omitted, sdr_name defaults to \"ion\".</p>"},{"location":"man/ici/ionunlock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ionunlock has terminated successfully.</p> </li> <li> <p>\"1\"</p> <p>ionunlock has terminated unsuccessfully.  See diagnostic messages in the ion.log log file for details.</p> </li> </ul>"},{"location":"man/ici/ionunlock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/ionunlock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/ionunlock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't initialize the SDR system.</p> <p>Probable operations error: ION appears not to be initialized, in which case there is no point in running ionunlock.</p> </li> <li> <p>Can't start using SDR.</p> <p>ION system error.  See earlier diagnostic messages posted to ion.log for details.  In this event it is unlikely that ionunlock can be run successfully, and it is also unlikely that it would have any effect if it did run successfully.</p> </li> <li> <p>ionunlock unnecessary; exiting.</p> <p>Either the indicated SDR is not initialized or it is not currently stuck in a transaction.</p> </li> </ul>"},{"location":"man/ici/ionunlock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/ionunlock/#see-also","title":"SEE ALSO","text":"<p>ionxnowner(1), sdrmend(1), sdr(3)</p>"},{"location":"man/ici/ionxnowner/","title":"NAME","text":"<p>ionxnowner - report on which threads are initiating SDR transactions</p>"},{"location":"man/ici/ionxnowner/#synopsis","title":"SYNOPSIS","text":"<p>ionxnowner [interval [count [echo]]]</p>"},{"location":"man/ici/ionxnowner/#description","title":"DESCRIPTION","text":"<p>For count interations (defaulting to 1), ionxnowner prints the process ID and thread ID of the thread that currently \"owns\" the  local node's SDR data store (i.e., started the current transaction), then sleeps interval seconds (minimum 1).  If the optional echo parameter is set to 1, then the transaction owner message is logged as well as printed to the console.</p>"},{"location":"man/ici/ionxnowner/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ionxnowner has terminated.</p> </li> </ul>"},{"location":"man/ici/ionxnowner/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/ionxnowner/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/ionxnowner/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to ION.</p> <p>ION system error.  See earlier diagnostic messages posted to ion.log for details.</p> </li> <li> <p>Can't access SDR.</p> <p>ION system error.  See earlier diagnostic messages posted to ion.log for details.</p> </li> </ul>"},{"location":"man/ici/ionxnowner/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/ionxnowner/#see-also","title":"SEE ALSO","text":"<p>ionunlock(1), sdr(3), psmwatch(1)</p>"},{"location":"man/ici/llcv/","title":"NAME","text":"<p>llcv - library for manipulating linked-list condition variable objects</p>"},{"location":"man/ici/llcv/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"llcv.h\"\n\ntypedef struct llcv_str\n{\n    Lyst            list;\n    pthread_mutex_t mutex;\n    pthread_cond_t  cv;\n} *Llcv;\n\ntypedef int (*LlcvPredicate)(Llcv);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/llcv/#description","title":"DESCRIPTION","text":"<p>A \"linked-list condition variable\" object (LLCV) is an inter-thread communication mechanism that pairs a process-private linked list in memory with a condition variable as provided by the pthreads library. LLCVs echo in thread programming the standard ION inter-process or inter-task communication model that pairs shared-memory semaphores with linked lists in shared memory or shared non-volatile storage. As in the semaphore/list model, variable-length messages may be transmitted; the resources allocated to the communication mechanism grow and shrink to accommodate changes in data rate; the rate at which messages are issued is completely decoupled from the rate at which messages are received and processed.  That is, there is no flow control, no blocking, and therefore no possibility of deadlock or \"deadly embrace\".  Traffic spikes are handled without impact on processing rate, provided sufficient memory is provided to accommodate the peak backlog.</p> <p>An LLCV comprises a Lyst, a mutex, and a condition variable.  The Lyst may be in either private or shared memory, but the Lyst itself is not shared with other processes.  The reader thread waits on the condition variable until signaled by a writer that some condition is now true.  The standard Lyst API functions are used to populate and drain the linked list.  In order to protect linked list integrity, each thread must call llcv_lock() before operating on the Lyst and llcv_unlock() afterwards.  The other llcv functions merely effect flow signaling in a way that makes it unnecessary for the reader to poll or busy-wait on the Lyst.</p> <ul> <li> <p>Llcv llcv_open(Lyst list, Llcv llcv)</p> <p>Opens an LLCV, initializing as necessary.  The list argument must point to an existing Lyst, which may reside in either private or shared dynamic memory.  llcv must point to an existing llcv_str management object, which may reside in either static or dynamic (private or shared) memory -- but NOT in stack space.  Returns llcv on success, NULL on any error. </p> </li> <li> <p>void llcv_lock(Llcv llcv)</p> <p>Locks the LLCV's Lyst so that it may be updated or examined safely by the calling thread.  Fails silently on any error.</p> </li> <li> <p>void llcv_unlock(Llcv llcv)</p> <p>Unlocks the LLCV's Lyst so that another thread may lock and update or examine it.  Fails silently on any error.</p> </li> <li> <p>int llcv_wait(Llcv llcv, LlcvPredicate cond, int microseconds)</p> <p>Returns when the Lyst encapsulated within the LLCV meets the indicated condition.  If microseconds is non-negative, will return -1 and set errno to ETIMEDOUT when the indicated number of microseconds has passed, if and only if the indicated condition has not been met by that time.  Negative values of the microseconds argument other than LLCV_BLOCKING (defined as -1) are illegal.  Returns -1 on any error.</p> </li> <li> <p>void llcv_signal(Llcv llcv, LlcvPredicate cond)</p> <p>Locks the indicated LLCV's Lyst; tests (evaluates) the indicated condition with regard to that LLCV; if the condition is true, signals to the waiting reader on this LLCV (if any) that the Lyst encapsulated in the indicated LLCV now meets the indicated condition; and unlocks the Lyst.</p> </li> <li> <p>void llcv_signal_while_locked(Llcv llcv, LlcvPredicate cond)</p> <p>Same as llcv_signal() except does not lock the Llcv's mutex before signalling or unlock afterwards.  For use when the Llcv is already locked; prevents deadlock.</p> </li> <li> <p>void llcv_close(Llcv llcv)</p> <p>Destroys the indicated LLCV's mutex and condition variable.  Fails silently (and has no effect) if a reader is currently waiting on the Llcv.</p> </li> <li> <p>int llcv_lyst_is_empty(Llcv Llcv)</p> <p>A built-in \"convenience\" predicate, for use when calling llcv_wait(), llcv_signal(), or llcv_signal_while_locked().  Returns true if the length of the indicated LLCV's encapsulated Lyst is zero, false otherwise.</p> </li> <li> <p>int llcv_lyst_not_empty(Llcv Llcv)</p> <p>A built-in \"convenience\" predicate, for use when calling llcv_wait(), llcv_signal(), or llcv_signal_while_locked().  Returns true if the length of the LLCV's encapsulated Lyst is non-zero, false otherwise.</p> </li> </ul>"},{"location":"man/ici/llcv/#see-also","title":"SEE ALSO","text":"<p>lyst(3)</p>"},{"location":"man/ici/lyst/","title":"NAME","text":"<p>lyst - library for manipulating generalized doubly linked lists</p>"},{"location":"man/ici/lyst/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"lyst.h\"\n\ntypedef int  (*LystCompareFn)(void *s1, void *s2);\ntypedef void (*LystCallback)(LystElt elt, void *userdata);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/lyst/#description","title":"DESCRIPTION","text":"<p>The \"lyst\" library uses two types of objects, Lyst objects and LystElt objects.  A Lyst knows how many elements it contains,  its first and last elements, the memory manager used to create/destroy the Lyst and its elements, and how the elements are sorted.  A LystElt knows its content (normally a pointer to an item in memory), what Lyst it belongs to, and the LystElts before and after it in that Lyst.</p> <ul> <li> <p>Lyst lyst_create(void)</p> <p>Create and return a new Lyst object without any elements in it. All operations performed on this Lyst will use the allocation/deallocation functions of the default memory manager \"std\" (see memmgr(3)).  Returns NULL on any failure.</p> </li> <li> <p>Lyst lyst_create_using(unsigned memmgrId)</p> <p>Create and return a new Lyst object without any elements in it. All operations performed on this Lyst will use the allocation/deallocation functions of the specified memory manager (see memmgr(3)).  Returns NULL on any failure.</p> </li> <li> <p>void lyst_clear(Lyst list)</p> <p>Clear a Lyst, i.e. free all elements of list, calling the Lyst's deletion function if defined, but without destroying the Lyst itself.</p> </li> <li> <p>void lyst_destroy(Lyst list)</p> <p>Destroy a Lyst.  Will free all elements of list, calling the Lyst's deletion function if defined.</p> </li> <li> <p>void lyst_compare_set(Lyst list, LystCompareFn compareFn)</p> </li> <li> <p>LystCompareFn lyst_compare_get(Lyst list)</p> <p>Set/get comparison function for specified Lyst.  Comparison  functions are called with two Lyst element data pointers, and must return a negative integer if first is less than second, 0 if both are equal, and a positive integer if first is greater than second (i.e., same return values as strcmp(3)). The comparison function is used by the lyst_insert(), lyst_search(), lyst_sort(), and lyst_sorted() functions.</p> </li> <li> <p>void lyst_direction_set(Lyst list, LystSortDirection direction)</p> <p>Set sort direction (either LIST_SORT_ASCENDING or LIST_SORT_DESCENDING) for specified Lyst.  If no comparison function is set, then this controls whether new elements are added to the end or beginning (respectively)  of the Lyst when lyst_insert() is called.</p> </li> <li> <p>void lyst_delete_set(Lyst list, LystCallback deleteFn, void *userdata)</p> <p>Set user deletion function for specified Lyst.  This function is automatically called whenever an element of the Lyst is deleted, to perform any user-required processing.  When automatically called, the deletion function is passed two arguments: the element being deleted and the userdata pointer specified in the lyst_delete_set() call.</p> </li> <li> <p>void lyst_insert_set(Lyst list, LystCallback insertFn, void *userdata)</p> <p>Set user insertion function for specified Lyst.  This function is automatically called whenever a Lyst element is inserted into the Lyst, to perform any user-required processing. When automatically called, the insertion function is passed two arguments: the element being inserted and the userdata pointer specified in the lyst_insert_set() call.</p> </li> <li> <p>unsigned long lyst_length(Lyst list)</p> <p>Return the number of elements in the Lyst.</p> </li> <li> <p>LystElt lyst_insert(Lyst list, void *data)</p> <p>Create a new element whose content is the pointer value data and insert it into the Lyst.  Uses the Lyst's comparison function to select insertion point, if defined; otherwise adds the new element at the beginning or end of the Lyst, depending on the Lyst sort direction setting.  Returns a pointer to the newly created element, or NULL on any failure.</p> </li> <li> <p>LystElt lyst_insert_first(Lyst list, void *data)</p> </li> <li> <p>LystElt lyst_insert_last(Lyst list, void *data)</p> <p>Create a new element and insert it at the beginning/end of the Lyst.  If these functions are used when inserting elements into a Lyst with a defined comparison function, then the Lyst may get out of order and future calls to lyst_insert() can put new elements  in unpredictable locations.  Returns a pointer to the newly created element, or NULL on any failure.</p> </li> <li> <p>LystElt lyst_insert_before(LystElt element, void *data)</p> </li> <li> <p>LystElt lyst_insert_after(LystElt element, void *data)</p> <p>Create a new element and insert it before/after the specified element.  If these functions are used when inserting elements into a Lyst with a defined comparison function, then the Lyst may get out of order and future calls to lyst_insert() can put new elements in unpredictable locations.  Returns a pointer to the newly created element, or NULL on any failure.</p> </li> <li> <p>void lyst_delete(LystElt element)</p> <p>Delete the specified element from its Lyst and deallocate its memory. Calls the user delete function if defined.</p> </li> <li> <p>LystElt lyst_first(Lyst list)</p> </li> <li> <p>LystElt lyst_last(Lyst list)</p> <p>Return a pointer to the first/last element of a Lyst.</p> </li> <li> <p>LystElt lyst_next(LystElt element)</p> </li> <li> <p>LystElt lyst_prev(LystElt element)</p> <p>Return a pointer to the element following/preceding the specified element.</p> </li> <li> <p>LystElt lyst_search(LystElt element, void *searchValue)</p> <p>Find the first matching element in a Lyst starting with the specified element.  Returns NULL if no matches are found.  Uses the Lyst's comparison function if defined, otherwise searches from the given element to the end of the Lyst.</p> </li> <li> <p>Lyst lyst_lyst(LystElt element)</p> <p>Return the Lyst to which the specified element belongs.</p> </li> <li> <p>void* lyst_data(LystElt element)</p> </li> <li> <p>void* lyst_data_set(LystElt element, void *data)</p> <p>Get/set the pointer value content of the specified Lyst element.  The set routine returns the element's previous content, and the delete function is not called.  If the lyst_data_set() function is used on an element of a Lyst with a defined comparison function, then the Lyst may get out of order and future calls to lyst_insert() can put new elements in unpredictable locations.</p> </li> <li> <p>void lyst_sort(Lyst list)</p> <p>Sort the Lyst based on the current comparison function and sort direction.  A stable insertion sort is used that is very fast when the elements are already in order.</p> </li> <li> <p>int lyst_sorted(Lyst list)</p> <p>Determine whether or not the Lyst is sorted based on the current comparison function and sort direction.</p> </li> <li> <p>void lyst_apply(Lyst list, LystCallback applyFn, void *userdata)</p> <p>Apply the function applyFn automatically to each element in the Lyst.  When automatically called, applyFn is passed two arguments: a pointer to an element, and the userdata argument specified in the call to lyst_apply().  applyFn should not delete or reorder the elements in the Lyst.</p> </li> </ul>"},{"location":"man/ici/lyst/#see-also","title":"SEE ALSO","text":"<p>memmgr(3), psm(3)</p>"},{"location":"man/ici/memmgr/","title":"NAME","text":"<p>memmgr - memory manager abstraction functions</p>"},{"location":"man/ici/memmgr/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"memmgr.h\"\n\ntypedef void *(* MemAllocator)\n    (char *fileName, int lineNbr, size_t size);\ntypedef void (* MemDeallocator)\n    (char *fileName, int lineNbr, void * blk);\ntypedef void *(* MemAtoPConverter) (unsigned int address);\ntypedef unsigned int (* MemPtoAConverter) (void * pointer);\n\nunsigned int memmgr_add       (char *name,\n                               MemAllocator take, \n                               MemDeallocator release, \n                               MemAtoPConverter AtoP, \n                               MemPtoAConverter PtoA);\nint memmgr_find               (char *name);\nchar *memmgr_name             (int mgrId);\nMemAllocator memmgr_take      (int mgrId);\nMemDeallocator memmgr_release (int mgrId);\nMemAtoPConverter memmgr_AtoP  (int mgrId);\nMemPtoAConverter memmgr_PtoA  (int mgrId;\n\nint memmgr_open               (int memKey,\n                               unsigned long memSize,\n                               char **memPtr,\n                               int *smId,\n                               char *partitionName,\n                               PsmPartition *partition,\n                               int *memMgr,\n                               MemAllocator afn,\n                               MemDeallocator ffn,\n                               MemAtoPConverter apfn,\n                               MemPtoAConverter pafn);\nvoid memmgr_destroy           (int smId,\n                               PsmPartition *partition);\n</code></pre>"},{"location":"man/ici/memmgr/#description","title":"DESCRIPTION","text":"<p>\"memmgr\" is an abstraction layer for administration of memory management.  It enables multiple memory managers to coexist in a single application.  Each memory manager specification is required to include pointers to a memory allocation function, a memory deallocation function, and functions for translating between local memory pointers and \"addresses\", which are abstract memory locations that have private meaning to the manager.  The allocation function is expected to return a block of memory of size \"size\" (in bytes), initialized to all binary zeroes.  The fileName and lineNbr arguments to the allocation and deallocation functions are expected to be the values of __FILE__ and __LINE__ at the point at which the functions are called; this supports any memory usage tracing via sptrace(3) that may be implemented by the underlying memory management system.</p> <p>Memory managers are identified by number and by name.  The identifying number for a memory manager is an index into a private, fixed-length array of up to 8 memory manager configuration structures; that is, memory manager number must be in the range 0-7.  However, memory manager numbers are assigned dynamically and not always predictably. To enable multiple applications to use the same memory manager for a given segment of shared memory, a memory manager may be located by a predefined name of up to 15 characters that is known to all the applications.</p> <p>The memory manager with manager number 0 is always available; its name is \"std\".  Its memory allocation function is calloc(), its deallocation function is free(), and its pointer/address translation functions are merely casts.</p> <ul> <li> <p>unsigned int memmgr_add(char *name,                               MemAllocator take,                                MemDeallocator release,                                MemAtoPConverter AtoP,                                MemPtoAConverter PtoA)</p> <p>Add a memory manager to the memory manager array, if not already defined; attempting to add a previously added memory manager is not considered an error.  name is the name of the memory manager. take is a pointer to the manager's memory allocation function; release is a pointer to the manager's memory deallocation function.  AtoP is a pointer to the manager's function for converting an address  to a local memory pointer; PtoA is a pointer to the manager's pointer-to-address converter function. Returns the memory manager ID number assigned to the named manager, or -1 on any error.</p> <p>NOTE: memmgr_add() is NOT thread-safe.  In a multithreaded execution image (e.g., VxWorks), all memory managers should be loaded before any subordinate threads or tasks are spawned.</p> </li> <li> <p>int memmgr_find(char *name)</p> <p>Return the memmgr ID of the named manager, or -1 if not found.</p> </li> <li> <p>char *memmgr_name(int mgrId)</p> <p>Return the name of the manager given by mgrId.</p> </li> <li> <p>MemAllocator memmgr_take(int mgrId)</p> <p>Return the allocator function pointer for the manager given by mgrId.</p> </li> <li> <p>memDeallocator memmgr_release(int mgrId)</p> <p>Return the deallocator function pointer for the manager given by mgrId.</p> </li> <li> <p>MemAtoPConverter memmgr_AtoP(int mgrId)</p> <p>Return the address-to-pointer converter function pointer for the manager given by mgrId.</p> </li> <li> <p>MemPtoAConverter memmgr_PtoA(int mgrId)</p> <p>Return the pointer-to-address converter function pointer for the manager given by mgrId.</p> </li> <li> <p>int memmgr_open(int memKey,                       unsigned long memSize,                       char **memPtr,                       int *smId,                       char *partitionName,                       PsmPartition *partition,                       int *memMgr,                       MemAllocator afn,                       MemDeallocator ffn,                       MemAtoPConverter apfn,                       MemPtoAConverter pafn);</p> <p>memmgr_open() opens one avenue of access to a PSM managed region of shared memory, initializing as necessary.</p> <p>In order for multiple tasks to share access to this memory region, all must cite the same memkey and partitionName when they call memmgr_open().  If shared access is not necessary, then memKey can be SM_NO_KEY and partitionName can be any valid partition name.</p> <p>If it is known that a prior invocation of memmgr_open() has already initialized the region, then memSize can be zero and memPtr must be NULL.  Otherwise memSize is required and the required value of memPtr depends on whether or not the memory that is to be shared and managed has already been allocated (e.g., it's a fixed region of bus memory).  If so, then the memory pointer variable that memPtr points to must contain the address of that memory region.  Otherwise, *memPtr must contain NULL.</p> <p>memmgr_open() will allocate system memory as necessary and will in any case return the address of the shared memory region in *memPtr.</p> <p>If the shared memory is newly allocated or otherwise not yet under PSM management, then memmgr_open() will invoke psm_manage() to manage the shared memory region.  It will also add a catalogue for the managed shared memory region as necessary.</p> <p>If memMgr is non-NULL, then memmgr_open() will additionally call memmgr_add() to establish a new memory manager for this managed shared memory region, as necessary.  The index of the applicable memory manager will be returned in memMgr.  If that memory manager is newly created, then the supplied afn, ffn, apfn, and pafn functions (which can be written with reference to the memory manager index value returned in memMgr) have been established as the memory management functions for local private access to this managed shared memory region.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>void memmgr_destroy(int smId, PsmPartition *partition);</p> <p>memmgr_destroy() terminates all access to a PSM managed region of shared memory, invoking psm_erase() to destroy the partition and sm_ShmDestroy() to destroy the shared memory object.</p> </li> </ul>"},{"location":"man/ici/memmgr/#example","title":"EXAMPLE","text":"<pre><code>/* this example uses the calloc/free memory manager, which is\n * called \"std\", and is always defined in memmgr. */\n\n #include \"memmgr.h\"\n\n main() \n {\n     int mgrId;\n     MemAllocator myalloc;\n     MemDeallocator myfree;\n     char *newBlock;\n\n     mgrId = memmgr_find(\"std\");\n     myalloc = memmgr_take(mgrId);\n     myfree = memmgr_release(mgrId);\n     ...\n\n     newBlock = myalloc(5000);\n     ...\n     myfree(newBlock);\n }\n</code></pre>"},{"location":"man/ici/memmgr/#see-also","title":"SEE ALSO","text":"<p>psm(3)</p>"},{"location":"man/ici/owltsim/","title":"NAME","text":"<p>owltsim - one-way light time transmission delay simulator</p>"},{"location":"man/ici/owltsim/#synopsis","title":"SYNOPSIS","text":"<p>owltsim config_filename [-v]</p>"},{"location":"man/ici/owltsim/#description","title":"DESCRIPTION","text":"<p>owltsim delays delivery of data between pairs of ION nodes by specified lengths of time, simulating the signal propagation delay imposed by distance between the nodes.</p> <p>Its operation is configured by delay simulation configuration lines in the file identified by config_filename.  A pair of threads is created for each line in the file: one that receives UDP datagrams on a specified port and queues them in a linked list, and a second that later removes queued datagrams from the linked list and sends them on to a specified UDP port on a specified network host.</p> <p>Each configuration line must be of the following form:</p> <p>to from my_port# dest_host dest_port# owlt modulus</p> <ul> <li> <p>to identifies the receiving node.</p> <p>This parameter is purely informational, intended to make owltsim's printed messages more helpful to the user.</p> </li> <li> <p>from identifies the sending node.</p> <p>A value of '*' may be used to indicate \"all nodes\".  Again, this parameter is purely informational, intended to make owltsim's printed messages more helpful to the user.</p> </li> <li> <p>my_port# identifies owltsim's receiving port for this traffic.</p> </li> <li>dest_host is a hostname identifying the computer to which owltsim will transmit this traffic.</li> <li>dest_port# identifies the port to which owltsim will transmit this traffic.</li> <li>owlt specifies the number of seconds to wait before forwarding each received datagram.</li> <li> <p>modulus controls the artificial random data loss imposed on this traffic by owltsim.</p> <p>A value of '0' specifies \"no imposed data loss\".  Any modulus value N &gt; 0 causes owltsim to randomly drop (i.e., not transmit upon expiration of the delay interval) one out of every N packets.  Any modulus value N &lt; 0 causes owltsim to deterministically drop every (0 - N)th packet.</p> </li> </ul> <p>The optional -v (\"verbose\") parameter causes owltsim to print a message whenever it receives, sends, or drops (due to artificial random data loss) a datagram.</p> <p>Note that error conditions may cause one delay simulation (a pair of threads) to terminate without terminating any others.</p> <p>owltsim is designed to run indefinitely.  To terminate the program, just use control-C to kill it.</p>"},{"location":"man/ici/owltsim/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Nominal termination.</li> <li>\"1\" Termination due to an error condition, as noted in printed messages.</li> </ul>"},{"location":"man/ici/owltsim/#examples","title":"EXAMPLES","text":"<p>Here is a sample owltsim configuration file:</p> <ul> <li>2 7 5502 ptl07.jpl.nasa.gov 5001 75 0</li> <li>7 2 5507 ptl02.jpl.nasa.gov 5001 75 16</li> </ul> <p>This file indicates that owltsim will receive on port 5502 the ION traffic from node 2 that is destined for node 7, which will receive it at port 5001 on the computer named ptl07.jpl.nasa.gov; 75 seconds of delay (simulating a distance of 75 light seconds) will be imposed on this transmission activity, and owltsim will not simulate any random data loss.</p> <p>In the reverse direction, owltsim will receive on port 5507 the ION traffic from node 7 that is destined for node 2, which will receive it at port 5001 on the computer named ptl02.jpl.nasa.gov; 75 seconds of delay will again be imposed on this transmission activity, and owltsim will randomly discard (i.e., not transmit upon expiration of the transmission delay interval) one datagram out of every 16 received at this port.</p>"},{"location":"man/ici/owltsim/#files","title":"FILES","text":"<p>Not applicable.</p>"},{"location":"man/ici/owltsim/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/owltsim/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be printed to stdout:</p> <ul> <li> <p>owltsim can't open configuration file</p> <p>The program terminates.</p> </li> <li> <p>owltsim failed on fscanf</p> <p>Failure on reading the configuration file.  The program terminates.</p> </li> <li> <p>owltsim stopped malformed config file line line_number.</p> <p>Failure on parsing the configuration file.  The program terminates.</p> </li> <li> <p>owltsim can't spawn receiver thread</p> <p>The program terminates.</p> </li> <li> <p>owltsim out of memory.</p> <p>The program terminates.</p> </li> <li> <p>owltsim can't open reception socket</p> <p>The program terminates.</p> </li> <li> <p>owltsim can't initialize reception socket</p> <p>The program terminates.</p> </li> <li> <p>owltsim can't open transmission socket</p> <p>The program terminates.</p> </li> <li> <p>owltsim can't initialize transmission socket</p> <p>The program terminates.</p> </li> <li> <p>owltsim can't spawn timer thread</p> <p>The program terminates.</p> </li> <li> <p>owltsim can't acquire datagram</p> <p>Datagram transmission failed.  This causes the threads for the affected delay simulation to terminate, without terminating any other threads.</p> </li> <li> <p>owltsim failed on send</p> <p>Datagram transmission failed.  This causes the threads for the affected delay simulation to terminate, without terminating any other threads.</p> </li> <li> <p>at time owltsim LOST a dg of length length from sending node destined for receiving node due to ECONNREFUSED.</p> <p>This is an informational message.  Due to an apparent bug in Internet protocol implementation, transmission of a datagram on a connected UDP socket occasionally fails.  owltsim does not attempt to retransmit the affected datagram.</p> </li> </ul>"},{"location":"man/ici/owltsim/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/owltsim/#see-also","title":"SEE ALSO","text":"<p>udplsi(1), udplso(1)</p>"},{"location":"man/ici/owlttb/","title":"NAME","text":"<p>owlttb - one-way light time transmission delay simulator</p>"},{"location":"man/ici/owlttb/#synopsis","title":"SYNOPSIS","text":"<p>owlttb own_uplink_port# own_downlink_port# dest_uplink_IP_address dest_uplink_port# dest_downlink_IP_address dest_downlink_port# owlt_sec. [-v]</p>"},{"location":"man/ici/owlttb/#description","title":"DESCRIPTION","text":"<p>owlttb delays delivery of data between an NTTI and a NetAcquire box (or two, one for uplink and one for downlink) by a specified length of time, simulating the signal propagation delay imposed by distance between the nodes.</p> <p>Its operation is configured by the command-line parameters, except that the delay interval itself may be changed while the program is running.  owlttb offers a command prompt (:), and when a new value of one-way light time is entered at this prompt the new delay interval takes effect immediately.</p> <ul> <li>own_uplink_port# identifies the port on owlttb accepts the NTTI's TCP connection for uplink traffic (i.e., data destined for the NetAcquire box).</li> <li>own_downlink_port# identifies the port on owlttb accepts the NTTI's TCP connection for downlink traffic (i.e., data issued by the NetAcquire box).</li> <li>dest_uplink_IP_address is the IP address (a dotted string) identifying the NetAcquire box to which owlttb will transmit uplink traffic.</li> <li>dest_uplink_port# identifies the TCP port to which owlttb will connect in order to transmit uplink traffic to NetAcquire.</li> <li>dest_downlink_IP_address is the IP address (a dotted string) identifying the NetAcquire box from which owlttb will receive downlink traffic.</li> <li>dest_downlink_port# identifies the TCP port to which owlttb will connect in order to receive downlink traffic from NetAcquire.</li> <li>owlt specifies the number of seconds to wait before forwarding each received segment of TCP traffic.</li> </ul> <p>The optional -v (\"verbose\") parameter causes owlttb to print a message whenever it receives, sends, or discards (due to absence of a connected downlink client) a segment of TCP traffic.</p> <p>owlttb is designed to run indefinitely.  To terminate the program, just use control-C to kill it or enter \"q\" at the prompt.</p>"},{"location":"man/ici/owlttb/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Nominal termination.</li> <li>\"1\" Termination due to an error condition, as noted in printed messages.</li> </ul>"},{"location":"man/ici/owlttb/#examples","title":"EXAMPLES","text":"<p>Here is a sample owlttb command:</p> <ul> <li>owlttb 2901 2902 137.7.8.19 10001 137.7.8.19 10002 75</li> </ul> <p>This command indicates that owlttb will accept an uplink traffic connection on port 2901, forwarding the received uplink traffic to port 10001 on the NetAcquire box at 137.7.8.19, and it will accept a downlink traffic connection on port 2902, delivering over that connection all downlink traffic that it receives from connecting to port 10002 on the NetAcquire box at 137.7.8.19. 75 seconds of delay (simulating a distance of 75 light seconds) will be imposed on this transmission activity.</p>"},{"location":"man/ici/owlttb/#files","title":"FILES","text":"<p>Not applicable.</p>"},{"location":"man/ici/owlttb/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/owlttb/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be printed to stdout:</p> <ul> <li> <p>owlttb can't spawn uplink thread</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't spawn uplink sender thread</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't spawn downlink thread</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't spawn downlink receiver thread</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't spawn downlink sender thread</p> <p>The program terminates.</p> </li> <li> <p>owlttb fgets failed</p> <p>The program terminates.</p> </li> <li> <p>owlttb out of memory.</p> <p>The program terminates.</p> </li> <li> <p>owlttb lost uplink client.</p> <p>This is an informational message.  The NTTI may reconnect at any time.</p> </li> <li> <p>owlttb lost downlink client</p> <p>This is an informational message.  The NTTI may reconnect at any time.</p> </li> <li> <p>owlttb can't open TCP socket to NetAcquire</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't connect TCP socket to NetAcquire</p> <p>The program terminates.</p> </li> <li> <p>owlttb write() error on socket</p> <p>The program terminates if it was writing to NetAcquire; otherwise it simply recognizes that the client NTTI has disconnected.</p> </li> <li> <p>owlttb read() error on socket</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't open uplink dialup socket</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't initialize uplink dialup socket</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't open downlink dialup socket</p> <p>The program terminates.</p> </li> <li> <p>owlttb can't initialize downlink dialup socket</p> <p>The program terminates.</p> </li> <li> <p>owlttb accept() failed</p> <p>The program terminates.</p> </li> </ul>"},{"location":"man/ici/owlttb/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/platform/","title":"NAME","text":"<p>platform - C software portability definitions and functions</p>"},{"location":"man/ici/platform/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"platform.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/platform/#description","title":"DESCRIPTION","text":"<p>platform is a library of functions that simplify the porting of software written in C.  It provides an API that enables application  code to access the resources of an abstract POSIX-compliant \"least common denominator\" operating system -- typically a large subset of the resources of the actual underlying operating system.</p> <p>Most of the functionality provided by the platform library is aimed at making communication code portable: common functions for shared memory, semaphores, and IP sockets are provided. The implementation of the abstract O/S API varies according to the actual operating system on which the application runs, but the API's behavior is always the same; applications that invoke the platform library functions rather than native O/S system calls may forego some O/S-specific capability, but they gain portability  at little if any cost in performance.</p> <p>Differences in word size among platforms are implemented by values of the SPACE_ORDER macro.  \"Space order\" is the base 2 log of the number of octets in a word: for 32-bit machines the space order is 2 (2^2 = 4 octets per word), for 64-bit machines it is 3 (2^3 = 8 octets per word).</p> <p>A consistent platform-independent representation of large integers is useful for some applications.  For this purpose, platform defines new types vast and uvast (unsigned vast) which are consistently defined to be 64-bit integers regardless of the platform's native word size.</p> <p>The platform.h header file #includes many of the most frequently needed header files: sys/types.h, errno.h, string.h, stdio.h, sys/socket.h, signal.h, dirent.h, netinet/in.h, unistd.h, stdlib.h, sys/time.h, sys/resource.h, malloc.h, sys/param.h, netdb.h, sys/uni.h, and fcntl.h.  Beyond this, platform attempts  to enhance compatibility by providing standard macros, type definitions, external references, or function implementations  that are missing from a few supported O/S's but supported by all others.  Finally, entirely new, generic functions are provided  to establish a common body of functionality that subsumes significantly different O/S-specific capabilities.</p>"},{"location":"man/ici/platform/#platform-compatibility-patches","title":"PLATFORM COMPATIBILITY PATCHES","text":"<p>The platform library \"patches\" the APIs of supported O/S's to guarantee that all of the following items may be utilized by application  software:</p> <pre><code>The strchr(), strrchr(), strcasecmp(), and strncasecmp() functions.\n\nThe unlink(), getpid(), and gettimeofday() functions.\n\nThe select() function.\n\nThe FD_BITMAP macro (used by select()).\n\nThe MAXHOSTNAMELEN macro.\n\nThe NULL macro.\n\nThe timer_t type definition.\n</code></pre>"},{"location":"man/ici/platform/#platform-generic-macros-and-functions","title":"PLATFORM GENERIC MACROS AND FUNCTIONS","text":"<p>The generic macros and functions in this section may be used in place of comparable O/S-specific functions, to enhance the portability  of code.  (The implementations of these macros and functions are  no-ops in environments in which they are inapplicable, so they're always safe to call.)</p> <ul> <li> <p>FDTABLE_SIZE</p> <p>The FDTABLE_SIZE macro returns the total number of file descriptors defined for the process (or VxWorks target).</p> </li> <li> <p>ION_PATH_DELIMITER</p> <p>The ION_PATH_DELIMITER macro returns the ASCII character -- either '/' or '\\' -- that is used as a directory name delimiter in path names for the file system used by the local platform.</p> </li> <li> <p>oK(expression)</p> <p>The oK macro simply casts the value of expression to void, a way of handling function return codes that are not meaningful in this context.</p> </li> <li> <p>CHKERR(condition)</p> <p>The CHKERR macro is an \"assert\" mechanism.  It causes the calling function to return -1 immediately if condition is false. </p> </li> <li> <p>CHKZERO(condition)</p> <p>The CHKZERO macro is an \"assert\" mechanism.  It causes the calling function to return 0 immediately if condition is false. </p> </li> <li> <p>CHKNULL(condition)</p> <p>The CHKNULL macro is an \"assert\" mechanism.  It causes the calling function to return NULL immediately if condition is false. </p> </li> <li> <p>CHKVOID(condition)</p> <p>The CHKVOID macro is an \"assert\" mechanism.  It causes the calling function to return immediately if condition is false. </p> </li> <li> <p>void snooze(unsigned int seconds)</p> <p>Suspends execution of the invoking task or process for the indicated  number of seconds.</p> </li> <li> <p>void microsnooze(unsigned int microseconds)</p> <p>Suspends execution of the invoking task or process for the indicated number of microseconds.</p> </li> <li> <p>void getCurrentTime(struct timeval *time)</p> <p>Returns the current local time (ctime, i.e., Unix epoch time) in a timeval structure (see gettimeofday(3C)).</p> </li> <li> <p>void isprintf(char *buffer, int bufSize, char *format, ...)</p> <p>isprintf() is a safe, portable implementation of snprintf(); see the snprintf(P) man page for details.  isprintf() differs from snprintf() in that it always NULL-terminates the string in buffer, even if the length of the composed string would equal or exceed bufSize.  Buffer overruns are reported by log message; unlike snprintf(), isprintf() returns void.</p> </li> <li> <p>size_t istrlen(const char *sourceString, size_t maxlen)</p> <p>istrlen() is a safe implementation of strlen(); see the strlen(3) man  page for details.  istrlen() differs from strlen() in that it takes a second argument, the maximum valid length of sourceString.  The function returns the number of non-NULL characters in sourceString preceding the first NULL character in sourceString, provided that a NULL character appears somewhere within the first maxlen characters of sourceString; otherwise it returns maxlen.</p> </li> <li> <p>char *istrcpy(char *buffer, char *sourceString, int bufSize)</p> <p>istrcpy() is a safe implementation of strcpy(); see the strcpy(3) man page for details.  istrcpy() differs from strcpy() in that it takes a third argument, the total size of the buffer into which sourceString is to be copied.  istrcpy() always NULL-terminates the string in buffer, even if the length of sourceString string would equal or exceed bufSize (in which case sourceString is truncated to fit within the buffer).</p> </li> <li> <p>char *istrcat(char *buffer, char *sourceString, int bufSize)</p> <p>istrcat() is a safe implementation of strcat(); see the strcat(3) man page for details.  istrcat() differs from strcat() in that it takes a third argument, the total size of the buffer for the string that is being aggregated. istrcat() always NULL-terminates the string in buffer, even if the length of sourceString string would equal or exceed the sum of bufSize and the length of the string currently occupying the buffer (in which case sourceString is truncated to fit within the buffer).</p> </li> <li> <p>char *igetcwd(char *buf, size_t size)</p> <p>igetcwd() is normally just a wrapper around getcwd(3).  It differs from getcwd(3) only when FSWWDNAME is defined, in which case the implementation of igetcwd() must be supplied in an included file named \"wdname.c\"; this adaptation option accommodates flight software environments in which the current working directory name must be configured rather than discovered at run time.</p> </li> <li> <p>void isignal(int signbr, void (*handler)(int))</p> <p>isignal() is a portable, simplified interface to signal handling that is functionally indistinguishable from signal(P).  It assures that reception of the indicated signal will interrupt system calls in SVR4 fashion, even when running on a FreeBSD platform.</p> </li> <li> <p>void iblock(int signbr)</p> <p>iblock() simply prevents reception of the indicated signal by the calling thread.  It provides a means of controlling which of the threads in a process will receive the signal cited in an invocation of isignal().</p> </li> <li> <p>int ifopen(const char *fileName, int flags, int pmode)</p> <p>ifopen() is a portable function for opening \"regular\" files.  It operates in exactly the same way as open() except that it fails (returning -1) if  fileName does not identify a regular file, i.e., it's a directory, a named pipe, etc.</p> <p>NOTE that ION also provides iopen() which is nothing more than a portable wrapper for open().  iopen() can be used to open a directory, for example.</p> </li> <li> <p>char *igets(int fd, char *buffer, int buflen, int *lineLen)</p> <p>igets() reads a line of text, delimited by a newline character, from fd into buffer and writes a NULL character at the end of the string.  The newline character itself is omitted from the NULL-terminated text line in buffer; if the newline is immediately preceded by a carriage return character (i.e., the line is from a DOS text file), then the carriage return character is likewise omitted from the NULL-terminated text line in buffer.  End of file is interpreted as an implicit newline, terminating the line.  If the number of characters preceding the newline is greater than or equal to buflen, only the first (buflen - 1) characters of the line are written into buffer.  On error the function sets *lineLen to -1 and returns NULL.  On reading end-of-file, the function sets *lineLen to zero and returns NULL.  Otherwise the function sets *lineLen to the length of the text line in buffer, as if from strlen(3), and returns buffer.</p> </li> <li> <p>int iputs(int fd, char *string)</p> <p>iputs() writes to fd the NULL-terminated character string at string.  No terminating newline character is appended to string by iputs().  On error the function returns -1; otherwise the function returns the length of the character string written to fd, as if from strlen(3).</p> </li> <li> <p>vast strtovast(char *string)</p> <p>Converts the leading characters of string, skipping leading white space and ending at the first subsequent character that can't be interpreted as contributing to a numeric value, to a vast integer and returns that integer.</p> </li> <li> <p>uvast strtouvast(char *string)</p> <p>Same as strtovast() except the result is an unsigned vast integer value.</p> </li> <li> <p>void findToken(char **cursorPtr, char **token)</p> <p>Locates the next non-whitespace lexical token in a character array, starting at *cursorPtr.  The function NULL-terminates that token within the array and places a pointer to the token in *token.  Also accommodates tokens enclosed within matching single quotes, which may contain embedded spaces and escaped single-quote characters.  If no token is found, *token contains NULL on return from this function.</p> </li> <li> <p>void *acquireSystemMemory(size_t size)</p> <p>Uses memalign() to allocate a block of system memory of length size, starting at an address that is guaranteed to be an integral multiple of the size of a pointer to void, and initializes the entire block to binary zeroes.  Returns the starting address of the allocated block on success; returns NULL on any error.</p> </li> <li> <p>int createFile(const char *name, int flags)</p> <p>Creates a file of the indicated name, using the indicated file creation flags. This function provides common file creation functionality across VxWorks and Unix platforms, invoking creat() under VxWorks and open() elsewhere.  For return values, see creat(2) and open(2).</p> </li> <li> <p>unsigned int getInternetAddress(char *hostName)</p> <p>Returns the IP address of the indicated host machine, or zero if the address cannot be determined.</p> </li> <li> <p>char *getInternetHostName(unsigned int hostNbr, char *buffer)</p> <p>Writes the host name of the indicated host machine into buffer and returns buffer, or returns NULL on any error.  The size of buffer should be (MAXHOSTNAMELEN + 1).</p> </li> <li> <p>int getNameOfHost(char *buffer, int bufferLength)</p> <p>Writes the first (bufferLength - 1) characters of the host name of the local machine into buffer.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>unsigned int getAddressOfHost()</p> <p>Returns the IP address for the host name of the local machine, or 0 on any error.</p> </li> <li> <p>void parseSocketSpec(char *socketSpec, unsigned short *portNbr, unsigned int *hostNbr)</p> <p>Parses socketSpec, extracting host number (IP address) and port number from the string.  socketSpec is expected to be of the form \"{ @ | hostname }[:&lt;portnbr&gt;]\", where @ signifies \"the host name of the local machine\".  If host number can be determined, writes it into *hostNbr; otherwise writes 0 into *hostNbr.  If port number is supplied and is in the range 1024 to 65535, writes it into *portNbr; otherwise writes 0 into *portNbr.</p> </li> <li> <p>void printDottedString(unsigned int hostNbr, char *buffer)</p> <p>Composes a dotted-string (xxx.xxx.xxx.xxx) representation of the IPv4 address in hostNbr and writes that string into buffer.  The length of buffer must be at least 16.</p> </li> <li> <p>char *getNameOfUser(char *buffer)</p> <p>Writes the user name of the invoking task or process into buffer and returns buffer.  The size of buffer must be at least L_cuserid, a constant defined in the stdio.h header file.  Returns buffer.</p> </li> <li> <p>int reUseAddress(int fd)</p> <p>Makes the address that is bound to the socket identified by  fd reusable, so that the socket can be closed and immediately reopened and re-bound to the same port number. Returns 0 on success, -1 on any error.</p> </li> <li> <p>int makeIoNonBlocking(int fd)</p> <p>Makes I/O on the socket identified by fd non-blocking; returns -1 on failure.  An attempt to read on a non-blocking socket when no data are pending,  or to write on it when its output buffer is full, will not block;  it will instead return -1 and cause errno to be set to EWOULDBLOCK.</p> </li> <li> <p>int watchSocket(int fd)</p> <p>Turns on the \"linger\" and \"keepalive\" options for the socket identified by fd.  See socket(2) for details.  Returns 0 on success, -1 on any failure.</p> </li> <li> <p>void closeOnExec(int fd)</p> <p>Ensures that fd will NOT be open in any child process fork()ed from the invoking process.  Has no effect on a VxWorks platform.</p> </li> </ul>"},{"location":"man/ici/platform/#exception-reporting","title":"EXCEPTION REPORTING","text":"<p>The functions in this section offer platform-independent capabilities for reporting on processing exceptions.</p> <p>The underlying mechanism for ICI's exception reporting is a pair of functions that record error messages in a privately managed pool of static memory.  These functions -- postErrmsg() and postSysErrmsg() -- are designed to return very rapidly with no possibility of failing, themselves.  Nonetheless they are not safe to call from an interrupt service routing (ISR).  Although each merely copies its text to the next available location in the error message memory pool, that pool is protected by a mutex; multiple processes might be queued up to take that mutex, so the total time to execute the function is non-deterministic.</p> <p>Built on top of postErrmsg() and postSysErrmsg() are the putErrmsg() and putSysErrmsg() functions, which may take longer to return.  Each one simply calls the corresponding \"post\" function but then calls the writeErrmsgMemos() function, which calls writeMemo() to print (or otherwise deliver) each message currently posted to the pool and then destroys all of those posted messages, emptying the pool.</p> <p>Recommended general policy on using the ICI exception reporting functions (which the functions in the ION distribution libraries are supposed to adhere to) is as follows:</p> <pre><code>    In the implementation of any ION library function or any ION\n    task's top-level driver function, any condition that prevents\n    the function from continuing execution toward producing the\n    effect it is designed to produce is considered an \"error\".\n\n    Detection of an error should result in the printing of an\n    error message and, normally, the immediate return of whatever\n    return value is used to indicate the failure of the function\n    in which the error was detected.  By convention this value\n    is usually -1, but both zero and NULL are appropriate\n    failure indications under some circumstances such as object\n    creation.\n\n    The CHKERR, CHKZERO, CHKNULL, and CHKVOID macros are used to\n    implement this behavior in a standard and lexically terse\n    manner.  Use of these macros offers an additional feature:\n    for debugging purposes, they can easily be configured to\n    call sm_Abort() to terminate immediately with a core dump\n    instead of returning a error indication.  This option is\n    enabled by setting the compiler parameter CORE_FILE_NEEDED\n    to 1 at compilation time.\n\n    In the absence of either any error, the function returns a\n    value that indicates nominal completion.  By convention this\n    value is usually zero, but under some circumstances other\n    values (such as pointers or addresses) are appropriate\n    indications of nominal completion.  Any additional information\n    produced by the function, such as an indication of \"success\",\n    is usually returned as the value of a reference argument.\n    [Note, though, that database management functions and the\n    SDR hash table management functions deviate from this rule:\n    most return 0 to indicate nominal completion but functional\n    failure (e.g., duplicate key or object not found) and return\n    1 to indicate functional success.]\n\n    So when returning a value that indicates nominal completion\n    of the function -- even if the result might be interpreted\n    as a failure at a higher level (e.g., an object identified\n    by a given string is not found, through no failure of the\n    search function) -- do NOT invoke putErrmsg().\n\n    Use putErrmsg() and putSysErrmsg() only when functions are\n    unable to proceed to nominal completion.  Use writeMemo()\n    or writeMemoNote() if you just want to log a message.\n\n    Whenever returning a value that indicates an error:\n\n            If the failure is due to the failure of a system call\n            or some other non-ION function, assume that errno\n            has already been set by the function at the lowest\n            layer of the call stack; use putSysErrmsg (or\n            postSysErrmsg if in a hurry) to describe the nature\n            of the activity that failed.  The text of the error\n            message should normally start with a capital letter\n            and should NOT end with a period.\n\n            Otherwise -- i.e., the failure is due to a condition\n            that was detected within ION -- use putErrmsg (or\n            postErrmg if pressed for time) to describe the nature\n            of the failure condition.  This will aid in tracing\n            the failure through the function stack in which the\n            failure was detected.  The text of the error message\n            should normally start with a capital letter and should\n            end with a period.\n\n    When a failure in a called function is reported to \"driver\"\n    code in an application program, before continuing or exiting\n    use writeErrmsgMemos() to empty the message pool and print a\n    simple stack trace identifying the failure.\n</code></pre> <ul> <li> <p>char *system_error_msg( )</p> <p>Returns a brief text string describing the current system error, as identified by the current value of errno.</p> </li> <li> <p>void setLogger(Logger usersLoggerName)</p> <p>Sets the user function to be used for writing messages to a user-defined \"log\" medium.  The logger function's calling sequence must match the following prototype:</p> <pre><code>    void    usersLoggerName(char *msg);\n</code></pre> <p>The default Logger function simply writes the message to standard output.</p> </li> <li> <p>void writeMemo(char *msg)</p> <p>Writes one log message, using the currently defined message logging function.</p> </li> <li> <p>void writeMemoNote(char *msg, char *note)</p> <p>Writes a log message like writeMemo(), accompanied by the user-supplied context-specific text in note.</p> </li> <li> <p>void writeErrMemo(char *msg)</p> <p>Writes a log message like writeMemo(), accompanied by text describing the current system error.</p> </li> <li> <p>char *itoa(int value)</p> <p>Returns a string representation of the signed integer in value, nominally for immediate use as an argument to putErrmsg().  [Note that the string is constructed in a static buffer; this function is not thread-safe.]</p> </li> <li> <p>char *utoa(unsigned int value)</p> <p>Returns a string representation of the unsigned integer in value, nominally for immediate use as an argument to putErrmsg().  [Note that the string is constructed in a static buffer; this function is not thread-safe.]</p> </li> <li> <p>void postErrmsg(char *text, char *argument)</p> <p>Constructs an error message noting the name of the source file containing the line at which this function was called, the line number, the text of the message, and -- if not NULL -- a single textual argument that can be used to give more specific information about the nature of the reported failure (such as the value of one of the arguments to the failed function).  The error message is appended to the list of messages in a privately managed pool of static memory, ERRMSGS_BUFSIZE bytes in length.</p> <p>If text is NULL or is a string of zero length or begins with a newline character (i.e., *text == '\\0' or '\\n'), the function returns immediately and no error message is recorded.</p> <p>The errmsgs pool is designed to be large enough to contain error messages from all levels of the calling stack at the time that an error is encountered.  If the remaining unused space in the pool is less than the size of the new error message, however, the error message is silently omitted.  In this case, provided at least two bytes of unused space remain in the pool, a message comprising a single newline character is appended to the list to indicate that a message was omitted due to excessive length.</p> </li> <li> <p>void postSysErrmsg(char *text, char *arg)</p> <p>Like postErrmsg() except that the error message constructed by the function additionally contains text describing the current system error.  text is truncated as necessary to assure that the sum of its length and that of the description of the current system error does not exceed 1021 bytes.</p> </li> <li> <p>int getErrmsg(char *buffer)</p> <p>Copies the oldest error message in the message pool into buffer and removes that message from the pool, making room for new messages.  Returns zero if the message pool cannot be locked for update or there are no more messages in the pool; otherwise returns the length of the message copied into buffer.  Note that, for safety, the size of buffer should be ERRMSGS_BUFSIZE.</p> <p>Note that a returned error message comprising only a single newline character always signifies an error message that was silently omitted because there wasn't enough space left on the message pool to contain it.</p> </li> <li> <p>void writeErrmsgMemos( )</p> <p>Calls getErrmsg() repeatedly until the message pool is empty, using writeMemo() to log all the messages in the pool.  Messages that were omitted due to excessive length are indicated by logged lines of the form \"[message omitted due to excessive length]\".</p> </li> <li> <p>void putErrmsg(char *text, char *argument)</p> <p>The putErrmsg() function merely calls postErrmsg() and then writeErrmsgMemos().</p> </li> <li> <p>void putSysErrmsg(char *text, char *arg)</p> <p>The putSysErrmsg() function merely calls postSysErrmsg() and then writeErrmsgMemos().</p> </li> <li> <p>void discardErrmsgs( )</p> <p>Calls getErrmsg() repeatedly until the message pool is empty, discarding all of the messages.</p> </li> <li> <p>void printStackTrace( )</p> <p>On Linux machines only, uses writeMemo() to print a trace of the process's current execution stack, starting with the lowest level of the stack and proceeding to the main() function of the executable.</p> <p>Note that (a) printStackTrace() is only implemented for Linux platforms at this time; (b) symbolic names of functions can only be printed if the -rdynamic flag was enabled when the executable was linked; (c) only the names of non-static functions will appear in the stack trace.</p> <p>For more complete information about the state of the executable at the time the stack trace snapshot was taken, use the Linux addr2line tool. To do this, cd into a directory in which the executable file resides (such as /opt/bin) and submit an addr2line command as follows:</p> <pre><code>addr2line -e _name\\_of\\_executable_ _stack\\_frame\\_address_\n</code></pre> <p>where both name_of_executable and stack_frame_address are taken from one of the lines of the printed stack trace.  addr2line will print the source file name and line number for that stack frame.</p> </li> </ul>"},{"location":"man/ici/platform/#watch-characters","title":"WATCH CHARACTERS","text":"<p>The functions in this section offer platform-independent capabilities for recording \"watch\" characters indicating the occurrence of protocol events.  See bprc(5), ltprc(5), cfdprc(5), etc. for details of the watch character production options provided by the protocol packages.</p> <ul> <li> <p>void setWatcher(Watcher usersWatcherName)</p> <p>Sets the user function to be used for recording watch characters to a user-defined \"watch\" medium.  The watcher function's calling sequence must match the following prototype:</p> <pre><code>    void    usersWatcherName(char token);\n</code></pre> <p>The default Watcher function simply writes the token to standard output.</p> </li> <li> <p>void iwatch(char token)</p> <p>Records one \"watch\" character, using the currently defined watch character recording function.</p> </li> </ul>"},{"location":"man/ici/platform/#self-delimiting-numeric-values-sdnv","title":"SELF-DELIMITING NUMERIC VALUES (SDNV)","text":"<p>The functions in this section encode and decode SDNVs, portable variable-length numeric variables that expand to whatever size is necessary to contain the values they contain.  SDNVs are used extensively in the BP and LTP libraries.</p> <ul> <li> <p>void encodeSdnv(Sdnv *sdnvBuffer, uvast value)</p> <p>Determines the number of octets of SDNV text needed to contain the value, places that number in the length field of the SDNV buffer, and encodes the value in SDNV format into the first length octets of the text field of the SDNV buffer.</p> </li> <li> <p>int decodeSdnv(uvast *value, unsigned char *sdnvText)</p> <p>Determines the length of the SDNV located at sdnvText and returns this number after extracting the SDNV's value from those octets and storing it in value.  Returns 0 if the encoded number value will not fit into an unsigned vast integer.</p> </li> </ul>"},{"location":"man/ici/platform/#arithmetic-on-large-integers-scalars","title":"ARITHMETIC ON LARGE INTEGERS (SCALARS)","text":"<p>The functions in this section perform simple arithmetic operations on unsigned Scalar objects -- structures encapsulating large positive integers in a machine-independent way.  Each Scalar comprises two integers, a count of units [ranging from 0 to (2^30 - 1), i.e., up to 1 gig] and a count of gigs [ranging from 0 to (2^31 -1)].  A Scalar can represent a numeric value up to 2 billion billions, i.e., 2 million trillions.</p> <ul> <li> <p>void loadScalar(Scalar *scalar, signed int value)</p> <p>Sets the value of scalar to the absolute value of value.</p> </li> <li> <p>void increaseScalar(Scalar *scalar, signed int value)</p> <p>Adds to scalar the absolute value of value.</p> </li> <li> <p>void reduceScalar(Scalar *scalar, signed int value)</p> <p>Adds to scalar the absolute value of value.</p> </li> <li> <p>void multiplyScalar(Scalar *scalar, signed int value)</p> <p>Multiplies scalar by the absolute value of value.</p> </li> <li> <p>void divideScalar(Scalar *scalar, signed int value)</p> <p>Divides scalar by the absolute value of value.</p> </li> <li> <p>void copyScalar(Scalar *to, Scalar *from)</p> <p>Copies the value of from into to.</p> </li> <li> <p>void addToScalar(Scalar *scalar, Scalar *increment)</p> <p>Adds increment (a Scalar rather than a C integer) to scalar.</p> </li> <li> <p>void subtractFromScalar(Scalar *scalar, Scalar *decrement)</p> <p>Subtracts decrement (a Scalar rather than a C integer) from scalar.</p> </li> <li> <p>int scalarIsValid(Scalar *scalar)</p> <p>Returns 1 if the arithmetic performed on scalar has not resulted in overflow or underflow.</p> </li> <li> <p>int scalarToSdnv(Sdnv *sdnv, Scalar *scalar)</p> <p>If scalar points to a valid Scalar, stores the value of scalar in sdnv; otherwise sets the length of sdnv to zero.</p> </li> <li> <p>int sdnvToScalar(Scalar *scalar, unsigned char *sdnvText)</p> <p>If sdnvText points to a sequence of bytes that, when interpreted as the text of an Sdnv, has a value that can be represented in a 61-bit unsigned binary integer, then this function stores that value in scalar and returns the detected Sdnv length.  Otherwise returns zero.</p> <p>Note that Scalars and Sdnvs are both representations of potentially large unsigned integer values.  Any Scalar can alternatively be represented as an Sdnv.  However, it is possible for a valid Sdnv to be too large to represent in a Scalar.</p> </li> </ul>"},{"location":"man/ici/platform/#private-mutexes","title":"PRIVATE MUTEXES","text":"<p>The functions in this section provide platform-independent management of mutexes for synchronizing operations of threads or tasks in a common private address space.</p> <ul> <li> <p>int initResourceLock(ResourceLock *lock)</p> <p>Establishes an inter-thread lock for use in locking some resource.  Returns 0 if successful, -1 if not.</p> </li> <li> <p>void killResourceLock(ResourceLock *lock)</p> <p>Deletes the resource lock referred to by lock.</p> </li> <li> <p>void lockResource(ResourceLock *lock)</p> <p>Checks the state of lock.  If the lock is already owned by a different thread, the call blocks until the other thread relinquishes the lock.  If the lock is unowned, it is given to the current thread and the lock count is set to 1.  If the lock is already owned by this thread, the lock count is incremented by 1.</p> </li> <li> <p>void unlockResource(ResourceLock *lock)</p> <p>If called by the current owner of lock, decrements lock's lock count by 1; if zero, relinquishes the lock so it may be taken by other threads.  Care must be taken to make sure that one, and only one, unlockResource() call is issued for each lockResource() call issued on a given resource lock.</p> </li> </ul>"},{"location":"man/ici/platform/#shared-memory-ipc-devices","title":"SHARED MEMORY IPC DEVICES","text":"<p>The functions in this section provide platform-independent management of IPC mechanisms for synchronizing operations of threads, tasks, or processes that may occupy different address spaces but share access to a common system (nominally, processor) memory.</p> <p>NOTE that this is distinct from the VxWorks \"VxMP\" capability enabling tasks to share access to bus memory or dual-ported board memory from multiple processors.  The \"platform\" system will support IPC devices that  utilize this capability at some time in the future, but that support is not yet implemented.</p> <ul> <li> <p>int sm_ipc_init( )</p> <p>Acquires and initializes shared-memory IPC management resources.  Must be called before any other shared-memory IPC function is called.  Returns 0 on success, -1 on any failure.</p> </li> <li> <p>void sm_ipc_stop( )</p> <p>Releases shared-memory IPC management resources, disabling the shared-memory IPC functions until sm_ipc_init() is called again.</p> </li> <li> <p>int sm_GetUniqueKey( )</p> <p>Some of the \"sm_\" (shared memory) functions described below associate new communication objects with key values that uniquely identify them, so that different processes can access them independently.  Key values are typically defined as constants in application code. However, when a new communication object is required for which no specific need was anticipated in the application,  the sm_GetUniqueKey() function can be invoked to obtain a new, arbitrary key value that is known not to be already in use.</p> </li> <li> <p>sm_SemId sm_SemCreate(int key, int semType)</p> <p>Creates a shared-memory semaphore that can be used to synchronize activity among tasks or processes residing in a common system memory but possibly multiple address spaces; returns a reference handle for that semaphore, or SM_SEM_NONE on any failure.  If key refers to an existing semaphore, returns the handle of that semaphore.  If key is the constant value SM_NO_KEY, automatically obtains an unused key.  On VxWorks platforms, semType determines the order in which the semaphore is given to multiple tasks that attempt to take it while it is already taken: if set to SM_SEM_PRIORITY then the semaphore is given to tasks in task priority sequence (i.e., the highest-priority task waiting for it receives it when it is released), while otherwise (SM_SEM_FIFO) the semaphore is given to tasks in the order in which they attempted to take it.  On all other platforms, only SM_SEM_FIFO behavior is supported and semType is ignored.</p> </li> <li> <p>int sm_SemTake(sm_SemId semId)</p> <p>Blocks until the indicated semaphore is no longer taken by any other task or process, then takes it.  Return 0 on success, -1 on any error.</p> </li> <li> <p>void sm_SemGive(sm_SemId semId)</p> <p>Gives the indicated semaphore, so that another task or process can take it.</p> </li> <li> <p>void sm_SemEnd(sm_SemId semId)</p> <p>This function is used to pass a termination signal to whatever task is currently blocked on taking the indicated semaphore, if any.  It sets to 1 the \"ended\" flag associated with this semaphore, so that a test for sm_SemEnded() will return 1, and it gives the semaphore so that the blocked task will have an opportunity to test that flag.</p> </li> <li> <p>int sm_SemEnded(sm_SemId semId)</p> <p>This function returns 1 if the \"ended\" flag associated with the indicated semaphore has been set to 1; returns zero otherwise.  When the function returns 1 it also gives the semaphore so that any other tasks that might be pended on the same semaphore are also given an opportunity to test it and discover that it has been ended.</p> </li> <li> <p>void sm_SemUnend(sm_SemId semId)</p> <p>This function is used to reset an ended semaphore, so that a restarted subsystem can reuse that semaphore rather than delete it and allocate a new one.</p> </li> <li> <p>int sm_SemUnwedge(sm_SemId semId, int timeoutSeconds)</p> <p>Used to release semaphores that have been taken but never released, possibly because the tasks or processes that took them crashed before releasing them. Attempts to take the semaphore; if this attempt does not succeed within timeoutSeconds seconds (providing time for normal processing to be completed, in the event that the semaphore is legitimately and temporarily locked by some task), the semaphore is assumed to be wedged.  In any case, the semaphore is then released.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void sm_SemDelete(sm_SemId semId)</p> <p>Destroys the indicated semaphore.</p> </li> <li> <p>sm_SemId sm_GetTaskSemaphore(int taskId)</p> <p>Returns the ID of the semaphore that is dedicated to the private use of the indicated task, or SM_SEM_NONE on any error.</p> <p>This function implements the concept that for each task there can always be one dedicated semaphore, which the task can always use for its own purposes, whose key value may be known a priori because the key of the semaphore is based on the task's ID.  The design of the function rests on the assumption that each task's ID, whether a VxWorks task ID or a Unix process ID, maps to a number that is out of the range of all possible key values that are arbitrarily produced by sm_GetUniqueKey(). For VxWorks, we assume this to be true because task ID is a pointer to task state in memory which we assume not to exceed 2GB; the unique key counter starts at 2GB.  For Unix, we assume this to be true because process ID is an index into a process table whose size is less than 64K; unique keys are formed by shifting process ID left 16 bits and adding the value of an incremented counter which is always greater than zero.</p> </li> <li> <p>int sm_ShmAttach(int key, int size, char **shmPtr, int *id)</p> <p>Attaches to a segment of memory to which tasks or processes residing in a common system memory, but possibly multiple address spaces, all have access.</p> <p>This function registers the invoking task or process as a user of the shared memory segment identified by key.  If key is the constant value  SM_NO_KEY, automatically sets key to some unused key value. If a shared memory segment identified by key already exists, then size may be zero and the value of *shmPtr is ignored. Otherwise the size of the shared memory segment must be provided in size and a new shared memory segment is created in a manner that is dependent on *shmPtr: if *shmPtr is NULL then  size bytes of shared memory are dynamically acquired, allocated, and assigned to the newly created shared memory segment; otherwise the memory located at shmPtr is assumed to have been pre-allocated and is merely assigned to the newly created shared memory segment. </p> <p>On success, stores the unique shared memory ID of the segment in *id for possible future destruction, stores a pointer to the segment's assigned memory in *shmPtr, and returns 1 (if the segment is newly created) or 0 (otherwise).  Returns -1 on any error.  </p> </li> <li> <p>void sm_ShmDetach(char *shmPtr)</p> <p>Unregisters the invoking task or process as a user of the shared memory starting at shmPtr.</p> </li> <li> <p>void sm_ShmDestroy(int id)</p> <p>Destroys the shared memory segment identified by id, releasing any memory that was allocated when the segment was created.</p> </li> </ul>"},{"location":"man/ici/platform/#portable-multi-tasking","title":"PORTABLE MULTI-TASKING","text":"<ul> <li> <p>int sm_TaskIdSelf( )</p> <p>Returns the unique identifying number of the invoking task or process.</p> </li> <li> <p>int sm_TaskExists(int taskId)</p> <p>Returns non-zero if a task or process identified by taskId is currently running on the local processor, zero otherwise.</p> </li> <li> <p>void *sm_TaskVar(void **arg)</p> <p>Posts or retrieves the value of the \"task variable\" belonging to the invoking task.  Each task has access to a single task variable, initialized to NULL, that resides in the task's private state; this can be convenient for passing task-specific information to a signal handler, for example.  If arg is non-NULL, then *arg is posted as the new value of the task's private task variable.  In any case, the value of that task variable is returned.</p> </li> <li> <p>void sm_TaskSuspend( )</p> <p>Indefinitely suspends execution of the invoking task or process.  Helpful if you want to freeze an application at the point at which an error is detected, then use a debugger to examine its state.</p> </li> <li> <p>void sm_TaskDelay(int seconds)</p> <p>Same as snooze(3).</p> </li> <li> <p>void sm_TaskYield( )</p> <p>Relinquishes CPU temporarily for use by other tasks.</p> </li> <li> <p>int sm_TaskSpawn(char *name, char *arg1, char *arg2, char                        *arg3, char *arg4, char *arg5, char *arg6, char                        *arg7, char *arg8, char *arg9, char *arg10, int                        priority, int stackSize)</p> <p>Spawns/forks a new task/process, passing it up to ten command-line arguments.  name is the name of the function (VxWorks) or executable image (UNIX) to be executed  in the new task/process.</p> <p>For UNIX, name must be the name of some executable  program in the $PATH of the invoking process.</p> <p>For VxWorks, name must be the name of some function named in an application-defined private symbol table (if PRIVATE_SYMTAB is defined) or the system symbol table (otherwise).  If PRIVATE_SYMTAB is defined, the application must provide a suitable adaptation of the symtab.c source file, which implements the private symbol table.</p> <p>\"priority\" and \"stackSize\" are ignored under UNIX.  Under VxWorks, if zero they default to the values in the application-defined private symbol table if provided, or otherwise to ICI_PRIORITY (nominally 100) and 32768 respectively.</p> <p>Returns the task/process ID of the new task/process on success, or -1 on any error.</p> </li> <li> <p>void sm_TaskKill(int taskId, int sigNbr)</p> <p>Sends the indicated signal to the indicated task or process.</p> </li> <li> <p>void sm_TaskDelete(int taskId)</p> <p>Terminates the indicated task or process.</p> </li> <li> <p>void sm_Abort()</p> <p>Terminates the calling task or process.  If not called while ION is in flight configuration, a stack trace is printed or a core file is written.</p> </li> <li> <p>int pseudoshell(char *script)</p> <p>Parses script into a command name and up to 10 arguments, then passes the command name and arguments to sm_TaskSpawn() for execution. The sm_TaskSpawn() function is invoked with priority and stack size both set to zero, causing default values (possibly from an application-defined private symbol table) to be used.  Tokens in  script are normally whitespace-delimited, but a token that is enclosed in single-quote characters (') may contain embedded whitespace and may contain escaped single-quote characters (\"\\'\").  On any parsing failure returns -1; otherwise returns the value returned by sm_TaskSpawn().</p> </li> </ul>"},{"location":"man/ici/platform/#users-guide","title":"USER'S GUIDE","text":"<ul> <li> <p>Compiling an application that uses \"platform\":</p> <p>Just be sure to \"#include \"platform.h\"\" at the top of each source file that includes any platform function calls.</p> </li> <li> <p>Linking/loading an application that uses \"platform\":</p> <pre><code>a.   In a Solaris environment, link with these libraries:\n\n         -lplatform -socket -nsl -posix4 -c\n\nb.   In a Linux environment, simply link with platform:\n\n         -lplatform\n\nc.   In a VxWorks environment, use\n\n         ld 1, 0, \"libplatform.o\"\n\n     to load platform on the target before loading applications.\n</code></pre> </li> </ul>"},{"location":"man/ici/platform/#see-also","title":"SEE ALSO","text":"<p>gettimeofday(3C)</p>"},{"location":"man/ici/psm/","title":"NAME","text":"<p>psm - Personal Space Management</p>"},{"location":"man/ici/psm/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"psm.h\"\n\ntypedef enum { Okay, Redundant, Refused } PsmMgtOutcome;\ntypedef unsigned long PsmAddress;\ntypedef struct psm_str\n{\n        char            *space;\n        int             freeNeeded;\n        struct psm_str  *trace;\n        int             traceArea[3];\n} PsmView, *PsmPartition;\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/psm/#description","title":"DESCRIPTION","text":"<p>PSM is a library of functions that support personal space management, that is, user management of an application-configured memory partition.  PSM is designed to be faster and more efficient than malloc/free (for details, see the DETAILED DESCRIPTION below), but more importantly it provides a memory management abstraction that insulates applications from differences in the management of private versus shared memory.  </p> <p>PSM is often used to manage shared memory partitions.  On most operating systems, separate tasks that connect to a common shared memory partition are given the same base address with which to access the partition.  On some systems (such as Solaris) this is not necessarily the case; an absolute address within such a shared partition will be mapped to different pointer values in different tasks.  If a pointer value is stored within shared memory and used without conversion by multiple tasks, segment violations will occur.</p> <p>PSM gets around this problem by providing functions for translating between local pointer values and relative addresses within the shared memory partition.  For complete portability, applications which store addresses in shared memory should store these addresses as PSM relative addresses and convert them to local pointer values before using them.  The PsmAddress data type is provided for this purpose,  along with the conversion functions psa() and psp().</p> <ul> <li> <p>int  psm_manage(char *start, unsigned int length, char *name, PsmPartition *partitionPointer, PsmMgtOutcome *outcome)</p> <p>Puts the length bytes of memory at start under PSM management, associating this memory partition with the identifying string name (which is required and which can have a maximum string length of 31).  PSM can manage any contiguous range of addresses to which the application has access, typically a block of heap memory returned by a malloc call.</p> <p>Every other PSM API function must be passed a pointer to a local \"partition\" state structure characterizing the PSM-managed memory to which the function is to be applied.  The partition state structure itself may be pre-allocated in static or local (or shared) memory by the application, in which case a pointer to that structure must be passed to psm_manage() as the value of *partitionPointer; if *partitionPointer is null, psm_manage() will use malloc() to allocate this structure dynamically from local memory and will store a pointer to the structure in *partitionPointer.</p> <p>psm_manage() formats the managed memory as necessary and returns -1 on any error, 0 otherwise.  The outcome to the attempt to manage memory is placed in outcome.  An outcome of Redundant means that the memory at start is already under PSM management with the same name and size.  An outcome of Refused means that PSM was unable to put the memory at start under PSM management as directed; a diagnostic message was posted to the message pool (see discussion of putErrmsg() in platform(3)).</p> </li> <li> <p>char *psm_name(PsmPartition partition)</p> <p>Returns the name associated with the partition at the time it was put under management.</p> </li> <li> <p>char *psm_space(PsmPartition partition)</p> <p>Returns the address of the space managed by PSM for partition. This function is provided to enable the application to do an operating-system release (such as free()) of this memory when the managed partition is no longer needed.  NOTE that calling psm_erase() or psm_unmanage() [or any other PSM function, for that matter] after releasing that space is virtually guaranteed to result in a segmentation fault or other seriously bad behavior.</p> </li> <li> <p>void *psp(PsmPartition partition, PsmAddress address)</p> <p>address is an offset within the space managed for the partition.  Returns the conversion of that offset into a locally usable pointer.</p> </li> <li> <p>PsmAddress psa(PsmPartition partition, void *pointer)</p> <p>Returns the conversion of pointer into an offset within the space managed for the partition.</p> </li> <li> <p>PsmAddress psm_malloc(PsmPartition partition,  unsigned int length)</p> <p>Allocates a block of memory from the \"large pool\" of the indicated partition.  (See the DETAILED DESCRIPTION below.)  length is the size of the block to allocate; the maximum size is 1/2 of the total address space (i.e., 2G for a 32-bit machine).  Returns NULL if no free block could be found.  The block returned  is aligned on a doubleword boundary.</p> </li> <li> <p>void psm_panic(PsmPartition partition)</p> <p>Forces the \"large pool\" memory allocation algorithm to hunt laboriously for free blocks in buckets that may not contain any.  This setting remains in force for the indicated  partition until a subsequent psm_relax() call reverses it.</p> </li> <li> <p>void psm_relax(PsmPartition partition)</p> <p>Reverses psm_panic().  Lets the \"large pool\" memory allocation algorithm return NULL when no free block can be found easily.</p> </li> <li> <p>PsmAddress psm_zalloc(PsmPartition partition,  unsigned int length)</p> <p>Allocates a block of memory from the \"small pool\" of the indicated partition, if possible; if the requested block size -- length -- is too large for small pool allocation (which is limited to 64 words, i.e., 256 bytes for a 32-bit machine), or if no small pool space is available and the size of the small pool cannot be increased, then allocates from the large pool instead.  Small pool allocation is performed by an especially speedy algorithm, and  minimum space is consumed in memory management overhead for small-pool blocks.  Returns NULL if no free block could be found.  The block returned is aligned on a word boundary.</p> </li> <li> <p>void psm_free(PsmPartition partition, PsmAddress block)</p> <p>Frees for subsequent re-allocation the indicated block of memory from the indicated partition.  block may have been allocated by either psm_malloc() or psm_zalloc().</p> </li> <li> <p>int psm_set_root(PsmPartition partition, PsmAddress root)</p> <p>Sets the \"root\" word of the indicated partition (a word at a fixed, private location in the PSM bookkeeping data area) to the indicated value.  This function is typically useful in a shared-memory environment, such as a VxWorks address space, in which a task wants to retrieve from the indicated partition some data that was inserted  into the partition by some other task; the partition root  word enables multiple tasks to navigate the same data in the same PSM partition in shared memory. The argument is normally a pointer to something like a linked list of the linked lists that populate the partition; in particular, it is likely to be an object catalog (see psm_add_catlg()).  Returns 0 on success, -1 on any failure (e.g., the partition already has a root object, in which case psm_erase_root() must be called before psm_set_root()).</p> </li> <li> <p>PsmAddress psm_get_root(PsmPartition partition)</p> <p>Retrieves the current value of the root word of the indicated partition.</p> </li> <li> <p>void psm_erase_root(PsmPartition partition)</p> <p>Erases the current value of the root word of the indicated partition.</p> </li> <li> <p>PsmAddress psm_add_catlg(PsmPartition partition)</p> <p>Allocates space for an object catalog in the indicated partition and establishes the new catalog as the partition's root object.  Returns 0 on success, -1 on any error (e.g., the partition already has some other root object).</p> </li> <li> <p>int psm_catlg(PsmPartition partition, char *objName, PsmAddress objLocation)</p> <p>Inserts an entry for the indicated object into the catalog that is the root object for this partition.  The length of objName cannot exceed 32 bytes, and objName must be unique in the catalog.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int psm_uncatlg(PsmPartition partition, char *objName)</p> <p>Removes the entry for the named object from the catalog that is the root object for this partition, if that object is found in the catalog.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int psm_locate(PsmPartition partition, char *objName, PsmAddress *objLocation, PsmAddress *entryElt)</p> <p>Places in *objLocation the address associated with objName in the catalog that is the root object for this partition and places in *entryElt the address of the list element that points to this catalog entry.  If name is not found in catalog, set *entryElt to zero.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void psm_usage(PsmPartition partition, PsmUsageSummary *summary)</p> <p>Loads the indicated PsmUsageSummary structure with a snapshot of the indicated partition's usage status. PsmUsageSummary is defined by:</p> <pre><code>typedef struct {\n    char            partitionName[32];\n    unsigned int    partitionSize;\n    unsigned int    smallPoolSize;\n    unsigned int    smallPoolFreeBlockCount[SMALL_SIZES];\n    unsigned int    smallPoolFree;\n    unsigned int    smallPoolAllocated;\n    unsigned int    largePoolSize;\n    unsigned int    largePoolFreeBlockCount[LARGE_ORDERS];\n    unsigned int    largePoolFree;\n    unsigned int    largePoolAllocated;\n    unsigned int    unusedSize;\n} PsmUsageSummary;\n</code></pre> </li> <li> <p>void psm_report(PsmUsageSummary *summary)</p> <p>Sends to stdout the content of summary, a snapshot of a partition's usage status.</p> </li> <li> <p>void psm_unmanage(PsmPartition partition)</p> <p>Terminates local PSM management of the memory in partition and destroys the partition state structure *partition, but doesn't erase anything in the managed memory; PSM management can be re-established by a subsequent call to psm_manage().</p> </li> <li> <p>void psm_erase(PsmPartition partition)</p> <p>Unmanages the indicated partition and additionally discards all information in the managed memory, preventing re-management of the partition.</p> </li> </ul>"},{"location":"man/ici/psm/#memory-usage-tracing","title":"MEMORY USAGE TRACING","text":"<p>If PSM_TRACE is defined at the time the PSM source code is compiled, the system includes built-in support for simple tracing of memory usage: memory allocations are logged, and memory deallocations are matched to logged allocations, \"closing\" them.  This enables memory leaks and some other kinds of memory access problems to be readily investigated.</p> <ul> <li> <p>int psm_start_trace(PsmPartition partition, int traceLogSize, char *traceLogAddress)</p> <p>Begins an episode of PSM memory usage tracing.  traceLogSize is the number of bytes of shared memory to use for trace activity logging; the frequency with which \"closed\" trace log events must be deleted will vary inversely with the amount of memory allocated for the trace log. traceLogAddress is normally NULL, causing the trace system to allocate traceLogSize bytes of shared memory dynamically for trace logging; if non-NULL, it must point to traceLogSize bytes of shared memory that have been pre-allocated by the application for this purpose.  Returns 0 on success, -1 on any failure.</p> </li> <li> <p>void psm_print_trace(PsmPartition partition, int verbose)</p> <p>Prints a cumulative trace report and current usage report for  partition.  If verbose is zero, only exceptions (notably, trace log events that remain open -- potential memory leaks) are printed; otherwise all activity in the trace log is printed.</p> </li> <li> <p>void psm_clear_trace(PsmPartition partition)</p> <p>Deletes all closed trace log events from the log, freeing up memory for additional tracing.</p> </li> <li> <p>void psm_stop_trace(PsmPartition partition)</p> <p>Ends the current episode of PSM memory usage tracing.  If the shared memory used for the trace log was allocated by psm_start_trace(), releases that shared memory.</p> </li> </ul>"},{"location":"man/ici/psm/#example","title":"EXAMPLE","text":"<p>For an example of the use of psm, see the file psmshell.c in the PSM source directory.</p>"},{"location":"man/ici/psm/#users-guide","title":"USER'S GUIDE","text":"<ul> <li> <p>Compiling a PSM application</p> <p>Just be sure to \"#include \"psm.h\"\" at the top of each source file  that includes any PSM function calls.</p> </li> <li> <p>Linking/loading a PSM application</p> <p>a. In a UNIX environment, link with libpsm.a.</p> <p>b. In a VxWorks environment, use</p> <pre><code>  ld 1, 0, \"libpsm.o\"\n</code></pre> <p>to load PSM on the target before loading any PSM applications.</p> </li> <li> <p>Typical usage:</p> <p>a. Call psm_manage() to initiate management of the partition.</p> <p>b. Call psm_malloc() (and/or psm_zalloc()) to allocate space in the  partition; call psm_free() to release space for later re-allocation.</p> <p>c. When psm_malloc() returns NULL and you're willing to wait a while for a more exhaustive free block search, call psm_panic() before retrying psm_malloc().  When you're no longer so desperate for space, call psm_relax().</p> <p>d. To store a vital pointer in the single predefined location in the partition that PSM reserves for this purpose, call  psm_set_root(); to retrieve that pointer, call psm_get_root().</p> <p>e. To get a snapshot of the current configuration of the partition, call psm_usage().  To print this snapshot to stdout, call psm_report().</p> <p>f. When you're done with the partition but want to leave it in its current state for future re-management (e.g., if the partition is in shared memory), call psm_unmanage(). If you're done with the partition forever, call psm_erase().</p> </li> </ul>"},{"location":"man/ici/psm/#detailed-description","title":"DETAILED DESCRIPTION","text":"<p>PSM supports user management of an application-configured memory partition. The partition is functionally divided into two pools of variable size: a \"small pool\" of low-overhead blocks aligned on 4-byte boundaries that can each contain up to 256 bytes of user data, and a \"large pool\" of high-overhead blocks aligned on 8-byte boundaries that can each contain up to 2GB of user data.</p> <p>Space in the small pool is allocated in any one of 64 different block sizes; each possible block size is (4i + n) where i is a \"block list index\" from 1 through 64 and n is the length of the PSM overhead information per block [4 bytes on a 32-bit machine]. Given a user request for a block of size q where q is in the range 1 through 256 inclusive, we return the first block on the j'th small-pool free list where j = (q - 1) / 4.  If there is no such block, we increase the size of the small pool [incrementing its upper limit by (4 * (j + 1)) + n], initialize the increase as a free block from list j, and return that block.  No attempt is made to consolidate physically adjacent blocks when they are freed or to bisect large blocks to satisfy requests for small ones; if there is no free block of the requested size and the size of the small pool cannot be increased without encroaching on the large pool (or if the requested size exceeds 256), we attempt to allocate a large-pool block as described below.  The differences  between small-pool and large-pool blocks are transparent to the user, and small-pool and large-pool blocks can be freely intermixed  in an application.</p> <p>Small-pool blocks are allocated and freed very rapidly, and space overhead consumption is small, but capacity per block is limited and space assigned to small-pool blocks of a given size is never again available for any other purpose.  The small pool is designed to satisfy requests for allocation of a stable overall population of small, volatile objects such as List and ListElt structures (see lyst(3)).</p> <p>Space in the large pool is allocated from any one of 29 buckets, one for each power of 2 in the range 8 through 2G.  The size of each block can be expressed as (n + 8i + m) where i is any integer  in the range 1 through 256M, n is the size of the block's leading overhead area [8 bytes on a 32-bit machine], and m is the size of the block's trailing overhead area [also 8 bytes on a 32-bit machine].  Given a user request for a block of size q where q is in the range 1 through 2G inclusive, we first compute r as the smallest multiple of 8 that is greater than or equal to q.  We then allocate the first block in bucket t such that 2 ** (t + 3) is the smallest power of 2 that is greater than r [or, if r is a power of 2, the first block in bucket t such that 2 ** (t + 3) = r].  That is, we try to allocate blocks of size 8 from bucket 0 [2**3 = 8], blocks of size 16 from bucket 1 [2**4 = 16], blocks of size 24 from bucket 2 [2**5 = 32, 32 &gt; 24], blocks of size 32 from bucket 2 [2**5 = 32], and so on.  t is the first bucket whose free blocks are ALL guaranteed to be at least as large as r; bucket t - 1 may also contain some blocks that are as large as r (e.g., bucket 1 will contain blocks of size 24 as well as blocks of size 16), but we would have to do a possibly time consuming sequential search through the free blocks in that bucket  to find a match, because free blocks within a bucket are stored in no particular order.</p> <p>If bucket t is empty, we allocate the first block from the first non-empty bucket corresponding to a greater power of two; if all eligible bucket are empty, we increase the size of the large pool [decrementing its lower limit by (r + 16)], initialize the increase  as a free block and \"free\" it, and try again.  If the size of the large pool cannot be increased without encroaching on the small pool, then if we are desperate we search sequentially through all blocks in bucket t - 1 (some of which may be of size r or greater) and allocate the first block that is big enough, if any.  Otherwise, no block is returned.</p> <p>Having selected a free block to allocate, we remove the allocated block from the free list, split off as a new free block all bytes in excess of (r + 16) bytes [unless that excess is too small to form a legal-size block], and return the remainder to the user. When a block is freed, it is automatically consolidated with the physically preceding block (if that block is free) and the physically  subsequent block (if that block is free).</p> <p>Large-pool blocks are allocated and freed quite rapidly; capacity is effectively unlimited; space overhead consumption is very high for extremely small objects but becomes an insignificant fraction of block size as block size increases.  The large pool is designed to serve as a general-purpose heap with minimal fragmentation  whose overhead is best justified when used to store relatively  large, long-lived objects such as image packets.</p> <p>The general goal of this memory allocation scheme is to satisfy memory management requests rapidly and yet minimize the chance of refusing a memory allocation request when adequate unused space exists but is inaccessible (because it is fragmentary or is buried as unused space in a block that is larger than necessary). The size of a small-pool block delivered to satisfy a request for q bytes will never exceed q + 3 (alignment), plus 4 bytes of overhead.  The size of a large-pool block delivered to satisfy a request for q bytes will never exceed q + 7 (alignment) + 20 (the maximum excess that can't be split off as a separate free block), plus 16 bytes of overhead.</p> <p>Neither the small pool nor the large pool ever decrease in size, but large-pool space previously allocated and freed is available for small-pool allocation requests if no small-pool space is available.  Small-pool space previously allocated and freed cannot  easily be reassigned to the large pool, though, because blocks in the large pool must be physically contiguous to support defragmentation.  No such reassignment algorithm has yet been developed.</p>"},{"location":"man/ici/psm/#see-also","title":"SEE ALSO","text":"<p>lyst(3)</p>"},{"location":"man/ici/psmshell/","title":"NAME","text":"<p>psmshell - PSM memory management test shell</p>"},{"location":"man/ici/psmshell/#synopsis","title":"SYNOPSIS","text":"<p>psmshell partition_size</p>"},{"location":"man/ici/psmshell/#description","title":"DESCRIPTION","text":"<p>psmshell allocates a region of partition_size bytes of system memory, places it under PSM management, and offers the user an interactive \"shell\" for testing various PSM management functions.</p> <p>psmshell prints a prompt string (\": \") to stdout, accepts a command from  stdin, executes the command (possibly printing a diagnostic message),  then prints another prompt string and so on.</p> <p>The locations of objects allocated from the PSM-managed region of memory are referred to as \"cells\" in psmshell operations.  That is, when an object is to be allocated, a cell number in the range 0-99 must be specified as the notional \"handle\" for that object, for use in future commands.</p> <p>The following commands are supported:</p> <ul> <li> <p>h</p> <p>The help command.  Causes psmshell to print a summary of available commands.  Same effect as the ? command.</p> </li> <li> <p>?</p> <p>Another help command.  Causes psmshell to print a summary of available commands.  Same effect as the h command.</p> </li> <li> <p>m cell_nbr size</p> <p>The malloc command.  Allocates a large-pool object of the indicated size and associates that object with cell_nbr.</p> </li> <li> <p>z cell_nbr size</p> <p>The zalloc command.  Allocates a small-pool object of the indicated size and associates that object with cell_nbr.</p> </li> <li> <p>p cell_nbr</p> <p>The print command.  Prints the address (i.e., the offset within the managed block of memory) of the object associated with cell_nbr.</p> </li> <li> <p>f cell_nbr</p> <p>The free command.  Frees the object associated with cell_nbr, returning the space formerly occupied by that object to the appropriate free block list.</p> </li> <li> <p>u</p> <p>The usage command.  Prints a partition usage report, as per psm_report(3).</p> </li> <li> <p>q</p> <p>The quit command.  Frees the allocated system memory in the managed block and terminates psmshell.</p> </li> </ul>"},{"location":"man/ici/psmshell/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>psmshell has terminated.</p> </li> </ul>"},{"location":"man/ici/psmshell/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/psmshell/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/psmshell/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>IPC initialization failed.</p> <p>ION system error.  Investigate, correct problem, and try again.</p> </li> <li> <p>psmshell: can't allocate space; quitting.</p> <p>Insufficient available system memory for selected partition size.</p> </li> <li> <p>psmshell: can't allocate test variables; quitting.</p> <p>Insufficient available system memory for selected partition size.</p> </li> </ul>"},{"location":"man/ici/psmshell/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/psmshell/#see-also","title":"SEE ALSO","text":"<p>psm(3)</p>"},{"location":"man/ici/psmwatch/","title":"NAME","text":"<p>psmwatch - PSM memory partition activity monitor</p>"},{"location":"man/ici/psmwatch/#synopsis","title":"SYNOPSIS","text":"<p>psmwatch shared_memory_key memory_size partition_name interval count [ verbose ]</p>"},{"location":"man/ici/psmwatch/#description","title":"DESCRIPTION","text":"<p>For count interations, psmwatch sleeps interval seconds and then invokes the psm_print_trace() function (see psm(3)) to report on PSM dynamic memory management activity in the PSM-managed shared memory partition identified by shared_memory_key during that interval.  If the optional verbose parameter is specified, the printed PSM activity trace will be verbose as described in psm(3).</p> <p>To prevent confusion, the specified memory_size and partition_name are compared to those declared when this shared memory partition was initially managed; if they don't match, psmwatch immediately terminates.</p> <p>If interval is zero, psmwatch merely prints a current usage summary for the indicated shared-memory partition and terminates.</p> <p>psmwatch is helpful for detecting and diagnosing memory leaks.  For debugging the ION protocol stack:</p> <ul> <li> <p>shared_memory_key</p> <p>Normally \"65281\", but might be overridden by the value of wmKey in the .ionconfig file used to configure the node under study.</p> </li> <li> <p>memory_size</p> <p>As given by the value of wmKey in the .ionconfig file used to configure the node under study.  If this value is not stated in the .ionconfig file, the default value is \"5000000\".</p> </li> <li> <p>partition_name</p> <p>Always \"ionwm\".</p> </li> </ul>"},{"location":"man/ici/psmwatch/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>psmwatch has terminated.</p> </li> </ul>"},{"location":"man/ici/psmwatch/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/psmwatch/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/psmwatch/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to psm.</p> <p>ION system error.  One possible cause is that ION has not yet been initialized on the local computer; run ionadmin(1) to correct this.</p> </li> <li> <p>Can't start trace.</p> <p>Insufficient ION working memory to contain trace information.  Reinitialize ION with more memory.</p> </li> </ul>"},{"location":"man/ici/psmwatch/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/psmwatch/#see-also","title":"SEE ALSO","text":"<p>psm(3), sdrwatch(1)</p>"},{"location":"man/ici/rfxclock/","title":"NAME","text":"<p>rfxclock - ION daemon task for managing scheduled events</p>"},{"location":"man/ici/rfxclock/#synopsis","title":"SYNOPSIS","text":"<p>rfxclock</p>"},{"location":"man/ici/rfxclock/#description","title":"DESCRIPTION","text":"<p>rfxclock is a background \"daemon\" task that periodically applies scheduled changes in node connectivity and range to the ION node's database. It is spawned automatically by ionadmin in response to the 's' command that starts operation of the ION node infrastructure, and it is terminated by ionadmin in response to an 'x' (STOP) command.</p> <p>Once per second, rfxclock takes the following action:</p> <p>For each neighboring node that has been refusing custody of bundles sent to it to be forwarded to some destination node, to which no such bundle has been sent for at least N seconds (where N is twice the one-way light time from the local node to this neighbor), rfxclock turns on a probeIsDue flag authorizing transmission of the next such bundle in hopes of learning that this neighbor is now able to accept custody.</p> <p>Then rfxclock purges the database of all range and contact information that is no longer applicable, based on the stop times of the records.</p> <p>Finally, rfxclock applies to the database all range and contact information that is currently applicable, i.e., those records whose start times are before the current time and whose stop times are in the future.</p>"},{"location":"man/ici/rfxclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>rfxclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ionadmin to restart rfxclock.</p> </li> <li> <p>\"1\"</p> <p>rfxclock was unable to attach to the local ION node, probably because ionadmin has not yet been run.</p> </li> </ul>"},{"location":"man/ici/rfxclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/rfxclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/rfxclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>rfxclock can't attach to ION.</p> <p>ionadmin has not yet initialized the ION database.</p> </li> <li> <p>Can't apply ranges.</p> <p>An unrecoverable database error was encountered.  rfxclock terminates.</p> </li> <li> <p>Can't apply contacts.</p> <p>An unrecoverable database error was encountered.  rfxclock terminates.</p> </li> <li> <p>Can't purge ranges.</p> <p>An unrecoverable database error was encountered.  rfxclock terminates.</p> </li> <li> <p>Can't purge contacts.</p> <p>An unrecoverable database error was encountered.  rfxclock terminates.</p> </li> </ul>"},{"location":"man/ici/rfxclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/rfxclock/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1)</p>"},{"location":"man/ici/sdr/","title":"NAME","text":"<p>sdr - Simple Data Recorder library</p>"},{"location":"man/ici/sdr/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"sdr.h\"\n\n[see below for available functions]\n</code></pre>"},{"location":"man/ici/sdr/#description","title":"DESCRIPTION","text":"<p>SDR is a library of functions that support the use of an abstract data recording device called an \"SDR\" (\"simple data recorder\") for persistent storage of data.  The SDR abstraction insulates software not only from the specific characteristics of any single data storage device but also from some kinds of persistent  data storage and retrieval chores.  The underlying principle is that an SDR provides standardized support for user data organization at object granularity, with direct access to persistent  user data objects, rather than supporting user data organization  only at \"file\" granularity and requiring the user to implement access to the data objects accreted within those files.</p> <p>The SDR library is designed to provide some of the same kinds of directory services as a file system together with support for complex data structures that provide more operational flexibility than files.  (As an example of this flexibility, consider how much easier and faster it is to delete a given element from the middle  of a linked list than it is to delete a range of bytes from the middle of a text file.)  The intent is to enable the software developer to take maximum advantage of the high speed and direct byte addressability of a non-volatile flat address space in the management of persistent data.  The SDR equivalent of a \"record\" of data is simply a block of nominally persistent memory allocated from this address space.  The SDR equivalent of a \"file\" is a collection object.  Like files, collections can have names, can be located  by name within persistent storage, and can impose structure on the data items they encompass.  But, as discussed later, SDR collection objects can impose structures other than the strict FIFO accretion of records or bytes that characterizes a file.</p> <p>The notional data recorder managed by the SDR library takes the form of a single array of randomly accessible, contiguous, nominally persistent memory locations called a heap.  Physically, the heap may be implemented as a region of shared memory, as a single file of predefined size, or both -- that is, the heap may be a region of shared memory that is automatically mirrored in a file.</p> <p>SDR services that manage SDR data are provided in several layers, each of which relies on the services implemented at lower levels:</p> <p>At the highest level, a cataloguing service enables retrieval  of persistent objects by name.</p> <p>Services that manage three types of persistent data collections are  provided for use both by applications and by the cataloguing service: linked lists, self-delimiting tables (which function as arrays that remember their own dimensions), and self-delimiting strings (short character arrays that remember their lengths, for speedier retrieval).</p> <p>Basic SDR heap space management services, analogous to malloc() and free(), enable the creation and destruction of objects of arbitrary type.</p> <p>Farther down the service stack are memcpy-like low-level  functions for reading from and writing to the heap.</p> <p>Protection of SDR data integrity across a series of reads and writes is  provided by a transaction mechanism.</p> <p>SDR persistent data are referenced in application code by Object values and Address values, both of which are simply displacements (offsets) within SDR address space.  The difference between the two is that an Object is always the address of a block of heap space returned by some call to sdr_malloc(), while an Address can refer to any byte in the address space.  That is, an Address is the SDR functional equivalent of a C pointer in DRAM, and some Addresses point to Objects.</p> <p>Before using SDR services, the services must be loaded to the target machine and initialized by invoking the sdr_initialize() function and the management profiles of one or more SDR's must be loaded by invoking the sdr_load_profile() function.  These steps are normally performed only once, at application load time.</p> <p>An application gains access to an SDR by passing the name of the SDR to the sdr_start_using() function, which returns an Sdr pointer.  Most other SDR library functions take an Sdr pointer as first argument.</p> <p>All writing to an SDR heap must occur during a transaction that was initiated by the task issuing the write.  Transactions are single-threaded; if task B wants to start a transaction while a transaction begun by task A is still in progress, it must wait until A's transaction is either ended or cancelled.  A transaction is begun by calling sdr_begin_xn().  The current transaction is normally ended by calling the sdr_end_xn() function, which returns an error return code value in the event that any serious SDR-related processing error was encountered in the course of the transaction.  Transactions may safely be nested, provided that every level of transaction activity that is begun is properly ended.</p> <p>The current transaction may instead be cancelled by calling sdr_cancel_xn(), which is normally used to indicate that some sort of serious SDR-related processing error has been encountered.  Canceling a transaction reverses all SDR update activity performed up to that point within the scope of the transaction -- and, if the canceled transaction is an inner, nested transaction, all SDR update activity performed within the scope of every outer transaction encompassing that transaction and every other transaction nested within any of those outer transactions -- provided the SDR was configured for transaction reversibility.  When an SDR is configured for reversibility, all heap write operations performed during a transaction are recorded in a log file that is retained until the end of the transaction.  Each log file entry notes the location at which the write operation was performed, the length of data written, and the content of the overwritten heap bytes prior to the write operation.  Canceling the transaction causes the log entries to be read and processed in reverse order, restoring all overwritten data. Ending the transaction, on the other hand, simply causes the log to be discarded.</p> <p>If a log file exists at the time that the profile for an SDR is loaded (typically during application initialization), the transaction that was being logged is automatically canceled and reversed.  This ensures that, for example, a power failure that occurs in the middle of a transaction will never wreck the SDR's data integrity: either all updates issued during a given transaction are reflected in the current dataspace content or none are.</p> <p>As a further measure to protect SDR data integrity, an SDR may additionally be configured for object bounding.  When an SDR is configured to be \"bounded\", every heap write operation is restricted to the extent of a single object allocated from heap space; that is, it's impossible to overwrite part of one object by writing beyond the end of another.  To enable the library to enforce this mechanism, application code is prohibited from writing anywhere but within the extent of an object that either (a) was allocated from managed heap space during the same transaction (directly or indirectly via some collection management function) or (b) was staged -- identified as an update target -- during the same transaction (again, either directly or via some collection management function).</p> <p>Note that both transaction reversibility and object bounding consume processing cycles and inhibit performance to some degree.  Determining the right balance between operational safety and processing speed is left to the user.</p> <p>Note also that, since SDR transactions are single-threaded, they can additionally be used as a general mechanism for simply implementing \"critical sections\" in software that is already using SDR for other purposes: the beginning of a transaction marks the start of code that can't be executed concurrently by multiple tasks.  To support this use of the SDR transaction mechanism, the additional transaction termination function sdr_exit_xn() is provided.  sdr_exit_xn() simply ends a transaction without either signaling an error or checking for errors.  Like sdr_cancel_xn(), sdr_exit_xn() has no return value; unlike sdr_cancel_xn(), it assures that ending an inner, nested transaction does not cause the outer transaction to be aborted and backed out.  But this capability must be used carefully: the protection of SDR data integrity requires that transactions which are ended by sdr_exit_xn() must not encompass any SDR update activity whatsoever.</p> <p>The heap space management functions of the SDR library are adapted directly from the Personal Space Management (psm) function library.  The manual page for psm(3) explains the algorithms used and the rationale behind them.  The principal difference between PSM memory management and SDR heap management is that, for performance reasons, SDR reserves the \"small pool\" for its own use only; all user data space is allocated from the \"large pool\", via the sdr_malloc() function.</p>"},{"location":"man/ici/sdr/#return-values-and-error-handling","title":"RETURN VALUES AND ERROR HANDLING","text":"<p>Whenever an SDR function call fails, a diagnostic message explaining the failure of the function is recorded in the error message pool managed by the \"platform\" system (see the discussion of putErrmsg() in platform(3)).</p> <p>The failure of any function invoked in the course of an SDR transaction causes all subsequent SDR activity in that transaction to fail immediately.  This can streamline SDR application code somewhat: it may not be necessary to check the return value of every SDR function call executed during a transaction. If the sdr_end_xn() call returns zero, all updates performed during the transaction must have succeeded.</p>"},{"location":"man/ici/sdr/#system-administration-functions","title":"SYSTEM ADMINISTRATION FUNCTIONS","text":"<ul> <li> <p>int sdr_initialize(int wmSize, char *wmPtr, int wmKey, char *wmName)</p> <p>Initializes the SDR system.  sdr_initialize() must be called once every time the computer on which the system runs is rebooted, before any call to any other SDR library function.</p> <p>This function attaches to a pool of shared memory, managed by PSM (see psm(3), that enables SDR library operations.  If the SDR system is to access a common pool of shared memory with one or more other systems, the key of that shared memory segment must be provided in wmKey and the PSM partition name associated with that memory segment must be provided in wmName; otherwise wmKey must be zero and wmName must be NULL, causing sdr_initialize() to assign default values.  If a shared memory segment identified by the effective value of wmKey already exists, then wmSize may be zero and the value of wmPtr is ignored.  Otherwise the size of the shared memory pool must be provided in wmSize and a new shared memory segment is created in a manner that is dependent on wmPtr: if wmPtr is NULL then wmSize bytes of shared memory are dynamically acquired, allocated, and assigned to the newly created shared memory segment; otherwise the memory located at wmPtr is assumed to have been pre-allocated and is merely assigned to the newly created shared memory segment.</p> <p>sdr_initialize() also creates a semaphore to serialize access to the SDR system's private array of SDR profiles.  </p> <p>Returns 0 on success, -1 on any failure.</p> </li> <li> <p>void sdr_wm_usage(PsmUsageSummary *summary)</p> <p>Loads summary with a snapshot of the usage of the SDR system's private working memory.  To print the snapshot, use psm_report().  (See psm(3).)</p> </li> <li> <p>void sdr_shutdown( )</p> <p>Ends all access to all SDRs (see sdr_stop_using()), detaches from the SDR system's working memory (releasing the memory if it was dynamically allocated by sdr_initialize()), and destroys the SDR system's private semaphore.  After sdr_shutdown(), sdr_initialize() must be called again before any call to any other SDR library function.</p> </li> </ul>"},{"location":"man/ici/sdr/#database-administration-functions","title":"DATABASE ADMINISTRATION FUNCTIONS","text":"<ul> <li> <p>int sdr_load_profile(char *name, int configFlags, long heapWords, int heapKey, int logSize, int logKey, char *pathName, char *restartCmd, unsigned int restartLatency)</p> <p>Loads the profile for an SDR into the system's private list of SDR profiles. Although SDRs themselves are persistent, SDR profiles are not: in order for an application to access an SDR, sdr_load_profile() must have been called to load the profile of the SDR since the last invocation of sdr_initialize(). </p> <p>name is the name of the SDR, required for any subsequent sdr_start_using() call.  </p> <p>configFlags specifies the configuration of the SDR, the bitwise \"or\" of some combination of the following:</p> <ul> <li> <p>SDR_IN_DRAM</p> <p>SDR dataspace is implemented as a region of shared memory.</p> </li> <li> <p>SDR_IN_FILE</p> <p>SDR dataspace is implemented as a file.</p> </li> <li> <p>SDR_REVERSIBLE</p> <p>SDR transactions are logged and are reversed if canceled.</p> </li> <li> <p>SDR_BOUNDED</p> <p>Heap updates are not allowed to cross object boundaries.</p> </li> </ul> <p>heapWords specifies the size of the heap in words; word size depends on machine architecture, i.e., a word is 4 bytes on a 32-bit machine, 8 bytes on a 64-bit machine.  Note that each SDR prepends to the heap a \"map\" of predefined, fixed size.  The total amount of space occupied by an SDR dataspace in memory and/or in a file is the sum of the size of the map plus the product of word size and heapWords.</p> <p>heapKey is ignored if configFlags does not include SDR_IN_DRAM.  It should normally be SM_NO_KEY, causing the shared memory region for the SDR dataspace to be allocated dynamically and shared using a dynamically selected shared memory key.  If specified, heapKey must be a shared memory key identifying a pre-allocated region of shared memory whose length is equal to the total SDR dataspace size, shared via the indicated key.</p> <p>logSize specifies the maximum size of the transaction log (in bytes) if and only if the log is to be written to memory rather than to a file; otherwise it must be zero.  logKey is ignored if logSize is zero.  It should normally be SM_NO_KEY, causing the shared memory region for the transaction log to be allocated dynamically and shared using a dynamically selected shared memory key.  If specified, logKey must be a shared memory key identifying a pre-allocated region of shared memory whose length is equal to logSize, shared via the indicated key.</p> <p>pathName is ignored if configFlags includes neither SDR_REVERSIBLE nor SDR_IN_FILE.  It is the fully qualified name of the directory into which the SDR's log file and/or dataspace file will be written.  The name of the log file (if any) will be \"&lt;sdrname&gt;.sdrlog\".  The name of the dataspace file (if any) will be \"&lt;sdrname&gt;.sdr\"; this file will be automatically created and filled with zeros if it does not exist at the time the SDR's profile is loaded.</p> <p>If a cleanup task must be run whenever a transaction is reversed, the command to execute this task must be provided in restartCmd and the number of seconds to wait for this task to finish before resuming operations must be provided in restartLatency.  If restartCmd is NULL or restartLatency is zero then no cleanup task will be run upon transaction reversal.</p> <p>Returns 0 on success, -1 on any error.</p> </li> <li> <p>int sdr_reload_profile(char *name, int configFlags, long heapWords, int heapKey, int logSize, int logKey, char *pathName, char *restartCmd, unsigned int restartLatency)</p> <p>For use when the state of an SDR is thought to be inconsistent, perhaps due to crash of a program that had a transaction open.  Unloads the profile for the SDR, forcing the reversal of any transaction that is currently in progress when the SDR's profile is re-loaded.  Then calls sdr_load_profile() to re-load the profile for the SDR.  Same return values as sdr_load_profile.</p> </li> <li> <p>Sdr sdr_start_using(char *name)</p> <p>Locates SDR profile by name and returns a handle that can be used for all functions that operate on that SDR.  On any failure, returns NULL.</p> </li> <li> <p>char *sdr_name(Sdr sdr)</p> <p>Returns the name of the sdr.</p> </li> <li> <p>long sdr_heap_size(Sdr sdr)</p> <p>Returns the total size of the SDR heap, in bytes.</p> </li> <li> <p>void sdr_stop_using(Sdr sdr)</p> <p>Terminates access to the SDR via this handle.  Other users of the SDR are not affected.  Frees the Sdr object.</p> </li> <li> <p>void sdr_abort(Sdr sdr)</p> <p>Terminates the task.  In flight configuration, also terminates all use of the SDR system by all tasks.</p> </li> <li> <p>void sdr_destroy(Sdr sdr)</p> <p>Ends all access to this SDR, unloads the SDR's profile, and erases the SDR from memory and file system.</p> </li> </ul>"},{"location":"man/ici/sdr/#database-transaction-functions","title":"DATABASE TRANSACTION FUNCTIONS","text":"<ul> <li> <p>int sdr_begin_xn(Sdr sdr)</p> <p>Initiates a transaction.  Returns 1 on success, 0 on any failure.  Note that transactions are single-threaded; any task that calls sdr_begin_xn() is suspended until all previously requested transactions have been ended or canceled.</p> </li> <li> <p>int sdr_in_xn(Sdr sdr)</p> <p>Returns 1 if called in the course of a transaction, 0 otherwise.</p> </li> <li> <p>void sdr_exit_xn(Sdr sdr)</p> <p>Simply abandons the current transaction, ceasing the calling task's lock on ION.  Must not be used if any dataspace modifications were performed during the transaction; sdr_end_xn() must be called instead, to commit those modifications.</p> </li> <li> <p>void sdr_cancel_xn(Sdr sdr)</p> <p>Cancels the current transaction.  If reversibility is enabled for the SDR, canceling a transaction reverses all heap modifications performed during that transaction.</p> </li> <li> <p>int sdr_end_xn(Sdr sdr)</p> <p>Ends the current transaction.  Returns 0 if the transaction completed without any error; returns -1 if any operation performed in the course of the transaction failed, in which case the transaction was automatically canceled.</p> </li> </ul>"},{"location":"man/ici/sdr/#database-io-functions","title":"DATABASE I/O FUNCTIONS","text":"<ul> <li> <p>void sdr_read(Sdr sdr, char *into, Address from, int length)</p> <p>Copies length characters at from (a location in the indicated SDR) to the memory location given by into.  The data are copied from the shared memory region in which the SDR resides, if any; otherwise they are read from the file in which the SDR resides.</p> </li> <li> <p>void sdr_peek(sdr, variable, from)</p> <p>sdr_peek() is a macro that uses sdr_read() to load variable from the indicated address in the SDR dataspace; the size of variable is used as the number of bytes to copy.</p> </li> <li> <p>void sdr_write(Sdr sdr, Address into, char *from, int length)</p> <p>Copies length characters at from (a location in memory) to the SDR heap location given by into.  Can only be performed during a transaction,  and if the SDR is configured for object bounding then heap locations into through (into + (length - 1)) must be within the extent of some object that was either allocated or staged within the same transaction.  The data are copied both to the shared memory region in which the SDR resides, if any, and also to the file in which the SDR resides, if any.</p> </li> <li> <p>void sdr_poke(sdr, into, variable)</p> <p>sdr_poke() is a macro that uses sdr_write() to store variable at the indicated address in the SDR dataspace; the size of variable is used as the number of bytes to copy.</p> </li> <li> <p>char *sdr_pointer(Sdr sdr, Address address)</p> <p>Returns a pointer to the indicated location in the heap - a \"heap pointer\" - or NULL if the indicated address is invalid.  NOTE that this function cannot be used if the SDR does not reside in a shared memory region.</p> <p>Providing an alternative to using sdr_read() to retrieve objects into local memory, sdr_pointer() can help make SDR-based applications run very quickly, but it must be used WITH GREAT CAUTION!  Never use a direct pointer into the heap when not within a transaction, because you will have no assurance at any time that the object pointed to by that pointer has not changed (or is even still there).  And NEVER de-reference a heap  pointer in order to write directly into the heap: this makes transaction reversal impossible.  Whenever writing to the SDR, always use sdr_write().</p> </li> <li> <p>Address sdr_address(Sdr sdr, char *pointer)</p> <p>Returns the address within the SDR heap of the indicated location, which must be (or be derived from) a heap pointer as returned by sdr_pointer().  Returns zero if the indicated location is not greater than the start of the heap mirror.  NOTE that this function cannot be used if the SDR does not reside in a shared memory region.</p> </li> <li> <p>void sdr_get(sdr, variable, heap_pointer)</p> <p>sdr_get() is a macro that uses sdr_read() to load variable from the SDR address given by heap_pointer; heap_pointer must be (or be derived from) a heap pointer as returned by sdr_pointer().  The size of variable is used as the number of bytes to copy.</p> </li> <li> <p>void sdr_set(sdr, heap_pointer, variable)</p> <p>sdr_set() is a macro that uses sdr_write() to store variable at the SDR address given by heap_pointer; heap_pointer must be (or be derived from) a heap pointer as returned by sdr_pointer().  The size of variable is used as the number of bytes to copy.</p> </li> </ul>"},{"location":"man/ici/sdr/#heap-space-management-functions","title":"HEAP SPACE MANAGEMENT FUNCTIONS","text":"<ul> <li> <p>Object sdr_malloc(Sdr sdr, unsigned long size)</p> <p>Allocates a block of space from the of the indicated SDR's heap.  size is the size of the block to allocate; the maximum size is 1/2 of the maximum address space size (i.e., 2G for a 32-bit machine).  Returns block address if successful, zero if block could not be allocated.</p> </li> <li> <p>Object sdr_insert(Sdr sdr, char *from, unsigned long size)</p> <p>Uses sdr_malloc() to obtain a block of space of size size and, if this allocation is successful, uses sdr_write() to copy size bytes of data from memory at from into the newly allocated block.  Returns block address if successful, zero if block could not be allocated.</p> </li> <li> <p>Object sdr_stow(sdr, variable)</p> <p>sdr_stow() is a macro that uses sdr_insert() to insert a copy of variable into the dataspace.  The size of variable is used as the number of bytes to copy.</p> </li> <li> <p>int sdr_object_length(Sdr sdr, Object object)</p> <p>Returns the number of bytes of heap space allocated to the application data at object.</p> </li> <li> <p>void sdr_free(Sdr sdr, Object object)</p> <p>Frees for subsequent re-allocation the heap space occupied by object.</p> </li> <li> <p>void sdr_stage(Sdr sdr, char *into, Object from, int length)</p> <p>Like sdr_read(), this function will copy length characters at from (a location in the heap of the indicated SDR) to the memory location given by into.  Unlike sdr_get(), sdr_stage() requires that from be the address of some allocated object, not just any location within the heap.  sdr_stage(), when called from within a transaction,  notifies the SDR library that the indicated object may be  updated later in the transaction; this enables the library  to retrieve the object's size for later reference in validating attempts to write into some location within the object.  If length is zero, the object's size is privately retrieved by SDR but none of the object's content is copied into memory.</p> </li> <li> <p>long sdr_unused(Sdr sdr)</p> <p>Returns number of bytes of heap space not yet allocated to either the large or small objects pool.</p> </li> <li> <p>void sdr_usage(Sdr sdr, SdrUsageSummary *summary)</p> <p>Loads the indicated SdrUsageSummary structure with a snapshot of the SDR's usage status.  SdrUsageSummary is defined by:</p> <pre><code>typedef struct\n{\n        char            sdrName[MAX_SDR_NAME + 1];\n        unsigned int    dsSize;\n        unsigned int    smallPoolSize;\n        unsigned int    smallPoolFreeBlockCount[SMALL_SIZES];\n        unsigned int    smallPoolFree;\n        unsigned int    smallPoolAllocated;\n        unsigned int    largePoolSize;\n        unsigned int    largePoolFreeBlockCount[LARGE_ORDERS];\n        unsigned int    largePoolFree;\n        unsigned int    largePoolAllocated;\n        unsigned int    unusedSize;\n} SdrUsageSummary;\n</code></pre> </li> <li> <p>void sdr_report(SdrUsageSummary *summary)</p> <p>Sends to stdout a printed summary of the SDR's usage status.</p> </li> <li> <p>int sdr_heap_depleted(Sdr sdr)</p> <p>A Boolean function: returns 1 if the total available space in the SDR's heap (small pool free, large pool free, and unused) is less than 1/16 of the total size of the heap.  Otherwise returns zero.</p> </li> </ul>"},{"location":"man/ici/sdr/#heap-space-usage-tracing","title":"HEAP SPACE USAGE TRACING","text":"<p>If SDR_TRACE is defined at the time the SDR source code is compiled, the system includes built-in support for simple tracing of SDR heap space usage: heap space allocations are logged, and heap space deallocations are matched to logged allocations, \"closing\" them.  This enables heap space leaks and some other kinds of SDR heap access problems to be readily investigated.</p> <ul> <li> <p>int sdr_start_trace(Sdr sdr, int traceLogSize, char *traceLogAddress)</p> <p>Begins an episode of SDR heap space usage tracing.  traceLogSize is the number of bytes of shared memory to use for trace activity logging; the frequency with which \"closed\" trace log events must be deleted will vary inversely with the amount of memory allocated for the trace log. traceLogAddress is normally NULL, causing the trace system to allocate traceLogSize bytes of shared memory dynamically for trace logging; if non-NULL, it must point to traceLogSize bytes of shared memory that have been pre-allocated by the application for this purpose.  Returns 0 on success, -1 on any failure.</p> </li> <li> <p>void sdr_print_trace(Sdr sdr, int verbose)</p> <p>Prints a cumulative trace report and current usage report for  sdr.  If verbose is zero, only exceptions (notably, trace log events that remain open -- potential SDR heap space leaks) are printed; otherwise all activity in the trace log is printed.</p> </li> <li> <p>void sdr_clear_trace(Sdr sdr)</p> <p>Deletes all closed trace log events from the log, freeing up memory for additional tracing.</p> </li> <li> <p>void sdr_stop_trace(Sdr sdr)</p> <p>Ends the current episode of SDR heap space usage tracing.  If the shared memory used for the trace log was allocated by sdr_start_trace(), releases that shared memory.</p> </li> </ul>"},{"location":"man/ici/sdr/#catalogue-functions","title":"CATALOGUE FUNCTIONS","text":"<p>The SDR catalogue functions are used to maintain the catalogue of the names, types, and addresses of objects within an SDR.  The catalogue service includes functions for creating, deleting and finding catalogue entries and a function for navigating through catalogue entries sequentially.</p> <ul> <li> <p>void sdr_catlg(Sdr sdr, char *name, int type, Object object)</p> <p>Associates object with name in the indicated SDR's catalogue and notes  the type that was declared for this object.  type is optional and  has no significance other than that conferred on it by the application.</p> <p>The SDR catalogue is flat, not hierarchical like a directory tree,  and all names must be unique.  The length of name is limited to 15 characters.</p> </li> <li> <p>Object sdr_find(Sdr sdr, char *name, int *type)</p> <p>Locates the Object associated with name in the indicated SDR's catalogue  and returns its address; also reports the catalogued type of the object in  *type if type is non-NULL.  Returns zero if no object is currently catalogued under this name.</p> </li> <li> <p>void sdr_uncatlg(Sdr sdr, char *name)</p> <p>Dissociates from name whatever object in the indicated SDR's catalogue is currently catalogued under that name.</p> </li> <li> <p>Object sdr_read_catlg(Sdr sdr, char *name, int *type, Object *object, Object previous_entry)</p> <p>Used to navigate through catalogue entries sequentially.  If previous_entry is zero, reads the first entry in the indicated SDR's catalogue; otherwise, reads the next catalogue entry following the one located at previous_entry.  In either case, returns zero if no such catalogue entry exists; otherwise, copies that entry's name, type, and catalogued object address into name, *type, and *object, and then returns the address of the catalogue entry (which may be used as previous_entry in a subsequent call to sdr_read_catlg()).</p> </li> </ul>"},{"location":"man/ici/sdr/#users-guide","title":"USER'S GUIDE","text":"<ul> <li> <p>Compiling an SDR application</p> <p>Just be sure to \"#include \"sdr.h\"\" at the top of each source file that includes any SDR function calls.</p> <p>For UNIX applications, link with \"-lsdr\".</p> </li> <li> <p>Loading an SDR application (VxWorks)</p> <pre><code>ld &lt; \"libsdr.o\"\n</code></pre> <p>After the library has been loaded, you can begin loading SDR applications.</p> </li> </ul>"},{"location":"man/ici/sdr/#see-also","title":"SEE ALSO","text":"<p>sdrlist(3), sdrstring(3), sdrtable(3)</p>"},{"location":"man/ici/sdr2file/","title":"NAME","text":"<p>sdr2file - SDR data extraction test program</p>"},{"location":"man/ici/sdr2file/#synopsis","title":"SYNOPSIS","text":"<p>sdr2file configFlags</p>"},{"location":"man/ici/sdr2file/#description","title":"DESCRIPTION","text":"<p>sdr2file stress-tests SDR data extraction by retrieving and deleting all text file lines inserted into a test SDR data store named \"testsdr_configFlags_\" by the complementary test program file2sdr(1).</p> <p>The operation of sdr2file echoes the cyclical operation of file2sdr: each linked list created by file2sdr is used to create in the current working directory a copy of file2sdr's original source text file. The name of each file written by sdr2file is file_copy_cycleNbr, where cycleNbr identifies the linked list from which the file's text lines were obtained.</p> <p>sdr2file may catch up with the data ingestion activity of file2sdr, in which case it blocks (taking the file2sdr test semaphore) until the linked list it is currently draining is no longer empty.</p>"},{"location":"man/ici/sdr2file/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>sdr2file has terminated.</p> </li> </ul>"},{"location":"man/ici/sdr2file/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/sdr2file/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/sdr2file/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>Can't use sdr.</p> <p>ION system error.  Check for diagnostics in the ION log file ion.log.</p> </li> <li> <p>Can't create semaphore.</p> <p>ION system error.  Check for diagnostics in the ION log file ion.log.</p> </li> <li> <p>SDR transaction failed.</p> <p>ION system error.  Check for diagnostics in the ION log file ion.log.</p> </li> <li> <p>Can't open output file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>can't write to output file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> </ul>"},{"location":"man/ici/sdr2file/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/sdr2file/#see-also","title":"SEE ALSO","text":"<p>file2sdr(1), sdr(3)</p>"},{"location":"man/ici/sdrhash/","title":"NAME","text":"<p>sdrhash - Simple Data Recorder hash table management functions</p>"},{"location":"man/ici/sdrhash/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"sdr.h\"\n\nObject  sdr_hash_create        (Sdr sdr, int keyLength,\n                                    int estNbrOfEntries,\n                                    int meanSearchLength);\nint     sdr_hash_insert        (Sdr sdr, Object hash, char *key,\n                                    Address value, Object *entry);\nint     sdr_hash_delete_entry  (Sdr sdr, Object entry);\nint     sdr_hash_entry_value   (Sdr sdr, Object hash, Object entry);\nint     sdr_hash_retrieve      (Sdr sdr, Object hash, char *key,\n                                    Address *value, Object *entry);\nint     sdr_hash_count         (Sdr sdr, Object hash);\nint     sdr_hash_revise        (Sdr sdr, Object hash, char *key,\n                                    Address value);\nint     sdr_hash_remove        (Sdr sdr, Object hash, char *key,\n                                    Address *value);\nint     sdr_hash_destroy       (Sdr sdr, Object hash);\n</code></pre>"},{"location":"man/ici/sdrhash/#description","title":"DESCRIPTION","text":"<p>The SDR hash functions manage hash table objects in an SDR.  </p> <p>Hash tables associate values with keys.  A value is always in the form of an SDR Address, nominally the address of some stored object identified by the associated key, but the actual significance of a value may be anything that fits into a long.  A key is always an array of from 1 to 255 bytes, which may have any semantics at all.</p> <p>Keys must be unique; no two distinct entries in an SDR hash table may have the same key.  Any attempt to insert a duplicate entry in an SDR hash table will be rejected.</p> <p>All keys must be of the same length, and that length must be declared at the time the hash table is created.  Invoking a hash table function with a key that is shorter than the declared length will have unpredictable results.</p> <p>An SDR hash table is an array of linked lists.  The location of a given value in the hash table is automatically determined by computing a \"hash\" of the key, dividing the hash by the number of linked lists in the array, using the remainder as an index to the corresponding linked list, and then sequentially searching through the list entries until the entry with the matching key is found.</p> <p>The number of linked lists in the array is automatically computed at the time the hash table is created, based on the estimated maximum number of entries you expect to store in the table and the mean linked list length (i.e., mean search time) you prefer.  Increasing the maximum number of entries in the table and decreasing the mean linked list length both tend to increase the amount of SDR heap space occupied by the hash table.</p> <ul> <li> <p>Object sdr_hash_create(Sdr sdr, int keyLength, int estNbrOfEntries, int meanSearchLength)</p> <p>Creates an SDR hash table.  Returns the SDR address of the new hash table on success, zero on any error.</p> </li> <li> <p>int sdr_hash_insert(Sdr sdr, Object hash, char *key, Address value, Object *entry)</p> <p>Inserts an entry into the hash table identified by hash.  On success, places the address of the new hash table entry in entry and returns zero. Returns -1 on any error.</p> </li> <li> <p>int sdr_hash_delete_entry(Sdr sdr, Object entry)</p> <p>Deletes the hash table entry identified by entry.  Returns zero on success, -1 on any error.</p> </li> <li> <p>Address sdr_hash_entry_value(Sdr sdr, Object hash, Object entry)</p> <p>Returns the value of the hash table entry identified by entry.</p> </li> <li> <p>int sdr_hash_retrieve(Sdr sdr, Object hash, char *key, Address *value, Object *entry)</p> <p>Searches for the value associated with key in this hash table, storing it in value if found.  If the entry matching key was found, places the address of the hash table entry in entry and returns 1.  Returns zero if no such entry exists, -1 on any other failure.</p> </li> <li> <p>int sdr_hash_count(Sdr sdr, Object hash)</p> <p>Returns the number of entries in the hash table identified by hash.</p> </li> <li> <p>int sdr_hash_revise(Sdr sdr, Object hash, char *key, Address value)</p> <p>Searches for the hash table entry matching key in this hash table, replacing the associated value with value if found.  Returns 1 if the entry matching key was found, zero if no such entry exists, -1 on any other failure.</p> </li> <li> <p>int sdr_hash_remove(Sdr sdr, Object hash, char *key, Address *value)</p> <p>Searches for the hash table entry matching key in this hash table; if the entry is found, stores its value in value, deletes the entry, and returns 1.  Returns zero if no such entry exists, -1 on any other failure.</p> </li> <li> <p>void sdr_hash_destroy(Sdr sdr, Object hash);</p> <p>Destroys hash, destroying all entries in all linked lists of the array and destroying the hash table array structure itself.  DO NOT use sdr_free() to destroy a hash table, as this would leave the hash table's content allocated yet unreferenced.</p> </li> </ul>"},{"location":"man/ici/sdrhash/#see-also","title":"SEE ALSO","text":"<p>sdr(3), sdrlist(3), sdrtable(3)</p>"},{"location":"man/ici/sdrlist/","title":"NAME","text":"<p>sdrlist - Simple Data Recorder list management functions</p>"},{"location":"man/ici/sdrlist/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"sdr.h\"\n\ntypedef int (*SdrListCompareFn)(Sdr sdr, Address eltData, void *argData);\ntypedef void (*SdrListDeleteFn)(Sdr sdr, Object elt, void *argument);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/sdrlist/#description","title":"DESCRIPTION","text":"<p>The SDR list management functions manage doubly-linked lists in managed SDR heap space.  The functions manage two kinds of objects: lists and list elements.  A list knows how many elements it contains and what its start and end elements are.  An element knows what list it belongs to and the elements before and after it in the list.  An element also knows its content, which is normally the SDR Address of some object in the SDR heap.  A list may be sorted, which speeds the process of searching for a particular element.</p> <ul> <li> <p>Object sdr_list_create(Sdr sdr)</p> <p>Creates a new list object in the SDR; the new list object initially  contains no list elements.  Returns the address of the new list, or  zero on any error.</p> </li> <li> <p>void sdr_list_destroy(Sdr sdr, Object list, SdrListDeleteFn fn, void *arg)</p> <p>Destroys a list, freeing all elements of list.  If fn is non-NULL, that function is called once for each freed element; when called, fn is passed the Address that is the element's data and the argument pointer passed to sdr_list_destroy().</p> <p>Do not use sdr_free to destroy an SDR list, as this would leave the elements of the list allocated yet unreferenced.</p> </li> <li> <p>int sdr_list_length(Sdr sdr, Object list)</p> <p>Returns the number of elements in the list, or -1 on any error.</p> </li> <li> <p>void sdr_list_user_data_set(Sdr sdr, Object list, Address userData)</p> <p>Sets the \"user data\" word of list to userData.  Note that userData is nominally an Address but can in fact be any value that occupies a single word.  It is typically used to point to an SDR object that somehow characterizes the list as a whole, such as a name.</p> </li> <li> <p>Address  sdr_list_user_data(Sdr sdr, Object list)</p> <p>Returns the value of the \"user data\" word of list, or zero on any error.</p> </li> <li> <p>Object sdr_list_insert(Sdr sdr, Object list, Address data, SdrListCompareFn fn, void *dataBuffer)</p> <p>Creates a new list element whose data value is data and inserts that element into the list.  If fn is NULL, the new list element is simply appended to the list; otherwise, the new list element is inserted after the last element in the list whose data value is \"less than or equal to\" the data value of the new element (in dataBuffer) according to the collating sequence established by fn.  Returns the address of the newly created element, or zero on any error.</p> </li> <li> <p>Object sdr_list_insert_first(Sdr sdr, Object list, Address data)</p> </li> <li> <p>Object sdr_list_insert_last(Sdr sdr, Object list, Address data)</p> <p>Creates a new element and inserts it at the front/end of the list.  This function should not be used to insert a new  element into any ordered list; use sdr_list_insert() instead. Returns the address of the newly created list element on success, or zero on any error.</p> </li> <li> <p>Object sdr_list_insert_before(Sdr sdr, Object elt, Address data)</p> </li> <li> <p>Object sdr_list_insert_after(Sdr sdr, Object elt, Address data)</p> <p>Creates a new element and inserts it before/after the specified list element.  This function should not be used to insert a new element into any ordered list; use sdr_list_insert() instead.  Returns the address of the newly  created list element, or zero on any error.</p> </li> <li> <p>void sdr_list_delete(Sdr sdr, Object elt, SdrListDeleteFn fn, void *arg)</p> <p>Delete elt from the list it is in. If fn is non-NULL, that function will be called upon deletion of elt; when called, that function is passed the Address that is the list element's data value and the arg pointer passed to sdr_list_delete().</p> </li> <li> <p>Object sdr_list_first(Sdr sdr, Object list)</p> </li> <li> <p>Object sdr_list_last(Sdr sdr, Object list)</p> <p>Returns the address of the first/last element of list, or zero on any error.</p> </li> <li> <p>Object sdr_list_next(Sdr sdr, Object elt)</p> </li> <li> <p>Object sdr_list_prev(Sdr sdr, Object elt)</p> <p>Returns the address of the element following/preceding elt in that element's list, or zero on any error.</p> </li> <li> <p>Object sdr_list_search(Sdr sdr, Object elt, int reverse, SdrListCompareFn fn, void *dataBuffer);</p> <p>Search a list for an element whose data matches the data in dataBuffer, starting at the indicated initial list element.  If the compare function is non-NULL, the list is assumed to be sorted in the order implied by that function and the function is automatically called once for each element of the list until it returns a value that is greater than or equal to zero (where zero indicates an exact match and a value greater than zero indicates that the list contains no matching element); each time compare is called it is passed the Address that is the element's data value and the dataBuffer value passed to sm_list_search(). If reverse is non-zero, then the list is searched in reverse order (starting at the indicated initial list element) and the search ends when compare returns a value that is less than or equal to zero.  If compare is NULL, then the entire list is searched (in either forward or reverse order, as directed) until an element is located whose data value is equal to ((Address) dataBuffer).  Returns the address of the matching element if one is found, 0 otherwise.</p> </li> <li> <p>Object sdr_list_list(Sdr sdr, Object elt)</p> <p>Returns the address of the list to which elt belongs, or 0 on any error.</p> </li> <li> <p>Address sdr_list_data(Sdr sdr, Object elt)</p> <p>Returns the Address that is the data value of elt, or 0 on any error.</p> </li> <li> <p>Address sdr_list_data_set(Sdr sdr, Object elt, Address data)</p> <p>Sets the data value for elt to data, replacing the original value.  Returns the original data value for elt, or 0 on any error.  The original data value for elt may or may not have been the address of an object in heap data space; even if it was, that object was NOT deleted.</p> <p>Warning: changing the data value of an element of an ordered list may ruin the ordering of the list.</p> </li> </ul>"},{"location":"man/ici/sdrlist/#usage","title":"USAGE","text":"<p>When inserting elements or searching a list, the user may optionally provide a compare function of the form:</p> <pre><code>int user_comp_name(Sdr sdr, Address eltData, void *dataBuffer);\n</code></pre> <p>When provided, this function is automatically called by the sdrlist function being invoked; when the function is called it is passed the content of a list element (eltData, nominally the Address of an item in the SDR's heap space) and an argument, dataBuffer, which is nominally the address in local memory of some other item in the same format. The user-supplied function normally compares some key values of the two data items and returns 0 if they are equal, an integer less than 0 if eltData's key value is less than that of dataBuffer, and an integer greater than 0 if eltData's key value is greater than that of dataBuffer.  These return values will produce a list in ascending order. If the user desires the list to be in descending order, the function must reverse the signs of these return values.</p> <p>When deleting an element or destroying a list, the user may optionally provide a delete function of the form:</p> <pre><code>void user_delete_name(Sdr sdr, Address eltData, void *argData)\n</code></pre> <p>When provided, this function is automatically called by the sdrlist function being invoked; when the function is called it is passed the content of a list element (eltData, nominally the Address of an item in the SDR's heap space) and an argument, argData, which if non-NULL is normally the address in local memory of a data item providing context for the list element deletion. The user-supplied function performs any application-specific cleanup associated with deleting the element, such as freeing the element's content data item and/or other SDR heap space associated with the element.</p>"},{"location":"man/ici/sdrlist/#see-also","title":"SEE ALSO","text":"<p>lyst(3), sdr(3), sdrstring(3), sdrtable(3), smlist(3)</p>"},{"location":"man/ici/sdrmend/","title":"NAME","text":"<p>sdrmend - SDR corruption repair utility</p>"},{"location":"man/ici/sdrmend/#synopsis","title":"SYNOPSIS","text":"<p>sdrmend sdr_name config_flags heap_words heap_key path_name [restartCmd restartLatency]</p>"},{"location":"man/ici/sdrmend/#description","title":"DESCRIPTION","text":"<p>The sdrmend program simply invokes the sdr_reload_profile() function (see sdr(3)) to effect necessary repairs in a potentially corrupt SDR, e.g., due to the demise of a program that had an SDR transaction in progress at the moment it crashed.</p> <p>Note that sdrmend need not be run to repair ION's data store in the event of a hardware reboot: restarting ION will automatically reload the data store's profile.  sdrmend is needed only when it is desired to repair the data store without requiring all ION software to terminate and restart.</p>"},{"location":"man/ici/sdrmend/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>sdrmend has terminated successfully.</p> </li> <li> <p>\"1\"</p> <p>sdrmend has terminated unsuccessfully.  See diagnostic messages in the ion.log log file for details.</p> </li> </ul>"},{"location":"man/ici/sdrmend/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/sdrmend/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/sdrmend/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't initialize the SDR system.</p> <p>Probable operations error: ION appears not to be initialized, in which case there is no point in running sdrmend.</p> </li> <li> <p>Can't reload profile for SDR.</p> <p>ION system error.  See earlier diagnostic messages posted to ion.log for details.  In this event it is unlikely that sdrmend can be run successfully, and it is also unlikely that it would have any effect if it did run successfully.</p> </li> </ul>"},{"location":"man/ici/sdrmend/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/sdrmend/#see-also","title":"SEE ALSO","text":"<p>ionunlock(1), sdr(3), ionadmin(1)</p>"},{"location":"man/ici/sdrstring/","title":"NAME","text":"<p>sdrstring - Simple Data Recorder string functions</p>"},{"location":"man/ici/sdrstring/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"sdr.h\"\n\nObject sdr_string_create (Sdr sdr, char *from);\nObject sdr_string_dup    (Sdr sdr, Object from);\nint    sdr_string_length (Sdr sdr, Object string);\nint    sdr_string_read   (Sdr sdr, char *into, Object string);\n</code></pre>"},{"location":"man/ici/sdrstring/#description","title":"DESCRIPTION","text":"<p>SDR strings are used to record strings of up to 255 ASCII characters in the heap space of an SDR.  Unlike standard C strings, which are terminated by a zero byte, SDR strings record the length of the string as part of the string object.</p> <p>To store strings longer than 255 characters, use sdr_malloc() and sdr_write() instead of these functions.</p> <ul> <li> <p>Object sdr_string_create(Sdr sdr, char *from)</p> <p>Creates a \"self-delimited string\" in the heap of the indicated SDR, allocating the required space and copying the indicated content.  from must be a standard C string for which strlen() must not exceed 255; if it does, or if insufficient SDR space is available, 0 is returned.  Otherwise the address of the newly created SDR string object is returned.  To destroy, just use sdr_free().</p> </li> <li> <p>Object sdr_string_dup(Sdr sdr, Object from)</p> <p>Creates a duplicate of the SDR string whose address is from, allocating the required space and copying the original string's content.  If insufficient SDR space is available, 0 is returned.  Otherwise the address of the newly created copy of the original SDR string object is returned.  To destroy, use sdr_free().</p> </li> <li> <p>int sdr_string_length(Sdr sdr, Object string)</p> <p>Returns the length of the indicated self-delimited string (as would be returned by strlen()), or -1 on any error.</p> </li> <li> <p>int sdr_string_read(Sdr sdr, char *into, Object string)</p> <p>Retrieves the content of the indicated self-delimited string into memory as a standard C string (NULL terminated).  Length of into should normally be SDRSTRING_BUFSZ (i.e., 256) to allow for the largest possible SDR string (255 characters) plus the terminating NULL.  Returns length of string (as would be returned by strlen()), or -1 on any error.</p> </li> </ul>"},{"location":"man/ici/sdrstring/#see-also","title":"SEE ALSO","text":"<p>sdr(3), sdrlist(3), sdrtable(3), string(3)</p>"},{"location":"man/ici/sdrtable/","title":"NAME","text":"<p>sdrtable - Simple Data Recorder table management functions</p>"},{"location":"man/ici/sdrtable/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"sdr.h\"\n\nObject  sdr_table_create        (Sdr sdr, int rowSize, int rowCount);\nint     sdr_table_user_data_set (Sdr sdr, Object table, Address userData);\nAddress sdr_table_user_data     (Sdr sdr, Object table);\nint     sdr_table_dimensions    (Sdr sdr, Object table, int *rowSize, \n                                    int *rowCount);\nint     sdr_table_stage         (Sdr sdr, Object table);\nAddress sdr_table_row           (Sdr sdr, Object table, \n                                    unsigned int rowNbr);\nint     sdr_table_destroy       (Sdr sdr, Object table);\n</code></pre>"},{"location":"man/ici/sdrtable/#description","title":"DESCRIPTION","text":"<p>The SDR table functions manage table objects in the SDR.  An SDR table comprises N rows of M bytes each, plus optionally one word of user data (which is nominally the address of some other object in the SDR's heap space).  When a table is created, the number of rows in the table and the length of each row are specified; they remain fixed for the life of the table.  The table functions merely maintain information about the table structure and its location in the SDR and calculate row addresses; other SDR functions such as sdr_read() and sdr_write() are used to read and write the contents of the table's rows.  In particular, the format of the rows of a table is left entirely up to the user.</p> <ul> <li> <p>Object sdr_table_create(Sdr sdr, int rowSize, int rowCount)</p> <p>Creates a \"self-delimited table\", comprising rowCount rows of rowSize bytes each, in the heap space of the indicated SDR.  Note that the content of the table, a two-dimensional array, is a single SDR heap space object of size (rowCount x rowSize).  Returns the address of the new table on success, zero on any error.</p> </li> <li> <p>void sdr_table_user_data_set(Sdr sdr, Object table, Address userData)</p> <p>Sets the \"user data\" word of table to userData.  Note that userData is nominally an Address but can in fact be any value that occupies a single word.  It is typically used to point to an SDR object that somehow characterizes the table as a whole, such as an SDR string containing a name.</p> </li> <li> <p>Address sdr_table_user_data(Sdr sdr, Object table)</p> <p>Returns the value of the \"user data\" word of table, or zero on any error.</p> </li> <li> <p>void sdr_table_dimensions(Sdr sdr, Object table, int *rowSize, int *rowCount)</p> <p>Reports on the row size and row count of the indicated table, as specified when the table was created.</p> </li> <li> <p>void sdr_table_stage(Sdr sdr, Object table)</p> <p>Stages table so that the array it encapsulates may be updated; see the discussion of sdr_stage() in sdr(3).  The effect of this function is the same as: </p> <pre><code>sdr_stage(sdr, NULL, (Object) sdr_table_row(sdr, table, 0), 0)\n</code></pre> </li> <li> <p>Address sdr_table_row(Sdr sdr, Object table, unsigned int rowNbr)</p> <p>Returns the address of the rowNbr_th row of _table, for use in reading or writing the content of this row; returns -1 on any error.</p> </li> <li> <p>void sdr_table_destroy(Sdr sdr, Object table)</p> <p>Destroys table, releasing all bytes of all rows and destroying the table structure itself.  DO NOT use sdr_free() to destroy a table, as this would leave the table's content allocated yet unreferenced.</p> </li> </ul>"},{"location":"man/ici/sdrtable/#see-also","title":"SEE ALSO","text":"<p>sdr(3), sdrlist(3), sdrstring(3)</p>"},{"location":"man/ici/sdrwatch/","title":"NAME","text":"<p>sdrwatch - SDR non-volatile data store activity monitor</p>"},{"location":"man/ici/sdrwatch/#synopsis","title":"SYNOPSIS","text":"<p>sdrwatch sdr_name [ -t | -s | -r | -z ] [interval [count [ verbose ]]]</p>"},{"location":"man/ici/sdrwatch/#description","title":"DESCRIPTION","text":"<p>For count interations (defaulting to 1), sdrwatch sleeps interval seconds and then performs the SDR operation indicated by the specified mode: 's' to print statistics, 'r' to reset statistics, 'z' to print ZCO space utilization, 't' (the default) to call the sdr_print_trace() function (see sdr(3)) to report on SDR data storage management activity in the SDR data store identified by sdr_name during that interval.  If the optional verbose parameter is specified, the printed SDR activity trace will be verbose as described in sdr(3).</p> <p>If interval is zero, sdrwatch just performs the indicated operation once (for 't', it merely prints a current usage summary for the indicated data store) and terminates.</p> <p>sdrwatch is helpful for detecting and diagnosing storage space leaks.  For debugging the ION protocol stack, sdr_name is normally \"ion\" but might be overridden by the value of sdrName in the .ionconfig file used to configure the node under study.</p>"},{"location":"man/ici/sdrwatch/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>sdrwatch has terminated.</p> </li> </ul>"},{"location":"man/ici/sdrwatch/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/sdrwatch/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/sdrwatch/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>Can't attach to sdr.</p> <p>ION system error.  One possible cause is that ION has not yet been initialized on the local computer; run ionadmin(1) to correct this.</p> </li> <li> <p>Can't start trace.</p> <p>Insufficient ION working memory to contain trace information.  Reinitialize ION with more memory.</p> </li> </ul>"},{"location":"man/ici/sdrwatch/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/sdrwatch/#see-also","title":"SEE ALSO","text":"<p>sdr(3), psmwatch(1)</p>"},{"location":"man/ici/sm2file/","title":"NAME","text":"<p>sm2file - shared-memory linked list data extraction test program</p>"},{"location":"man/ici/sm2file/#synopsis","title":"SYNOPSIS","text":"<p>sm2file</p>"},{"location":"man/ici/sm2file/#description","title":"DESCRIPTION","text":"<p>sm2file stress-tests shared-memory linked list data extraction by retrieving and deleting all text file lines inserted into a shared-memory linked list that is the root object of a PSM partition named \"file2sm\".</p> <p>The operation of sm2file echoes the cyclical operation of file2sm: the EOF lines inserted into the linked list by file2sm punctuate the writing of files that are copies of file2sm's original source text file. The name of each file written by sm2file is file_copy_cycleNbr, where cycleNbr is, in effect, the count of EOF lines encountered in the linked list up to the point at which the writing of this file began.</p> <p>sm2file may catch up with the data ingestion activity of file2sm, in which case it blocks (taking the file2sm test semaphore) until the linked list is no longer empty.</p>"},{"location":"man/ici/sm2file/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>sm2file has terminated.</p> </li> </ul>"},{"location":"man/ici/sm2file/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/sm2file/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/sm2file/#diagnostics","title":"DIAGNOSTICS","text":"<ul> <li> <p>can't attach to shared memory</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Can't manage shared memory.</p> <p>PSM error.  Check for earlier diagnostics describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create shared memory list.</p> <p>PSM error.  Check for earlier diagnostics describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't create semaphore.</p> <p>ION system error.  Check for earlier diagnostics describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>Can't open output file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>can't write to output file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> </ul>"},{"location":"man/ici/sm2file/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/sm2file/#see-also","title":"SEE ALSO","text":"<p>file2sm(1), smlist(3), psm(3)</p>"},{"location":"man/ici/smlist/","title":"NAME","text":"<p>smlist - shared memory list management library</p>"},{"location":"man/ici/smlist/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"smlist.h\"\n\ntypedef int (*SmListCompareFn)\n    (PsmPartition partition, PsmAddress eltData, void *argData);\ntypedef void (*SmListDeleteFn)\n    (PsmPartition partition, PsmAddress elt, void *argument);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/smlist/#description","title":"DESCRIPTION","text":"<p>The smlist library provides functions to create, manipulate and destroy doubly-linked lists in shared memory.  As with lyst(3),  smlist uses two types of objects, list objects and element objects.  However, as these objects are stored in shared memory which is managed by psm(3), pointers to these objects are carried as PsmAddress values.  A list knows how many elements it contains and what its first and last elements are. An element knows what list it belongs to and the elements before and after it in its list.  An element also knows its content, which is normally the PsmAddress of some object in shared memory.</p> <ul> <li> <p>PsmAddress sm_list_create(PsmPartition partition)</p> <p>Create a new list object without any elements in it, within the memory segment identified by partition.  Returns the PsmAddress of the list, or 0 on any error.</p> </li> <li> <p>void sm_list_unwedge(PsmPartition partition, PsmAddress list, int interval)</p> <p>Unwedge, as necessary, the mutex semaphore protecting shared access to the indicated list.  For details, see the explanation of the sm_SemUnwedge() function in platform(3).</p> </li> <li> <p>int sm_list_clear(PsmPartition partition, PsmAddress list, SmListDeleteFn delete, void *argument);</p> <p>Empty a list.  Frees each element of the list.  If the delete function  is non-NULL, that function is called once for each freed element; when called, that function is passed the PsmAddress of the list element and the argument pointer passed to sm_list_clear().  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int sm_list_destroy(PsmPartition partition, PsmAddress list, SmListDeleteFn delete, void *argument);</p> <p>Destroy a list.  Same as sm_list_clear(), but additionally frees the list structure itself.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>int sm_list_user_data_set(PsmPartition partition, PsmAddress list, PsmAddress userData);</p> <p>Set the value of a user data variable associated with the list as a whole. This value may be used for any purpose; it is typically used to store the PsmAddress of a shared memory block containing data (e.g., state data) which the user wishes to associate with the list.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>PsmAddress sm_list_user_data(PsmPartition partition, PsmAddress list);</p> <p>Return the value of the user data variable associated with the list as a whole, or 0 on any error.</p> </li> <li> <p>int sm_list_length(PsmPartition partition, PsmAddress list);</p> <p>Return the number of elements in the list.</p> </li> <li> <p>PsmAddress sm_list_insert(PsmPartition partition, PsmAddress list, PsmAddress data, SmListCompareFn compare, void *dataBuffer);</p> <p>Create a new list element whose data value is data and insert it into the given list.  If the compare function is NULL, the new list element is simply appended to the list; otherwise, the new list element is inserted after the last element in the list whose data value is \"less than or equal to\" the data value of the new element (in dataBuffer) according to the collating sequence established by compare.  Returns the PsmAddress of the new element, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_list_insert_first(PsmPartition partition, PsmAddress list, PsmAddress data);</p> </li> <li> <p>PsmAddress sm_list_insert_last(PsmPartition partition, PsmAddress list, PsmAddress data);</p> <p>Create a new list element and insert it at the start/end of a list.  Returns the PsmAddress of the new element on success, or 0 on any error.  Disregards any established sort order in the list.</p> </li> <li> <p>PsmAddress sm_list_insert_before(PsmPartition partition, PsmAddress elt, PsmAddress data);</p> </li> <li> <p>PsmAddress sm_list_insert_after(PsmPartition partition, PsmAddress elt, PsmAddress data);</p> <p>Create a new list element and insert it before/after a given element. Returns the PsmAddress of the new element on success, or 0 on any error.  Disregards any established sort order in the list.</p> </li> <li> <p>int sm_list_delete(PsmPartition partition, PsmAddress elt, SmListDeleteFn delete, void *argument);</p> <p>Delete an element from a list.  If the delete function is non-NULL, that function is called upon deletion of elt; when called, that function is passed the PsmAddress of the list element and the argument pointer passed to sm_list_delete().  Returns 0 on success, -1 on any error.</p> </li> <li> <p>PsmAddress sm_list_first(PsmPartition partition, PsmAddress list);</p> </li> <li> <p>PsmAddress sm_list_last(PsmPartition partition, PsmAddress list);</p> <p>Return the PsmAddress of the first/last element in list, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_list_next(PsmPartition partition, PsmAddress elt);</p> </li> <li> <p>PsmAddress sm_list_prev(PsmPartition partition, PsmAddress elt);</p> <p>Return the PsmAddress of the element following/preceding elt in that element's list, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_list_search(PsmPartition partition, PsmAddress elt, SmListCompareFn compare, void *dataBuffer);</p> <p>Search a list for an element whose data matches the data in dataBuffer.  If the compare function is non-NULL, the list is assumed to be sorted in the order implied by that function and the function is automatically called once for each element of the list until it returns a value that is greater than or equal to zero (where zero indicates an exact match and a value greater than zero indicates that the list contains no matching element); each time compare is called it is passed the PsmAddress that is the element's data value and the dataBuffer value passed to sm_list_search(). If compare is NULL, then the entire list is searched until an element is located whose data value is equal to ((PsmAddress) dataBuffer). Returns the PsmAddress of the matching element if one is found, 0 otherwise.</p> </li> <li> <p>PsmAddress sm_list_list(PsmPartition partition, PsmAddress elt);</p> <p>Return the PsmAddress of the list to which elt belongs, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_list_data(PsmPartition partition, PsmAddress elt);</p> <p>Return the PsmAddress that is the data value for elt, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_list_data_set(PsmPartition partition, PsmAddress elt, PsmAddress data);</p> <p>Set the data value for elt to data, replacing the original value.  Returns the original data value for elt, or 0 on any error.  The original data value for elt may or may not have been the address of an object in memory; even if it was, that object was NOT deleted.  </p> <p>Warning: changing the data value of an element of an ordered list may ruin the ordering of the list.</p> </li> </ul>"},{"location":"man/ici/smlist/#usage","title":"USAGE","text":"<p>A user normally creates an element and adds it to a list by doing the following:</p> <ul> <li> <p><code>1</code></p> <p>obtaining a shared memory block to contain the element's data;</p> </li> <li> <p><code>2</code></p> <p>converting the shared memory block's PsmAddress to a character pointer;</p> </li> <li> <p><code>3</code></p> <p>using that pointer to write the data into the shared memory block;</p> </li> <li> <p><code>4</code></p> <p>calling one of the sm_list_insert functions to create the element  structure (which will include the shared memory block's PsmAddress)  and insert it into the list.</p> </li> </ul> <p>When inserting elements or searching a list, the user may optionally provide a compare function of the form:</p> <pre><code>int user_comp_name(PsmPartition partition, PsmAddress eltData, \n                   void *dataBuffer);\n</code></pre> <p>When provided, this function is automatically called by the smlist function being invoked; when the function is called it is passed the content of a list element (eltData, nominally the PsmAddress of an item in shared memory) and an argument, dataBuffer, which is nominally the address in local memory of some other item in the same format. The user-supplied function normally compares some key values of the two data items and returns 0 if they are equal, an integer less than 0 if eltData's key value is less than that of dataBuffer, and an integer greater than 0 if eltData's key value is greater than that of dataBuffer.  These return values will produce a list in ascending order. If the user desires the list to be in descending order, the function must reverse the signs of these return values.</p> <p>When deleting an element or destroying a list, the user may optionally provide a delete function of the form:</p> <pre><code>void user_delete_name(PsmPartition partition, PsmAddress elt, void *argData)\n</code></pre> <p>When provided, this function is automatically called by the smlist function being invoked; when the function is called it is passed the address of a list element (elt and an argument, argData, which if non-NULL is normally the address in local memory of a data item providing context for the list element deletion. The user-supplied function performs any application-specific cleanup associated with deleting the element, such as freeing the element's content data item and/or other memory associated with the element.</p>"},{"location":"man/ici/smlist/#example","title":"EXAMPLE","text":"<p>For an example of the use of smlist, see the file smlistsh.c in the utils directory of ICI.</p>"},{"location":"man/ici/smlist/#see-also","title":"SEE ALSO","text":"<p>lyst(3), platform(3), psm(3)</p>"},{"location":"man/ici/smlistsh/","title":"NAME","text":"<p>smlistsh - shared-memory linked list test shell</p>"},{"location":"man/ici/smlistsh/#synopsis","title":"SYNOPSIS","text":"<p>smlistsh partition_size</p>"},{"location":"man/ici/smlistsh/#description","title":"DESCRIPTION","text":"<p>smlistsh attaches to a region of system memory (allocating it if necessary, and placing it under PSM management as necessary) and offers the user an interactive \"shell\" for testing various shared-memory linked list management functions.</p> <p>smlistsh prints a prompt string (\": \") to stdout, accepts a command from  stdin, executes the command (possibly printing a diagnostic message),  then prints another prompt string and so on.</p> <p>The following commands are supported:</p> <ul> <li> <p>h</p> <p>The help command.  Causes smlistsh to print a summary of available commands.  Same effect as the ? command.</p> </li> <li> <p>?</p> <p>Another help command.  Causes smlistsh to print a summary of available commands.  Same effect as the h command.</p> </li> <li> <p>k</p> <p>The key command.  Computes and prints an unused shared-memory key, for possible use in attaching to a shared-memory region.</p> </li> <li> <p>+ key_value size</p> <p>The attach command.  Attaches smlistsh to a region of shared memory. key_value identifies an existing shared-memory region, in the event that you want to attach to an existing shared-memory region (possibly created by another smlistsh process running on the same computer).  To create and attach to a new shared-memory region that other processes can attach to, use a key_value as returned by the key command and supply the size of the new region.  If you want to create and attach to a new shared-memory region that is for strictly private use, use -1 as key and supply the size of the new region.</p> </li> <li> <p>-</p> <p>The detach command.  Detaches smlistsh from the region of shared memory it is currently using, but does not free any memory.</p> </li> <li> <p>n</p> <p>The new command.  Creates a new shared-memory list to operate on, within the currently attached shared-memory region.  Prints the address of the list.</p> </li> <li> <p>s list_address</p> <p>The share command.  Selects an existing shared-memory list to operate on, within the currently attached shared-memory region.</p> </li> <li> <p>a element_value</p> <p>The append command.  Appends a new list element, containing element_value, to the list on which smlistsh is currently operating.</p> </li> <li> <p>p element_value</p> <p>The prepend command.  Prepends a new list element, containing element_value, to the list on which smlistsh is currently operating.</p> </li> <li> <p>w</p> <p>The walk command.  Prints the addresses and contents of all elements of the list on which smlistsh is currently operating.</p> </li> <li> <p>f element_value</p> <p>The find command.  Finds the list element that contains element_value, within the list on which smlistsh is currently operating, and prints the address of that list element.</p> </li> <li> <p>d element_address</p> <p>The delete command.  Deletes the list element located at element_address.</p> </li> <li> <p>r</p> <p>The report command.  Prints a partition usage report, as per psm_report(3).</p> </li> <li> <p>q</p> <p>The quit command.  Detaches smlistsh from the region of shared memory it is currently using (without freeing any memory) and terminates smlistsh.</p> </li> </ul>"},{"location":"man/ici/smlistsh/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>smlistsh has terminated.</p> </li> </ul>"},{"location":"man/ici/smlistsh/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/smlistsh/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/smlistsh/#diagnostics","title":"DIAGNOSTICS","text":"<p>No diagnostics apply.</p>"},{"location":"man/ici/smlistsh/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/smlistsh/#see-also","title":"SEE ALSO","text":"<p>smlist(3)</p>"},{"location":"man/ici/smrbt/","title":"NAME","text":"<p>smrbt - shared-memory red-black tree management library</p>"},{"location":"man/ici/smrbt/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"smrbt.h\"\n\ntypedef int (*SmRbtCompareFn)\n    (PsmPartition partition, PsmAddress nodeData, void *dataBuffer);\ntypedef void (*SmRbtDeleteFn)\n    (PsmPartition partition, PsmAddress nodeData, void *argument);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/smrbt/#description","title":"DESCRIPTION","text":"<p>The smrbt library provides functions to create, manipulate and destroy \"red-black\" balanced binary trees in shared memory. smrbt uses two types of objects, rbt objects and node objects; as these objects are stored in shared memory which is managed by psm(3), pointers to these objects are carried as PsmAddress values.  An rbt knows how many nodes it contains and what its root node is. An node knows what rbt it belongs to and which nodes are its parent and (up to 2) children. A node also knows its content, which is normally the PsmAddress of some object in shared memory.</p> <ul> <li> <p>PsmAddress sm_rbt_create(PsmPartition partition)</p> <p>Create a new rbt object without any nodes in it, within the memory segment identified by partition.  Returns the PsmAddress of the rbt, or 0 on any error.</p> </li> <li> <p>void sm_rbt_unwedge(PsmPartition partition, PsmAddress rbt, int interval)</p> <p>Unwedge, as necessary, the mutex semaphore protecting shared access to the indicated rbt.  For details, see the explanation of the sm_SemUnwedge() function in platform(3).</p> </li> <li> <p>int sm_rbt_clear(PsmPartition partition, PsmAddress rbt, SmRbtDeleteFn delete, void *argument);</p> <p>Frees every node of the rbt, leaving the rbt empty.  If the delete function  is non-NULL, that function is called once for each freed node; when called, that function is passed the PsmAddress that is the node's data and the argument pointer passed to sm_rbt_clear().  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void sm_rbt_destroy(PsmPartition partition, PsmAddress rbt, SmRbtDeleteFn delete, void *argument);</p> <p>Destroy an rbt.  Frees all nodes of the rbt as in sm_rbt_clear(), then frees the rbt structure itself.</p> </li> <li> <p>int sm_rbt_user_data_set(PsmPartition partition, PsmAddress rbt, PsmAddress userData);</p> <p>Set the value of a user data variable associated with the rbt as a whole. This value may be used for any purpose; it is typically used to store the PsmAddress of a shared memory block containing data (e.g., state data) which the user wishes to associate with the rbt.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>PsmAddress sm_rbt_user_data(PsmPartition partition, PsmAddress rbt);</p> <p>Return the value of the user data variable associated with the rbt as a whole, or 0 on any error.</p> </li> <li> <p>int sm_rbt_length(PsmPartition partition, PsmAddress rbt);</p> <p>Return the number of nodes in the rbt.</p> </li> <li> <p>PsmAddress sm_rbt_insert(PsmPartition partition, PsmAddress rbt, PsmAddress data, SmRbtCompareFn compare, void *dataBuffer);</p> <p>Create a new rbt node whose data value is data and insert it into rbt.  The nodes of an rbt are ordered by their notional \"key\" values; for this purpose, no two nodes may have the same key value.  The key value of a node is assumed to be some function of the content of dataBuffer, which is assumed to be a representation in memory of the data value indicated by data, and that function must be implicit in the compare function, which must not be NULL.  The new rbt node is inserted into the rbt in a tree location that preserves order in the tree, according to the collating sequence established by compare, and also ensures that no path (from root to leaf) in the tree is more than twice as long as any other path.  This makes searching the tree for a given data value quite rapid even if the number of nodes in the tree is very large.  Returns the PsmAddress of the new node, or 0 on any error.</p> </li> <li> <p>void sm_rbt_delete(PsmPartition partition, PsmAddress rbt, SmRbtCompareFn compare, void *dataBuffer, SmRbtDeleteFn delete, void *argument);</p> <p>Delete a node from rbt.  compare must be the same function that was used to insert the node: the tree must be dynamically re-balanced upon node deletion, and the compare function and the data value of the node that is to be deleted (as represented in memory in dataBuffer) are required for this purpose.  (Since the function descends the tree in search of the matching node anyway, in order to preserve balance, the address of the node itself is not needed.)</p> <p>If the delete function is non-NULL, that function is called upon deletion of the indicated node.  When called, that function is passed the PsmAddress that is the node's data value and the argument pointer passed to sm_rbt_delete().</p> <p>NOTE that this function does something highly devious to avoid extra tree-balancing complexity when node is deleted.  For details, see the code, but the main point is that deleting a node WILL MOVE NODES WITHIN THE TREE. After the deletion, the next node may not be the one that would have been reported if you passed the to-be-deleted node to sm_rbt_next() before calling sm_rbt_delete().  This is important: do not apply updates (no insertions, and especially no deletions) while you are traversing a red-black tree sequentially.  If you do, the result will not be what you expect.</p> </li> <li> <p>PsmAddress sm_rbt_first(PsmPartition partition, PsmAddress rbt);</p> </li> <li> <p>PsmAddress sm_rbt_last(PsmPartition partition, PsmAddress rbt);</p> <p>Return the PsmAddress of the first/last node in rbt, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_rbt_next(PsmPartition partition, PsmAddress node);</p> </li> <li> <p>PsmAddress sm_rbt_prev(PsmPartition partition, PsmAddress node);</p> <p>Return the PsmAddress of the node following/preceding node in that node's rbt, or 0 on any error.</p> <p>NOTE that the red-black tree node insertion and deletion functions  WILL MOVE NODES WITHIN THE TREE. This is important: do not apply updates (no insertions, and especially no deletions) while you are traversing a red-black tree sequentially, using sm_rbt_next() or sm_rbt_prev().  If you do, the result will not be what you expect.</p> </li> <li> <p>PsmAddress sm_rbt_search(PsmPartition partition, PsmAddress rbt, SmRbtCompareFn compare, void *dataBuffer, PsmAddress *successor);</p> <p>Search rbt for a node whose data matches the data in dataBuffer. compare must be the same function that was used to insert all nodes into the tree.  The tree is searched until a node is found whose data value is \"equal\" (according to compare) to the data value represented in memory in dataBuffer, or until it is known that there is no such node in the tree.  If the matching node is found, the PsmAddress of that node is returned and *successor is set to zero.  Otherwise, zero is returned and *successor is set to the PsmAddress of the first node in the tree whose key value is greater than the key value of dataBuffer, according to compare, or to zero if there is no such successor node.</p> </li> <li> <p>PsmAddress sm_rbt_rbt(PsmPartition partition, PsmAddress node);</p> <p>Return the PsmAddress of the rbt to which node belongs, or 0 on any error.</p> </li> <li> <p>PsmAddress sm_rbt_data(PsmPartition partition, PsmAddress node);</p> <p>Return the PsmAddress that is the data value for node, or 0 on any error.</p> </li> </ul>"},{"location":"man/ici/smrbt/#usage","title":"USAGE","text":"<p>A user normally creates an node and adds it to a rbt by doing the following:</p> <ul> <li> <p><code>1</code></p> <p>obtaining a shared memory block to contain the node's data;</p> </li> <li> <p><code>2</code></p> <p>converting the shared memory block's PsmAddress to a character pointer;</p> </li> <li> <p><code>3</code></p> <p>using that pointer to write the data into the shared memory block;</p> </li> <li> <p><code>4</code></p> <p>calling the sm_rbt_insert function to create the node structure (which will include the shared memory block's PsmAddress) and insert it into the rbt.</p> </li> </ul> <p>When inserting or deleting nodes or searching a rbt, the user must provide a compare function of the form:</p> <pre><code>int user_comp_name(PsmPartition partition, PsmAddress node, \n                   void *dataBuffer);\n</code></pre> <p>This function is automatically called by the smrbt function being invoked; when the function is called it is passed the data content of an rbt node (node, nominally the PsmAddress of an item in shared memory) and an argument, dataBuffer, which is nominally the address in local memory of some other data item in the same format.  The user-supplied function normally compares some key values of the two data items and returns 0 if they are equal, an integer less than 0 if node's key value is less than that of dataBuffer, and an integer greater than 0 if node's key value is greater than that of dataBuffer.  These return values will produce an rbt in ascending order.  </p> <p>When deleting an node or destroying a rbt, the user may optionally provide a delete function of the form:</p> <pre><code>void user_delete_name(PsmPartition partition, PsmAddress node, \n                      void *argData)\n</code></pre> <p>When provided, this function is automatically called by the smrbt function being invoked; when the function is called it is passed the content of a rbt node (node, nominally the PsmAddress of an item in shared memory) and an argument, argData, which if non-NULL is normally the address in local memory of a data item providing context for the rbt node deletion. The user-supplied function performs any application-specific cleanup associated with deleting the node, such as freeing the node's content data item and/or other memory associated with the node.</p>"},{"location":"man/ici/smrbt/#example","title":"EXAMPLE","text":"<p>For an example of the use of smrbt, see the file smrbtsh.c in the utils directory of ICI.</p>"},{"location":"man/ici/smrbt/#see-also","title":"SEE ALSO","text":"<p>smrbtsh(1), platform(3), psm(3)</p>"},{"location":"man/ici/smrbtsh/","title":"NAME","text":"<p>smrbtsh - shared-memory red-black tree test shell</p>"},{"location":"man/ici/smrbtsh/#synopsis","title":"SYNOPSIS","text":"<p>smrbtsh [command_file_name]</p>"},{"location":"man/ici/smrbtsh/#description","title":"DESCRIPTION","text":"<p>smrbtsh allocates a region of shared system memory, attaches to that region, places it under PSM management, creates a temporary \"test\" red-black tree in that memory region, and executes a series of shared-memory red-black tree commands that exercise various tree access and management functions.</p> <p>If command_file_name is provided, then the commands in the indicated file are executed and the program then terminates.  Upon termination, the shared memory region allocated to smrbtsh is detached and destroyed.</p> <p>Otherwise, smrbtsh offers the user an interactive \"shell\" for testing the smrbt functions in a conversational manner: smrbtsh prints a prompt string (\": \") to stdout, accepts a command from stdin, executes the command (possibly printing a diagnostic message), then prints another prompt string and so on. Upon execution of the 'q' command, the program terminates.</p> <p>The following commands are supported:</p> <ul> <li> <p>h</p> <p>The help command.  Causes smrbtsh to print a summary of available commands.  Same effect as the ? command.</p> </li> <li> <p>?</p> <p>Another help command.  Causes smrbtsh to print a summary of available commands.  Same effect as the h command.</p> </li> <li> <p>s [seed_value]</p> <p>The seed command.  Seeds random data value generator, which is used to generate node values when the r command is used.  If seed_value is omitted, uses current time (as returned by time(1)) as seed value.</p> </li> <li> <p>r [count]</p> <p>The random command.  Inserts count new nodes into the red-black tree, using randomly selected unsigned long integers as the data values of the nodes; count defaults to 1 if omitted.</p> </li> <li> <p>i data_value</p> <p>The insert command.  Inserts a single new node into the red-black tree, using data_value as the data value of the node.</p> </li> <li> <p>f data_value</p> <p>The find command.  Finds the rbt node whose value is data_value, within the red-black tree, and prints the address of that node.  If the  node is not found, prints address zero and prints the address of the successor node in the tree.</p> </li> <li> <p>d data_value</p> <p>The delete command.  Deletes the rbt node whose data value is data_value.</p> </li> <li> <p>p</p> <p>The print command.  Prints the red-black tree, using indentation to indicate descent along paths of the tree.</p> <p>Note: this function is supported only if the smrbt library was built with compilation flag -DSMRBT_DEBUG=1.</p> </li> <li> <p>k</p> <p>The check command.  Examines the red-black tree, noting the first violation of red-black structure rules, if any.</p> <p>Note: this function is supported only if the smrbt library was built with compilation flag -DSMRBT_DEBUG=1.</p> </li> <li> <p>l</p> <p>The list command.  Lists all nodes in the red-black tree in traversal order, noting any nodes whose data values are not in ascending numerical order.</p> </li> <li> <p>q</p> <p>The quit command.  Detaches smrbtsh from the region of shared memory it is currently using, destroys that shared memory region, and terminates smrbtsh.</p> </li> </ul>"},{"location":"man/ici/smrbtsh/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>smrbtsh has terminated.</p> </li> </ul>"},{"location":"man/ici/smrbtsh/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ici/smrbtsh/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ici/smrbtsh/#diagnostics","title":"DIAGNOSTICS","text":"<p>No diagnostics apply.</p>"},{"location":"man/ici/smrbtsh/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ici/smrbtsh/#see-also","title":"SEE ALSO","text":"<p>smrbt(3)</p>"},{"location":"man/ici/zco/","title":"NAME","text":"<p>zco - library for manipulating zero-copy objects</p>"},{"location":"man/ici/zco/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"zco.h\"\n\ntypedef enum\n{\n    ZcoInbound = 0,\n    ZcoOutbound = 1,\n    ZcoUnknown = 2\n} ZcoAcct;\n\ntypedef enum\n{\n    ZcoFileSource = 1,\n    ZcoBulkSource = 2,\n    ZcoObjSource = 3,\n    ZcoSdrSource = 4,\n    ZcoZcoSource = 5\n} ZcoMedium;\n\ntypedef void (*ZcoCallback)(ZcoAcct);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ici/zco/#description","title":"DESCRIPTION","text":"<p>\"Zero-copy objects\" (ZCOs) are abstract data access representations designed to minimize I/O in the encapsulation of application source data within one or more layers of communication protocol structure.  ZCOs are constructed within the heap space of an SDR to which implementations of all layers of the stack must have access.  Each ZCO contains information enabling access to the source data objects, together with (a) a linked list of zero or more \"extents\" that reference portions of these source data objects and (b) linked lists of protocol header and trailer capsules that have been explicitly attached to the ZCO since its creation.  The concatenation of the headers (in ascending stack sequence), source data object extents, and trailers (in descending stack sequence) is what is to be transmitted or has been received.</p> <p>Each source data object may be either a file (identified by pathname stored in a \"file reference\" object in SDR heap) or an item in mass storage (identified by item number, with implementation-specific semantics, stored in a \"bulk reference\" object in SDR heap) or an object in SDR heap space (identified by heap address stored in an \"object reference\" object in SDR heap) or an array of bytes in SDR heap space (identified by heap address).  Each protocol header or trailer capsule indicates the length and the address (within SDR heap space) of a single protocol header or trailer at some layer of the stack.  Note that the source data object for each ZCO extent is specified indirectly, by reference to a content lien reference structure that refers to a heap space object, mass storage item, or file; the reference structures contain the actual locations of the source data together with reference counts, enabling any number of \"clones\" of a given ZCO extent to be constructed without consuming additional resources. These reference counts ensure that the reference structures and the source data items they refer to are deleted automatically when (and only when) all ZCO extents that reference them have been deleted.</p> <p>Note that the safety of shared access to a ZCO is protected by the fact that the ZCO resides in SDR heap space and therefore cannot be modified other than in the course of an SDR transaction, which serializes access.  Moreover, extraction of data from a ZCO may entail the reading of file-based source data extents, which may cause file progress to be updated in one or more file reference objects in the SDR heap.  For this reason, all ZCO \"transmit\" and \"receive\" functions must be performed within SDR transactions.</p> <p>Note also that ZCO can more broadly be used as a general-purpose reference counting system for non-volatile data objects, where a need for such a system is identified.</p> <p>The total volume of file system space, mass storage space, and SDR heap space that may be occupied by inbound and (separately) outbound ZCO extents are system configuration parameters that may be set by ZCO library functions.  Those limits are enforced when extents are appended to ZCOs: total inbound and outbound ZCO file space, mass storage, and SDR heap occupancy are updated continuously as ZCOs are created and destroyed, and the formation of a new extent is prohibited when the length of the extent exceeds the difference between the applicable limit and the corresponding current occupancy total.  Doing separate accounting for inbound and outbound ZCOs enables inbound ZCOs to be formed (for data reception purposes) even when the total current volume of outbound ZCOs has reached its limit, and vice versa.</p> <ul> <li> <p>void zco_register_callback(ZcoCallback notify)</p> <p>This function registers the \"callback\" function that the ZCO system will invoke every time a ZCO is destroyed, making ZCO file, bulk, and/or heap space available for the formation of new ZCO extents.  This mechanism can be used, for example, to notify tasks that are waiting for ZCO space to be made available so that they can resume some communication protocol procedure.</p> </li> <li> <p>void zco_unregister_callback( )</p> <p>This function simply unregisters the currently registered callback function for ZCO destruction.</p> </li> <li> <p>Object zco_create_file_ref(Sdr sdr, char *pathName, char *cleanupScript, ZcoAcct acct)</p> <p>Creates and returns a new file reference object, which can be used as the source data extent location for creating a ZCO whose source data object is the file identified by pathName.  cleanupScript, if not NULL, is invoked at the moment the last ZCO that cites this file reference is destroyed [normally upon delivery either down to the \"ZCO transition layer\" of the protocol stack or up to a ZCO-capable application].  A zero-length string is interpreted as implicit direction to delete the referenced file when the file reference object is destroyed.  Maximum length of cleanupScript is 255.  acct must be ZcoInbound or ZcoOutbound, depending on whether the first ZCO that will reference this object will be inbound or outbound. Returns SDR location of file reference object on success, 0 on any error.</p> </li> <li> <p>Object zco_revise_file_ref(Sdr sdr, Object fileRef, char *pathName, char *cleanupScript)</p> <p>Changes the pathName and cleanupScript of the indicated file reference.  The new values of these fields are validated as for zco_create_file_ref().  Returns 0 on success, -1 on any error.</p> </li> <li> <p>char *zco_file_ref_path(Sdr sdr, Object fileRef, char *buffer, int buflen)</p> <p>Retrieves the pathName associated with fileRef and stores it in buffer, truncating it to fit (as indicated by buflen) and NULL-terminating it.  On success, returns buffer; returns NULL on any error.</p> </li> <li> <p>int zco_file_ref_xmit_eof(Sdr sdr, Object fileRef)</p> <p>Returns 1 if the last octet of the referenced file (as determined at the time the file reference object was created) has been read by ZCO via a reader with file offset tracking turned on.  Otherwise returns zero.</p> </li> <li> <p>void zco_destroy_file_ref(Sdr sdr, Object fileRef)</p> <p>If the file reference object residing at location fileRef within the indicated Sdr is no longer in use (no longer referenced by any ZCO), destroys this file reference object immediately.  Otherwise, flags this file reference object for destruction as soon as the last reference to it is removed.</p> </li> <li> <p>Object zco_create_bulk_ref(Sdr sdr, unsigned long item, vast length, ZcoAcct acct)</p> <p>Creates and returns a new bulk reference object, which can be used as the source data extent location for creating a ZCO whose source data object is the mass storage item of length length identified by item (the semantics of which are implementation-dependent).  Note that the referenced item is automatically destroyed at the time that the last ZCO that cites this bulk reference is destroyed (normally upon delivery either down to the \"ZCO transition layer\" of the protocol stack or up to a ZCO-capable application). acct must be ZcoInbound or ZcoOutbound, depending on whether the first ZCO that will reference this object will be inbound or outbound.  Returns SDR location of bulk reference object on success, 0 on any error.</p> </li> <li> <p>void zco_destroy_bulk_ref(Sdr sdr, Object bulkRef)</p> <p>If the bulk reference object residing at location bulkRef within the indicated Sdr is no longer in use (no longer referenced by any ZCO), destroys this bulk reference object immediately.  Otherwise, flags this bulk reference object for destruction as soon as the last reference to it is removed.</p> </li> <li> <p>Object zco_create_obj_ref(Sdr sdr, Object object, vast length, ZcoAcct acct)</p> <p>Creates and returns a new object reference object, which can be used as the source data extent location for creating a ZCO whose source data object is the SDR heap object of length length identified by object.  Note that the referenced object is automatically freed at the time that the last ZCO that cites this object reference is destroyed (normally upon delivery either down to the \"ZCO transition layer\" of the protocol stack or up to a ZCO-capable application).  acct must be ZcoInbound or ZcoOutbound, depending on whether the first ZCO that will reference this object will be inbound or outbound.  Returns SDR location of object reference object on success, 0 on any error.</p> </li> <li> <p>void zco_destroy_obj_ref(Sdr sdr, Object objRef)</p> <p>If the object reference object residing at location objRef within the indicated Sdr is no longer in use (no longer referenced by any ZCO), destroys this object reference object immediately.  Otherwise, flags this object reference object for destruction as soon as the last reference to it is removed.</p> </li> <li> <p>void zco_status(Sdr sdr)</p> <p>Uses the ION logging function to write a report of the current contents of the ZCO space accounting database.</p> </li> <li> <p>vast zco_get_file_occupancy(Sdr sdr, ZcoAcct acct)</p> <p>Returns the total number of file system space bytes occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>void zco_set_max_file_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)</p> <p>Declares the total number of file system space bytes that may be occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>vast zco_get_max_file_occupancy(Sdr sdr, ZcoAcct acct)</p> <p>Returns the total number of file system space bytes that may be occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>int zco_enough_file_space(Sdr sdr, vast length, ZcoAcct acct)</p> <p>Returns 1 if the total remaining file system space available for ZCOs (inbound or outbound) in this Sdr is greater than length.  Returns 0 otherwise.</p> </li> <li> <p>vast zco_get_bulk_occupancy(Sdr sdr, ZcoAcct acct)</p> <p>Returns the total number of mass storage space bytes occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>void zco_set_max_bulk_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)</p> <p>Declares the total number of mass storage space bytes that may be occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>vast zco_get_max_bulk_occupancy(Sdr sdr, ZcoAcct acct)</p> <p>Returns the total number of mass storage space bytes that may be occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>int zco_enough_bulk_space(Sdr sdr, vast length, ZcoAcct acct)</p> <p>Returns 1 if the total remaining mass storage space available for ZCOs (inbound or outbound) in this Sdr is greater than length.  Returns 0 otherwise.</p> </li> <li> <p>vast zco_get_heap_occupancy(Sdr sdr, ZcoAcct acct)</p> <p>Returns the total number of SDR heap space bytes occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>void zco_set_max_heap_occupancy(Sdr sdr, vast occupancy, ZcoAcct acct)</p> <p>Declares the total number of SDR heap space bytes that may be occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>vast zco_get_max_heap_occupancy(Sdr sdr, ZcoAcct acct)</p> <p>Returns the total number of SDR heap space bytes that may be occupied by ZCOs (inbound or outbound) created in this Sdr.</p> </li> <li> <p>int zco_enough_heap_space(Sdr sdr, vast length, ZcoAcct acct)</p> <p>Returns 1 if the total remaining SDR heap space available for ZCOs (inbound or outbound) in this Sdr is greater than length.  Returns 0 otherwise.</p> </li> <li> <p>int zco_extent_too_large(Sdr sdr, ZcoMedium source, vast length, ZcoAcct acct)</p> <p>Returns 1 if the total remaining space available for ZCOs (inbound or outbound) is NOT enough to contain a new extent of the indicated length in the indicated source medium.  Returns 0 otherwise.</p> </li> <li> <p>int zco_get_aggregate_length(Sdr sdr, Object location, vast offset, vast length, vast *fileSpaceOccupied, vast *bulkSpaceOccupied, vast *heapSpaceOccupied)</p> <p>Populates *fileSpaceOccupied, *bulkSpaceOccupied, and *heapSpaceOccupied with the total number of ZCO space bytes occupied by the extents of the zco at location, from offset to offset + length. If offset isn't the start of an extent or offset + length isn't the end of an extent, returns -1 in all three fields.</p> </li> <li> <p>Object zco_create(Sdr sdr, ZcoMedium firstExtentSourceMedium, Object firstExtentLocation, vast firstExtentOffset, vast firstExtentLength, ZcoAcct acct)</p> <p>Creates a new inbound or outbound ZCO.  firstExtentLocation and firstExtentLength must either both be zero (indicating that zco_append_extent() will be used to insert the first source data extent later) or else both be non-zero.  If firstExtentLocation is non-zero, then (a) firstExtentLocation must be the SDR location of a file reference object, bulk reference object, object reference object, SDR heap object, or ZCO, depending on the value of firstExtentSourceMedium, and (b) firstExtentOffset indicates how many leading bytes of the source data object should be skipped over when adding the initial source data extent to the new ZCO.  A negative value for firstExtentLength indicates that the extent is already known not to be too large for the available ZCO space, and the actual length of the extent is the additive inverse of this value.  On success, returns the SDR location of the new ZCO.  Returns 0 if there is insufficient ZCO space for creation of the new ZCO; returns ((Object) -1) on any error.</p> </li> <li> <p>int zco_append_extent(Sdr sdr, Object zco, ZcoMedium sourceMedium, Object location, vast offset, vast length)</p> <p>Appends the indicated source data extent to the indicated ZCO, as described for zco_create().  Both the location and length of the source data must be non-zero.  A negative value for length indicates that the extent is already known not to be too large for the available ZCO space, and the actual length of the extent is the additive inverse of this value.  For constraints on the value of location, see zco_create().  Returns length on success, 0 if there is insufficient ZCO space for creation of the new source data extent, -1 on any error.</p> </li> <li> <p>int zco_prepend_header(Sdr sdr, Object zco, char *header, vast length)</p> </li> <li>int zco_append_trailer(Sdr sdr, Object zco, char *trailer, vast length)</li> <li>void zco_discard_first_header(Sdr sdr, Object zco)</li> <li> <p>void zco_discard_last_trailer(Sdr sdr, Object zco)</p> <p>These functions attach and remove the ZCO's headers and trailers.  header and trailer are assumed to be arrays of octets, not necessarily text. Attaching a header or trailer causes it to be written to the SDR.  The prepend and append functions return 0 on success, -1 on any error.</p> </li> <li> <p>Object zco_header_text(Sdr sdr, Object zco, int skip, vast *length)</p> <p>Skips over the first skip headers of zco and returns the address of the text of the next header, placing the length of the header's text in *length.  Returns 0 on any error.</p> </li> <li> <p>Object zco_trailer_text(Sdr sdr, Object zco, int skip, vast *length)</p> <p>Skips over the first skip trailers of zco and returns the address of the text of the next trailer, placing the length of the trailer's text in *length.  Returns 0 on any error.</p> </li> <li> <p>void zco_destroy(Sdr sdr, Object zco)</p> <p>Destroys the indicated Zco.  This reduces the reference counts for all files and SDR objects referenced in the ZCO's extents, resulting in the freeing of SDR objects and (optionally) the deletion of files as those reference count drop to zero.</p> </li> <li> <p>void zco_bond(Sdr sdr, Object zco)</p> <p>Converts all headers and trailers of the indicated Zco to source data extents. Use this function to ensure that known header and trailer data are included when the ZCO is cloned.</p> </li> <li> <p>int zco_revise(Sdr sdr, Object zco, vast offset, char *buffer, vast length)</p> <p>Writes the contents of buffer, for length length, into zco at offset offset.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>Object zco_clone(Sdr sdr, Object zco, vast offset, vast length)</p> <p>Creates a new ZCO whose source data is a copy of a subset of the source data of the referenced ZCO.  This procedure is required whenever it is necessary to process the ZCO's source data in multiple different ways, for different purposes, and therefore the ZCO must be in multiple states at the same time.  Portions of the source data extents of the original ZCO are copied as necessary, but no header or trailer capsules are copied.  Returns SDR location of the new ZCO on success, (Object) -1 on any error.</p> </li> <li> <p>vast zco_clone_source_data(Sdr sdr, Object toZco, Object fromZco, vast offset, vast length)</p> <p>Appends to toZco a copy of a subset of the source data of fromZCO. Portions of the source data extents of fromZCO are copied as necessary. Returns total data length cloned, or -1 on any error.</p> </li> <li> <p>vast zco_length(Sdr sdr, Object zco)</p> <p>Returns length of entire ZCO, including all headers and trailers and all source data extents.  This is the size of the object that would be formed by concatenating the text of all headers, trailers, and source data extents into a single serialized object.</p> </li> <li> <p>vast zco_source_data_length(Sdr sdr, Object zco)</p> <p>Returns length of entire ZCO minus the lengths of all attached header and trailer capsules.  This is the size of the object that would be formed by concatenating the text of all source data extents (including those that are presumed to contain header or trailer text attached elsewhere) into a single serialized object.</p> </li> <li> <p>ZcoAcct zco_acct(Sdr sdr, Object zco)</p> <p>Returns an indicator as to whether zco is inbound or outbound.</p> </li> <li> <p>void zco_start_transmitting(Object zco, ZcoReader *reader)</p> <p>Used by underlying protocol layer to start extraction of an outbound ZCO's bytes (both from header and trailer capsules and from source data extents) for \"transmission\" -- i.e., the copying of bytes into a memory buffer for delivery to some non-ZCO-aware protocol implementation.  Initializes reading at the first byte of the total concatenated ZCO object.  Populates reader, which is used to keep track of \"transmission\" progress via this ZCO reference.</p> <p>Note that this function can be called multiple times to restart reading at the start of the ZCO.  Note also that multiple ZcoReader objects may be used concurrently, by the same task or different tasks, to advance through the ZCO independently.</p> </li> <li> <p>void zco_track_file_offset(ZcoReader *reader)</p> <p>Turns on file offset tracking for this reader.</p> </li> <li> <p>vast zco_transmit(Sdr sdr, ZcoReader *reader, vast length, char *buffer)</p> <p>Copies length as-yet-uncopied bytes of the total concatenated ZCO (referenced by reader) into buffer.  If buffer is NULL, skips over length bytes without copying.  Returns the number of bytes copied (or skipped) on success, 0 on any file access error, -1 on any other error.</p> </li> <li> <p>void zco_start_receiving(Object zco, ZcoReader *reader)</p> <p>Used by overlying protocol layer to start extraction of an inbound ZCO's bytes for \"reception\" -- i.e., the copying of bytes into a memory buffer for delivery to a protocol header parser, to a protocol trailer parser, or to the ultimate recipient (application).  Initializes reading of headers, source data, and trailers at the first byte of the concatenated ZCO objects.  Populates reader, which is used to keep track of \"reception\" progress via this ZCO reference and is required.</p> </li> <li> <p>vast zco_receive_headers(Sdr sdr, ZcoReader *reader, vast length, char *buffer)</p> <p>Copies length as-yet-uncopied bytes of presumptive protocol header text from ZCO source data extents into buffer.  If buffer is NULL, skips over length bytes without copying.  Returns number of bytes copied (or skipped) on success, 0 on any file access error, -1 on any other error.</p> </li> <li> <p>void zco_delimit_source(Sdr sdr, Object zco, vast offset, vast length)</p> <p>Sets the computed offset and length of actual source data in the ZCO, thereby implicitly establishing the total length of the ZCO's concatenated protocol headers as offset and the location of the ZCO's innermost protocol trailer as the sum of offset and length.  Offset and length are typically determined from the information carried in received presumptive protocol header text.</p> </li> <li> <p>vast zco_receive_source(Sdr sdr, ZcoReader *reader, vast length, char *buffer)</p> <p>Copies length as-yet-uncopied bytes of source data from ZCO extents into buffer.  If buffer is NULL, skips over length bytes without copying.  Returns number of bytes copied (or skipped) on success, 0 on any file access error, -1 on any other error.</p> </li> <li> <p>vast zco_receive_trailers(Sdr sdr, ZcoReader *reader, vast length, char *buffer)</p> <p>Copies length as-yet-uncopied bytes of trailer data from ZCO extents into buffer.  If buffer is NULL, skips over length bytes without copying. Returns number of bytes copied (or skipped) on success, 0 on any file access error, -1 on any other error.</p> </li> <li> <p>void zco_strip(Sdr sdr, Object zco)</p> <p>Deletes all source data extents that contain only header or trailer data and adjusts the offsets and/or lengths of all remaining extents to exclude any known header or trailer data.  This function is useful when handling a ZCO that was received from an underlying protocol layer rather than from an overlying application or protocol layer; use it before starting the transmission of the ZCO to another node or before enqueuing it for reception by an overlying application or protocol layer.</p> </li> </ul>"},{"location":"man/ici/zco/#see-also","title":"SEE ALSO","text":"<p>sdr(3)</p>"},{"location":"man/ltp/","title":"Index of Man Pages","text":"<ul> <li>dccplsi</li> <li>dccplso</li> <li>ltp</li> <li>ltpadmin</li> <li>ltpclock</li> <li>ltpcounter</li> <li>ltpdriver</li> <li>ltpmeter</li> <li>ltprc</li> <li>ltpsecadmin</li> <li>ltpsecrc</li> <li>sda</li> <li>sdatest</li> <li>udplsi</li> <li>udplso</li> </ul>"},{"location":"man/ltp/dccplsi/","title":"NAME","text":"<p>dccplsi - DCCP-based LTP link service input task</p>"},{"location":"man/ltp/dccplsi/#synopsis","title":"SYNOPSIS","text":"<p>dccplsi {local_hostname | @}[:local_port_nbr]</p>"},{"location":"man/ltp/dccplsi/#description","title":"DESCRIPTION","text":"<p>dccplsi is a background \"daemon\" task that receives DCCP datagrams via a DCCP socket bound to local_hostname and local_port_nbr, extracts LTP segments from those datagrams, and passes them to the local LTP engine. Host name \"@\" signifies that the host name returned by hostname(1) is to be used as the socket's host name.  If not specified, port number defaults to 1113.</p> <p>The link service input task is spawned automatically by ltpadmin in response to the 's' command that starts operation of the LTP protocol; the text of the command that is used to spawn the task must be provided as a parameter to the 's' command.  The link service input task is terminated by ltpadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/ltp/dccplsi/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dccplsi terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ltpadmin to restart dccplsi.</p> </li> <li> <p>\"1\"</p> <p>dccplsi terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use ltpadmin to restart dccplsi.</p> </li> </ul>"},{"location":"man/ltp/dccplsi/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/dccplsi/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/dccplsi/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dccplsi can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>LSI task is already started.</p> <p>Redundant initiation of dccplsi.</p> </li> <li> <p>LSI can't open DCCP socket. This probably means DCCP is not supported on your system.</p> <p>Operating system error. This probably means that you are not using an operating system that supports DCCP. Make sure that you are using a current Linux kernel and that the DCCP modules are being compiled. Check errtext, correct problem, and restart dccplsi.</p> </li> <li> <p>LSI can't initialize socket.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccplsi.</p> </li> <li> <p>LSI can't create listener thread.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccplsi.</p> </li> </ul>"},{"location":"man/ltp/dccplsi/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/dccplsi/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), dccplso(1), owltsim(1)</p>"},{"location":"man/ltp/dccplso/","title":"NAME","text":"<p>dccplso - DCCP-based LTP link service output task</p>"},{"location":"man/ltp/dccplso/#synopsis","title":"SYNOPSIS","text":"<p>dccplso {remote_engine_hostname | @}[:remote_port_nbr] remote_engine_nbr</p>"},{"location":"man/ltp/dccplso/#description","title":"DESCRIPTION","text":"<p>dccplso is a background \"daemon\" task that extracts LTP segments from the queue of segments bound for the indicated remote LTP engine, encapsulates them in DCCP datagrams, and sends those datagrams to the indicated DCCP port on the indicated host.  If not specified, port number defaults to 1113.</p> <p>Each \"span\" of LTP data interchange between the local LTP engine and a neighboring LTP engine requires its own link service output task, such as dccplso.  All link service output tasks are spawned automatically by ltpadmin in response to the 's' command that starts operation of the LTP protocol, and they are all terminated by ltpadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/ltp/dccplso/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dccplso terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ltpadmin to restart dccplso.</p> </li> <li> <p>\"1\"</p> <p>dccplso terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use ltpadmin to restart dccplso.</p> </li> </ul>"},{"location":"man/ltp/dccplso/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/dccplso/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/dccplso/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>dccplso can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>No such engine in database.</p> <p>remote_engine_nbr is invalid, or the applicable span has not yet been added to the LTP database by ltpadmin.</p> </li> <li> <p>LSO task is already started for this engine.</p> <p>Redundant initiation of dccplso.</p> </li> <li> <p>LSO can't create idle thread.</p> <p>Operating system error.  Check errtext, correct problem, and restart dccplso.</p> </li> <li> <p>LSO can't open DCCP socket. This probably means DCCP is not supported on your system.</p> <p>Operating system error. This probably means that you are not using an operating system that supports DCCP. Make sure that you are using a current Linux kernel and that the DCCP modules are being compiled. Check errtext, correct problem, and restart dccplso.</p> </li> <li> <p>LSO can't connect DCCP socket.</p> <p>Remote host's dccplsi isn't listening or has terminated. Restart dccplsi on the remote host and then restart dccplso.</p> </li> <li> <p>Segment is too big for DCCP LSO.</p> <p>Configuration error: segments that are too large for DCCP transmission (i.e., larger than 65535 bytes) are being enqueued for dccplso.  Use ltpadmin to change maximum segment size for this span.</p> </li> </ul>"},{"location":"man/ltp/dccplso/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/dccplso/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltpmeter(1), dccplsi(1), owltsim(1)</p>"},{"location":"man/ltp/ltp/","title":"NAME","text":"<p>ltp - Licklider Transmission Protocol (LTP) communications library</p>"},{"location":"man/ltp/ltp/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"ltp.h\"\n\ntypedef enum\n{\n    LtpNoNotice = 0,\n    LtpExportSessionStart,\n    LtpXmitComplete,\n    LtpExportSessionCanceled,\n    LtpExportSessionComplete,\n    LtpRecvGreenSegment,\n    LtpRecvRedPart,\n    LtpImportSessionCanceled\n} LtpNoticeType;\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ltp/ltp/#description","title":"DESCRIPTION","text":"<p>The ltp library provides functions enabling application software to use LTP to send and receive information reliably over a long-latency link.  It conforms to the LTP specification as documented by the Delay-Tolerant Networking Research Group of the Internet Research Task Force.</p> <p>The LTP notion of engine ID corresponds closely to the Internet notion of a host, and in ION engine IDs are normally indistinguishable from node numbers including the node numbers in Bundle Protocol endpoint IDs conforming to the \"ipn\" scheme.</p> <p>The LTP notion of client ID corresponds closely to the Internet notion of \"protocol number\" as used in the Internet Protocol.  It enables data from multiple applications -- clients -- to be multiplexed over a single reliable link.  However, for ION operations we normally use LTP exclusively for the transmission of Bundle Protocol data, identified by client ID = 1.</p> <ul> <li> <p>int ltp_attach()</p> <p>Attaches the application to LTP functionality on the lcoal computer.  Returns 0 on success, -1 on any error.</p> </li> <li> <p>void ltp_detach()</p> <p>Terminates all access to LTP functionality on the local computer.</p> </li> <li> <p>int ltp_engine_is_started()</p> <p>Returns 1 if the local LTP engine has been started and not yet stopped, 0 otherwise.</p> </li> <li> <p>int ltp_send(uvast destinationEngineId, unsigned int clientId, Object clientServiceData, unsigned int redLength, LtpSessionId *sessionId)</p> <p>Sends a client service data unit to the application that is waiting for data tagged with the indicated clientId as received at the remote LTP engine identified by destinationEngineId.</p> <p>clientServiceData must be a \"zero-copy object\" reference as returned by ionCreateZco().  Note that LTP will privately make and destroy its own reference to the client service data object; the application is free to destroy its reference at any time.</p> <p>redLength indicates the number of leading bytes of data in clientServiceData that are to be sent reliably, i.e., with selective retransmission in response to explicit or implicit negative acknowledgment as necessary.  All remaining bytes of data in clientServiceData will be sent as \"green\" data, i.e., unreliably.  If redLength is zero, the entire client service data unit will be sent unreliably.  If the entire client service data unit is to be sent reliably, redLength may be simply be set to LTP_ALL_RED (i.e., -1).</p> <p>On success, the function populates *sessionId with the source engine ID and the \"session number\" assigned to transmission of this client service data unit and returns zero.  The session number may be used to link future LTP processing events, such as transmission cancellation, to the affected client service data.  ltp_send() returns -1 on any error.</p> </li> <li> <p>int ltp_open(unsigned int clientId)</p> <p>Establishes the application's exclusive access to received service data units tagged with the indicated client service data ID.  At any time, only a single application task is permitted to receive service data units for any single client service data ID.</p> <p>Returns 0 on success, -1 on any error (e.g., the indicated client service is already being held open by some other application task).</p> </li> <li> <p>int ltp_get_notice(unsigned int clientId, LtpNoticeType *type, LtpSessionId *sessionId, unsigned char *reasonCode, unsigned char *endOfBlock, unsigned int *dataOffset, unsigned int *dataLength, Object *data)</p> <p>Receives notices of LTP processing events pertaining to the flow of service data units tagged with the indicated client service ID.  The nature of each event is indicated by *type.  Additional parameters characterizing the event are returned in *sessionId, *reasonCode, *endOfBlock, *dataOffset, *dataLength, and *data as relevant.</p> <p>The value returned in *data is always a zero-copy object; use the zco_* functions defined in \"zco.h\" to retrieve the content of that object.</p> <p>When the notice is an LtpRecvGreenSegment, the ZCO returned in *data contains the content of a single LTP green segment.  Reassembly of the green part of some block from these segments is the responsibility of the application.</p> <p>When the notice is an LtpRecvRedPart, the ZCO returned in *data contains the red part of a possibly aggregated block.  The ZCO's content may therefore comprise multiple service data objects.  Extraction of individual service data objects from the aggregated block is the responsibility of the application.  A simple way to do this is to prepend the length of the service data object to the object itself (using zco_prepend_header) before calling ltp_send, so that the receiving application can alternate extraction of object lengths and objects from the delivered block's red part.</p> <p>The cancellation of an export session may result in delivery of multiple LtpExportSessionCanceled notices, one for each service data unit in the export session's (potentially) aggregated block.  The ZCO returned in *data for each such notice is a service data unit ZCO that had previously been passed to ltp_send().</p> <p>ltp_get_notice() always blocks indefinitely until an LTP processing event is delivered.</p> <p>Returns zero on success, -1 on any error.</p> </li> <li> <p>void ltp_interrupt(unsigned int clientId)</p> <p>Interrupts an ltp_get_notice() invocation.  This function is designed to be called from a signal handler; for this purpose, clientId may need to be obtained from a static variable.</p> </li> <li> <p>void ltp_release_data(Object data)</p> <p>Releases the resources allocated to hold data, which must be a received client service data ZCO.</p> </li> <li> <p>void ltp_close(unsigned int clientId)</p> <p>Terminates the application's exclusive access to received service data units tagged with the indicated client service data ID.</p> </li> </ul>"},{"location":"man/ltp/ltp/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltprc(5), zco(3)</p>"},{"location":"man/ltp/ltpadmin/","title":"NAME","text":"<p>ltpadmin - ION Licklider Transmission Protocol (LTP) administration interface</p>"},{"location":"man/ltp/ltpadmin/#synopsis","title":"SYNOPSIS","text":"<p>ltpadmin [ commands_filename | . | ! ]</p>"},{"location":"man/ltp/ltpadmin/#description","title":"DESCRIPTION","text":"<p>ltpadmin configures, starts, manages, and stops LTP operations for the local ION node.</p> <p>It operates in response to LTP configuration commands found in the file commands_filename, if provided; if not, ltpadmin prints a simple prompt (:) so that the user may type commands directly into standard input.  If commands_filename is a period (.), the effect is the same as if a command file containing the single command 'x' were passed to ltpadmin -- that is, the ION node's ltpclock task,  ltpmeter tasks, and link service adapter tasks are stopped. If commands_filename is an exclamation point (!), that effect is reversed: the ION node's ltpclock task, ltpmeter tasks, and link service adapter tasks are restarted.</p> <p>The format of commands for commands_filename can be queried from ltpadmin with the 'h' or '?' commands at the prompt.  The commands are documented in ltprc(5).</p>"},{"location":"man/ltp/ltpadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li>\"0\" Successful completion of LTP administration.</li> </ul>"},{"location":"man/ltp/ltpadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>ltpadmin</p> <p>Enter interactive LTP configuration command entry mode.</p> </li> <li> <p>ltpadmin host1.ltp</p> <p>Execute all configuration commands in host1.ltp, then terminate immediately.</p> </li> <li> <p>ltpadmin .</p> <p>Stop all LTP operations on the local node.</p> </li> </ul>"},{"location":"man/ltp/ltpadmin/#files","title":"FILES","text":"<p>See ltprc(5) for details of the LTP configuration commands.</p>"},{"location":"man/ltp/ltpadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/ltpadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ltprc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to ltpadmin.  Otherwise ltpadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the logfile ion.log:</p> <ul> <li> <p>ltpadmin can't attach to ION.</p> <p>There is no SDR data store for ltpadmin to use.  You should run ionadmin(1) first, to set up an SDR data store for ION.</p> </li> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause ltpadmin to fail but are noted in the ion.log log file may be caused by improperly formatted commands given at the prompt or in the commands_filename file. Please see ltprc(5) for details.</p>"},{"location":"man/ltp/ltpadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/ltpadmin/#see-also","title":"SEE ALSO","text":"<p>ltpmeter(1), ltprc(5)</p>"},{"location":"man/ltp/ltpclock/","title":"NAME","text":"<p>ltpclock - LTP daemon task for managing scheduled events</p>"},{"location":"man/ltp/ltpclock/#synopsis","title":"SYNOPSIS","text":"<p>ltpclock</p>"},{"location":"man/ltp/ltpclock/#description","title":"DESCRIPTION","text":"<p>ltpclock is a background \"daemon\" task that periodically performs scheduled LTP activities.  It is spawned automatically by ltpadmin in response to the 's' command that starts operation of the LTP protocol, and it is terminated by ltpadmin in response to an 'x' (STOP) command.</p> <p>Once per second, ltpclock takes the following action:</p> <p>First it manages the current state of all links (\"spans\").  In particular, it checks the age of the currently buffered session block for each span and, if that age exceeds the span's configured aggregation time limit, gives the \"buffer full\" semaphore for that span to initiate block segmentation and transmission by ltpmeter.</p> <p>In so doing, it also infers link state changes (\"link cues\") from data rate changes as noted in the RFX database by rfxclock:</p> <p>If the rate of transmission to a neighbor was zero but is now non-zero, then transmission to that neighbor is unblocked.  The applicable \"buffer empty\" semaphore is given if no outbound block is being constructed (enabling start of a new transmission session) and the \"segments ready\" semaphore is given if the outbound segment queue is non-empty (enabling transmission of segments by the link service output task).</p> <p>If the rate of transmission to a neighbor was non-zero but is now zero, then transmission to that neighbor is blocked -- i.e., the semaphores triggering transmission will no longer be given.</p> <p>If the imputed rate of transmission from a neighbor was non-zero but is now zero, then all timers affecting segment retransmission to that neighbor are suspended.  This has the effect of extending the interval of each affected timer by the length of time that the timers remain suspended.</p> <p>If the imputed rate of transmission from a neighbor was zero but is now non-zero, then all timers affecting segment retransmission to that neighbor are resumed.</p> <p>Then ltpclock retransmits all unacknowledged checkpoint segments, report segments, and cancellation segments whose computed timeout intervals have expired.</p>"},{"location":"man/ltp/ltpclock/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpclock terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ltpadmin to restart ltpclock.</p> </li> <li> <p>\"1\"</p> <p>ltpclock was unable to attach to LTP protocol operations, probably because ltpadmin has not yet been run.</p> </li> </ul>"},{"location":"man/ltp/ltpclock/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/ltpclock/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/ltpclock/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ltpclock can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>Can't dispatch events.</p> <p>An unrecoverable database error was encountered.  ltpclock terminates.</p> </li> <li> <p>Can't manage links.</p> <p>An unrecoverable database error was encountered.  ltpclock terminates.</p> </li> </ul>"},{"location":"man/ltp/ltpclock/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/ltpclock/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltpmeter(1), rfxclock(1)</p>"},{"location":"man/ltp/ltpcounter/","title":"NAME","text":"<p>ltpcounter - LTP reception test program</p>"},{"location":"man/ltp/ltpcounter/#synopsis","title":"SYNOPSIS","text":"<p>ltpcounter client_ID [max_nbr_of_bytes]</p>"},{"location":"man/ltp/ltpcounter/#description","title":"DESCRIPTION","text":"<p>ltpcounter uses LTP to receive service data units flagged with client service number client_ID from a remote ltpdriver client service process.  When the total number of bytes of client service data it has received exceeds max_nbr_of_bytes, it terminates and prints reception and cancellation statistics.  If max_nbr_of_bytes is omitted, the default limit is 2 billion bytes.</p> <p>While receiving data, ltpcounter prints a 'v' character every 5 seconds to indicate that it is still alive.</p>"},{"location":"man/ltp/ltpcounter/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpcounter has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>ltpcounter was unable to start, because it could not attach to the LTP protocol on the local node or could not open access to client service clientId.</p> <p>In the former case, run ltpadmin to start LTP and try again.</p> <p>In the latter case, some other client service task has already opened access to client service clientId.  If no such task is currently running (e.g., it crashed while holding the client service open), use ltpadmin to stop and restart the LTP protocol.</p> </li> </ul>"},{"location":"man/ltp/ltpcounter/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/ltpcounter/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/ltpcounter/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by ltpcounter are written to the ION log file ion.log.</p> <ul> <li> <p>ltpcounter can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>ltpcounter can't open client access.</p> <p>Another task has opened access to service client clientId and has not yet relinquished it.</p> </li> <li> <p>Can't get LTP notice.</p> <p>LTP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/ltp/ltpcounter/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/ltpcounter/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltpdriver(1), ltp(3)</p>"},{"location":"man/ltp/ltpdriver/","title":"NAME","text":"<p>ltpdriver - LTP transmission test program</p>"},{"location":"man/ltp/ltpdriver/#synopsis","title":"SYNOPSIS","text":"<p>ltpdriver remoteEngineNbr clientId nbrOfCycles greenLength [ totalLength]</p>"},{"location":"man/ltp/ltpdriver/#description","title":"DESCRIPTION","text":"<p>ltpdriver uses LTP to send nbrOfCycles service data units of length indicated by totalLength, of which the trailing greenLength bytes are sent unreliably, to the ltpcounter client service process for client service number clientId attached to the remote LTP engine identified by remoteEngineNbr.  If omitted, length defaults to 60000.  If length is 1, the sizes of the transmitted service data units will be randomly selected multiples of 1024 in the range 1024 to 62464.</p> <p>Whenever the size of the transmitted service data unit is less than or equal to greenLength, the entire SDU is sent unreliably.</p> <p>When all copies of the file have been sent, ltpdriver prints a performance report.</p>"},{"location":"man/ltp/ltpdriver/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpdriver has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>ltpdriver was unable to start, because it could not attach to the LTP protocol on the local node.  Run ltpadmin to start LTP, then try again.</p> </li> </ul>"},{"location":"man/ltp/ltpdriver/#files","title":"FILES","text":"<p>The service data units transmitted by ltpdriver are sequences of text obtained from a file in the current working directory named \"ltpdriverAduFile\", which ltpdriver creates automatically.</p>"},{"location":"man/ltp/ltpdriver/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/ltpdriver/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by ltpdriver are written to the ION log file ion.log.</p> <ul> <li> <p>ltpdriver can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>Can't create ADU file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>Error writing to ADU file</p> <p>Operating system error.  Check errtext, correct problem, and rerun.</p> </li> <li> <p>ltpdriver can't create file ref.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>ltpdriver can't create ZCO.</p> <p>ION system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> <li> <p>ltpdriver can't send message.</p> <p>LTP span to the remote engine has been stopped.</p> </li> <li> <p>ltp_send failed.</p> <p>LTP system error.  Check for earlier diagnostic messages describing the cause of the error; correct problem and rerun.</p> </li> </ul>"},{"location":"man/ltp/ltpdriver/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/ltpdriver/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltpcounter(1), ltp(3)</p>"},{"location":"man/ltp/ltpmeter/","title":"NAME","text":"<p>ltpmeter - LTP daemon task for aggregating and segmenting transmission blocks</p>"},{"location":"man/ltp/ltpmeter/#synopsis","title":"SYNOPSIS","text":"<p>ltpmeter remote_engine_nbr</p>"},{"location":"man/ltp/ltpmeter/#description","title":"DESCRIPTION","text":"<p>ltpmeter is a background \"daemon\" task that manages the presentation of LTP segments to link service output tasks.  Each \"span\" of LTP data interchange between the local LTP engine and a neighboring LTP engine requires its own ltpmeter task.  All ltpmeter tasks are spawned automatically by ltpadmin in response to the 's' command that starts operation of the LTP protocol, and they are all terminated by ltpadmin in response to an 'x' (STOP) command.</p> <p>ltpmeter waits until its span's current transmission block (the data to be transmitted during the transmission session that is currently being constructed) is ready for transmission, then divides the data in the span's block buffer into segments and enqueues the segments for transmission by the span's link service output task (giving the segments semaphore to unblock the link service output task as necessary), then reinitializes the span's block buffer and starts another session (giving the \"buffer empty\" semaphore to unblock the client service task -- nominally ltpclo, the LTP convergence layer output task for Bundle Protocol -- as necessary).</p> <p>ltpmeter determines that the current transmission block is ready for transmission by waiting until either (a) the aggregate size of all service data units in the block's buffer exceeds the aggregation size limit for this span or (b) the length of time that the first service data unit in the block's buffer has been awaiting transmission exceeds the aggregation time limit for this span.  The \"buffer full\" semaphore is given when ION (either the ltp_send() function or the ltpclock daemon) determines that one of these conditions is true; ltpmeter simply waits for this semaphore to be given.</p> <p>The initiation of a new session may also be blocked: the total number of transmission sessions that the local LTP engine may have open at a single time is limited (this is LTP flow control), and while the engine is at this limit no new sessions can be started.  Availability of a session from the session pool is signaled by the \"session\" semaphore, which is given whenever a session is completed or canceled.</p>"},{"location":"man/ltp/ltpmeter/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ltpmeter terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ltpadmin to restart ltpmeter.</p> </li> <li> <p>\"1\"</p> <p>ltpmeter terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use ltpadmin to restart ltpmeter.</p> </li> </ul>"},{"location":"man/ltp/ltpmeter/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/ltpmeter/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/ltpmeter/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>ltpmeter can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>No such engine in database.</p> <p>remote_engine_nbr is invalid, or the applicable span has not yet been added to the LTP database by ltpadmin.</p> </li> <li> <p>ltpmeter task is already started for this engine.</p> <p>Redundant initiation of ltpmeter.</p> </li> <li> <p>ltpmeter can't start new session.</p> <p>An unrecoverable database error was encountered.  ltpmeter terminates.</p> </li> <li> <p>Can't take bufClosedSemaphore.</p> <p>An unrecoverable database error was encountered.  ltpmeter terminates.</p> </li> <li> <p>Can't create extents list.</p> <p>An unrecoverable database error was encountered.  ltpmeter terminates.</p> </li> <li> <p>Can't post ExportSessionStart notice.</p> <p>An unrecoverable database error was encountered.  ltpmeter terminates.</p> </li> <li> <p>Can't finish session.</p> <p>An unrecoverable database error was encountered.  ltpmeter terminates.</p> </li> </ul>"},{"location":"man/ltp/ltpmeter/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/ltpmeter/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltpclock(1)</p>"},{"location":"man/ltp/ltprc/","title":"NAME","text":"<p>ltprc - Licklider Transmission Protocol management commands file</p>"},{"location":"man/ltp/ltprc/#description","title":"DESCRIPTION","text":"<p>LTP management commands are passed to ltpadmin either in a file of text lines or interactively at ltpadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the LTP management commands are described below.</p>"},{"location":"man/ltp/ltprc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ltpadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>1 est_max_export_sessions</p> <p>The initialize command.  Until this command is executed, LTP is not in operation on the local ION node and most ltpadmin commands will fail.</p> <p>The command uses est_max_export_sessions to configure the hashtable it will use to manage access to export transmission sessions that are currently in progress.  For optimum performance, est_max_export_sessions should normally equal or exceed the summation of max_export_sessions over all spans as discussed below.</p> <p>Appropriate values for the parameters configuring each \"span\" of potential LTP data exchange between the local LTP and neighboring engines are non-trivial to determine.  See the ION LTP configuration spreadsheet and accompanying documentation for details.</p> </li> <li> <p>a span peer_engine_nbr max_export_sessions max_import_sessions max_segment_size aggregation_size_threshold aggregation_time_limit 'LSO_command' [queuing_latency]</p> <p>The add span command.  This command declares that a span of potential LTP data interchange exists between the local LTP engine and the indicated (neighboring) LTP engine.</p> <p>The max_segment_size and aggregation_size_threshold are expressed as numbers of bytes of data.  max_segment_size limits the size of each of the segments into which each outbound data block will be divided; typically this limit will be the maximum number of bytes that can be encapsulated within a single transmission frame of the underlying link service.</p> <p>aggregation_size_threshold limits the number of LTP service data units (e.g., bundles) that can be aggregated into a single block: when the sum of the sizes of all service data units aggregated into a block exceeds this threshold, aggregation into this block must cease and the block must be segmented and transmitted.  </p> <p>aggregation_time_limit alternatively limits the number of seconds that any single export session block for this span will await aggregation before it is segmented and transmitted regardless of size.  The aggregation time limit prevents undue delay before the transmission of data during periods of low activity.</p> <p>max_export_sessions constitutes, in effect, the local LTP engine's retransmission \"window\" for this span.  The retransmission windows of the spans impose flow control on LTP transmission, reducing the chance of allocation of all available space in the ION node's data store to LTP transmission sessions.</p> <p>max_import_sessions is simply the neighoring engine's own value for the corresponding export session parameter; it is the neighboring engine's retransmission window size for this span.  It reduces the chance of allocation of all available space in the ION node's data store to LTP reception sessions.</p> <p>LSO_command is script text that will be executed when LTP is started on this node, to initiate operation of a link service output task for this span.  Note that \" peer_engine_nbr\" will automatically be appended to LSO_command by ltpadmin before the command is executed, so only the link-service-specific portion of the command should be provided in the LSO_command string itself.</p> <p>queuing_latency is the estimated number of seconds that we expect to lapse between reception of a segment at this node and transmission of an acknowledging segment, due to processing delay in the node.  (See the 'm ownqtime' command below.)  The default value is 1.</p> <p>If queuing latency a negative number, the absolute value of this number is used as the actual queuing latency and session purging is enabled; otherwise session purging is disabled.  If session purging is enabled for a span then at the end of any period of transmission over this span all of the span's export sessions that are currently in progress are automatically canceled.  Notionally this forces re-forwarding of the DTN bundles in each session's block, to avoid having to wait for the restart of transmission on this span before those bundles can be successfully transmitted.</p> </li> <li> <p>a seat 'LSI_command' </p> <p>The add seat command.  This command declares that the local LTP engine can receive LTP segments via the link service input daemon that begins running when 'LSI_command' is executed.</p> </li> <li> <p>c span peer_engine_nbr max_export_sessions max_import_sessions max_segment_size aggregation_size_threshold aggregation_time_limit 'LSO_command' [queuing_latency]</p> <p>The change span command.  This command sets the indicated span's  configuration parameters to the values provided as arguments.</p> </li> <li> <p>d span peer_engine_nbr</p> <p>The delete span command.  This command deletes the span identified by peer_engine_nbr.  The command will fail if any outbound segments for this span are pending transmission or any inbound blocks from the peer engine are incomplete.</p> </li> <li> <p>d seat 'LSI_command'</p> <p>The delete seat command.  This command deletes the seat identified by 'LSI_command'.  </p> </li> <li> <p>i span peer_engine_nbr</p> <p>This command will print information (all configuration parameters) about the span identified by peer_engine_nbr.</p> </li> <li> <p>i seat 'LSI_command'</p> <p>This command will print all information (i.e., process ID number) about the seat identified by 'LSI_command'.  </p> </li> <li> <p>l span</p> <p>This command lists all declared LTP data interchange spans.</p> </li> <li> <p>l seat</p> <p>This command lists all declared LTP data acquisition seats.</p> </li> <li> <p>s ['LSI_command']</p> <p>The start command.  This command starts link service input tasks for all LTP seats and output tasks for all LTP spans (to remote engines) from the local LTP engine.  'LSI_command' is deprecated but is supported for backward compatibility; if provided, the effect is the same as entering the command \"a seat 'LSI_command'\" prior to starting all daemon tasks.</p> </li> <li> <p>m heapmax max_database_heap_per_block</p> <p>The manage heap for block acquisition command.  This command declares the maximum number of bytes of SDR heap space that will be occupied by the acquisition of any single LTP block.  All data acquired in excess of this limit will be written to a temporary file pending extraction and dispatching of the acquired block.  Default is the minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimum SDR heap space occupancy in the event that all acquisition is into a file.</p> </li> <li> <p>m screening { y | n }</p> <p>The manage screening command.  </p> <p>The manage screening command.  This command disables or enables the screening of received LTP segments per the periods of scheduled reception in the node's contact graph.</p> <p>By default, screening is enabled - that is, LTP segments from a given remote LTP engine (ION node) will be silently discarded when they arrive during an interval when the contact graph says the data rate from that engine to the local LTP engine is zero.  The reason for this is that without a known nominal reception rate we cannot enforce reception rate control, which is needed in order to prevent resource exhaustion at the receiving node.</p> <p>Note, though, that the enabling of screening implies that the ranges declared in the contact graph must be accurate and clocks must be synchronized; otherwise, segments will be arriving at times other than the scheduled contact intervals and will be discarded.  </p> <p>For some research purposes this constraint may be difficult to satisfy. For such purposes ONLY, where resource exhaustion at the receiving node is not at issue, screening may be disabled.</p> </li> <li> <p>m ownqtime own_queuing_latency</p> <p>The manage own queuing time command.  This command sets the number of seconds of predicted additional latency attributable to processing delay within the local engine itself that should be included whenever LTP computes the nominal round-trip time for an exchange of data with any remote engine. The default value is 1.</p> </li> <li> <p>m maxber max_expected_bit_error_rate</p> <p>The manage max bit error rate command.  This command sets the expected maximum bit error rate that LTP should provide for in computing the maximum number of transmission efforts to initiate in the transmission of a given block.  (Note that this computation is also sensitive to data segment size and to the size of the block that is to be transmitted.)  The default value is .000001 (10^-6).</p> </li> <li> <p>m maxbacklog max_delivery_backlog</p> <p>The manage max delivery backlog command.  This command sets the limit on the number of blocks (service data units) that may be queued up for delivery to clients.  While the queue is at this limit, red segments are discarded as it is not possible to deliver the blocks to which they pertain.  The intent here is to prevent resource exhaustion by limiting the rate at which new blocks can be acquired and inserted into ZCO space. The default value is 10.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops all link service input and output tasks for the local LTP engine.</p> </li> <li> <p>w { 0 | 1 | &lt;activity_spec&gt; }</p> <p>The LTP watch command.  This command enables and disables production of a continuous stream of user-selected LTP activity indication characters.  A watch parameter of \"1\" selects all LTP activity indication characters; \"0\" de-selects all LTP activity indication characters; any other activity_spec such as \"df{]\" selects all activity indication characters in the string, de-selecting all others.  LTP will print each selected activity indication character to stdout every time a processing event of the associated type occurs:</p> <p>d   bundle appended to block for next session</p> <p>e   segment of block is queued for transmission</p> <p>f   block has been fully segmented for transmission</p> <p>g   segment popped from transmission queue</p> <p>h   positive ACK received for block, session ended</p> <p>s   segment received</p> <p>t   block has been fully received</p> <p>@   negative ACK received for block, segments retransmitted</p> <p>=   unacknowledged checkpoint was retransmitted</p> <p>+   unacknowledged report segment was retransmitted</p> <p>{   export session canceled locally (by sender)</p> <p>}   import session canceled by remote sender</p> <p>[  import session canceled locally (by receiver)</p> <p>]  export session canceled by remote receiver</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/ltp/ltprc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>a span 19 20 5 1024 32768 2 'udplso node19.ohio.edu:5001'</p> <p>Declares a data interchange span between the local LTP engine and the remote engine (ION node) numbered 19.  There can be at most 20 concurrent sessions of export activity to this node.  Conversely, node 19 can have at most 5 concurrent sessions of export activity to the local node. Maximum segment size for this span is set to 1024 bytes, aggregation size threshold is 32768 bytes, aggregation time limit is 2 seconds, and the link service output task that is initiated when LTP is started on the local ION node will execute the udplso program as indicated.</p> </li> <li> <p>m screening n</p> <p>Disables strict enforcement of the contact schedule.</p> </li> </ul>"},{"location":"man/ltp/ltprc/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), udplsi(1), udplso(1)</p>"},{"location":"man/ltp/ltpsecadmin/","title":"NAME","text":"<p>ltpsecadmin - LTP security policy administration interface</p>"},{"location":"man/ltp/ltpsecadmin/#synopsis","title":"SYNOPSIS","text":"<p>ltpsecadmin [ commands_filename ]</p>"},{"location":"man/ltp/ltpsecadmin/#description","title":"DESCRIPTION","text":"<p>ltpsecadmin configures and manages LTP security policy on the local computer.</p> <p>It configures and manages LTP security policy on the local computer in response to LTP configuration commands found in commands_filename, if provided; if not, ltpsecadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from ltpsecadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in ltpsecrc(5).</p>"},{"location":"man/ltp/ltpsecadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of LTP security policy administration.</p> </li> </ul>"},{"location":"man/ltp/ltpsecadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>ltpsecadmin</p> <p>Enter interactive LTP security policy administration command entry mode.</p> </li> <li> <p>ltpsecadmin host1.ltpsecrc</p> <p>Execute all configuration commands in host1.ltpsecrc, then terminate immediately.</p> </li> </ul>"},{"location":"man/ltp/ltpsecadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from ltpsecadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which ltpsecadmin was run.  The log file is typically named ion.log.</p> <p>See also ltpsecrc(5).</p>"},{"location":"man/ltp/ltpsecadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/ltpsecadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the ionrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to ltpsecadmin.  Otherwise ltpsecadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause ltpsecadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see ltpsecrc(5) for details.</p>"},{"location":"man/ltp/ltpsecadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/ltpsecadmin/#see-also","title":"SEE ALSO","text":"<p>ltpsecrc(5)</p>"},{"location":"man/ltp/ltpsecrc/","title":"NAME","text":"<p>ltpsecrc - LTP security policy management commands file</p>"},{"location":"man/ltp/ltpsecrc/#description","title":"DESCRIPTION","text":"<p>LTP security policy management commands are passed to ltpsecadmin either in a file of text lines or interactively at ltpsecadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the LTP security policy management commands are described below.</p>"},{"location":"man/ltp/ltpsecrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by ltpsecadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>a ltprecvauthrule ltp_engine_id ciphersuite_nbr [key_name]</p> <p>The add ltprecvauthrule command.  This command adds a rule specifying the manner in which LTP segment authentication will be applied to LTP segments received from the indicated LTP engine.</p> <p>A segment from the indicated LTP engine will only be deemed authentic if it contains an authentication extension computed via the ciphersuite identified by ciphersuite_nbr using the applicable key value.  If ciphersuite_nbr is 255 then the applicable key value is a hard-coded constant and key_name must be omitted; otherwise key_name is required and the applicable key value is the current value of the key named key_name in the local security policy database.</p> <p>Valid values of ciphersuite_nbr are:</p> <pre><code>0: HMAC-SHA1-80\n1: RSA-SHA256\n255: NULL\n</code></pre> </li> <li> <p>c ltprecvauthrule ltp_engine_id ciphersuite_nbr [key_name]</p> <p>The change ltprecvauthrule command.  This command changes the parameters of the LTP segment authentication rule for the indicated LTP engine. </p> </li> <li> <p>d ltprecvauthrule ltp_engine_id</p> <p>The delete ltprecvauthrule command.  This command deletes the LTP segment authentication rule for the indicated LTP engine.</p> </li> <li> <p>i ltprecvauthrule ltp_engine_id</p> <p>This command will print information (the LTP engine id, ciphersuite number, and key name) about the LTP segment authentication rule for the indicated LTP engine.</p> </li> <li> <p>l ltprecvauthrule</p> <p>This command lists all LTP segment authentication rules in the security policy database.</p> </li> <li> <p>a ltpxmitauthrule ltp_engine_id ciphersuite_nbr [key_name]</p> <p>The add ltpxmitauthrule command.  This command adds a rule specifying the manner in which LTP segments transmitted to the indicated LTP engine must be signed.</p> <p>Signing a segment destined for the indicated LTP engine entails computing an authentication extension via the ciphersuite identified by ciphersuite_nbr using the applicable key value.  If ciphersuite_nbr is 255 then the applicable key value is a hard-coded constant and key_name must be omitted; otherwise key_name is required and the applicable key value is the current value of the key named key_name in the local security policy database.</p> <p>Valid values of ciphersuite_nbr are:</p> <pre><code>0: HMAC\\_SHA1-80\n1: RSA\\_SHA256\n255: NULL\n</code></pre> </li> <li> <p>c ltpxmitauthrule ltp_engine_id ciphersuite_nbr [key_name]</p> <p>The change ltpxmitauthrule command.  This command changes the parameters of the LTP segment signing rule for the indicated LTP engine. </p> </li> <li> <p>d ltpxmitauthrule ltp_engine_id</p> <p>The delete ltpxmitauthrule command.  This command deletes the LTP segment signing rule for the indicated LTP engine.</p> </li> <li> <p>i ltpxmitauthrule ltp_engine_id</p> <p>This command will print information (the LTP engine id, ciphersuite number, and key name) about the LTP segment signing rule for the indicated LTP engine.</p> </li> <li> <p>l ltpxmitauthrule</p> <p>This command lists all LTP segment signing rules in the security policy database.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/ltp/ltpsecrc/#see-also","title":"SEE ALSO","text":"<p>ltpsecadmin(1)</p>"},{"location":"man/ltp/sda/","title":"NAME","text":"<p>sda - LTP Service Data Aggregation (SDA) library</p>"},{"location":"man/ltp/sda/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"sda.h\"\n\ntypedef vast (*SdaDelimiterFn)(unsigned int clientId, unsigned char *buffer, vast bufferLength);\n\ntypedef int (*SdaHandlerFn)(uvast sourceEngineId, unsigned int clientId, Object clientServiceData);\n\n[see description for available functions]\n</code></pre>"},{"location":"man/ltp/sda/#description","title":"DESCRIPTION","text":"<p>The sda library provides functions enabling application software to use LTP more efficiently, by aggregating multiple small client service data units into larger LTP client service data items.  This reduces overhead somewhat, but more importantly it reduces the volume of positive and negative LTP acknowledgment traffic by sending more data in fewer LTP blocks -- because LTP acknowledgments are issued on a per-block basis.</p> <p>The library relies on the application to detect the boundaries between aggregated service data units in each received LTP client service data item; the application must provide an SdaDelimiterFn function for this purpose.  An SDA delimiter function inspects the client service data bytes in buffer - some portion of an LTP service data block, of length bufferLength - to determine the length of the client service data unit at the start of the buffer; data unit client service ID is provided to aid in this determination. The function returns that length if the determination was successful, zero if there is no valid client service data item at the start of the buffer, -1 on any system failure.</p> <p>The sda library similarly relies on the application to process the service data units identified in this manner; the application must provide an SdaHandlerFn function for this purpose.  An SDA handler function is provided with the ID of the LTP engine that sent the service data unit, the client ID characterizing the service data unit, and the service data unit itself; the service data unit is presented as a Zero-Copy Object (ZCO).  The handler function must return -1 on any system error, zero otherwise.</p> <ul> <li> <p>int sda_send(uvast destinationEngineId, unsigned int clientId, Object clientServiceData);</p> <p>Sends a client service data unit to an application, identified by clientId, at the LTP engine identified by destinationEngineId.  clientServiceData must be a \"zero-copy object\" reference as returned by ionCreateZco().  Note that SDA will privately make and destroy its own reference to the client service data; the application is free to destroy its reference at any time.   Note that the client service data unit will always be sent reliably (i.e., \"red\").</p> <p>Also note that sda_run() must be executing in order for sda_send to be performed.</p> <p>Returns 0 on success, -1 on any system failure.</p> </li> <li> <p>int sda_run(SdaDelimiterFn delimiter, SdaHandlerFn handler);</p> <p>sda_run() executes an infinite loop that receives LTP client service data items, calls delimiter to determine the length of each client service data unit in each item, and passes those client service data units to the handler function.  To terminate the loop, call sda_interrupt().  Note that sda_send() can only be executed while the sda_run() loop is still executing.</p> <p>Returns 0 on success, -1 on any system failure.</p> </li> <li> <p>void sda_interrupt();</p> <p>Interrupts sda_run().</p> </li> </ul>"},{"location":"man/ltp/sda/#see-also","title":"SEE ALSO","text":"<p>sdatest(1), zco(3)</p>"},{"location":"man/ltp/sdatest/","title":"NAME","text":"<p>sdatest - LTP service data aggreggation test program</p>"},{"location":"man/ltp/sdatest/#synopsis","title":"SYNOPSIS","text":"<p>sdatest [remoteEngineNbr]</p>"},{"location":"man/ltp/sdatest/#description","title":"DESCRIPTION","text":"<p>sdatest tests LTP service data aggregation (SDA).</p> <p>Each instance of the program can run either as a sender and receiver or as a receiver only.  For sending, sdatest starts a background thread that offers a command-line prompt and accepts strings of text for transmission.  It uses SDA to aggregate the strings into LTP service data items for LTP client ID 2, which is SDA.  The strings (SDA data units) are delimited by terminating NULLs, and they are all identified by SDA client ID number 135.</p> <p>For reception, sdatest listens for LTP traffic for client 2.  When it receives an LTP Service data item (in an LTP block), it parses out all of the SDA data units aggregated in that data item and prints them to stdout.</p> <p>Use ^C to terminate sdatest.</p>"},{"location":"man/ltp/sdatest/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>sdatest has terminated.  Any problems encountered during operation will be noted in the ion.log log file.</p> </li> <li> <p>\"1\"</p> <p>sdatest was unable to start.  See the ion.log file for details.</p> </li> </ul>"},{"location":"man/ltp/sdatest/#files","title":"FILES","text":"<p>No files are used by sdatest.</p>"},{"location":"man/ltp/sdatest/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/sdatest/#diagnostics","title":"DIAGNOSTICS","text":"<p>Diagnostic messages produced by sdatest are written to the ION log file ion.log.</p>"},{"location":"man/ltp/sdatest/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/sdatest/#see-also","title":"SEE ALSO","text":"<p>sda(3)</p>"},{"location":"man/ltp/udplsi/","title":"NAME","text":"<p>udplsi - UDP-based LTP link service input task</p>"},{"location":"man/ltp/udplsi/#synopsis","title":"SYNOPSIS","text":"<p>udplsi {local_hostname | @}[:local_port_nbr]</p>"},{"location":"man/ltp/udplsi/#description","title":"DESCRIPTION","text":"<p>udplsi is a background \"daemon\" task that receives UDP datagrams via a UDP socket bound to local_hostname and local_port_nbr, extracts LTP segments from those datagrams, and passes them to the local LTP engine. Host name \"@\" signifies that the host name returned by hostname(1) is to be used as the socket's host name.  If not specified, port number defaults to 1113.</p> <p>The link service input task is spawned automatically by ltpadmin in response to the 's' command that starts operation of the LTP protocol; the text of the command that is used to spawn the task must be provided as a parameter to the 's' command.  The link service input task is terminated by ltpadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/ltp/udplsi/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udplsi terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ltpadmin to restart udplsi.</p> </li> <li> <p>\"1\"</p> <p>udplsi terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use ltpadmin to restart udplsi.</p> </li> </ul>"},{"location":"man/ltp/udplsi/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/udplsi/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/udplsi/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udplsi can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>LSI task is already started.</p> <p>Redundant initiation of udplsi.</p> </li> <li> <p>LSI can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udplsi.</p> </li> <li> <p>LSI can't initialize socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udplsi.</p> </li> <li> <p>LSI can't create receiver thread</p> <p>Operating system error.  Check errtext, correct problem, and restart udplsi.</p> </li> </ul>"},{"location":"man/ltp/udplsi/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/udplsi/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), udplso(1), owltsim(1)</p>"},{"location":"man/ltp/udplso/","title":"NAME","text":"<p>udplso - UDP-based LTP link service output task</p>"},{"location":"man/ltp/udplso/#synopsis","title":"SYNOPSIS","text":"<p>udplso {remote_engine_hostname | @}[:remote_port_nbr] remote_engine_nbr</p>"},{"location":"man/ltp/udplso/#description","title":"DESCRIPTION","text":"<p>udplso is a background \"daemon\" task that extracts LTP segments from the queue of segments bound for the indicated remote LTP engine, encapsulates them in UDP datagrams, and sends those datagrams to the indicated UDP port on the indicated host.  If not specified, port number defaults to 1113.</p> <p>Each \"span\" of LTP data interchange between the local LTP engine and a neighboring LTP engine requires its own link service output task, such as udplso.  All link service output tasks are spawned automatically by ltpadmin in response to the 's' command that starts operation of the LTP protocol, and they are all terminated by ltpadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/ltp/udplso/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>udplso terminated normally, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use ltpadmin to restart udplso.</p> </li> <li> <p>\"1\"</p> <p>udplso terminated abnormally, for reasons noted in the ion.log file. Investigate and solve the problem identified in the log file, then use ltpadmin to restart udplso.</p> </li> </ul>"},{"location":"man/ltp/udplso/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/ltp/udplso/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/ltp/udplso/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>udplso can't initialize LTP.</p> <p>ltpadmin has not yet initialized LTP protocol operations.</p> </li> <li> <p>No such engine in database.</p> <p>remote_engine_nbr is invalid, or the applicable span has not yet been added to the LTP database by ltpadmin.</p> </li> <li> <p>LSO task is already started for this engine.</p> <p>Redundant initiation of udplso.</p> </li> <li> <p>LSO can't open UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udplso.</p> </li> <li> <p>LSO can't connect UDP socket</p> <p>Operating system error.  Check errtext, correct problem, and restart udplso.</p> </li> <li> <p>Segment is too big for UDP LSO.</p> <p>Configuration error: segments that are too large for UDP transmission (i.e., larger than 65535 bytes) are being enqueued for udplso.  Use ltpadmin to change maximum segment size for this span.</p> </li> </ul>"},{"location":"man/ltp/udplso/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/ltp/udplso/#see-also","title":"SEE ALSO","text":"<p>ltpadmin(1), ltpmeter(1), udplsi(1), owltsim(1)</p>"},{"location":"man/nm/","title":"Index of Man Pages","text":"<ul> <li>nm_agent</li> <li>nm_mgr</li> </ul>"},{"location":"man/nm/nm_agent/","title":"NAME","text":"<p>nm_agent - Network Management Agent implementing the Asynchronous Management Protocol (AMP)</p>"},{"location":"man/nm/nm_agent/#synopsis","title":"SYNOPSIS","text":"<p>nm_agent &lt;agent eid&gt; manager eid</p>"},{"location":"man/nm/nm_agent/#description","title":"DESCRIPTION","text":"<p>Starts the network management agent listening on agent eid and communicating with a remote  manager at manager eid</p>"},{"location":"man/nm/nm_agent/#see-also","title":"SEE ALSO","text":"<p>Asynchronous Management Protocol</p> <p>nm_mgr(1)</p>"},{"location":"man/nm/nm_mgr/","title":"NAME","text":"<p>nm_mgr - Network Management server implementing the Asynchronous Management Protocol (AMP)</p>"},{"location":"man/nm/nm_mgr/#synopsis","title":"SYNOPSIS","text":"<p>nm_mgr [options] manager eid</p> <p>The following options may be specified to customize behavior.  Use \"nm_mgr --help\" for full usage information:</p> <ul> <li> <p>-A</p> <p>Startup directly in the alternative Automator UI mode. This mode is designed to provide a consistent line-based interface suitable for automated scripting.  Type ? when active for usage details.</p> </li> <li> <p>-l</p> <p>If specified, enable file-based logging of Manager Activity on startup.  This can be toggled at any time from the main menu of the UI.</p> <p>If logging is not enabled, the following arguments have no affect until enabled in UI.</p> </li> <li> <p>-d</p> <p>Log each agent to a different directory.</p> </li> <li> <p>-L #</p> <p>Specify maximum number of entries (reports+tables) per file before rotating.</p> </li> <li> <p>-D DIR</p> <p>NM logs will be placed in this directory.</p> </li> <li> <p>-r</p> <p>Log all received reports to file in text format (as shown in UI).</p> </li> <li> <p>-t</p> <p>Log all received tables to file in text format (as shown in UI).</p> </li> <li> <p>-T</p> <p>Log all transmitted message as ASCII-encoded CBOR HEX strings.</p> </li> <li> <p>-R</p> <p>Log all received messages as ASCII-encoded CBOR HEX strings.</p> </li> </ul>"},{"location":"man/nm/nm_mgr/#description","title":"DESCRIPTION","text":"<p>Starts the nm_mgr application listening on mgr eid for messages from nm_agent clients.  Specify \"--help\" for full usage information.</p> <p>An agent will automatically attempt to register with it's configured manager on startup.  Agents may also be added manually through the managers UI.</p> <p>The manager provides a text based UI as its primary interface.  The UI provides capabilities to list, register, or delete agents. It can view received reports and tables, and be used to send commands (ARIs) to registered agents.</p> <p>An experimental REST API is available if built with the configuration option \"--enable-rest\".  The default configuration will be accessible at http://localhost:8089/nm/api.</p>"},{"location":"man/nm/nm_mgr/#see-also","title":"SEE ALSO","text":"<p>Asynchronous Management Protocol</p> <p>nm_agent(1)</p>"},{"location":"man/restart/","title":"Index of Man Pages","text":"<ul> <li>ionrestart</li> </ul>"},{"location":"man/restart/ionrestart/","title":"NAME","text":"<p>ionrestart - ION node restart utility</p>"},{"location":"man/restart/ionrestart/#synopsis","title":"SYNOPSIS","text":"<p>ionrestart</p>"},{"location":"man/restart/ionrestart/#description","title":"DESCRIPTION","text":"<p>ionrestart is a utility task that is executed automatically when an ION transaction fails, provided transaction reversibility is enabled (see ionconfig(5)).  It should never need to be executed from the command line.</p> <p>When an ION transaction is reversed, all changes made to the SDR non-volatile heap in the course of the transaction are backed out but changes made to ION's working memory are not.  (Forward logging of these changes to enable automatic reversal on these relatively rare occasions is judged to impose too much continuous processing overhead to be cost-justified.)  Because the state of working memory is thereupon in conflict with information in the heap, ionrestart is automatically invoked to reload all of working memory; because this would obviously threaten the stability of all running ION tasks, ionrestart gracefully terminates the tasks of the node (not only ION daemons but also applications), then reloads working memory from the recovered heap, and finally restarts the ION daemons.  Applications that receive termination indications from ionrestart may choose to sleep for a few seconds and then automatically re-initialize their own operations.</p> <p>ionrestart will attempt to restart all core ION protocols including LTP, BP, and CFDP, but any protocols which were not operating at the time of the transaction reversal are not restarted.  Also, protocols that ionrestart has not yet been adapted to cleanly terminate and restart (including, at the time of this writing, BSSP and DPTC) are not restarted.</p>"},{"location":"man/restart/ionrestart/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>ionrestart terminated normally.</p> </li> <li> <p>\"1\"</p> <p>ionrestart failed, for reasons noted in the ion.log file; the task terminated.</p> </li> </ul>"},{"location":"man/restart/ionrestart/#files","title":"FILES","text":"<p>No configuration files are used beyond those required for normal ION node initialization.</p>"},{"location":"man/restart/ionrestart/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/restart/ionrestart/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/restart/ionrestart/#see-also","title":"SEE ALSO","text":"<p>ionadmin(1), ltpadmin(1), bpadmin(1), cfdpadmin(1)</p>"},{"location":"man/tc/","title":"Index of Man Pages","text":"<ul> <li>dtka</li> <li>dtkaadmin</li> <li>dtkarc</li> <li>tc</li> <li>tcaadmin</li> <li>tcaboot</li> <li>tcacompile</li> <li>tcapublish</li> <li>tcarc</li> <li>tcarecv</li> <li>tcc</li> <li>tccadmin</li> <li>tccrc</li> </ul>"},{"location":"man/tc/dtka/","title":"NAME","text":"<p>dtka - Delay-Tolerant Key Administration (DTKA) daemon</p>"},{"location":"man/tc/dtka/#synopsis","title":"SYNOPSIS","text":"<p>dtka</p> <p>dtka is a delay-tolerant public key infrastructure (PKI) system, built on the Trusted Collective (TC) application framework.  Each DTKA daemon generates public/private key pairs and uses the TC framework to distribute public keys securely and to receive the public keys generated and distributed by other DTKA daemons.  For an overview of TC, see the tc(3) manual page.</p>"},{"location":"man/tc/dtka/#description","title":"DESCRIPTION","text":"<p>The DTKA system provides a trustworthy mechanism for delay-tolerant distribution of public keys, enabling ION's BP and LTP implementations to utilize asymmetric cryptography to ensure the integrity and/or confidentiality of data exchange as necessary.  (Discussion of asymmetric cryptography is beyond the scope of this manual page.)</p> <p>A central principle of DTKA is that keys have effective times which condition their applicability.  For example, the public key that must be used to encrypt a bundle payload destined for a given node is the public key (asserted by that node) whose associated effective time is greatest among all of that node's public keys whose associated effective times are less than or equal to the creation time of the bundle.  Effective times enable keys to be distributed far in advance of the times at which they will be used, which is what makes DTKA delay-tolerant: when the time arrives at which a node needs a given key, the key is already in place.</p> <p>The dtka daemon is responsible for periodically generating, on behalf of a given DTN node, public/private key pairs that will be effective at times in the future.</p> <p>The first public key generated by a given DTN node's dtka daemon is distributed by means of an application-specific DTKA initialization procedure.  The procedure may be an out-of-band mechanism by which the initializing node's public key is generated and submitted to the DTKA authority while the user node is under the physical control of the DTKA authority's administrator.  Alternatively, the initializing node's public key may be submitted to the DTKA authority by some other DTN node whose dtka daemon is known to the DTKA authority and is trusted, in which case that node utilizes the TC framework on behalf of the initializing node.</p> <p>Each subsequently generated public key is signed in the node's applicable private key and is submitted directly to the DTKA authority by means of the TC framework.</p> <p>Public key revocations, generated by the DTKA authority's administrator, are submitted in the same way as assertions of new public keys.</p> <p>NOTE that dtka utilizes functions provided by cryptography software that is not distributed with ION.  To indicate that this supporting software has been installed, set the compiler flag -DCRYPTO_SOFTWARE_INSTALLED when compiling this program.  Absent that flag setting at compile time, the dtka daemon's generateKeyPair() function does nothing.</p>"},{"location":"man/tc/dtka/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>dtka terminated, for reasons noted in the ion.log file.</p> </li> <li> <p>\"1\"</p> <p>dtka was unable to attach to TC client functionality, possibly because tcc is not running.</p> </li> </ul>"},{"location":"man/tc/dtka/#files","title":"FILES","text":"<p>The dtkaadmin utility is used to configure the operation of the dtka daemon; see the dtkarc(5) man page for details.</p>"},{"location":"man/tc/dtka/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/dtka/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/dtka/#see-also","title":"SEE ALSO","text":"<p>dtkaadmin(1), dtkarc(5), tc(3), tcc(1), tccadmin(1), tccrc(5)</p>"},{"location":"man/tc/dtkaadmin/","title":"NAME","text":"<p>dtkaadmin - DTKA user function administration interface</p>"},{"location":"man/tc/dtkaadmin/#synopsis","title":"SYNOPSIS","text":"<p>dtkaadmin [ commands_filename ]</p>"},{"location":"man/tc/dtkaadmin/#description","title":"DESCRIPTION","text":"<p>dtkaadmin configures and manages the DTKA administration database for the local ION node, enabling the node to utilize the services of the Trusted Collective for Delay-Tolerant Key Administration.</p> <p>It configures and manages that database in response to DTKA configuration commands found in commands_filename, if provided; if not, dtkaadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from dtkaadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in dtkarc(5).</p>"},{"location":"man/tc/dtkaadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of DTKA configuration.</p> </li> </ul>"},{"location":"man/tc/dtkaadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>dtkaadmin</p> <p>Enter interactive DTKA configuration command entry mode.</p> </li> <li> <p>dtkaadmin host1.karc</p> <p>Execute all configuration commands in host1.karc, then terminate immediately.</p> </li> </ul>"},{"location":"man/tc/dtkaadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from dtkaadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which dtkaadmin was run.  The log file is typically named ion.log.</p> <p>See also dtkarc(5).</p>"},{"location":"man/tc/dtkaadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/dtkaadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the dtkarc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to dtkaadmin.  Otherwise dtkaadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause dtkaadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see dtkarc(5) for details.</p>"},{"location":"man/tc/dtkaadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/dtkaadmin/#see-also","title":"SEE ALSO","text":"<p>dtka(1), dtkarc(5)</p>"},{"location":"man/tc/dtkarc/","title":"NAME","text":"<p>dtkarc - DTKA user configuration commands file</p>"},{"location":"man/tc/dtkarc/#description","title":"DESCRIPTION","text":"<p>DTKA user configuration commands are passed to dtkaadmin either in a file of text lines or interactively at dtkaadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the DTKA user function administration commands are described below.</p>"},{"location":"man/tc/dtkarc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by dtkaadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>1</p> <p>The initialize command.  Until this command is executed, the DTKA user function is not in operation on the local ION node and most dtkaadmin commands will fail.</p> </li> <li> <p>i</p> <p>The info This command will print information about the current state of the local node's DTKA user function, including the current settings of all parameters that can be managed as described below.</p> </li> <li> <p>m keygentime time</p> <p>The manage key generation time command.  This command sets the time at which the node will next generate a public/private key pair and multicast the public key.  The command is not needed in normal operations, because future key generation times are computed automatically as key pairs are generated. time must be in yyyy/mm/dd-hh:mm:ss format.</p> </li> <li> <p>m interval key_pair_generation_interval</p> <p>The manage key pair generation interval command.  This interval, expressed as a number of seconds, controls the period on which the DTKA user function will generate new public/private key pairs.  The default value is 604800 (one week).</p> </li> <li> <p>m leadtime key_pair_effectivenes_lead_time</p> <p>The manage key pair effectivenes lead time command.  This interval, expressed as a number of seconds, controls the length of time after the time of key pair generation at which the key pair will become effective. The default value is 345600 (four days).</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/tc/dtkarc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>m interval 3600</p> <p>Asserts that the DTKA function will generate a new key pair every 3600 seconds (one hour).</p> </li> </ul>"},{"location":"man/tc/dtkarc/#see-also","title":"SEE ALSO","text":"<p>dtkaadmin(1)</p>"},{"location":"man/tc/tc/","title":"NAME","text":"<p>tc - the Trusted Collective system for Delay-Tolerant Networking</p>"},{"location":"man/tc/tc/#synopsis","title":"SYNOPSIS","text":"<pre><code>#include \"tcc.h\"\n\n[see description for available functions]\n</code></pre>"},{"location":"man/tc/tc/#description","title":"DESCRIPTION","text":"<p>The TC system provides a trustworthy framework for delay-tolerant distribution of information that is of critical importance - that is, information that must be made available as needed and must not be corrupt - but is not confidential.  As such it accomplishes some of the same objectives as are accomplished by \"servers\" in the Internet.</p> <p>A central principle of TC is that items of critical information may have effective times which condition their applicability.  For example, a change in rules restricting air travel will typically be scheduled to take effect on some stated date in the near future.  Effective times enable critical information to be distributed far in advance of the time at which it will be needed, which is what makes TC delay-tolerant: when the time arrives at which a node needs a given item of critical information, the information is already in place.  No query/response exchange is necessary.</p> <p>The TC framework for a given TC application comprises (a) a collective authority, which should include several geographically distributed \"authority\" nodes, and (b) \"client\" nodes which utilize the services of the collective authority, possibly including the key authority nodes themselves.  The framework is designed to convey to every participating client node the critical information submitted to the collective authority by all other participating client nodes, in a trustworthy manner, prior to the times at which those items of information become effective.  It operates as follows.</p> <p>The user function of a given TC application generates records containing critical information and issues those records as the application data units forming the payloads of BP bundles.  The destination of each such bundle is the multicast group designated for receivers of the records of that application.  The members of that multicast group are the authority nodes of the application's collective authority.</p> <p>The records are delivered to the tcarecv daemons of the authority nodes.  Each such daemon validates the received records and inserts all valid records in its authority node's private database of pending records.</p> <p>Periodically, the tcacompile daemons of all authority nodes in the application's collective authority simultaneously compile bulletins of all records recently received from user nodes.  (A TC bulletin is simply an array of contiguous TC records.)  These daemons then all issue their bulletins as the application data units forming the payloads of BP bundles.  The destination of each such bundle is the multicast group designated for receivers of the bulletins of that application.  The members of that multicast group are, again, the authority nodes of the application's collective authority.  In addition, each tcacompile daemon spawns one tcapublish process that is assigned the task of processing the bulletins compiled by all authority nodes during this iteration of the compilation cycle.</p> <p>The bulletins are delivered to the tcapublish processes of all authority nodes in the application's collective authority.  The tcapublish processes then compute a common consensus bulletin, which includes all recently asserted records that all of the authority nodes have received and found valid.</p> <p>Each tcapublish process then computes a hash for the consensus bulletin and erasure-codes the bulletin, producing a list of code blocks; the hashes and lists of blocks will be identical for all key authority nodes.  It then issues a small subset of those code blocks as the application data units forming the payloads of BP bundles.  The destination of each such bundle is the multicast group designated for receivers of the code blocks of the application.  The members of that multicast group are the tcc (that is, TC client) daemons serving the application's user nodes.  The subsets of the block list issued by all tcapublish daemons are different, but each code block is tagged with the common bulletin hash.</p> <p>The code blocks are delivered to the tcc daemons of all of the application's user nodes, each of which uses the received code blocks to reassemble the consensus bulletin.  Code blocks with differing bulletin hashes are not used to reassemble the same bulletin, and the erasure coding of the bulletin prevents failure to receive all code blocks from preventing reassembly of the complete bulletin.  When a consensus bulletin has been successfully reassembled, the records in the bulletin are delivered to the user function.</p> <p>The tcaboot and tcaadmin utilities are used to configure the collective authority of a given TC application; the tccadmin utility is used to configure TC client functionality for a given TC application on a given user node.</p> <p>The TC library functions provided to TC application user software are described below.</p> <ul> <li> <p>int tc_serialize(char *buffer, unsigned int buflen, uvast nodeNbr, time_t effectiveTime, time_t assertionTime, unsigned short datLength, unsigned char *datValue)</p> <p>Forms in buffer a serialized TC record, ready for transmission as a BP application data unit, that contains the indicated node number, effective time, assertion time, application data length, and application data.  Returns the length of the record, or -1 on any missing arguments.</p> </li> <li> <p>int tcc_getBulletin(int blocksGroupNbr, char **bulletinContent, int *length)</p> <p>Places in *bulletinContent a pointer to an ION private working memory buffer containing the content of the oldest previously unhandled received TC bulletin for the application identified by blocksGroupNbr.  Returns 0 on success, -1 on any system failure.  A returned buffer length of 0 indicates that the function was interrupted and must be repeated.</p> <p>Note that the calling function MUST MRELEASE the bulletin content buffer when processing is complete.  Failure to do so will introduce a memory leak.</p> </li> <li> <p>int tc_deserialize(char **buffer, int *buflen, unsigned short maxDatLength, uvast *nodeNbr, time_t *effectiveTime, time_t *assertionTime, unsigned short *datLength, unsigned char *datValue)</p> <p>Parses out of the bulletin in buffer the data elements of a single serialized TC record: node number, effective time, assertion time, application data length, and application data.  Returns -1 on any missing arguments, 0 on any record malformation, record length otherwise.</p> </li> </ul>"},{"location":"man/tc/tc/#see-also","title":"SEE ALSO","text":"<p>tcaboot(1), tcaadmin(1), tcarecv(1), tcacompile(1), tcapublish(1), tccadmin(1), tcc(1)</p>"},{"location":"man/tc/tcaadmin/","title":"NAME","text":"<p>tcaadmin - Trusted Collective (TC) authority administration interface</p>"},{"location":"man/tc/tcaadmin/#synopsis","title":"SYNOPSIS","text":"<p>tcaadmin blocks_group_number [ commands_filename ]</p>"},{"location":"man/tc/tcaadmin/#description","title":"DESCRIPTION","text":"<p>tcaadmin configures and manages the Trusted Collective authority databases for TC applications on the local ION node, enabling the node to function as a member of one or more collective authorities.</p> <p>The first command-line argument to tcaadmin is blocksGroupNumber, which identifies the specific TC application to which all commands submitted to this instance of tcaadmin will apply.  A TC application is uniquely identified by the group number of the Bundle Protocol multicast group comprising all nodes hosting TC clients that subscribe to TC \"blocks\" published for that application.</p> <p>tcaadmin configures and manages a TC authority database in response to authority configuration commands found in commands_filename, if provided; if not, tcaadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from tcaadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in tcarc(5).</p>"},{"location":"man/tc/tcaadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of TC authority administration.</p> </li> </ul>"},{"location":"man/tc/tcaadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>tcaadmin 203</p> <p>Enter interactive TC authority administration command entry mode for application 203.</p> </li> <li> <p>tcaadmin 203 host1.tcarc</p> <p>Apply the application-203 configuration commands in host1.tcarc, then terminate immediately.</p> </li> </ul>"},{"location":"man/tc/tcaadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from tcaadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which tcaadmin was run.  The log file is typically named ion.log.</p> <p>See also tcarc(5).</p>"},{"location":"man/tc/tcaadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tcaadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the tcarc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to tcaadmin.  Otherwise tcaadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause tcaadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see tcarc(5) for details.</p>"},{"location":"man/tc/tcaadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tcaadmin/#see-also","title":"SEE ALSO","text":"<p>tcacompile(1), tcapublish(1), tcarecv(1), tcarc(5)</p>"},{"location":"man/tc/tcaboot/","title":"NAME","text":"<p>tcaboot - Trusted Collective (TC) authority initialization utility</p>"},{"location":"man/tc/tcaboot/#synopsis","title":"SYNOPSIS","text":"<p>tcaboot multicast_group_number_for_TC_bulletins multicast_group_number_for_TC_records number_of_authorities_in_collective K R [ delay ]</p>"},{"location":"man/tc/tcaboot/#description","title":"DESCRIPTION","text":"<p>tcaboot writes a TC authority administration command file that initializes a TC authority database.  The file, named \"boot.tcarc\", is written to the current working directory.  It simply contains two authority configuration commands that initialize the TC authority database for the TC application and then set the initial bulletin compilation time for this authority to the current ctime plus delay seconds.  If omitted, delay defaults to 5.  The other command-line arguments for tcaboot are discussed in the descriptions of application initialization commands for tcaadmin; see the tcarc(5) manual page for details.</p>"},{"location":"man/tc/tcaboot/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful generation of TC authority initialization file.</p> </li> </ul>"},{"location":"man/tc/tcaboot/#examples","title":"EXAMPLES","text":"<ul> <li> <p>tcaboot 210 209 6 50 .2</p> <p>Writes a boot.tcarc file that initializes the local node's TC authority database as indicated and sets the next bulletin compilation time to the current time plus 5 seconds.</p> </li> <li> <p>tcaboot 210 209 6 50 .2 90</p> <p>Writes a boot.tcarc file that initializes the local node's TC authority database as indicated and sets the next bulletin compilation time to the current time plus 90 seconds.</p> </li> </ul>"},{"location":"man/tc/tcaboot/#files","title":"FILES","text":"<p>No files apply.</p>"},{"location":"man/tc/tcaboot/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tcaboot/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open cmd file</p> <p>tcaboot is unable to create a file named boot.tcarc for the indicated reason, a system error.</p> </li> <li> <p>Can't write to cmd file</p> <p>tcaboot is unable to write to boot.tcarc for the indicated reason, a system error.</p> </li> </ul>"},{"location":"man/tc/tcaboot/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tcaboot/#see-also","title":"SEE ALSO","text":"<p>tcaadmin(1), tcarc(5)</p>"},{"location":"man/tc/tcacompile/","title":"NAME","text":"<p>tcacompile - Trusted Collective daemon task for compiling critical information bulletins</p>"},{"location":"man/tc/tcacompile/#synopsis","title":"SYNOPSIS","text":"<p>tcacompile blocks_group_number</p>"},{"location":"man/tc/tcacompile/#description","title":"DESCRIPTION","text":"<p>tcacompile is a background \"daemon\" task that periodically generates new proposed bulletins of recent critical information records and multicasts those bulletins to all nodes in the collective authority for the TC application identified by blocks_group_number.  It is spawned automatically by tcaadmin in response to the 's' command that starts operation of the TC authority function for this application on the local node, and it is terminated by tcaadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/tc/tcacompile/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcacompile terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use tcaadmin to restart tcacompile.</p> </li> <li> <p>\"1\"</p> <p>tcacompile was unable to attach to TC authority operations, probably because tcaadmin has not yet been run.</p> </li> </ul>"},{"location":"man/tc/tcacompile/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/tc/tcacompile/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tcacompile/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcacompile can't attach to tca system.</p> <p>tcaadmin has not yet initialized the authority database for this TC application.</p> </li> </ul>"},{"location":"man/tc/tcacompile/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tcacompile/#see-also","title":"SEE ALSO","text":"<p>tcaadmin(1), tc(3), tcarc(5)</p>"},{"location":"man/tc/tcapublish/","title":"NAME","text":"<p>tcapublish - Trusted Collective authority task that publishes consensus critical information bulletins</p>"},{"location":"man/tc/tcapublish/#synopsis","title":"SYNOPSIS","text":"<p>tcapublish blocks_group_number</p>"},{"location":"man/tc/tcapublish/#description","title":"DESCRIPTION","text":"<p>tcapublish is a background task that completes the processing of a single iteration of the bulletin publication cycle for the collective authority function of the TC application identified by blocks_group_number on the local node.  To do so, it receives proposed bulletins multicast by tcacompile daemons, resolves differences among the received bulletins to arrive at a consensus bulletin, computes a hash for the consensus bulletin, erasure-codes the consensus bulletin, and multicasts that subset of the resulting code blocks that is allocated to the local node according to the local node's assigned position in the authority array of the application's collective authority.  It is spawned automatically by the local node's tcacompile daemon for the indicated application, at the time that daemon publishes its own proposed bulletin for this iteration of the bulletin compilation cycle; it terminates immediately after it has finished publishing code blocks.</p>"},{"location":"man/tc/tcapublish/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcapublish terminated, for reasons noted in the ion.log file.</p> </li> <li> <p>\"1\"</p> <p>tcapublish was unable to attach to TC authority operations, probably because tcaadmin has not yet been run.</p> </li> </ul>"},{"location":"man/tc/tcapublish/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/tc/tcapublish/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tcapublish/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcapublish can't attach to DTKA.</p> <p>tcaadmin has not yet initialized the authority database for this TC application.</p> </li> </ul>"},{"location":"man/tc/tcapublish/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tcapublish/#see-also","title":"SEE ALSO","text":"<p>tcaadmin(1), tc(3), tcauthrc(5)</p>"},{"location":"man/tc/tcarc/","title":"NAME","text":"<p>tcarc - Trusted Collective authority configuration commands file</p>"},{"location":"man/tc/tcarc/#description","title":"DESCRIPTION","text":"<p>TC authority configuration commands are passed to tcaadmin either in a file of text lines or interactively at tcaadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the TC authority configuration commands are described below.</p>"},{"location":"man/tc/tcarc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by tcaadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v </p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine with e 1 command to log the version number at startup.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> <li> <p>1 multicast_group_number_for_TC_bulletins multicast_group_number_for_TC_records number_of_authorities_in_collective K R</p> <p>The initialize command.  Until this command is executed, the authority function for the selected TC application is not in operation on the local ION node and most tcaadmin commands will fail.</p> <p>K is the mandated diffusion for the selected TC application, i.e., the number of blocks into which each bulletin of published TC information is divided for transmission.</p> <p>R is the mandated redundancy for the selected TC application, i.e., the percentage of blocks issued per bulletin that will be parity blocks rather than extents of the bulletin itself.</p> </li> <li> <p>i</p> <p>The info This command will print information about the current state of the authority function for the selected TC application on the local node, including the current settings of all parameters that can be managed as described below.</p> </li> <li> <p>s</p> <p>The start command.  This command starts the tcarecv and tcacompile daemons of the authority function for the selected TC application on the local node.</p> </li> <li> <p>m compiletime time</p> <p>The manage compile time command.  This command sets the time at which the authority function for the selected TC application on this node will next compile a bulletin.  The command is not needed in normal operations, because future compile times are computed automatically as bulletins are compiled. time must be in yyyy/mm/dd-hh:mm:ss format.</p> </li> <li> <p>m interval bulletin_compilation_interval</p> <p>The manage bulletin compilation interval command.  This interval, expressed as a number of seconds, controls the period on which the  authority function for the selected TC appliction on this node will compile new key information bulletins.  The default value is 3600 (one hour).</p> </li> <li> <p>m grace bulletin_consensus_grace_time</p> <p>The manage bulletin consensus grace time command.  This interval, expressed as a number of seconds, controls the length of time the authority function for the selected TC application on this node  will wait after publishing a bulletin before computing a consensus bulletin; this parameter is intended to relax the degree to which the system clocks of all members of the collective authority for this TC application must be in agreement.  The default value is 60 (1 minute).</p> </li> <li> <p>+ authority_array_index node_number</p> <p>This command asserts that the trusted Nth member of the collective authority for the selected TC application, where N is the authority_array_index value, is the node identified by node_number.</p> </li> <li> <p>- authority_array_index</p> <p>This command asserts that the Nth member of the collective authority for the selected TC application, where N is the authority_array_index value, is no longer trusted; bulletins received from this collective authority member must be discarded.</p> </li> <li> <p>a node_number</p> <p>This command adds the node identified by node_number to the list of nodes hosting authorized_clients for the selected TC application.  Once this list has been populated, TC records for this application that are received from clients residing on nodes that are not in the list are automatically discarded by the authority function residing on the local node.</p> </li> <li> <p>d node_number</p> <p>This command deletes the node identified by node_number from the list of nodes hosting authorized_clients for the selected TC application.</p> </li> <li> <p>l</p> <p>This command lists all nodes currently hosting authorized_clients for the selected TC application.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops the tcarecv and tcacompile daemons of the authority function for the selected TC application on the local node.</p> </li> </ul>"},{"location":"man/tc/tcarc/#examples","title":"EXAMPLES","text":"<ul> <li> <ul> <li>3 6913</li> </ul> <p>Asserts that node 6913 is now member 3 of the collective authority for the selected application.</p> </li> </ul>"},{"location":"man/tc/tcarc/#see-also","title":"SEE ALSO","text":"<p>tcaadmin(1), dtka(3)</p>"},{"location":"man/tc/tcarecv/","title":"NAME","text":"<p>tcarecv - Trusted Collective daemon task for receiving newly generated records of critical information</p>"},{"location":"man/tc/tcarecv/#synopsis","title":"SYNOPSIS","text":"<p>tcarecv blocks_group_number</p>"},{"location":"man/tc/tcarecv/#description","title":"DESCRIPTION","text":"<p>tcarecv is a background \"daemon\" task that receives new critical information records multicast by user nodes of the TC application identified by blocks_group_number.  It records those assertions in a database for future processing by tcacompile.  It is spawned automatically by tcaadmin in response to the 's' command that starts operation of the TC authority function for this application on the local node, and it is terminated by tcaadmin in response to an 'x' (STOP) command.</p>"},{"location":"man/tc/tcarecv/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcarecv terminated, for reasons noted in the ion.log file.  If this termination was not commanded, investigate and solve the problem identified in the log file and use tcaadmin to restart tcarecv.</p> </li> <li> <p>\"1\"</p> <p>tcarecv was unable to attach to DTKA operations, probably because tcaadmin has not yet been run.</p> </li> </ul>"},{"location":"man/tc/tcarecv/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/tc/tcarecv/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tcarecv/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcarecv can't attach to DTKA.</p> <p>tcaadmin has not yet initialized the authority database for this TC application.</p> </li> </ul>"},{"location":"man/tc/tcarecv/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tcarecv/#see-also","title":"SEE ALSO","text":"<p>tcaadmin(1), tc(3), tcarc(5)</p>"},{"location":"man/tc/tcc/","title":"NAME","text":"<p>tcc - Trusted Collective client daemon task for handling bulletins from a collective authority</p>"},{"location":"man/tc/tcc/#synopsis","title":"SYNOPSIS","text":"<p>tcc blocks_group_number</p>"},{"location":"man/tc/tcc/#description","title":"DESCRIPTION","text":"<p>tcc is a background \"daemon\" task that receives code blocks multicast by the authority nodes of the collective authority for the TC application identified by blocks_group_number.  It reassembles bulletins from compatible code blocks and delivers those bulletins to the application's user function on the local node.</p>"},{"location":"man/tc/tcc/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>tcc terminated, for reasons noted in the ion.log file.</p> </li> <li> <p>\"1\"</p> <p>tcc was unable to attach to TC client operations, possibly because the TC client database for this application has not yet been initialized by tcaadmin.</p> </li> </ul>"},{"location":"man/tc/tcc/#files","title":"FILES","text":"<p>No configuration files are needed.</p>"},{"location":"man/tc/tcc/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tcc/#diagnostics","title":"DIAGNOSTICS","text":"<p>The following diagnostics may be issued to the ion.log log file:</p> <ul> <li> <p>tcc can't attach to tcc system.</p> <p>tcaadmin has not yet initialized the TC client database for this application.</p> </li> </ul>"},{"location":"man/tc/tcc/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tcc/#see-also","title":"SEE ALSO","text":"<p>tcaadmin(1), tcarc(5)</p>"},{"location":"man/tc/tccadmin/","title":"NAME","text":"<p>tccadmin - DTKA node administration interface</p>"},{"location":"man/tc/tccadmin/#synopsis","title":"SYNOPSIS","text":"<p>tccadmin blocks_group_number [ commands_filename ]</p>"},{"location":"man/tc/tccadmin/#description","title":"DESCRIPTION","text":"<p>tccadmin configures and manages the Trusted Collecive client databases for TC applications on the local ION node, enabling the node to utilize the services of one or more collective authorities.</p> <p>The first command-line argument to tccadmin is blocksGroupNumber, which identifies the specific TC application to which all commands submitted to this instance of tccadmin will apply.  A TC application is uniquely identified by the group number of the Bundle Protocol multicast group comprising all nodes hosting TC clients that subscribe to TC \"blocks\" published for that application.</p> <p>tccadmin configures and manages a TC client database in response to client configuration commands found in commands_filename, if provided; if not, tccadmin prints a simple prompt (:) so that the user may type commands directly into standard input.</p> <p>The format of commands for commands_filename can be queried from tccadmin by entering the command 'h' or '?' at the prompt.  The commands are documented in tccrc(5).</p>"},{"location":"man/tc/tccadmin/#exit-status","title":"EXIT STATUS","text":"<ul> <li> <p>\"0\"</p> <p>Successful completion of TC client administration.</p> </li> </ul>"},{"location":"man/tc/tccadmin/#examples","title":"EXAMPLES","text":"<ul> <li> <p>tccadmin</p> <p>Enter interactive TC client administration command entry mode.</p> </li> <li> <p>tccadmin host1.karc</p> <p>Execute all configuration commands in host1.karc, then terminate immediately.</p> </li> </ul>"},{"location":"man/tc/tccadmin/#files","title":"FILES","text":"<p>Status and diagnostic messages from tccadmin and from other software that utilizes the ION node are nominally written to a log file in the current working directory within which tccadmin was run.  The log file is typically named ion.log.</p> <p>See also tccrc(5).</p>"},{"location":"man/tc/tccadmin/#environment","title":"ENVIRONMENT","text":"<p>No environment variables apply.</p>"},{"location":"man/tc/tccadmin/#diagnostics","title":"DIAGNOSTICS","text":"<p>Note: all ION administration utilities expect source file input to be lines of ASCII text that are NL-delimited.  If you edit the tccrc file on a Windows machine, be sure to use dos2unix to convert it to Unix text format before presenting it to tccadmin.  Otherwise tccadmin will detect syntax errors and will not function satisfactorily.</p> <p>The following diagnostics may be issued to the log file:</p> <ul> <li> <p>Can't open command file...</p> <p>The commands_filename specified in the command line doesn't exist.</p> </li> </ul> <p>Various errors that don't cause tccadmin to fail but are noted in the log file may be caused by improperly formatted commands given at the prompt or in the commands_filename.  Please see tccrc(5) for details.</p>"},{"location":"man/tc/tccadmin/#bugs","title":"BUGS","text":"<p>Report bugs to ion-dtn-support@lists.sourceforge.net</p>"},{"location":"man/tc/tccadmin/#see-also","title":"SEE ALSO","text":"<p>tcc(1), tccrc(5)</p>"},{"location":"man/tc/tccrc/","title":"NAME","text":"<p>tccrc - Trusted Collective client configuration commands file</p>"},{"location":"man/tc/tccrc/#description","title":"DESCRIPTION","text":"<p>TC client configuration commands are passed to tccadmin either in a file of text lines or interactively at tccadmin's command prompt (:).  Commands are interpreted line-by line, with exactly one command per line.  The formats and effects of the TC client configuration commands are described below.</p>"},{"location":"man/tc/tccrc/#commands","title":"COMMANDS","text":"<ul> <li> <p>?</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>#</p> <p>Comment line.  Lines beginning with # are not interpreted.</p> </li> <li> <p>e { 1 | 0 }</p> <p>Echo control.  Setting echo to 1 causes all output printed by tccadmin to be logged as well as sent to stdout.  Setting echo to 0 disables this behavior.</p> </li> <li> <p>v</p> <p>Version number.  Prints out the version of ION currently installed.  HINT: combine withe 1 command to log the version number at startup.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the h command.</p> </li> <li> <p>1 number_of_authorities_in_collective [ K [ R ]]</p> <p>The initialize command.  Until this command is executed, the client daemon for the selected TC application is not in operation on the local ION node and most tccadmin commands will fail.</p> <p>K is the mandated diffusion for the selected TC application, i.e., the number of blocks into which each bulletin of published TC information is divided for transmission.</p> <p>R is the mandated redundancy for the selected TC application, i.e., the percentage of  blocks issued per bulletin that will be parity blocks rather than extents of the bulletin itself.</p> </li> <li> <p>i</p> <p>The info This command will print information about the current state of the client daemon for the selected TC application on the local node, i.e., the identities of the TC authority nodes that the client daemon recognizes.</p> </li> <li> <p>s</p> <p>The start command.  This command starts the client daemon (tcc) for the selected TC application.</p> </li> <li> <p>m authority authority_array_index node_number</p> <p>This command asserts that the Nth member of the collective authority for the selected TC application, where N is the authority_array_index value, is the node identified by node_number.</p> </li> <li> <p>x</p> <p>The stop command.  This command stops the client daemon (tcc) for the selected TC application.</p> </li> <li> <p>h</p> <p>The help command.  This will display a listing of the commands and their formats.  It is the same as the ? command.</p> </li> </ul>"},{"location":"man/tc/tccrc/#examples","title":"EXAMPLES","text":"<ul> <li> <p>m authority 3 6913</p> <p>Asserts that node 6913 is member 3 of the collective authority for the selected application.</p> </li> </ul>"},{"location":"man/tc/tccrc/#see-also","title":"SEE ALSO","text":"<p>tccadmin(1)</p>"}]}