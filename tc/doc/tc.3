.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "tc::doc::pod3::tc 3"
.TH tc::doc::pod3::tc 3 "2022-11-03" "perl v5.30.0" "TC library functions"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
tc \- the Trusted Collective system for Delay\-Tolerant Networking
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include "tcc.h"
\&
\&    [see description for available functions]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1TC\s0 system provides a trustworthy framework for delay-tolerant
distribution of information that is of critical importance \- that is,
information that must be made available as needed and must not be
corrupt \- but is not confidential.  As such it accomplishes some of
the same objectives as are accomplished by \*(L"servers\*(R" in the Internet.
.PP
A central principle of \s-1TC\s0 is that items of critical information may
have \fBeffective times\fR which condition their applicability.  For example,
a change in rules restricting air travel will typically be scheduled to
take effect on some stated date in the near future.  Effective times
enable critical information to be distributed far in advance of the
time at which it will be needed, which is what makes \s-1TC\s0 delay-tolerant:
when the time arrives at which a node needs a given item of critical
information, the information is already in place.  No query/response
exchange is necessary.
.PP
The \s-1TC\s0 framework for a given \s-1TC\s0 \fBapplication\fR comprises (a) a collective
authority, which should include several geographically distributed
\&\*(L"authority\*(R" nodes, and (b) \*(L"client\*(R" nodes which utilize the services
of the collective authority, possibly including the key authority nodes
themselves.  The framework is designed to convey to every participating
client node the critical information submitted to the collective
authority by all other participating client nodes, in a trustworthy
manner, prior to the times at which those items of information become
effective.  It operates as follows.
.PP
The user function of a given \s-1TC\s0 application generates \fBrecords\fR containing
critical information and issues those records as the application data units
forming the payloads of \s-1BP\s0 bundles.  The destination of each such bundle
is the multicast group designated for receivers of the records of that
application.  The members of that multicast group are the authority nodes
of the application's collective authority.
.PP
The records are delivered to the \fBtcarecv\fR daemons of the authority
nodes.  Each such daemon validates the received records and inserts all
valid records in its authority node's private database of pending records.
.PP
Periodically, the \fBtcacompile\fR daemons of all authority nodes in the
application's collective authority simultaneously compile \fBbulletins\fR of
all records recently received from user nodes.  (A \s-1TC\s0 bulletin is simply
an array of contiguous \s-1TC\s0 records.)  These daemons then all issue their
bulletins as the application data units forming the payloads of \s-1BP\s0
bundles.  The destination of each such bundle is the multicast group
designated for receivers of the bulletins of that application.  The members
of that multicast group are, again, the authority nodes of the application's
collective authority.  In addition, each \fBtcacompile\fR daemon spawns one
\&\fBtcapublish\fR process that is assigned the task of processing the bulletins
compiled by all authority nodes during this iteration of the compilation cycle.
.PP
The bulletins are delivered to the \fBtcapublish\fR processes of all authority
nodes in the application's collective authority.  The \fBtcapublish\fR processes
then compute a common consensus bulletin, which includes all recently asserted
records that all of the authority nodes have received and found valid.
.PP
Each \fBtcapublish\fR process then computes a hash for the consensus bulletin and
erasure-codes the bulletin, producing a list of \fBcode blocks\fR; the hashes and
lists of blocks will be identical for all key authority nodes.  It then
issues a small subset of those code blocks as the application data units
forming the payloads of \s-1BP\s0 bundles.  The destination of each such bundle
is the multicast group designated for receivers of the code blocks of the
application.  The members of that multicast group are the \fBtcc\fR (that is,
\&\s-1TC\s0 \fBclient\fR) daemons serving the application's user nodes.  The subsets
of the block list issued by all \fBtcapublish\fR daemons are different, but
each code block is tagged with the common bulletin hash.
.PP
The code blocks are delivered to the \fBtcc\fR daemons of all of the
application's user nodes, each of which uses the received code blocks
to reassemble the consensus bulletin.  Code blocks with differing
bulletin hashes are not used to reassemble the same bulletin, and
the erasure coding of the bulletin prevents failure to receive all
code blocks from preventing reassembly of the complete bulletin.  When
a consensus bulletin has been successfully reassembled, the records
in the bulletin are delivered to the user function.
.PP
The \fBtcaboot\fR and \fBtcaadmin\fR utilities are used to configure the
collective authority of a given \s-1TC\s0 application; the \fBtccadmin\fR utility is
used to configure \s-1TC\s0 client functionality for a given \s-1TC\s0 application on
a given user node.
.PP
The \s-1TC\s0 library functions provided to \s-1TC\s0 application user software are
described below.
.IP "int tc_serialize(char *buffer, unsigned int buflen, uvast nodeNbr, time_t effectiveTime, time_t assertionTime, unsigned short datLength, unsigned char *datValue)" 4
.IX Item "int tc_serialize(char *buffer, unsigned int buflen, uvast nodeNbr, time_t effectiveTime, time_t assertionTime, unsigned short datLength, unsigned char *datValue)"
Forms in \fIbuffer\fR a serialized \s-1TC\s0 record, ready for transmission as a \s-1BP\s0
application data unit, that contains the indicated node number, effective time,
assertion time, application data length, and application data.  Returns the
length of the record, or \-1 on any missing arguments.
.IP "int tcc_getBulletin(int blocksGroupNbr, char **bulletinContent, int *length)" 4
.IX Item "int tcc_getBulletin(int blocksGroupNbr, char **bulletinContent, int *length)"
Places in \fI*bulletinContent\fR a pointer to an \s-1ION\s0 private working memory
buffer containing the content of the oldest previously unhandled received
\&\s-1TC\s0 bulletin for the application identified by \fIblocksGroupNbr\fR.  Returns
0 on success, \-1 on any system failure.  A returned buffer length of 0
indicates that the function was interrupted and must be repeated.
.Sp
Note that the calling function \s-1MUST\s0 \fB\s-1MRELEASE\s0\fR the bulletin content buffer
when processing is complete.  Failure to do so will introduce a memory leak.
.IP "int tc_deserialize(char **buffer, int *buflen, unsigned short maxDatLength, uvast *nodeNbr, time_t *effectiveTime, time_t *assertionTime, unsigned short *datLength, unsigned char *datValue)" 4
.IX Item "int tc_deserialize(char **buffer, int *buflen, unsigned short maxDatLength, uvast *nodeNbr, time_t *effectiveTime, time_t *assertionTime, unsigned short *datLength, unsigned char *datValue)"
Parses out of the bulletin in \fIbuffer\fR the data elements of a single
serialized \s-1TC\s0 record: node number, effective time, assertion time,
application data length, and application data.  Returns \-1 on any missing
arguments, 0 on any record malformation, record length otherwise.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBtcaboot\fR\|(1), \fBtcaadmin\fR\|(1), \fBtcarecv\fR\|(1), \fBtcacompile\fR\|(1), \fBtcapublish\fR\|(1), \fBtccadmin\fR\|(1), \fBtcc\fR\|(1)
